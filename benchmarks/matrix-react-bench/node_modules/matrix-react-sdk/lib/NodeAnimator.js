"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

/**
 * The NodeAnimator contains components and animates transitions.
 * It will only pick up direct changes to properties ('left', currently), and so
 * will not work for animating positional changes where the position is implicit
 * from DOM order. This makes it a lot simpler and lighter: if you need fully
 * automatic positional animation, look at react-shuffle or similar libraries.
 */
class NodeAnimator extends _react.default.Component {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "nodes", {});
    (0, _defineProperty2.default)(this, "children", void 0);
    this.updateChildren(this.props.children);
  }

  componentDidUpdate() {
    this.updateChildren(this.props.children);
  }
  /**
   *
   * @param {HTMLElement} node element to apply styles to
   * @param {React.CSSProperties} styles a key/value pair of CSS properties
   * @returns {void}
   */


  applyStyles(node, styles) {
    Object.entries(styles).forEach(([property, value]) => {
      node.style[property] = value;
    });
  }

  updateChildren(newChildren) {
    const oldChildren = this.children || {};
    this.children = {};

    _react.default.Children.toArray(newChildren).forEach(c => {
      if (oldChildren[c.key]) {
        const old = oldChildren[c.key];

        const oldNode = _reactDom.default.findDOMNode(this.nodes[old.key]);

        if (oldNode && oldNode.style.left !== c.props.style.left) {
          this.applyStyles(oldNode, {
            left: c.props.style.left
          }); // console.log("translation: "+oldNode.style.left+" -> "+c.props.style.left);
        } // clone the old element with the props (and children) of the new element
        // so prop updates are still received by the children.


        this.children[c.key] = /*#__PURE__*/_react.default.cloneElement(old, c.props, c.props.children);
      } else {
        // new element. If we have a startStyle, use that as the style and go through
        // the enter animations
        const newProps = {};
        const restingStyle = c.props.style;
        const startStyles = this.props.startStyles;

        if (startStyles.length > 0) {
          const startStyle = startStyles[0];
          newProps.style = startStyle; // console.log("mounted@startstyle0: "+JSON.stringify(startStyle));
        }

        newProps.ref = n => this.collectNode(c.key, n, restingStyle);

        this.children[c.key] = /*#__PURE__*/_react.default.cloneElement(c, newProps);
      }
    });
  }

  collectNode(k, node, restingStyle) {
    if (node && this.nodes[k] === undefined && this.props.startStyles.length > 0) {
      const startStyles = this.props.startStyles;

      const domNode = _reactDom.default.findDOMNode(node); // start from startStyle 1: 0 is the one we gave it
      // to start with, so now we animate 1 etc.


      for (let i = 1; i < startStyles.length; ++i) {
        this.applyStyles(domNode, startStyles[i]); // console.log("start:"
        //             JSON.stringify(startStyles[i]),
        //             );
      } // and then we animate to the resting state


      setTimeout(() => {
        this.applyStyles(domNode, restingStyle);
      }, 0); // console.log("enter:",
      //             JSON.stringify(restingStyle));
    }

    this.nodes[k] = node;
  }

  render() {
    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, Object.values(this.children));
  }

}

exports.default = NodeAnimator;
(0, _defineProperty2.default)(NodeAnimator, "defaultProps", {
  startStyles: []
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9Ob2RlQW5pbWF0b3IudHN4Il0sIm5hbWVzIjpbIk5vZGVBbmltYXRvciIsIlJlYWN0IiwiQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJwcm9wcyIsInVwZGF0ZUNoaWxkcmVuIiwiY2hpbGRyZW4iLCJjb21wb25lbnREaWRVcGRhdGUiLCJhcHBseVN0eWxlcyIsIm5vZGUiLCJzdHlsZXMiLCJPYmplY3QiLCJlbnRyaWVzIiwiZm9yRWFjaCIsInByb3BlcnR5IiwidmFsdWUiLCJzdHlsZSIsIm5ld0NoaWxkcmVuIiwib2xkQ2hpbGRyZW4iLCJDaGlsZHJlbiIsInRvQXJyYXkiLCJjIiwia2V5Iiwib2xkIiwib2xkTm9kZSIsIlJlYWN0RG9tIiwiZmluZERPTU5vZGUiLCJub2RlcyIsImxlZnQiLCJjbG9uZUVsZW1lbnQiLCJuZXdQcm9wcyIsInJlc3RpbmdTdHlsZSIsInN0YXJ0U3R5bGVzIiwibGVuZ3RoIiwic3RhcnRTdHlsZSIsInJlZiIsIm4iLCJjb2xsZWN0Tm9kZSIsImsiLCJ1bmRlZmluZWQiLCJkb21Ob2RlIiwiaSIsInNldFRpbWVvdXQiLCJyZW5kZXIiLCJ2YWx1ZXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2UsTUFBTUEsWUFBTixTQUEyQkMsZUFBTUMsU0FBakMsQ0FBbUQ7QUFPOURDLEVBQUFBLFdBQVcsQ0FBQ0MsS0FBRCxFQUFnQjtBQUN2QixVQUFNQSxLQUFOO0FBRHVCLGlEQU5YLEVBTVc7QUFBQTtBQUd2QixTQUFLQyxjQUFMLENBQW9CLEtBQUtELEtBQUwsQ0FBV0UsUUFBL0I7QUFDSDs7QUFFTUMsRUFBQUEsa0JBQWtCLEdBQVM7QUFDOUIsU0FBS0YsY0FBTCxDQUFvQixLQUFLRCxLQUFMLENBQVdFLFFBQS9CO0FBQ0g7QUFFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNZRSxFQUFBQSxXQUFXLENBQUNDLElBQUQsRUFBb0JDLE1BQXBCLEVBQXVEO0FBQ3RFQyxJQUFBQSxNQUFNLENBQUNDLE9BQVAsQ0FBZUYsTUFBZixFQUF1QkcsT0FBdkIsQ0FBK0IsQ0FBQyxDQUFDQyxRQUFELEVBQVdDLEtBQVgsQ0FBRCxLQUF1QjtBQUNsRE4sTUFBQUEsSUFBSSxDQUFDTyxLQUFMLENBQVdGLFFBQVgsSUFBdUJDLEtBQXZCO0FBQ0gsS0FGRDtBQUdIOztBQUVPVixFQUFBQSxjQUFjLENBQUNZLFdBQUQsRUFBcUM7QUFDdkQsVUFBTUMsV0FBVyxHQUFHLEtBQUtaLFFBQUwsSUFBaUIsRUFBckM7QUFDQSxTQUFLQSxRQUFMLEdBQWdCLEVBQWhCOztBQUNBTCxtQkFBTWtCLFFBQU4sQ0FBZUMsT0FBZixDQUF1QkgsV0FBdkIsRUFBb0NKLE9BQXBDLENBQTZDUSxDQUFELElBQVk7QUFDcEQsVUFBSUgsV0FBVyxDQUFDRyxDQUFDLENBQUNDLEdBQUgsQ0FBZixFQUF3QjtBQUNwQixjQUFNQyxHQUFHLEdBQUdMLFdBQVcsQ0FBQ0csQ0FBQyxDQUFDQyxHQUFILENBQXZCOztBQUNBLGNBQU1FLE9BQU8sR0FBR0Msa0JBQVNDLFdBQVQsQ0FBcUIsS0FBS0MsS0FBTCxDQUFXSixHQUFHLENBQUNELEdBQWYsQ0FBckIsQ0FBaEI7O0FBRUEsWUFBSUUsT0FBTyxJQUFLQSxPQUFELENBQXlCUixLQUF6QixDQUErQlksSUFBL0IsS0FBd0NQLENBQUMsQ0FBQ2pCLEtBQUYsQ0FBUVksS0FBUixDQUFjWSxJQUFyRSxFQUEyRTtBQUN2RSxlQUFLcEIsV0FBTCxDQUFpQmdCLE9BQWpCLEVBQXlDO0FBQUVJLFlBQUFBLElBQUksRUFBRVAsQ0FBQyxDQUFDakIsS0FBRixDQUFRWSxLQUFSLENBQWNZO0FBQXRCLFdBQXpDLEVBRHVFLENBRXZFO0FBQ0gsU0FQbUIsQ0FRcEI7QUFDQTs7O0FBQ0EsYUFBS3RCLFFBQUwsQ0FBY2UsQ0FBQyxDQUFDQyxHQUFoQixpQkFBdUJyQixlQUFNNEIsWUFBTixDQUFtQk4sR0FBbkIsRUFBd0JGLENBQUMsQ0FBQ2pCLEtBQTFCLEVBQWlDaUIsQ0FBQyxDQUFDakIsS0FBRixDQUFRRSxRQUF6QyxDQUF2QjtBQUNILE9BWEQsTUFXTztBQUNIO0FBQ0E7QUFDQSxjQUFNd0IsUUFBOEIsR0FBRyxFQUF2QztBQUNBLGNBQU1DLFlBQVksR0FBR1YsQ0FBQyxDQUFDakIsS0FBRixDQUFRWSxLQUE3QjtBQUVBLGNBQU1nQixXQUFXLEdBQUcsS0FBSzVCLEtBQUwsQ0FBVzRCLFdBQS9COztBQUNBLFlBQUlBLFdBQVcsQ0FBQ0MsTUFBWixHQUFxQixDQUF6QixFQUE0QjtBQUN4QixnQkFBTUMsVUFBVSxHQUFHRixXQUFXLENBQUMsQ0FBRCxDQUE5QjtBQUNBRixVQUFBQSxRQUFRLENBQUNkLEtBQVQsR0FBaUJrQixVQUFqQixDQUZ3QixDQUd4QjtBQUNIOztBQUVESixRQUFBQSxRQUFRLENBQUNLLEdBQVQsR0FBaUJDLENBQUQsSUFBTyxLQUFLQyxXQUFMLENBQ25CaEIsQ0FBQyxDQUFDQyxHQURpQixFQUNaYyxDQURZLEVBQ1RMLFlBRFMsQ0FBdkI7O0FBSUEsYUFBS3pCLFFBQUwsQ0FBY2UsQ0FBQyxDQUFDQyxHQUFoQixpQkFBdUJyQixlQUFNNEIsWUFBTixDQUFtQlIsQ0FBbkIsRUFBc0JTLFFBQXRCLENBQXZCO0FBQ0g7QUFDSixLQS9CRDtBQWdDSDs7QUFFT08sRUFBQUEsV0FBVyxDQUFDQyxDQUFELEVBQVk3QixJQUFaLEVBQXVDc0IsWUFBdkMsRUFBZ0Y7QUFDL0YsUUFDSXRCLElBQUksSUFDSixLQUFLa0IsS0FBTCxDQUFXVyxDQUFYLE1BQWtCQyxTQURsQixJQUVBLEtBQUtuQyxLQUFMLENBQVc0QixXQUFYLENBQXVCQyxNQUF2QixHQUFnQyxDQUhwQyxFQUlFO0FBQ0UsWUFBTUQsV0FBVyxHQUFHLEtBQUs1QixLQUFMLENBQVc0QixXQUEvQjs7QUFDQSxZQUFNUSxPQUFPLEdBQUdmLGtCQUFTQyxXQUFULENBQXFCakIsSUFBckIsQ0FBaEIsQ0FGRixDQUdFO0FBQ0E7OztBQUNBLFdBQUssSUFBSWdDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdULFdBQVcsQ0FBQ0MsTUFBaEMsRUFBd0MsRUFBRVEsQ0FBMUMsRUFBNkM7QUFDekMsYUFBS2pDLFdBQUwsQ0FBaUJnQyxPQUFqQixFQUF5Q1IsV0FBVyxDQUFDUyxDQUFELENBQXBELEVBRHlDLENBRXpDO0FBQ0E7QUFDQTtBQUNILE9BVkgsQ0FZRTs7O0FBQ0FDLE1BQUFBLFVBQVUsQ0FBQyxNQUFNO0FBQ2IsYUFBS2xDLFdBQUwsQ0FBaUJnQyxPQUFqQixFQUF5Q1QsWUFBekM7QUFDSCxPQUZTLEVBRVAsQ0FGTyxDQUFWLENBYkYsQ0FpQkU7QUFDQTtBQUNIOztBQUNELFNBQUtKLEtBQUwsQ0FBV1csQ0FBWCxJQUFnQjdCLElBQWhCO0FBQ0g7O0FBRU1rQyxFQUFBQSxNQUFNLEdBQWdCO0FBQ3pCLHdCQUNJLDREQUFJaEMsTUFBTSxDQUFDaUMsTUFBUCxDQUFjLEtBQUt0QyxRQUFuQixDQUFKLENBREo7QUFHSDs7QUFsRzZEOzs7OEJBQTdDTixZLGtCQUc2QjtBQUMxQ2dDLEVBQUFBLFdBQVcsRUFBRTtBQUQ2QixDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFJlYWN0RG9tIGZyb20gXCJyZWFjdC1kb21cIjtcblxuaW50ZXJmYWNlIElDaGlsZFByb3BzIHtcbiAgICBzdHlsZTogUmVhY3QuQ1NTUHJvcGVydGllcztcbiAgICByZWY6IChub2RlOiBSZWFjdC5SZWFjdEluc3RhbmNlKSA9PiB2b2lkO1xufVxuXG5pbnRlcmZhY2UgSVByb3BzIHtcbiAgICAvLyBlaXRoZXIgYSBsaXN0IG9mIGNoaWxkIG5vZGVzLCBvciBhIHNpbmdsZSBjaGlsZC5cbiAgICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xuXG4gICAgLy8gb3B0aW9uYWwgdHJhbnNpdGlvbiBpbmZvcm1hdGlvbiBmb3IgY2hhbmdpbmcgZXhpc3RpbmcgY2hpbGRyZW5cbiAgICB0cmFuc2l0aW9uPzogb2JqZWN0O1xuXG4gICAgLy8gYSBsaXN0IG9mIHN0YXRlIG9iamVjdHMgdG8gYXBwbHkgdG8gZWFjaCBjaGlsZCBub2RlIGluIHR1cm5cbiAgICBzdGFydFN0eWxlczogUmVhY3QuQ1NTUHJvcGVydGllc1tdO1xufVxuXG4vKipcbiAqIFRoZSBOb2RlQW5pbWF0b3IgY29udGFpbnMgY29tcG9uZW50cyBhbmQgYW5pbWF0ZXMgdHJhbnNpdGlvbnMuXG4gKiBJdCB3aWxsIG9ubHkgcGljayB1cCBkaXJlY3QgY2hhbmdlcyB0byBwcm9wZXJ0aWVzICgnbGVmdCcsIGN1cnJlbnRseSksIGFuZCBzb1xuICogd2lsbCBub3Qgd29yayBmb3IgYW5pbWF0aW5nIHBvc2l0aW9uYWwgY2hhbmdlcyB3aGVyZSB0aGUgcG9zaXRpb24gaXMgaW1wbGljaXRcbiAqIGZyb20gRE9NIG9yZGVyLiBUaGlzIG1ha2VzIGl0IGEgbG90IHNpbXBsZXIgYW5kIGxpZ2h0ZXI6IGlmIHlvdSBuZWVkIGZ1bGx5XG4gKiBhdXRvbWF0aWMgcG9zaXRpb25hbCBhbmltYXRpb24sIGxvb2sgYXQgcmVhY3Qtc2h1ZmZsZSBvciBzaW1pbGFyIGxpYnJhcmllcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9kZUFuaW1hdG9yIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PElQcm9wcz4ge1xuICAgIHByaXZhdGUgbm9kZXMgPSB7fTtcbiAgICBwcml2YXRlIGNoaWxkcmVuOiB7IFtrZXk6IHN0cmluZ106IFJlYWN0LkRldGFpbGVkUmVhY3RIVE1MRWxlbWVudDxhbnksIEhUTUxFbGVtZW50PiB9O1xuICAgIHB1YmxpYyBzdGF0aWMgZGVmYXVsdFByb3BzOiBQYXJ0aWFsPElQcm9wcz4gPSB7XG4gICAgICAgIHN0YXJ0U3R5bGVzOiBbXSxcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHM6IElQcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY29tcG9uZW50RGlkVXBkYXRlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSBlbGVtZW50IHRvIGFwcGx5IHN0eWxlcyB0b1xuICAgICAqIEBwYXJhbSB7UmVhY3QuQ1NTUHJvcGVydGllc30gc3R5bGVzIGEga2V5L3ZhbHVlIHBhaXIgb2YgQ1NTIHByb3BlcnRpZXNcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBwcml2YXRlIGFwcGx5U3R5bGVzKG5vZGU6IEhUTUxFbGVtZW50LCBzdHlsZXM6IFJlYWN0LkNTU1Byb3BlcnRpZXMpOiB2b2lkIHtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoc3R5bGVzKS5mb3JFYWNoKChbcHJvcGVydHksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgbm9kZS5zdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVDaGlsZHJlbihuZXdDaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG9sZENoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiB8fCB7fTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IHt9O1xuICAgICAgICBSZWFjdC5DaGlsZHJlbi50b0FycmF5KG5ld0NoaWxkcmVuKS5mb3JFYWNoKChjOiBhbnkpID0+IHtcbiAgICAgICAgICAgIGlmIChvbGRDaGlsZHJlbltjLmtleV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGQgPSBvbGRDaGlsZHJlbltjLmtleV07XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkTm9kZSA9IFJlYWN0RG9tLmZpbmRET01Ob2RlKHRoaXMubm9kZXNbb2xkLmtleV0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9sZE5vZGUgJiYgKG9sZE5vZGUgYXMgSFRNTEVsZW1lbnQpLnN0eWxlLmxlZnQgIT09IGMucHJvcHMuc3R5bGUubGVmdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGx5U3R5bGVzKG9sZE5vZGUgYXMgSFRNTEVsZW1lbnQsIHsgbGVmdDogYy5wcm9wcy5zdHlsZS5sZWZ0IH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInRyYW5zbGF0aW9uOiBcIitvbGROb2RlLnN0eWxlLmxlZnQrXCIgLT4gXCIrYy5wcm9wcy5zdHlsZS5sZWZ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY2xvbmUgdGhlIG9sZCBlbGVtZW50IHdpdGggdGhlIHByb3BzIChhbmQgY2hpbGRyZW4pIG9mIHRoZSBuZXcgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIHNvIHByb3AgdXBkYXRlcyBhcmUgc3RpbGwgcmVjZWl2ZWQgYnkgdGhlIGNoaWxkcmVuLlxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5bYy5rZXldID0gUmVhY3QuY2xvbmVFbGVtZW50KG9sZCwgYy5wcm9wcywgYy5wcm9wcy5jaGlsZHJlbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5ldyBlbGVtZW50LiBJZiB3ZSBoYXZlIGEgc3RhcnRTdHlsZSwgdXNlIHRoYXQgYXMgdGhlIHN0eWxlIGFuZCBnbyB0aHJvdWdoXG4gICAgICAgICAgICAgICAgLy8gdGhlIGVudGVyIGFuaW1hdGlvbnNcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdQcm9wczogUGFydGlhbDxJQ2hpbGRQcm9wcz4gPSB7fTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN0aW5nU3R5bGUgPSBjLnByb3BzLnN0eWxlO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRTdHlsZXMgPSB0aGlzLnByb3BzLnN0YXJ0U3R5bGVzO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydFN0eWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0U3R5bGUgPSBzdGFydFN0eWxlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMuc3R5bGUgPSBzdGFydFN0eWxlO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIm1vdW50ZWRAc3RhcnRzdHlsZTA6IFwiK0pTT04uc3RyaW5naWZ5KHN0YXJ0U3R5bGUpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuZXdQcm9wcy5yZWYgPSAoKG4pID0+IHRoaXMuY29sbGVjdE5vZGUoXG4gICAgICAgICAgICAgICAgICAgIGMua2V5LCBuLCByZXN0aW5nU3R5bGUsXG4gICAgICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2Mua2V5XSA9IFJlYWN0LmNsb25lRWxlbWVudChjLCBuZXdQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgY29sbGVjdE5vZGUoazogc3RyaW5nLCBub2RlOiBSZWFjdC5SZWFjdEluc3RhbmNlLCByZXN0aW5nU3R5bGU6IFJlYWN0LkNTU1Byb3BlcnRpZXMpOiB2b2lkIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgbm9kZSAmJlxuICAgICAgICAgICAgdGhpcy5ub2Rlc1trXSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLnByb3BzLnN0YXJ0U3R5bGVzLmxlbmd0aCA+IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydFN0eWxlcyA9IHRoaXMucHJvcHMuc3RhcnRTdHlsZXM7XG4gICAgICAgICAgICBjb25zdCBkb21Ob2RlID0gUmVhY3REb20uZmluZERPTU5vZGUobm9kZSk7XG4gICAgICAgICAgICAvLyBzdGFydCBmcm9tIHN0YXJ0U3R5bGUgMTogMCBpcyB0aGUgb25lIHdlIGdhdmUgaXRcbiAgICAgICAgICAgIC8vIHRvIHN0YXJ0IHdpdGgsIHNvIG5vdyB3ZSBhbmltYXRlIDEgZXRjLlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdGFydFN0eWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlTdHlsZXMoZG9tTm9kZSBhcyBIVE1MRWxlbWVudCwgc3RhcnRTdHlsZXNbaV0pO1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwic3RhcnQ6XCJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShzdGFydFN0eWxlc1tpXSksXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYW5kIHRoZW4gd2UgYW5pbWF0ZSB0byB0aGUgcmVzdGluZyBzdGF0ZVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVN0eWxlcyhkb21Ob2RlIGFzIEhUTUxFbGVtZW50LCByZXN0aW5nU3R5bGUpO1xuICAgICAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiZW50ZXI6XCIsXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShyZXN0aW5nU3R5bGUpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGVzW2tdID0gbm9kZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVuZGVyKCk6IEpTWC5FbGVtZW50IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDw+eyBPYmplY3QudmFsdWVzKHRoaXMuY2hpbGRyZW4pIH08Lz5cbiAgICAgICAgKTtcbiAgICB9XG59XG4iXX0=