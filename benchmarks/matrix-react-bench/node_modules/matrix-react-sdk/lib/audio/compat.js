"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAudioContext = createAudioContext;
exports.decodeOgg = decodeOgg;

var _VoiceRecording = require("./VoiceRecording");

var _decoderWorkerMin = _interopRequireDefault(require("opus-recorder/dist/decoderWorker.min.wasm"));

var _waveWorkerMin = _interopRequireDefault(require("opus-recorder/dist/waveWorker.min.js"));

var _decoderWorkerMin2 = _interopRequireDefault(require("opus-recorder/dist/decoderWorker.min.js"));

var _logger = require("matrix-js-sdk/src/logger");

/*
Copyright 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// @ts-ignore - we know that this is not a module. We're looking for a path.
function createAudioContext(opts) {
  if (window.AudioContext) {
    return new AudioContext(opts);
  } else if (window.webkitAudioContext) {
    // While the linter is correct that "a constructor name should not start with
    // a lowercase letter", it's also wrong to think that we have control over this.
    // eslint-disable-next-line new-cap
    return new window.webkitAudioContext(opts);
  } else {
    throw new Error("Unsupported browser");
  }
}

function decodeOgg(audioBuffer) {
  // Condensed version of decoder example, using a promise:
  // https://github.com/chris-rudmin/opus-recorder/blob/master/example/decoder.html
  return new Promise(resolve => {
    // no reject because the workers don't seem to have a fail path
    _logger.logger.log("Decoder WASM path: " + _decoderWorkerMin.default); // so we use the variable (avoid tree shake)


    const typedArray = new Uint8Array(audioBuffer);
    const decoderWorker = new Worker(_decoderWorkerMin2.default);
    const wavWorker = new Worker(_waveWorkerMin.default);
    decoderWorker.postMessage({
      command: 'init',
      decoderSampleRate: _VoiceRecording.SAMPLE_RATE,
      outputBufferSampleRate: _VoiceRecording.SAMPLE_RATE
    });
    wavWorker.postMessage({
      command: 'init',
      wavBitDepth: 24,
      // standard for 48khz (SAMPLE_RATE)
      wavSampleRate: _VoiceRecording.SAMPLE_RATE
    });

    decoderWorker.onmessage = ev => {
      if (ev.data === null) {
        // null == done
        wavWorker.postMessage({
          command: 'done'
        });
        return;
      }

      wavWorker.postMessage({
        command: 'encode',
        buffers: ev.data
      }, ev.data.map(b => b.buffer));
    };

    wavWorker.onmessage = ev => {
      if (ev.data.message === 'page') {
        // The encoding comes through as a single page
        resolve(new Blob([ev.data.page], {
          type: "audio/wav"
        }).arrayBuffer());
      }
    };

    decoderWorker.postMessage({
      command: 'decode',
      pages: typedArray
    }, [typedArray.buffer]);
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hdWRpby9jb21wYXQudHMiXSwibmFtZXMiOlsiY3JlYXRlQXVkaW9Db250ZXh0Iiwib3B0cyIsIndpbmRvdyIsIkF1ZGlvQ29udGV4dCIsIndlYmtpdEF1ZGlvQ29udGV4dCIsIkVycm9yIiwiZGVjb2RlT2dnIiwiYXVkaW9CdWZmZXIiLCJQcm9taXNlIiwicmVzb2x2ZSIsImxvZ2dlciIsImxvZyIsImRlY29kZXJXYXNtUGF0aCIsInR5cGVkQXJyYXkiLCJVaW50OEFycmF5IiwiZGVjb2RlcldvcmtlciIsIldvcmtlciIsImRlY29kZXJQYXRoIiwid2F2V29ya2VyIiwid2F2RW5jb2RlclBhdGgiLCJwb3N0TWVzc2FnZSIsImNvbW1hbmQiLCJkZWNvZGVyU2FtcGxlUmF0ZSIsIlNBTVBMRV9SQVRFIiwib3V0cHV0QnVmZmVyU2FtcGxlUmF0ZSIsIndhdkJpdERlcHRoIiwid2F2U2FtcGxlUmF0ZSIsIm9ubWVzc2FnZSIsImV2IiwiZGF0YSIsImJ1ZmZlcnMiLCJtYXAiLCJiIiwiYnVmZmVyIiwibWVzc2FnZSIsIkJsb2IiLCJwYWdlIiwidHlwZSIsImFycmF5QnVmZmVyIiwicGFnZXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFnQkE7O0FBR0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBT08sU0FBU0Esa0JBQVQsQ0FBNEJDLElBQTVCLEVBQXNFO0FBQ3pFLE1BQUlDLE1BQU0sQ0FBQ0MsWUFBWCxFQUF5QjtBQUNyQixXQUFPLElBQUlBLFlBQUosQ0FBaUJGLElBQWpCLENBQVA7QUFDSCxHQUZELE1BRU8sSUFBSUMsTUFBTSxDQUFDRSxrQkFBWCxFQUErQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxXQUFPLElBQUlGLE1BQU0sQ0FBQ0Usa0JBQVgsQ0FBOEJILElBQTlCLENBQVA7QUFDSCxHQUxNLE1BS0E7QUFDSCxVQUFNLElBQUlJLEtBQUosQ0FBVSxxQkFBVixDQUFOO0FBQ0g7QUFDSjs7QUFFTSxTQUFTQyxTQUFULENBQW1CQyxXQUFuQixFQUFtRTtBQUN0RTtBQUNBO0FBQ0EsU0FBTyxJQUFJQyxPQUFKLENBQWFDLE9BQUQsSUFBYTtBQUFFO0FBQzlCQyxtQkFBT0MsR0FBUCxDQUFXLHdCQUF3QkMseUJBQW5DLEVBRDRCLENBQ3lCOzs7QUFDckQsVUFBTUMsVUFBVSxHQUFHLElBQUlDLFVBQUosQ0FBZVAsV0FBZixDQUFuQjtBQUNBLFVBQU1RLGFBQWEsR0FBRyxJQUFJQyxNQUFKLENBQVdDLDBCQUFYLENBQXRCO0FBQ0EsVUFBTUMsU0FBUyxHQUFHLElBQUlGLE1BQUosQ0FBV0csc0JBQVgsQ0FBbEI7QUFFQUosSUFBQUEsYUFBYSxDQUFDSyxXQUFkLENBQTBCO0FBQ3RCQyxNQUFBQSxPQUFPLEVBQUUsTUFEYTtBQUV0QkMsTUFBQUEsaUJBQWlCLEVBQUVDLDJCQUZHO0FBR3RCQyxNQUFBQSxzQkFBc0IsRUFBRUQ7QUFIRixLQUExQjtBQU1BTCxJQUFBQSxTQUFTLENBQUNFLFdBQVYsQ0FBc0I7QUFDbEJDLE1BQUFBLE9BQU8sRUFBRSxNQURTO0FBRWxCSSxNQUFBQSxXQUFXLEVBQUUsRUFGSztBQUVEO0FBQ2pCQyxNQUFBQSxhQUFhLEVBQUVIO0FBSEcsS0FBdEI7O0FBTUFSLElBQUFBLGFBQWEsQ0FBQ1ksU0FBZCxHQUEyQkMsRUFBRCxJQUFRO0FBQzlCLFVBQUlBLEVBQUUsQ0FBQ0MsSUFBSCxLQUFZLElBQWhCLEVBQXNCO0FBQUU7QUFDcEJYLFFBQUFBLFNBQVMsQ0FBQ0UsV0FBVixDQUFzQjtBQUFFQyxVQUFBQSxPQUFPLEVBQUU7QUFBWCxTQUF0QjtBQUNBO0FBQ0g7O0FBRURILE1BQUFBLFNBQVMsQ0FBQ0UsV0FBVixDQUFzQjtBQUNsQkMsUUFBQUEsT0FBTyxFQUFFLFFBRFM7QUFFbEJTLFFBQUFBLE9BQU8sRUFBRUYsRUFBRSxDQUFDQztBQUZNLE9BQXRCLEVBR0dELEVBQUUsQ0FBQ0MsSUFBSCxDQUFRRSxHQUFSLENBQVlDLENBQUMsSUFBSUEsQ0FBQyxDQUFDQyxNQUFuQixDQUhIO0FBSUgsS0FWRDs7QUFZQWYsSUFBQUEsU0FBUyxDQUFDUyxTQUFWLEdBQXVCQyxFQUFELElBQVE7QUFDMUIsVUFBSUEsRUFBRSxDQUFDQyxJQUFILENBQVFLLE9BQVIsS0FBb0IsTUFBeEIsRUFBZ0M7QUFDNUI7QUFDQXpCLFFBQUFBLE9BQU8sQ0FBQyxJQUFJMEIsSUFBSixDQUFTLENBQUNQLEVBQUUsQ0FBQ0MsSUFBSCxDQUFRTyxJQUFULENBQVQsRUFBeUI7QUFBRUMsVUFBQUEsSUFBSSxFQUFFO0FBQVIsU0FBekIsRUFBZ0RDLFdBQWhELEVBQUQsQ0FBUDtBQUNIO0FBQ0osS0FMRDs7QUFPQXZCLElBQUFBLGFBQWEsQ0FBQ0ssV0FBZCxDQUEwQjtBQUN0QkMsTUFBQUEsT0FBTyxFQUFFLFFBRGE7QUFFdEJrQixNQUFBQSxLQUFLLEVBQUUxQjtBQUZlLEtBQTFCLEVBR0csQ0FBQ0EsVUFBVSxDQUFDb0IsTUFBWixDQUhIO0FBSUgsR0F6Q00sQ0FBUDtBQTBDSCIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAyMSBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB7IFNBTVBMRV9SQVRFIH0gZnJvbSBcIi4vVm9pY2VSZWNvcmRpbmdcIjtcblxuLy8gQHRzLWlnbm9yZSAtIHdlIGtub3cgdGhhdCB0aGlzIGlzIG5vdCBhIG1vZHVsZS4gV2UncmUgbG9va2luZyBmb3IgYSBwYXRoLlxuaW1wb3J0IGRlY29kZXJXYXNtUGF0aCBmcm9tICdvcHVzLXJlY29yZGVyL2Rpc3QvZGVjb2Rlcldvcmtlci5taW4ud2FzbSc7XG5pbXBvcnQgd2F2RW5jb2RlclBhdGggZnJvbSAnb3B1cy1yZWNvcmRlci9kaXN0L3dhdmVXb3JrZXIubWluLmpzJztcbmltcG9ydCBkZWNvZGVyUGF0aCBmcm9tICdvcHVzLXJlY29yZGVyL2Rpc3QvZGVjb2Rlcldvcmtlci5taW4uanMnO1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvbG9nZ2VyXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBdWRpb0NvbnRleHQob3B0cz86IEF1ZGlvQ29udGV4dE9wdGlvbnMpOiBBdWRpb0NvbnRleHQge1xuICAgIGlmICh3aW5kb3cuQXVkaW9Db250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQXVkaW9Db250ZXh0KG9wdHMpO1xuICAgIH0gZWxzZSBpZiAod2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCkge1xuICAgICAgICAvLyBXaGlsZSB0aGUgbGludGVyIGlzIGNvcnJlY3QgdGhhdCBcImEgY29uc3RydWN0b3IgbmFtZSBzaG91bGQgbm90IHN0YXJ0IHdpdGhcbiAgICAgICAgLy8gYSBsb3dlcmNhc2UgbGV0dGVyXCIsIGl0J3MgYWxzbyB3cm9uZyB0byB0aGluayB0aGF0IHdlIGhhdmUgY29udHJvbCBvdmVyIHRoaXMuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG4gICAgICAgIHJldHVybiBuZXcgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dChvcHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBicm93c2VyXCIpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU9nZyhhdWRpb0J1ZmZlcjogQXJyYXlCdWZmZXIpOiBQcm9taXNlPEFycmF5QnVmZmVyPiB7XG4gICAgLy8gQ29uZGVuc2VkIHZlcnNpb24gb2YgZGVjb2RlciBleGFtcGxlLCB1c2luZyBhIHByb21pc2U6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NocmlzLXJ1ZG1pbi9vcHVzLXJlY29yZGVyL2Jsb2IvbWFzdGVyL2V4YW1wbGUvZGVjb2Rlci5odG1sXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7IC8vIG5vIHJlamVjdCBiZWNhdXNlIHRoZSB3b3JrZXJzIGRvbid0IHNlZW0gdG8gaGF2ZSBhIGZhaWwgcGF0aFxuICAgICAgICBsb2dnZXIubG9nKFwiRGVjb2RlciBXQVNNIHBhdGg6IFwiICsgZGVjb2Rlcldhc21QYXRoKTsgLy8gc28gd2UgdXNlIHRoZSB2YXJpYWJsZSAoYXZvaWQgdHJlZSBzaGFrZSlcbiAgICAgICAgY29uc3QgdHlwZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KGF1ZGlvQnVmZmVyKTtcbiAgICAgICAgY29uc3QgZGVjb2RlcldvcmtlciA9IG5ldyBXb3JrZXIoZGVjb2RlclBhdGgpO1xuICAgICAgICBjb25zdCB3YXZXb3JrZXIgPSBuZXcgV29ya2VyKHdhdkVuY29kZXJQYXRoKTtcblxuICAgICAgICBkZWNvZGVyV29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGNvbW1hbmQ6ICdpbml0JyxcbiAgICAgICAgICAgIGRlY29kZXJTYW1wbGVSYXRlOiBTQU1QTEVfUkFURSxcbiAgICAgICAgICAgIG91dHB1dEJ1ZmZlclNhbXBsZVJhdGU6IFNBTVBMRV9SQVRFLFxuICAgICAgICB9KTtcblxuICAgICAgICB3YXZXb3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgY29tbWFuZDogJ2luaXQnLFxuICAgICAgICAgICAgd2F2Qml0RGVwdGg6IDI0LCAvLyBzdGFuZGFyZCBmb3IgNDhraHogKFNBTVBMRV9SQVRFKVxuICAgICAgICAgICAgd2F2U2FtcGxlUmF0ZTogU0FNUExFX1JBVEUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlY29kZXJXb3JrZXIub25tZXNzYWdlID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXYuZGF0YSA9PT0gbnVsbCkgeyAvLyBudWxsID09IGRvbmVcbiAgICAgICAgICAgICAgICB3YXZXb3JrZXIucG9zdE1lc3NhZ2UoeyBjb21tYW5kOiAnZG9uZScgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3YXZXb3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdlbmNvZGUnLFxuICAgICAgICAgICAgICAgIGJ1ZmZlcnM6IGV2LmRhdGEsXG4gICAgICAgICAgICB9LCBldi5kYXRhLm1hcChiID0+IGIuYnVmZmVyKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgd2F2V29ya2VyLm9ubWVzc2FnZSA9IChldikgPT4ge1xuICAgICAgICAgICAgaWYgKGV2LmRhdGEubWVzc2FnZSA9PT0gJ3BhZ2UnKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGVuY29kaW5nIGNvbWVzIHRocm91Z2ggYXMgYSBzaW5nbGUgcGFnZVxuICAgICAgICAgICAgICAgIHJlc29sdmUobmV3IEJsb2IoW2V2LmRhdGEucGFnZV0sIHsgdHlwZTogXCJhdWRpby93YXZcIiB9KS5hcnJheUJ1ZmZlcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBkZWNvZGVyV29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGNvbW1hbmQ6ICdkZWNvZGUnLFxuICAgICAgICAgICAgcGFnZXM6IHR5cGVkQXJyYXksXG4gICAgICAgIH0sIFt0eXBlZEFycmF5LmJ1ZmZlcl0pO1xuICAgIH0pO1xufVxuIl19