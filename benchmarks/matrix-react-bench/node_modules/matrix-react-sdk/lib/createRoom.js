"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canEncryptToAllUsers = canEncryptToAllUsers;
exports.default = createRoom;
exports.ensureDMExists = ensureDMExists;
exports.ensureVirtualRoomExists = ensureVirtualRoomExists;
exports.findDMForUser = findDMForUser;
exports.privateShouldBeEncrypted = privateShouldBeEncrypted;
exports.waitForMember = waitForMember;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _event = require("matrix-js-sdk/src/@types/event");

var _partials = require("matrix-js-sdk/src/@types/partials");

var _MatrixClientPeg = require("./MatrixClientPeg");

var _Modal = _interopRequireDefault(require("./Modal"));

var _languageHandler = require("./languageHandler");

var _dispatcher = _interopRequireDefault(require("./dispatcher/dispatcher"));

var Rooms = _interopRequireWildcard(require("./Rooms"));

var _DMRoomMap = _interopRequireDefault(require("./utils/DMRoomMap"));

var _UserAddress = require("./UserAddress");

var _WellKnownUtils = require("./utils/WellKnownUtils");

var _GroupStore = _interopRequireDefault(require("./stores/GroupStore"));

var _CountlyAnalytics = _interopRequireDefault(require("./CountlyAnalytics"));

var _membership = require("./utils/membership");

var _CallHandler = require("./CallHandler");

var _SpaceStore = _interopRequireDefault(require("./stores/spaces/SpaceStore"));

var _space = require("./utils/space");

var _actions = require("./dispatcher/actions");

var _ErrorDialog = _interopRequireDefault(require("./components/views/dialogs/ErrorDialog"));

var _Spinner = _interopRequireDefault(require("./components/views/elements/Spinner"));

var _logger = require("matrix-js-sdk/src/logger");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Create a new room, and switch to it.
 *
 * @param {object=} opts parameters for creating the room
 * @param {string=} opts.dmUserId If specified, make this a DM room for this user and invite them
 * @param {object=} opts.createOpts set of options to pass to createRoom call.
 * @param {bool=} opts.spinner True to show a modal spinner while the room is created.
 *     Default: True
 * @param {bool=} opts.guestAccess Whether to enable guest access.
 *     Default: True
 * @param {bool=} opts.encryption Whether to enable encryption.
 *     Default: False
 * @param {bool=} opts.inlineErrors True to raise errors off the promise instead of resolving to null.
 *     Default: False
 * @param {bool=} opts.andView True to dispatch an action to view the room once it has been created.
 *
 * @returns {Promise} which resolves to the room id, or null if the
 * action was aborted or failed.
 */
async function createRoom(opts) {
  opts = opts || {};
  if (opts.spinner === undefined) opts.spinner = true;
  if (opts.guestAccess === undefined) opts.guestAccess = true;
  if (opts.encryption === undefined) opts.encryption = false;

  const startTime = _CountlyAnalytics.default.getTimestamp();

  const client = _MatrixClientPeg.MatrixClientPeg.get();

  if (client.isGuest()) {
    _dispatcher.default.dispatch({
      action: 'require_registration'
    });

    return null;
  }

  const defaultPreset = opts.dmUserId ? _partials.Preset.TrustedPrivateChat : _partials.Preset.PrivateChat; // set some defaults for the creation

  const createOpts = opts.createOpts || {};
  createOpts.preset = createOpts.preset || defaultPreset;
  createOpts.visibility = createOpts.visibility || _partials.Visibility.Private;

  if (opts.dmUserId && createOpts.invite === undefined) {
    switch ((0, _UserAddress.getAddressType)(opts.dmUserId)) {
      case 'mx-user-id':
        createOpts.invite = [opts.dmUserId];
        break;

      case 'email':
        createOpts.invite_3pid = [{
          id_server: _MatrixClientPeg.MatrixClientPeg.get().getIdentityServerUrl(true),
          medium: 'email',
          address: opts.dmUserId
        }];
    }
  }

  if (opts.dmUserId && createOpts.is_direct === undefined) {
    createOpts.is_direct = true;
  }

  if (opts.roomType) {
    createOpts.creation_content = _objectSpread(_objectSpread({}, createOpts.creation_content), {}, {
      [_event.RoomCreateTypeField]: opts.roomType
    });
  } // By default, view the room after creating it


  if (opts.andView === undefined) {
    opts.andView = true;
  }

  createOpts.initial_state = createOpts.initial_state || []; // Allow guests by default since the room is private and they'd
  // need an invite. This means clicking on a 3pid invite email can
  // actually drop you right in to a chat.

  if (opts.guestAccess) {
    createOpts.initial_state.push({
      type: 'm.room.guest_access',
      state_key: '',
      content: {
        guest_access: 'can_join'
      }
    });
  }

  if (opts.encryption) {
    createOpts.initial_state.push({
      type: 'm.room.encryption',
      state_key: '',
      content: {
        algorithm: 'm.megolm.v1.aes-sha2'
      }
    });
  }

  if (opts.parentSpace) {
    createOpts.initial_state.push((0, _space.makeSpaceParentEvent)(opts.parentSpace, true));

    if (!opts.historyVisibility) {
      opts.historyVisibility = createOpts.preset === _partials.Preset.PublicChat ? _partials.HistoryVisibility.WorldReadable : _partials.HistoryVisibility.Invited;
    }

    if (opts.joinRule === _partials.JoinRule.Restricted) {
      var _SpaceStore$instance$;

      if ((_SpaceStore$instance$ = _SpaceStore.default.instance.restrictedJoinRuleSupport) !== null && _SpaceStore$instance$ !== void 0 && _SpaceStore$instance$.preferred) {
        createOpts.room_version = _SpaceStore.default.instance.restrictedJoinRuleSupport.preferred;
        createOpts.initial_state.push({
          type: _event.EventType.RoomJoinRules,
          content: {
            "join_rule": _partials.JoinRule.Restricted,
            "allow": [{
              "type": _partials.RestrictedAllowType.RoomMembership,
              "room_id": opts.parentSpace.roomId
            }]
          }
        });
      }
    }
  } // we handle the restricted join rule in the parentSpace handling block above


  if (opts.joinRule && opts.joinRule !== _partials.JoinRule.Restricted) {
    createOpts.initial_state.push({
      type: _event.EventType.RoomJoinRules,
      content: {
        join_rule: opts.joinRule
      }
    });
  }

  if (opts.avatar) {
    let url = opts.avatar;

    if (opts.avatar instanceof File) {
      url = await client.uploadContent(opts.avatar);
    }

    createOpts.initial_state.push({
      type: _event.EventType.RoomAvatar,
      content: {
        url
      }
    });
  }

  if (opts.historyVisibility) {
    createOpts.initial_state.push({
      type: _event.EventType.RoomHistoryVisibility,
      content: {
        "history_visibility": opts.historyVisibility
      }
    });
  }

  let modal;
  if (opts.spinner) modal = _Modal.default.createDialog(_Spinner.default, null, 'mx_Dialog_spinner');
  let roomId;
  return client.createRoom(createOpts).catch(function (err) {
    // NB This checks for the Synapse-specific error condition of a room creation
    // having been denied because the requesting user wanted to publish the room,
    // but the server denies them that permission (via room_list_publication_rules).
    // The check below responds by retrying without publishing the room.
    if (err.httpStatus === 403 && err.errcode === "M_UNKNOWN" && err.data.error === "Not allowed to publish room") {
      _logger.logger.warn("Failed to publish room, try again without publishing it");

      createOpts.visibility = _partials.Visibility.Private;
      return client.createRoom(createOpts);
    } else {
      return Promise.reject(err);
    }
  }).finally(function () {
    if (modal) modal.close();
  }).then(function (res) {
    roomId = res.room_id;

    if (opts.dmUserId) {
      return Rooms.setDMRoom(roomId, opts.dmUserId);
    } else {
      return Promise.resolve();
    }
  }).then(() => {
    if (opts.parentSpace) {
      return _SpaceStore.default.instance.addRoomToSpace(opts.parentSpace, roomId, [client.getDomain()], opts.suggested);
    }

    if (opts.associatedWithCommunity) {
      return _GroupStore.default.addRoomToGroup(opts.associatedWithCommunity, roomId, false);
    }
  }).then(function () {
    // NB createRoom doesn't block on the client seeing the echo that the
    // room has been created, so we race here with the client knowing that
    // the room exists, causing things like
    // https://github.com/vector-im/vector-web/issues/1813
    // Even if we were to block on the echo, servers tend to split the room
    // state over multiple syncs so we can't atomically know when we have the
    // entire thing.
    if (opts.andView) {
      _dispatcher.default.dispatch({
        action: _actions.Action.ViewRoom,
        room_id: roomId,
        should_peek: false,
        // Creating a room will have joined us to the room,
        // so we are expecting the room to come down the sync
        // stream, if it hasn't already.
        joining: true,
        justCreatedOpts: opts
      });
    }

    _CountlyAnalytics.default.instance.trackRoomCreate(startTime, roomId);

    return roomId;
  }, function (err) {
    // Raise the error if the caller requested that we do so.
    if (opts.inlineErrors) throw err; // We also failed to join the room (this sets joining to false in RoomViewStore)

    _dispatcher.default.dispatch({
      action: _actions.Action.JoinRoomError,
      roomId
    });

    _logger.logger.error("Failed to create room " + roomId + " " + err);

    let description = (0, _languageHandler._t)("Server may be unavailable, overloaded, or you hit a bug.");

    if (err.errcode === "M_UNSUPPORTED_ROOM_VERSION") {
      // Technically not possible with the UI as of April 2019 because there's no
      // options for the user to change this. However, it's not a bad thing to report
      // the error to the user for if/when the UI is available.
      description = (0, _languageHandler._t)("The server does not support the room version specified.");
    }

    _Modal.default.createTrackedDialog('Failure to create room', '', _ErrorDialog.default, {
      title: (0, _languageHandler._t)("Failure to create room"),
      description
    });

    return null;
  });
}

function findDMForUser(client, userId) {
  const roomIds = _DMRoomMap.default.shared().getDMRoomsForUserId(userId);

  const rooms = roomIds.map(id => client.getRoom(id));
  const suitableDMRooms = rooms.filter(r => {
    // Validate that we are joined and the other person is also joined. We'll also make sure
    // that the room also looks like a DM (until we have canonical DMs to tell us). For now,
    // a DM is a room of two people that contains those two people exactly. This does mean
    // that bots, assistants, etc will ruin a room's DM-ness, though this is a problem for
    // canonical DMs to solve.
    if (r && r.getMyMembership() === "join") {
      const members = r.currentState.getMembers();
      const joinedMembers = members.filter(m => (0, _membership.isJoinedOrNearlyJoined)(m.membership));
      const otherMember = joinedMembers.find(m => m.userId === userId);
      return otherMember && joinedMembers.length === 2;
    }

    return false;
  }).sort((r1, r2) => {
    return r2.getLastActiveTimestamp() - r1.getLastActiveTimestamp();
  });

  if (suitableDMRooms.length) {
    return suitableDMRooms[0];
  }
}
/*
 * Try to ensure the user is already in the megolm session before continuing
 * NOTE: this assumes you've just created the room and there's not been an opportunity
 * for other code to run, so we shouldn't miss RoomState.newMember when it comes by.
 */


async function waitForMember(client, roomId, userId, opts = {
  timeout: 1500
}) {
  const {
    timeout
  } = opts;
  let handler;
  return new Promise(resolve => {
    handler = function (_, __, member) {
      // eslint-disable-line @typescript-eslint/naming-convention
      if (member.userId !== userId) return;
      if (member.roomId !== roomId) return;
      resolve(true);
    };

    client.on("RoomState.newMember", handler);
    /* We don't want to hang if this goes wrong, so we proceed and hope the other
       user is already in the megolm session */

    setTimeout(resolve, timeout, false);
  }).finally(() => {
    client.removeListener("RoomState.newMember", handler);
  });
}
/*
 * Ensure that for every user in a room, there is at least one device that we
 * can encrypt to.
 */


async function canEncryptToAllUsers(client, userIds) {
  try {
    const usersDeviceMap = await client.downloadKeys(userIds); // { "@user:host": { "DEVICE": {...}, ... }, ... }

    return Object.values(usersDeviceMap).every(userDevices => // { "DEVICE": {...}, ... }
    Object.keys(userDevices).length > 0);
  } catch (e) {
    _logger.logger.error("Error determining if it's possible to encrypt to all users: ", e);

    return false; // assume not
  }
} // Similar to ensureDMExists but also adds creation content
// without polluting ensureDMExists with unrelated stuff (also
// they're never encrypted).


async function ensureVirtualRoomExists(client, userId, nativeRoomId) {
  const existingDMRoom = findDMForUser(client, userId);
  let roomId;

  if (existingDMRoom) {
    roomId = existingDMRoom.roomId;
  } else {
    roomId = await createRoom({
      dmUserId: userId,
      spinner: false,
      andView: false,
      createOpts: {
        creation_content: {
          // This allows us to recognise that the room is a virtual room
          // when it comes down our sync stream (we also put the ID of the
          // respective native room in there because why not?)
          [_CallHandler.VIRTUAL_ROOM_EVENT_TYPE]: nativeRoomId
        }
      }
    });
  }

  return roomId;
}

async function ensureDMExists(client, userId) {
  const existingDMRoom = findDMForUser(client, userId);
  let roomId;

  if (existingDMRoom) {
    roomId = existingDMRoom.roomId;
  } else {
    let encryption = undefined;

    if (privateShouldBeEncrypted()) {
      encryption = await canEncryptToAllUsers(client, [userId]);
    }

    roomId = await createRoom({
      encryption,
      dmUserId: userId,
      spinner: false,
      andView: false
    });
    await waitForMember(client, roomId, userId);
  }

  return roomId;
}

function privateShouldBeEncrypted() {
  const e2eeWellKnown = (0, _WellKnownUtils.getE2EEWellKnown)();

  if (e2eeWellKnown) {
    const defaultDisabled = e2eeWellKnown["default"] === false;
    return !defaultDisabled;
  }

  return true;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jcmVhdGVSb29tLnRzIl0sIm5hbWVzIjpbImNyZWF0ZVJvb20iLCJvcHRzIiwic3Bpbm5lciIsInVuZGVmaW5lZCIsImd1ZXN0QWNjZXNzIiwiZW5jcnlwdGlvbiIsInN0YXJ0VGltZSIsIkNvdW50bHlBbmFseXRpY3MiLCJnZXRUaW1lc3RhbXAiLCJjbGllbnQiLCJNYXRyaXhDbGllbnRQZWciLCJnZXQiLCJpc0d1ZXN0IiwiZGlzIiwiZGlzcGF0Y2giLCJhY3Rpb24iLCJkZWZhdWx0UHJlc2V0IiwiZG1Vc2VySWQiLCJQcmVzZXQiLCJUcnVzdGVkUHJpdmF0ZUNoYXQiLCJQcml2YXRlQ2hhdCIsImNyZWF0ZU9wdHMiLCJwcmVzZXQiLCJ2aXNpYmlsaXR5IiwiVmlzaWJpbGl0eSIsIlByaXZhdGUiLCJpbnZpdGUiLCJpbnZpdGVfM3BpZCIsImlkX3NlcnZlciIsImdldElkZW50aXR5U2VydmVyVXJsIiwibWVkaXVtIiwiYWRkcmVzcyIsImlzX2RpcmVjdCIsInJvb21UeXBlIiwiY3JlYXRpb25fY29udGVudCIsIlJvb21DcmVhdGVUeXBlRmllbGQiLCJhbmRWaWV3IiwiaW5pdGlhbF9zdGF0ZSIsInB1c2giLCJ0eXBlIiwic3RhdGVfa2V5IiwiY29udGVudCIsImd1ZXN0X2FjY2VzcyIsImFsZ29yaXRobSIsInBhcmVudFNwYWNlIiwiaGlzdG9yeVZpc2liaWxpdHkiLCJQdWJsaWNDaGF0IiwiSGlzdG9yeVZpc2liaWxpdHkiLCJXb3JsZFJlYWRhYmxlIiwiSW52aXRlZCIsImpvaW5SdWxlIiwiSm9pblJ1bGUiLCJSZXN0cmljdGVkIiwiU3BhY2VTdG9yZSIsImluc3RhbmNlIiwicmVzdHJpY3RlZEpvaW5SdWxlU3VwcG9ydCIsInByZWZlcnJlZCIsInJvb21fdmVyc2lvbiIsIkV2ZW50VHlwZSIsIlJvb21Kb2luUnVsZXMiLCJSZXN0cmljdGVkQWxsb3dUeXBlIiwiUm9vbU1lbWJlcnNoaXAiLCJyb29tSWQiLCJqb2luX3J1bGUiLCJhdmF0YXIiLCJ1cmwiLCJGaWxlIiwidXBsb2FkQ29udGVudCIsIlJvb21BdmF0YXIiLCJSb29tSGlzdG9yeVZpc2liaWxpdHkiLCJtb2RhbCIsIk1vZGFsIiwiY3JlYXRlRGlhbG9nIiwiU3Bpbm5lciIsImNhdGNoIiwiZXJyIiwiaHR0cFN0YXR1cyIsImVycmNvZGUiLCJkYXRhIiwiZXJyb3IiLCJsb2dnZXIiLCJ3YXJuIiwiUHJvbWlzZSIsInJlamVjdCIsImZpbmFsbHkiLCJjbG9zZSIsInRoZW4iLCJyZXMiLCJyb29tX2lkIiwiUm9vbXMiLCJzZXRETVJvb20iLCJyZXNvbHZlIiwiYWRkUm9vbVRvU3BhY2UiLCJnZXREb21haW4iLCJzdWdnZXN0ZWQiLCJhc3NvY2lhdGVkV2l0aENvbW11bml0eSIsIkdyb3VwU3RvcmUiLCJhZGRSb29tVG9Hcm91cCIsIkFjdGlvbiIsIlZpZXdSb29tIiwic2hvdWxkX3BlZWsiLCJqb2luaW5nIiwianVzdENyZWF0ZWRPcHRzIiwidHJhY2tSb29tQ3JlYXRlIiwiaW5saW5lRXJyb3JzIiwiSm9pblJvb21FcnJvciIsImRlc2NyaXB0aW9uIiwiY3JlYXRlVHJhY2tlZERpYWxvZyIsIkVycm9yRGlhbG9nIiwidGl0bGUiLCJmaW5kRE1Gb3JVc2VyIiwidXNlcklkIiwicm9vbUlkcyIsIkRNUm9vbU1hcCIsInNoYXJlZCIsImdldERNUm9vbXNGb3JVc2VySWQiLCJyb29tcyIsIm1hcCIsImlkIiwiZ2V0Um9vbSIsInN1aXRhYmxlRE1Sb29tcyIsImZpbHRlciIsInIiLCJnZXRNeU1lbWJlcnNoaXAiLCJtZW1iZXJzIiwiY3VycmVudFN0YXRlIiwiZ2V0TWVtYmVycyIsImpvaW5lZE1lbWJlcnMiLCJtIiwibWVtYmVyc2hpcCIsIm90aGVyTWVtYmVyIiwiZmluZCIsImxlbmd0aCIsInNvcnQiLCJyMSIsInIyIiwiZ2V0TGFzdEFjdGl2ZVRpbWVzdGFtcCIsIndhaXRGb3JNZW1iZXIiLCJ0aW1lb3V0IiwiaGFuZGxlciIsIl8iLCJfXyIsIm1lbWJlciIsIm9uIiwic2V0VGltZW91dCIsInJlbW92ZUxpc3RlbmVyIiwiY2FuRW5jcnlwdFRvQWxsVXNlcnMiLCJ1c2VySWRzIiwidXNlcnNEZXZpY2VNYXAiLCJkb3dubG9hZEtleXMiLCJPYmplY3QiLCJ2YWx1ZXMiLCJldmVyeSIsInVzZXJEZXZpY2VzIiwia2V5cyIsImUiLCJlbnN1cmVWaXJ0dWFsUm9vbUV4aXN0cyIsIm5hdGl2ZVJvb21JZCIsImV4aXN0aW5nRE1Sb29tIiwiVklSVFVBTF9ST09NX0VWRU5UX1RZUEUiLCJlbnN1cmVETUV4aXN0cyIsInByaXZhdGVTaG91bGRCZUVuY3J5cHRlZCIsImUyZWVXZWxsS25vd24iLCJkZWZhdWx0RGlzYWJsZWQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBOztBQUVBOztBQVFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOzs7Ozs7Ozs7O0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2UsZUFBZUEsVUFBZixDQUEwQkMsSUFBMUIsRUFBK0Q7QUFDMUVBLEVBQUFBLElBQUksR0FBR0EsSUFBSSxJQUFJLEVBQWY7QUFDQSxNQUFJQSxJQUFJLENBQUNDLE9BQUwsS0FBaUJDLFNBQXJCLEVBQWdDRixJQUFJLENBQUNDLE9BQUwsR0FBZSxJQUFmO0FBQ2hDLE1BQUlELElBQUksQ0FBQ0csV0FBTCxLQUFxQkQsU0FBekIsRUFBb0NGLElBQUksQ0FBQ0csV0FBTCxHQUFtQixJQUFuQjtBQUNwQyxNQUFJSCxJQUFJLENBQUNJLFVBQUwsS0FBb0JGLFNBQXhCLEVBQW1DRixJQUFJLENBQUNJLFVBQUwsR0FBa0IsS0FBbEI7O0FBRW5DLFFBQU1DLFNBQVMsR0FBR0MsMEJBQWlCQyxZQUFqQixFQUFsQjs7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SixFQUFvQjtBQUNoQmhHLElBQUFBLE1BQU0sR0FBR2dHLGNBQWMsQ0FBQ2hHLE1BQXhCO0FBQ0gsR0FGRCxNQUVPO0FBQ0gsUUFBSXpELFVBQW1CLEdBQUdGLFNBQTFCOztBQUNBLFFBQUk4Six3QkFBd0IsRUFBNUIsRUFBZ0M7QUFDNUI1SixNQUFBQSxVQUFVLEdBQUcsTUFBTTZJLG9CQUFvQixDQUFDekksTUFBRCxFQUFTLENBQUNzRyxNQUFELENBQVQsQ0FBdkM7QUFDSDs7QUFFRGpELElBQUFBLE1BQU0sR0FBRyxNQUFNOUQsVUFBVSxDQUFDO0FBQUVLLE1BQUFBLFVBQUY7QUFBY1ksTUFBQUEsUUFBUSxFQUFFOEYsTUFBeEI7QUFBZ0M3RyxNQUFBQSxPQUFPLEVBQUUsS0FBekM7QUFBZ0RrQyxNQUFBQSxPQUFPLEVBQUU7QUFBekQsS0FBRCxDQUF6QjtBQUNBLFVBQU1xRyxhQUFhLENBQUNoSSxNQUFELEVBQVNxRCxNQUFULEVBQWlCaUQsTUFBakIsQ0FBbkI7QUFDSDs7QUFDRCxTQUFPakQsTUFBUDtBQUNIOztBQUVNLFNBQVNtRyx3QkFBVCxHQUE2QztBQUNoRCxRQUFNQyxhQUFhLEdBQUcsdUNBQXRCOztBQUNBLE1BQUlBLGFBQUosRUFBbUI7QUFDZixVQUFNQyxlQUFlLEdBQUdELGFBQWEsQ0FBQyxTQUFELENBQWIsS0FBNkIsS0FBckQ7QUFDQSxXQUFPLENBQUNDLGVBQVI7QUFDSDs7QUFDRCxTQUFPLElBQVA7QUFDSCIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxNSwgMjAxNiBPcGVuTWFya2V0IEx0ZFxuQ29weXJpZ2h0IDIwMTksIDIwMjAgVGhlIE1hdHJpeC5vcmcgRm91bmRhdGlvbiBDLkkuQy5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgeyBNYXRyaXhDbGllbnQgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvY2xpZW50XCI7XG5pbXBvcnQgeyBSb29tIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL21vZGVscy9yb29tXCI7XG5pbXBvcnQgeyBSb29tTWVtYmVyIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL21vZGVscy9yb29tLW1lbWJlclwiO1xuaW1wb3J0IHsgRXZlbnRUeXBlLCBSb29tQ3JlYXRlVHlwZUZpZWxkLCBSb29tVHlwZSB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9AdHlwZXMvZXZlbnRcIjtcbmltcG9ydCB7IElDcmVhdGVSb29tT3B0cyB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9AdHlwZXMvcmVxdWVzdHNcIjtcbmltcG9ydCB7XG4gICAgSGlzdG9yeVZpc2liaWxpdHksXG4gICAgSm9pblJ1bGUsXG4gICAgUHJlc2V0LFxuICAgIFJlc3RyaWN0ZWRBbGxvd1R5cGUsXG4gICAgVmlzaWJpbGl0eSxcbn0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL0B0eXBlcy9wYXJ0aWFsc1wiO1xuXG5pbXBvcnQgeyBNYXRyaXhDbGllbnRQZWcgfSBmcm9tICcuL01hdHJpeENsaWVudFBlZyc7XG5pbXBvcnQgTW9kYWwgZnJvbSAnLi9Nb2RhbCc7XG5pbXBvcnQgeyBfdCB9IGZyb20gJy4vbGFuZ3VhZ2VIYW5kbGVyJztcbmltcG9ydCBkaXMgZnJvbSBcIi4vZGlzcGF0Y2hlci9kaXNwYXRjaGVyXCI7XG5pbXBvcnQgKiBhcyBSb29tcyBmcm9tIFwiLi9Sb29tc1wiO1xuaW1wb3J0IERNUm9vbU1hcCBmcm9tIFwiLi91dGlscy9ETVJvb21NYXBcIjtcbmltcG9ydCB7IGdldEFkZHJlc3NUeXBlIH0gZnJvbSBcIi4vVXNlckFkZHJlc3NcIjtcbmltcG9ydCB7IGdldEUyRUVXZWxsS25vd24gfSBmcm9tIFwiLi91dGlscy9XZWxsS25vd25VdGlsc1wiO1xuaW1wb3J0IEdyb3VwU3RvcmUgZnJvbSBcIi4vc3RvcmVzL0dyb3VwU3RvcmVcIjtcbmltcG9ydCBDb3VudGx5QW5hbHl0aWNzIGZyb20gXCIuL0NvdW50bHlBbmFseXRpY3NcIjtcbmltcG9ydCB7IGlzSm9pbmVkT3JOZWFybHlKb2luZWQgfSBmcm9tIFwiLi91dGlscy9tZW1iZXJzaGlwXCI7XG5pbXBvcnQgeyBWSVJUVUFMX1JPT01fRVZFTlRfVFlQRSB9IGZyb20gXCIuL0NhbGxIYW5kbGVyXCI7XG5pbXBvcnQgU3BhY2VTdG9yZSBmcm9tIFwiLi9zdG9yZXMvc3BhY2VzL1NwYWNlU3RvcmVcIjtcbmltcG9ydCB7IG1ha2VTcGFjZVBhcmVudEV2ZW50IH0gZnJvbSBcIi4vdXRpbHMvc3BhY2VcIjtcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gXCIuL2Rpc3BhdGNoZXIvYWN0aW9uc1wiO1xuaW1wb3J0IEVycm9yRGlhbG9nIGZyb20gXCIuL2NvbXBvbmVudHMvdmlld3MvZGlhbG9ncy9FcnJvckRpYWxvZ1wiO1xuaW1wb3J0IFNwaW5uZXIgZnJvbSBcIi4vY29tcG9uZW50cy92aWV3cy9lbGVtZW50cy9TcGlubmVyXCI7XG5cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9sb2dnZXJcIjtcblxuLy8gd2UgZGVmaW5lIGEgbnVtYmVyIG9mIGludGVyZmFjZXMgd2hpY2ggdGFrZSB0aGVpciBuYW1lcyBmcm9tIHRoZSBqcy1zZGtcbi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIElPcHRzIHtcbiAgICBkbVVzZXJJZD86IHN0cmluZztcbiAgICBjcmVhdGVPcHRzPzogSUNyZWF0ZVJvb21PcHRzO1xuICAgIHNwaW5uZXI/OiBib29sZWFuO1xuICAgIGd1ZXN0QWNjZXNzPzogYm9vbGVhbjtcbiAgICBlbmNyeXB0aW9uPzogYm9vbGVhbjtcbiAgICBpbmxpbmVFcnJvcnM/OiBib29sZWFuO1xuICAgIGFuZFZpZXc/OiBib29sZWFuO1xuICAgIGFzc29jaWF0ZWRXaXRoQ29tbXVuaXR5Pzogc3RyaW5nO1xuICAgIGF2YXRhcj86IEZpbGUgfCBzdHJpbmc7IC8vIHdpbGwgdXBsb2FkIGlmIGdpdmVuIGZpbGUsIGVsc2UgbXhjVXJsIGlzIG5lZWRlZFxuICAgIHJvb21UeXBlPzogUm9vbVR5cGUgfCBzdHJpbmc7XG4gICAgaGlzdG9yeVZpc2liaWxpdHk/OiBIaXN0b3J5VmlzaWJpbGl0eTtcbiAgICBwYXJlbnRTcGFjZT86IFJvb207XG4gICAgLy8gY29udGV4dHVhbGx5IG9ubHkgbWFrZXMgc2Vuc2UgaWYgcGFyZW50U3BhY2UgaXMgc3BlY2lmaWVkLCBpZiB0cnVlIHRoZW4gd2lsbCBiZSBhZGRlZCB0byBwYXJlbnRTcGFjZSBhcyBzdWdnZXN0ZWRcbiAgICBzdWdnZXN0ZWQ/OiBib29sZWFuO1xuICAgIGpvaW5SdWxlPzogSm9pblJ1bGU7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHJvb20sIGFuZCBzd2l0Y2ggdG8gaXQuXG4gKlxuICogQHBhcmFtIHtvYmplY3Q9fSBvcHRzIHBhcmFtZXRlcnMgZm9yIGNyZWF0aW5nIHRoZSByb29tXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdHMuZG1Vc2VySWQgSWYgc3BlY2lmaWVkLCBtYWtlIHRoaXMgYSBETSByb29tIGZvciB0aGlzIHVzZXIgYW5kIGludml0ZSB0aGVtXG4gKiBAcGFyYW0ge29iamVjdD19IG9wdHMuY3JlYXRlT3B0cyBzZXQgb2Ygb3B0aW9ucyB0byBwYXNzIHRvIGNyZWF0ZVJvb20gY2FsbC5cbiAqIEBwYXJhbSB7Ym9vbD19IG9wdHMuc3Bpbm5lciBUcnVlIHRvIHNob3cgYSBtb2RhbCBzcGlubmVyIHdoaWxlIHRoZSByb29tIGlzIGNyZWF0ZWQuXG4gKiAgICAgRGVmYXVsdDogVHJ1ZVxuICogQHBhcmFtIHtib29sPX0gb3B0cy5ndWVzdEFjY2VzcyBXaGV0aGVyIHRvIGVuYWJsZSBndWVzdCBhY2Nlc3MuXG4gKiAgICAgRGVmYXVsdDogVHJ1ZVxuICogQHBhcmFtIHtib29sPX0gb3B0cy5lbmNyeXB0aW9uIFdoZXRoZXIgdG8gZW5hYmxlIGVuY3J5cHRpb24uXG4gKiAgICAgRGVmYXVsdDogRmFsc2VcbiAqIEBwYXJhbSB7Ym9vbD19IG9wdHMuaW5saW5lRXJyb3JzIFRydWUgdG8gcmFpc2UgZXJyb3JzIG9mZiB0aGUgcHJvbWlzZSBpbnN0ZWFkIG9mIHJlc29sdmluZyB0byBudWxsLlxuICogICAgIERlZmF1bHQ6IEZhbHNlXG4gKiBAcGFyYW0ge2Jvb2w9fSBvcHRzLmFuZFZpZXcgVHJ1ZSB0byBkaXNwYXRjaCBhbiBhY3Rpb24gdG8gdmlldyB0aGUgcm9vbSBvbmNlIGl0IGhhcyBiZWVuIGNyZWF0ZWQuXG4gKlxuICogQHJldHVybnMge1Byb21pc2V9IHdoaWNoIHJlc29sdmVzIHRvIHRoZSByb29tIGlkLCBvciBudWxsIGlmIHRoZVxuICogYWN0aW9uIHdhcyBhYm9ydGVkIG9yIGZhaWxlZC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlUm9vbShvcHRzOiBJT3B0cyk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIGlmIChvcHRzLnNwaW5uZXIgPT09IHVuZGVmaW5lZCkgb3B0cy5zcGlubmVyID0gdHJ1ZTtcbiAgICBpZiAob3B0cy5ndWVzdEFjY2VzcyA9PT0gdW5kZWZpbmVkKSBvcHRzLmd1ZXN0QWNjZXNzID0gdHJ1ZTtcbiAgICBpZiAob3B0cy5lbmNyeXB0aW9uID09PSB1bmRlZmluZWQpIG9wdHMuZW5jcnlwdGlvbiA9IGZhbHNlO1xuXG4gICAgY29uc3Qgc3RhcnRUaW1lID0gQ291bnRseUFuYWx5dGljcy5nZXRUaW1lc3RhbXAoKTtcblxuICAgIGNvbnN0IGNsaWVudCA9IE1hdHJpeENsaWVudFBlZy5nZXQoKTtcbiAgICBpZiAoY2xpZW50LmlzR3Vlc3QoKSkge1xuICAgICAgICBkaXMuZGlzcGF0Y2goeyBhY3Rpb246ICdyZXF1aXJlX3JlZ2lzdHJhdGlvbicgfSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGRlZmF1bHRQcmVzZXQgPSBvcHRzLmRtVXNlcklkID8gUHJlc2V0LlRydXN0ZWRQcml2YXRlQ2hhdCA6IFByZXNldC5Qcml2YXRlQ2hhdDtcblxuICAgIC8vIHNldCBzb21lIGRlZmF1bHRzIGZvciB0aGUgY3JlYXRpb25cbiAgICBjb25zdCBjcmVhdGVPcHRzOiBJQ3JlYXRlUm9vbU9wdHMgPSBvcHRzLmNyZWF0ZU9wdHMgfHwge307XG4gICAgY3JlYXRlT3B0cy5wcmVzZXQgPSBjcmVhdGVPcHRzLnByZXNldCB8fCBkZWZhdWx0UHJlc2V0O1xuICAgIGNyZWF0ZU9wdHMudmlzaWJpbGl0eSA9IGNyZWF0ZU9wdHMudmlzaWJpbGl0eSB8fCBWaXNpYmlsaXR5LlByaXZhdGU7XG4gICAgaWYgKG9wdHMuZG1Vc2VySWQgJiYgY3JlYXRlT3B0cy5pbnZpdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzd2l0Y2ggKGdldEFkZHJlc3NUeXBlKG9wdHMuZG1Vc2VySWQpKSB7XG4gICAgICAgICAgICBjYXNlICdteC11c2VyLWlkJzpcbiAgICAgICAgICAgICAgICBjcmVhdGVPcHRzLmludml0ZSA9IFtvcHRzLmRtVXNlcklkXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2VtYWlsJzpcbiAgICAgICAgICAgICAgICBjcmVhdGVPcHRzLmludml0ZV8zcGlkID0gW3tcbiAgICAgICAgICAgICAgICAgICAgaWRfc2VydmVyOiBNYXRyaXhDbGllbnRQZWcuZ2V0KCkuZ2V0SWRlbnRpdHlTZXJ2ZXJVcmwodHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgIG1lZGl1bTogJ2VtYWlsJyxcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogb3B0cy5kbVVzZXJJZCxcbiAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0cy5kbVVzZXJJZCAmJiBjcmVhdGVPcHRzLmlzX2RpcmVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNyZWF0ZU9wdHMuaXNfZGlyZWN0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5yb29tVHlwZSkge1xuICAgICAgICBjcmVhdGVPcHRzLmNyZWF0aW9uX2NvbnRlbnQgPSB7XG4gICAgICAgICAgICAuLi5jcmVhdGVPcHRzLmNyZWF0aW9uX2NvbnRlbnQsXG4gICAgICAgICAgICBbUm9vbUNyZWF0ZVR5cGVGaWVsZF06IG9wdHMucm9vbVR5cGUsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQnkgZGVmYXVsdCwgdmlldyB0aGUgcm9vbSBhZnRlciBjcmVhdGluZyBpdFxuICAgIGlmIChvcHRzLmFuZFZpZXcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRzLmFuZFZpZXcgPSB0cnVlO1xuICAgIH1cblxuICAgIGNyZWF0ZU9wdHMuaW5pdGlhbF9zdGF0ZSA9IGNyZWF0ZU9wdHMuaW5pdGlhbF9zdGF0ZSB8fCBbXTtcblxuICAgIC8vIEFsbG93IGd1ZXN0cyBieSBkZWZhdWx0IHNpbmNlIHRoZSByb29tIGlzIHByaXZhdGUgYW5kIHRoZXknZFxuICAgIC8vIG5lZWQgYW4gaW52aXRlLiBUaGlzIG1lYW5zIGNsaWNraW5nIG9uIGEgM3BpZCBpbnZpdGUgZW1haWwgY2FuXG4gICAgLy8gYWN0dWFsbHkgZHJvcCB5b3UgcmlnaHQgaW4gdG8gYSBjaGF0LlxuICAgIGlmIChvcHRzLmd1ZXN0QWNjZXNzKSB7XG4gICAgICAgIGNyZWF0ZU9wdHMuaW5pdGlhbF9zdGF0ZS5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdtLnJvb20uZ3Vlc3RfYWNjZXNzJyxcbiAgICAgICAgICAgIHN0YXRlX2tleTogJycsXG4gICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgZ3Vlc3RfYWNjZXNzOiAnY2FuX2pvaW4nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuZW5jcnlwdGlvbikge1xuICAgICAgICBjcmVhdGVPcHRzLmluaXRpYWxfc3RhdGUucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnbS5yb29tLmVuY3J5cHRpb24nLFxuICAgICAgICAgICAgc3RhdGVfa2V5OiAnJyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICBhbGdvcml0aG06ICdtLm1lZ29sbS52MS5hZXMtc2hhMicsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5wYXJlbnRTcGFjZSkge1xuICAgICAgICBjcmVhdGVPcHRzLmluaXRpYWxfc3RhdGUucHVzaChtYWtlU3BhY2VQYXJlbnRFdmVudChvcHRzLnBhcmVudFNwYWNlLCB0cnVlKSk7XG4gICAgICAgIGlmICghb3B0cy5oaXN0b3J5VmlzaWJpbGl0eSkge1xuICAgICAgICAgICAgb3B0cy5oaXN0b3J5VmlzaWJpbGl0eSA9IGNyZWF0ZU9wdHMucHJlc2V0ID09PSBQcmVzZXQuUHVibGljQ2hhdFxuICAgICAgICAgICAgICAgID8gSGlzdG9yeVZpc2liaWxpdHkuV29ybGRSZWFkYWJsZVxuICAgICAgICAgICAgICAgIDogSGlzdG9yeVZpc2liaWxpdHkuSW52aXRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRzLmpvaW5SdWxlID09PSBKb2luUnVsZS5SZXN0cmljdGVkKSB7XG4gICAgICAgICAgICBpZiAoU3BhY2VTdG9yZS5pbnN0YW5jZS5yZXN0cmljdGVkSm9pblJ1bGVTdXBwb3J0Py5wcmVmZXJyZWQpIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVPcHRzLnJvb21fdmVyc2lvbiA9IFNwYWNlU3RvcmUuaW5zdGFuY2UucmVzdHJpY3RlZEpvaW5SdWxlU3VwcG9ydC5wcmVmZXJyZWQ7XG5cbiAgICAgICAgICAgICAgICBjcmVhdGVPcHRzLmluaXRpYWxfc3RhdGUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5Sb29tSm9pblJ1bGVzLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImpvaW5fcnVsZVwiOiBKb2luUnVsZS5SZXN0cmljdGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhbGxvd1wiOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBSZXN0cmljdGVkQWxsb3dUeXBlLlJvb21NZW1iZXJzaGlwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicm9vbV9pZFwiOiBvcHRzLnBhcmVudFNwYWNlLnJvb21JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gd2UgaGFuZGxlIHRoZSByZXN0cmljdGVkIGpvaW4gcnVsZSBpbiB0aGUgcGFyZW50U3BhY2UgaGFuZGxpbmcgYmxvY2sgYWJvdmVcbiAgICBpZiAob3B0cy5qb2luUnVsZSAmJiBvcHRzLmpvaW5SdWxlICE9PSBKb2luUnVsZS5SZXN0cmljdGVkKSB7XG4gICAgICAgIGNyZWF0ZU9wdHMuaW5pdGlhbF9zdGF0ZS5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5Sb29tSm9pblJ1bGVzLFxuICAgICAgICAgICAgY29udGVudDogeyBqb2luX3J1bGU6IG9wdHMuam9pblJ1bGUgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuYXZhdGFyKSB7XG4gICAgICAgIGxldCB1cmwgPSBvcHRzLmF2YXRhcjtcbiAgICAgICAgaWYgKG9wdHMuYXZhdGFyIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICAgICAgdXJsID0gYXdhaXQgY2xpZW50LnVwbG9hZENvbnRlbnQob3B0cy5hdmF0YXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3JlYXRlT3B0cy5pbml0aWFsX3N0YXRlLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLlJvb21BdmF0YXIsXG4gICAgICAgICAgICBjb250ZW50OiB7IHVybCB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5oaXN0b3J5VmlzaWJpbGl0eSkge1xuICAgICAgICBjcmVhdGVPcHRzLmluaXRpYWxfc3RhdGUucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuUm9vbUhpc3RvcnlWaXNpYmlsaXR5LFxuICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAgIFwiaGlzdG9yeV92aXNpYmlsaXR5XCI6IG9wdHMuaGlzdG9yeVZpc2liaWxpdHksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBsZXQgbW9kYWw7XG4gICAgaWYgKG9wdHMuc3Bpbm5lcikgbW9kYWwgPSBNb2RhbC5jcmVhdGVEaWFsb2coU3Bpbm5lciwgbnVsbCwgJ214X0RpYWxvZ19zcGlubmVyJyk7XG5cbiAgICBsZXQgcm9vbUlkO1xuICAgIHJldHVybiBjbGllbnQuY3JlYXRlUm9vbShjcmVhdGVPcHRzKS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgLy8gTkIgVGhpcyBjaGVja3MgZm9yIHRoZSBTeW5hcHNlLXNwZWNpZmljIGVycm9yIGNvbmRpdGlvbiBvZiBhIHJvb20gY3JlYXRpb25cbiAgICAgICAgLy8gaGF2aW5nIGJlZW4gZGVuaWVkIGJlY2F1c2UgdGhlIHJlcXVlc3RpbmcgdXNlciB3YW50ZWQgdG8gcHVibGlzaCB0aGUgcm9vbSxcbiAgICAgICAgLy8gYnV0IHRoZSBzZXJ2ZXIgZGVuaWVzIHRoZW0gdGhhdCBwZXJtaXNzaW9uICh2aWEgcm9vbV9saXN0X3B1YmxpY2F0aW9uX3J1bGVzKS5cbiAgICAgICAgLy8gVGhlIGNoZWNrIGJlbG93IHJlc3BvbmRzIGJ5IHJldHJ5aW5nIHdpdGhvdXQgcHVibGlzaGluZyB0aGUgcm9vbS5cbiAgICAgICAgaWYgKGVyci5odHRwU3RhdHVzID09PSA0MDMgJiYgZXJyLmVycmNvZGUgPT09IFwiTV9VTktOT1dOXCIgJiYgZXJyLmRhdGEuZXJyb3IgPT09IFwiTm90IGFsbG93ZWQgdG8gcHVibGlzaCByb29tXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiRmFpbGVkIHRvIHB1Ymxpc2ggcm9vbSwgdHJ5IGFnYWluIHdpdGhvdXQgcHVibGlzaGluZyBpdFwiKTtcbiAgICAgICAgICAgIGNyZWF0ZU9wdHMudmlzaWJpbGl0eSA9IFZpc2liaWxpdHkuUHJpdmF0ZTtcbiAgICAgICAgICAgIHJldHVybiBjbGllbnQuY3JlYXRlUm9vbShjcmVhdGVPcHRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKG1vZGFsKSBtb2RhbC5jbG9zZSgpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIHJvb21JZCA9IHJlcy5yb29tX2lkO1xuICAgICAgICBpZiAob3B0cy5kbVVzZXJJZCkge1xuICAgICAgICAgICAgcmV0dXJuIFJvb21zLnNldERNUm9vbShyb29tSWQsIG9wdHMuZG1Vc2VySWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgIGlmIChvcHRzLnBhcmVudFNwYWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gU3BhY2VTdG9yZS5pbnN0YW5jZS5hZGRSb29tVG9TcGFjZShvcHRzLnBhcmVudFNwYWNlLCByb29tSWQsIFtjbGllbnQuZ2V0RG9tYWluKCldLCBvcHRzLnN1Z2dlc3RlZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuYXNzb2NpYXRlZFdpdGhDb21tdW5pdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBHcm91cFN0b3JlLmFkZFJvb21Ub0dyb3VwKG9wdHMuYXNzb2NpYXRlZFdpdGhDb21tdW5pdHksIHJvb21JZCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gTkIgY3JlYXRlUm9vbSBkb2Vzbid0IGJsb2NrIG9uIHRoZSBjbGllbnQgc2VlaW5nIHRoZSBlY2hvIHRoYXQgdGhlXG4gICAgICAgIC8vIHJvb20gaGFzIGJlZW4gY3JlYXRlZCwgc28gd2UgcmFjZSBoZXJlIHdpdGggdGhlIGNsaWVudCBrbm93aW5nIHRoYXRcbiAgICAgICAgLy8gdGhlIHJvb20gZXhpc3RzLCBjYXVzaW5nIHRoaW5ncyBsaWtlXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZWN0b3ItaW0vdmVjdG9yLXdlYi9pc3N1ZXMvMTgxM1xuICAgICAgICAvLyBFdmVuIGlmIHdlIHdlcmUgdG8gYmxvY2sgb24gdGhlIGVjaG8sIHNlcnZlcnMgdGVuZCB0byBzcGxpdCB0aGUgcm9vbVxuICAgICAgICAvLyBzdGF0ZSBvdmVyIG11bHRpcGxlIHN5bmNzIHNvIHdlIGNhbid0IGF0b21pY2FsbHkga25vdyB3aGVuIHdlIGhhdmUgdGhlXG4gICAgICAgIC8vIGVudGlyZSB0aGluZy5cbiAgICAgICAgaWYgKG9wdHMuYW5kVmlldykge1xuICAgICAgICAgICAgZGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IEFjdGlvbi5WaWV3Um9vbSxcbiAgICAgICAgICAgICAgICByb29tX2lkOiByb29tSWQsXG4gICAgICAgICAgICAgICAgc2hvdWxkX3BlZWs6IGZhbHNlLFxuICAgICAgICAgICAgICAgIC8vIENyZWF0aW5nIGEgcm9vbSB3aWxsIGhhdmUgam9pbmVkIHVzIHRvIHRoZSByb29tLFxuICAgICAgICAgICAgICAgIC8vIHNvIHdlIGFyZSBleHBlY3RpbmcgdGhlIHJvb20gdG8gY29tZSBkb3duIHRoZSBzeW5jXG4gICAgICAgICAgICAgICAgLy8gc3RyZWFtLCBpZiBpdCBoYXNuJ3QgYWxyZWFkeS5cbiAgICAgICAgICAgICAgICBqb2luaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIGp1c3RDcmVhdGVkT3B0czogb3B0cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIENvdW50bHlBbmFseXRpY3MuaW5zdGFuY2UudHJhY2tSb29tQ3JlYXRlKHN0YXJ0VGltZSwgcm9vbUlkKTtcbiAgICAgICAgcmV0dXJuIHJvb21JZDtcbiAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgLy8gUmFpc2UgdGhlIGVycm9yIGlmIHRoZSBjYWxsZXIgcmVxdWVzdGVkIHRoYXQgd2UgZG8gc28uXG4gICAgICAgIGlmIChvcHRzLmlubGluZUVycm9ycykgdGhyb3cgZXJyO1xuXG4gICAgICAgIC8vIFdlIGFsc28gZmFpbGVkIHRvIGpvaW4gdGhlIHJvb20gKHRoaXMgc2V0cyBqb2luaW5nIHRvIGZhbHNlIGluIFJvb21WaWV3U3RvcmUpXG4gICAgICAgIGRpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICBhY3Rpb246IEFjdGlvbi5Kb2luUm9vbUVycm9yLFxuICAgICAgICAgICAgcm9vbUlkLFxuICAgICAgICB9KTtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSByb29tIFwiICsgcm9vbUlkICsgXCIgXCIgKyBlcnIpO1xuICAgICAgICBsZXQgZGVzY3JpcHRpb24gPSBfdChcIlNlcnZlciBtYXkgYmUgdW5hdmFpbGFibGUsIG92ZXJsb2FkZWQsIG9yIHlvdSBoaXQgYSBidWcuXCIpO1xuICAgICAgICBpZiAoZXJyLmVycmNvZGUgPT09IFwiTV9VTlNVUFBPUlRFRF9ST09NX1ZFUlNJT05cIikge1xuICAgICAgICAgICAgLy8gVGVjaG5pY2FsbHkgbm90IHBvc3NpYmxlIHdpdGggdGhlIFVJIGFzIG9mIEFwcmlsIDIwMTkgYmVjYXVzZSB0aGVyZSdzIG5vXG4gICAgICAgICAgICAvLyBvcHRpb25zIGZvciB0aGUgdXNlciB0byBjaGFuZ2UgdGhpcy4gSG93ZXZlciwgaXQncyBub3QgYSBiYWQgdGhpbmcgdG8gcmVwb3J0XG4gICAgICAgICAgICAvLyB0aGUgZXJyb3IgdG8gdGhlIHVzZXIgZm9yIGlmL3doZW4gdGhlIFVJIGlzIGF2YWlsYWJsZS5cbiAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gX3QoXCJUaGUgc2VydmVyIGRvZXMgbm90IHN1cHBvcnQgdGhlIHJvb20gdmVyc2lvbiBzcGVjaWZpZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIE1vZGFsLmNyZWF0ZVRyYWNrZWREaWFsb2coJ0ZhaWx1cmUgdG8gY3JlYXRlIHJvb20nLCAnJywgRXJyb3JEaWFsb2csIHtcbiAgICAgICAgICAgIHRpdGxlOiBfdChcIkZhaWx1cmUgdG8gY3JlYXRlIHJvb21cIiksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZERNRm9yVXNlcihjbGllbnQ6IE1hdHJpeENsaWVudCwgdXNlcklkOiBzdHJpbmcpOiBSb29tIHtcbiAgICBjb25zdCByb29tSWRzID0gRE1Sb29tTWFwLnNoYXJlZCgpLmdldERNUm9vbXNGb3JVc2VySWQodXNlcklkKTtcbiAgICBjb25zdCByb29tcyA9IHJvb21JZHMubWFwKGlkID0+IGNsaWVudC5nZXRSb29tKGlkKSk7XG4gICAgY29uc3Qgc3VpdGFibGVETVJvb21zID0gcm9vbXMuZmlsdGVyKHIgPT4ge1xuICAgICAgICAvLyBWYWxpZGF0ZSB0aGF0IHdlIGFyZSBqb2luZWQgYW5kIHRoZSBvdGhlciBwZXJzb24gaXMgYWxzbyBqb2luZWQuIFdlJ2xsIGFsc28gbWFrZSBzdXJlXG4gICAgICAgIC8vIHRoYXQgdGhlIHJvb20gYWxzbyBsb29rcyBsaWtlIGEgRE0gKHVudGlsIHdlIGhhdmUgY2Fub25pY2FsIERNcyB0byB0ZWxsIHVzKS4gRm9yIG5vdyxcbiAgICAgICAgLy8gYSBETSBpcyBhIHJvb20gb2YgdHdvIHBlb3BsZSB0aGF0IGNvbnRhaW5zIHRob3NlIHR3byBwZW9wbGUgZXhhY3RseS4gVGhpcyBkb2VzIG1lYW5cbiAgICAgICAgLy8gdGhhdCBib3RzLCBhc3Npc3RhbnRzLCBldGMgd2lsbCBydWluIGEgcm9vbSdzIERNLW5lc3MsIHRob3VnaCB0aGlzIGlzIGEgcHJvYmxlbSBmb3JcbiAgICAgICAgLy8gY2Fub25pY2FsIERNcyB0byBzb2x2ZS5cbiAgICAgICAgaWYgKHIgJiYgci5nZXRNeU1lbWJlcnNoaXAoKSA9PT0gXCJqb2luXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lbWJlcnMgPSByLmN1cnJlbnRTdGF0ZS5nZXRNZW1iZXJzKCk7XG4gICAgICAgICAgICBjb25zdCBqb2luZWRNZW1iZXJzID0gbWVtYmVycy5maWx0ZXIobSA9PiBpc0pvaW5lZE9yTmVhcmx5Sm9pbmVkKG0ubWVtYmVyc2hpcCkpO1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJNZW1iZXIgPSBqb2luZWRNZW1iZXJzLmZpbmQobSA9PiBtLnVzZXJJZCA9PT0gdXNlcklkKTtcbiAgICAgICAgICAgIHJldHVybiBvdGhlck1lbWJlciAmJiBqb2luZWRNZW1iZXJzLmxlbmd0aCA9PT0gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSkuc29ydCgocjEsIHIyKSA9PiB7XG4gICAgICAgIHJldHVybiByMi5nZXRMYXN0QWN0aXZlVGltZXN0YW1wKCkgLVxuICAgICAgICAgICAgcjEuZ2V0TGFzdEFjdGl2ZVRpbWVzdGFtcCgpO1xuICAgIH0pO1xuICAgIGlmIChzdWl0YWJsZURNUm9vbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdWl0YWJsZURNUm9vbXNbMF07XG4gICAgfVxufVxuXG4vKlxuICogVHJ5IHRvIGVuc3VyZSB0aGUgdXNlciBpcyBhbHJlYWR5IGluIHRoZSBtZWdvbG0gc2Vzc2lvbiBiZWZvcmUgY29udGludWluZ1xuICogTk9URTogdGhpcyBhc3N1bWVzIHlvdSd2ZSBqdXN0IGNyZWF0ZWQgdGhlIHJvb20gYW5kIHRoZXJlJ3Mgbm90IGJlZW4gYW4gb3Bwb3J0dW5pdHlcbiAqIGZvciBvdGhlciBjb2RlIHRvIHJ1biwgc28gd2Ugc2hvdWxkbid0IG1pc3MgUm9vbVN0YXRlLm5ld01lbWJlciB3aGVuIGl0IGNvbWVzIGJ5LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2FpdEZvck1lbWJlcihjbGllbnQ6IE1hdHJpeENsaWVudCwgcm9vbUlkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nLCBvcHRzID0geyB0aW1lb3V0OiAxNTAwIH0pIHtcbiAgICBjb25zdCB7IHRpbWVvdXQgfSA9IG9wdHM7XG4gICAgbGV0IGhhbmRsZXI7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGhhbmRsZXIgPSBmdW5jdGlvbihfLCBfXywgbWVtYmVyOiBSb29tTWVtYmVyKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgICAgICAgICBpZiAobWVtYmVyLnVzZXJJZCAhPT0gdXNlcklkKSByZXR1cm47XG4gICAgICAgICAgICBpZiAobWVtYmVyLnJvb21JZCAhPT0gcm9vbUlkKSByZXR1cm47XG4gICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICBjbGllbnQub24oXCJSb29tU3RhdGUubmV3TWVtYmVyXCIsIGhhbmRsZXIpO1xuXG4gICAgICAgIC8qIFdlIGRvbid0IHdhbnQgdG8gaGFuZyBpZiB0aGlzIGdvZXMgd3JvbmcsIHNvIHdlIHByb2NlZWQgYW5kIGhvcGUgdGhlIG90aGVyXG4gICAgICAgICAgIHVzZXIgaXMgYWxyZWFkeSBpbiB0aGUgbWVnb2xtIHNlc3Npb24gKi9cbiAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0LCBmYWxzZSk7XG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIGNsaWVudC5yZW1vdmVMaXN0ZW5lcihcIlJvb21TdGF0ZS5uZXdNZW1iZXJcIiwgaGFuZGxlcik7XG4gICAgfSk7XG59XG5cbi8qXG4gKiBFbnN1cmUgdGhhdCBmb3IgZXZlcnkgdXNlciBpbiBhIHJvb20sIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBkZXZpY2UgdGhhdCB3ZVxuICogY2FuIGVuY3J5cHQgdG8uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYW5FbmNyeXB0VG9BbGxVc2VycyhjbGllbnQ6IE1hdHJpeENsaWVudCwgdXNlcklkczogc3RyaW5nW10pIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB1c2Vyc0RldmljZU1hcCA9IGF3YWl0IGNsaWVudC5kb3dubG9hZEtleXModXNlcklkcyk7XG4gICAgICAgIC8vIHsgXCJAdXNlcjpob3N0XCI6IHsgXCJERVZJQ0VcIjogey4uLn0sIC4uLiB9LCAuLi4gfVxuICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh1c2Vyc0RldmljZU1hcCkuZXZlcnkoKHVzZXJEZXZpY2VzKSA9PlxuICAgICAgICAgICAgLy8geyBcIkRFVklDRVwiOiB7Li4ufSwgLi4uIH1cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHVzZXJEZXZpY2VzKS5sZW5ndGggPiAwLFxuICAgICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiRXJyb3IgZGV0ZXJtaW5pbmcgaWYgaXQncyBwb3NzaWJsZSB0byBlbmNyeXB0IHRvIGFsbCB1c2VyczogXCIsIGUpO1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGFzc3VtZSBub3RcbiAgICB9XG59XG5cbi8vIFNpbWlsYXIgdG8gZW5zdXJlRE1FeGlzdHMgYnV0IGFsc28gYWRkcyBjcmVhdGlvbiBjb250ZW50XG4vLyB3aXRob3V0IHBvbGx1dGluZyBlbnN1cmVETUV4aXN0cyB3aXRoIHVucmVsYXRlZCBzdHVmZiAoYWxzb1xuLy8gdGhleSdyZSBuZXZlciBlbmNyeXB0ZWQpLlxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuc3VyZVZpcnR1YWxSb29tRXhpc3RzKFxuICAgIGNsaWVudDogTWF0cml4Q2xpZW50LCB1c2VySWQ6IHN0cmluZywgbmF0aXZlUm9vbUlkOiBzdHJpbmcsXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IGV4aXN0aW5nRE1Sb29tID0gZmluZERNRm9yVXNlcihjbGllbnQsIHVzZXJJZCk7XG4gICAgbGV0IHJvb21JZDtcbiAgICBpZiAoZXhpc3RpbmdETVJvb20pIHtcbiAgICAgICAgcm9vbUlkID0gZXhpc3RpbmdETVJvb20ucm9vbUlkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb21JZCA9IGF3YWl0IGNyZWF0ZVJvb20oe1xuICAgICAgICAgICAgZG1Vc2VySWQ6IHVzZXJJZCxcbiAgICAgICAgICAgIHNwaW5uZXI6IGZhbHNlLFxuICAgICAgICAgICAgYW5kVmlldzogZmFsc2UsXG4gICAgICAgICAgICBjcmVhdGVPcHRzOiB7XG4gICAgICAgICAgICAgICAgY3JlYXRpb25fY29udGVudDoge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGFsbG93cyB1cyB0byByZWNvZ25pc2UgdGhhdCB0aGUgcm9vbSBpcyBhIHZpcnR1YWwgcm9vbVxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGl0IGNvbWVzIGRvd24gb3VyIHN5bmMgc3RyZWFtICh3ZSBhbHNvIHB1dCB0aGUgSUQgb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc3BlY3RpdmUgbmF0aXZlIHJvb20gaW4gdGhlcmUgYmVjYXVzZSB3aHkgbm90PylcbiAgICAgICAgICAgICAgICAgICAgW1ZJUlRVQUxfUk9PTV9FVkVOVF9UWVBFXTogbmF0aXZlUm9vbUlkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJvb21JZDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuc3VyZURNRXhpc3RzKGNsaWVudDogTWF0cml4Q2xpZW50LCB1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgZXhpc3RpbmdETVJvb20gPSBmaW5kRE1Gb3JVc2VyKGNsaWVudCwgdXNlcklkKTtcbiAgICBsZXQgcm9vbUlkO1xuICAgIGlmIChleGlzdGluZ0RNUm9vbSkge1xuICAgICAgICByb29tSWQgPSBleGlzdGluZ0RNUm9vbS5yb29tSWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGVuY3J5cHRpb246IGJvb2xlYW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChwcml2YXRlU2hvdWxkQmVFbmNyeXB0ZWQoKSkge1xuICAgICAgICAgICAgZW5jcnlwdGlvbiA9IGF3YWl0IGNhbkVuY3J5cHRUb0FsbFVzZXJzKGNsaWVudCwgW3VzZXJJZF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcm9vbUlkID0gYXdhaXQgY3JlYXRlUm9vbSh7IGVuY3J5cHRpb24sIGRtVXNlcklkOiB1c2VySWQsIHNwaW5uZXI6IGZhbHNlLCBhbmRWaWV3OiBmYWxzZSB9KTtcbiAgICAgICAgYXdhaXQgd2FpdEZvck1lbWJlcihjbGllbnQsIHJvb21JZCwgdXNlcklkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvb21JZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByaXZhdGVTaG91bGRCZUVuY3J5cHRlZCgpOiBib29sZWFuIHtcbiAgICBjb25zdCBlMmVlV2VsbEtub3duID0gZ2V0RTJFRVdlbGxLbm93bigpO1xuICAgIGlmIChlMmVlV2VsbEtub3duKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHREaXNhYmxlZCA9IGUyZWVXZWxsS25vd25bXCJkZWZhdWx0XCJdID09PSBmYWxzZTtcbiAgICAgICAgcmV0dXJuICFkZWZhdWx0RGlzYWJsZWQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuIl19