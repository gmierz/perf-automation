"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "RovingAccessibleButton", {
  enumerable: true,
  get: function () {
    return _RovingAccessibleButton.RovingAccessibleButton;
  }
});
Object.defineProperty(exports, "RovingAccessibleTooltipButton", {
  enumerable: true,
  get: function () {
    return _RovingAccessibleTooltipButton.RovingAccessibleTooltipButton;
  }
});
exports.RovingTabIndexProvider = void 0;
Object.defineProperty(exports, "RovingTabIndexWrapper", {
  enumerable: true,
  get: function () {
    return _RovingTabIndexWrapper.RovingTabIndexWrapper;
  }
});
exports.useRovingTabIndex = exports.reducer = exports.findSiblingElement = exports.Type = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _Keyboard = require("../Keyboard");

var _RovingTabIndexWrapper = require("./roving/RovingTabIndexWrapper");

var _RovingAccessibleButton = require("./roving/RovingAccessibleButton");

var _RovingAccessibleTooltipButton = require("./roving/RovingAccessibleTooltipButton");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Module to simplify implementing the Roving TabIndex accessibility technique
 *
 * Wrap the Widget in an RovingTabIndexContextProvider
 * and then for all buttons make use of useRovingTabIndex or RovingTabIndexWrapper.
 * The code will keep track of which tabIndex was most recently focused and expose that information as `isActive` which
 * can then be used to only set the tabIndex to 0 as expected by the roving tabindex technique.
 * When the active button gets unmounted the closest button will be chosen as expected.
 * Initially the first button to mount will be given active state.
 *
 * https://developer.mozilla.org/en-US/docs/Web/Accessibility/Keyboard-navigable_JavaScript_widgets#Technique_1_Roving_tabindex
 */
const DOCUMENT_POSITION_PRECEDING = 2;
const RovingTabIndexContext = /*#__PURE__*/(0, _react.createContext)({
  state: {
    activeRef: null,
    refs: [] // list of refs in DOM order

  },
  dispatch: () => {}
});
RovingTabIndexContext.displayName = "RovingTabIndexContext";
let Type;
exports.Type = Type;

(function (Type) {
  Type["Register"] = "REGISTER";
  Type["Unregister"] = "UNREGISTER";
  Type["SetFocus"] = "SET_FOCUS";
})(Type || (exports.Type = Type = {}));

const reducer = (state, action) => {
  switch (action.type) {
    case Type.Register:
      {
        let left = 0;
        let right = state.refs.length - 1;
        let index = state.refs.length; // by default append to the end
        // do a binary search to find the right slot

        while (left <= right) {
          index = Math.floor((left + right) / 2);
          const ref = state.refs[index];

          if (ref === action.payload.ref) {
            return state; // already in refs, this should not happen
          }

          if (action.payload.ref.current.compareDocumentPosition(ref.current) & DOCUMENT_POSITION_PRECEDING) {
            left = ++index;
          } else {
            right = index - 1;
          }
        }

        if (!state.activeRef) {
          // Our list of refs was empty, set activeRef to this first item
          state.activeRef = action.payload.ref;
        } // update the refs list


        if (index < state.refs.length) {
          state.refs.splice(index, 0, action.payload.ref);
        } else {
          state.refs.push(action.payload.ref);
        }

        return _objectSpread({}, state);
      }

    case Type.Unregister:
      {
        const oldIndex = state.refs.findIndex(r => r === action.payload.ref);

        if (oldIndex === -1) {
          return state; // already removed, this should not happen
        }

        if (state.refs.splice(oldIndex, 1)[0] === state.activeRef) {
          var _state$activeRef, _state$activeRef$curr;

          // we just removed the active ref, need to replace it
          // pick the ref closest to the index the old ref was in
          if (oldIndex >= state.refs.length) {
            state.activeRef = findSiblingElement(state.refs, state.refs.length - 1, true);
          } else {
            state.activeRef = findSiblingElement(state.refs, oldIndex) || findSiblingElement(state.refs, oldIndex, true);
          }

          (_state$activeRef = state.activeRef) === null || _state$activeRef === void 0 ? void 0 : (_state$activeRef$curr = _state$activeRef.current) === null || _state$activeRef$curr === void 0 ? void 0 : _state$activeRef$curr.focus();
        } // update the refs list


        return _objectSpread({}, state);
      }

    case Type.SetFocus:
      {
        // update active ref
        state.activeRef = action.payload.ref;
        return _objectSpread({}, state);
      }

    default:
      return state;
  }
};

exports.reducer = reducer;

const findSiblingElement = (refs, startIndex, backwards = false) => {
  if (backwards) {
    for (let i = startIndex; i < refs.length && i >= 0; i--) {
      var _refs$i$current;

      if (((_refs$i$current = refs[i].current) === null || _refs$i$current === void 0 ? void 0 : _refs$i$current.offsetParent) !== null) {
        return refs[i];
      }
    }
  } else {
    for (let i = startIndex; i < refs.length && i >= 0; i++) {
      var _refs$i$current2;

      if (((_refs$i$current2 = refs[i].current) === null || _refs$i$current2 === void 0 ? void 0 : _refs$i$current2.offsetParent) !== null) {
        return refs[i];
      }
    }
  }
};

exports.findSiblingElement = findSiblingElement;

const RovingTabIndexProvider = ({
  children,
  handleHomeEnd,
  handleUpDown,
  handleLeftRight,
  onKeyDown
}) => {
  const [state, dispatch] = (0, _react.useReducer)(reducer, {
    activeRef: null,
    refs: []
  });
  const context = (0, _react.useMemo)(() => ({
    state,
    dispatch
  }), [state]);
  const onKeyDownHandler = (0, _react.useCallback)(ev => {
    if (onKeyDown) {
      onKeyDown(ev, context.state);

      if (ev.defaultPrevented) {
        return;
      }
    }

    let handled = false; // Don't interfere with input default keydown behaviour

    if (ev.target.tagName !== "INPUT" && ev.target.tagName !== "TEXTAREA") {
      // check if we actually have any items
      switch (ev.key) {
        case _Keyboard.Key.HOME:
          if (handleHomeEnd) {
            var _findSiblingElement, _findSiblingElement$c;

            handled = true; // move focus to first (visible) item

            (_findSiblingElement = findSiblingElement(context.state.refs, 0)) === null || _findSiblingElement === void 0 ? void 0 : (_findSiblingElement$c = _findSiblingElement.current) === null || _findSiblingElement$c === void 0 ? void 0 : _findSiblingElement$c.focus();
          }

          break;

        case _Keyboard.Key.END:
          if (handleHomeEnd) {
            var _findSiblingElement2, _findSiblingElement2$;

            handled = true; // move focus to last (visible) item

            (_findSiblingElement2 = findSiblingElement(context.state.refs, context.state.refs.length - 1, true)) === null || _findSiblingElement2 === void 0 ? void 0 : (_findSiblingElement2$ = _findSiblingElement2.current) === null || _findSiblingElement2$ === void 0 ? void 0 : _findSiblingElement2$.focus();
          }

          break;

        case _Keyboard.Key.ARROW_UP:
        case _Keyboard.Key.ARROW_RIGHT:
          if (ev.key === _Keyboard.Key.ARROW_UP && handleUpDown || ev.key === _Keyboard.Key.ARROW_RIGHT && handleLeftRight) {
            handled = true;

            if (context.state.refs.length > 0) {
              var _findSiblingElement3, _findSiblingElement3$;

              const idx = context.state.refs.indexOf(context.state.activeRef);
              (_findSiblingElement3 = findSiblingElement(context.state.refs, idx - 1)) === null || _findSiblingElement3 === void 0 ? void 0 : (_findSiblingElement3$ = _findSiblingElement3.current) === null || _findSiblingElement3$ === void 0 ? void 0 : _findSiblingElement3$.focus();
            }
          }

          break;

        case _Keyboard.Key.ARROW_DOWN:
        case _Keyboard.Key.ARROW_LEFT:
          if (ev.key === _Keyboard.Key.ARROW_DOWN && handleUpDown || ev.key === _Keyboard.Key.ARROW_LEFT && handleLeftRight) {
            handled = true;

            if (context.state.refs.length > 0) {
              var _findSiblingElement4, _findSiblingElement4$;

              const idx = context.state.refs.indexOf(context.state.activeRef);
              (_findSiblingElement4 = findSiblingElement(context.state.refs, idx + 1, true)) === null || _findSiblingElement4 === void 0 ? void 0 : (_findSiblingElement4$ = _findSiblingElement4.current) === null || _findSiblingElement4$ === void 0 ? void 0 : _findSiblingElement4$.focus();
            }
          }

          break;
      }
    }

    if (handled) {
      ev.preventDefault();
      ev.stopPropagation();
    }
  }, [context.state, onKeyDown, handleHomeEnd, handleUpDown, handleLeftRight]);
  return /*#__PURE__*/_react.default.createElement(RovingTabIndexContext.Provider, {
    value: context
  }, children({
    onKeyDownHandler
  }));
}; // Hook to register a roving tab index
// inputRef parameter specifies the ref to use
// onFocus should be called when the index gained focus in any manner
// isActive should be used to set tabIndex in a manner such as `tabIndex={isActive ? 0 : -1}`
// ref should be passed to a DOM node which will be used for DOM compareDocumentPosition


exports.RovingTabIndexProvider = RovingTabIndexProvider;

const useRovingTabIndex = inputRef => {
  const context = (0, _react.useContext)(RovingTabIndexContext);
  let ref = (0, _react.useRef)(null);

  if (inputRef) {
    // if we are given a ref, use it instead of ours
    ref = inputRef;
  } // setup (after refs)


  (0, _react.useLayoutEffect)(() => {
    context.dispatch({
      type: Type.Register,
      payload: {
        ref
      }
    }); // teardown

    return () => {
      context.dispatch({
        type: Type.Unregister,
        payload: {
          ref
        }
      });
    };
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  const onFocus = (0, _react.useCallback)(() => {
    context.dispatch({
      type: Type.SetFocus,
      payload: {
        ref
      }
    });
  }, [ref, context]);
  const isActive = context.state.activeRef === ref;
  return [onFocus, isActive, ref];
}; // re-export the semantic helper components for simplicity


exports.useRovingTabIndex = useRovingTabIndex;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hY2Nlc3NpYmlsaXR5L1JvdmluZ1RhYkluZGV4LnRzeCJdLCJuYW1lcyI6WyJET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkciLCJSb3ZpbmdUYWJJbmRleENvbnRleHQiLCJzdGF0ZSIsImFjdGl2ZVJlZiIsInJlZnMiLCJkaXNwYXRjaCIsImRpc3BsYXlOYW1lIiwiVHlwZSIsInJlZHVjZXIiLCJhY3Rpb24iLCJ0eXBlIiwiUmVnaXN0ZXIiLCJsZWZ0IiwicmlnaHQiLCJsZW5ndGgiLCJpbmRleCIsIk1hdGgiLCJmbG9vciIsInJlZiIsInBheWxvYWQiLCJjdXJyZW50IiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJzcGxpY2UiLCJwdXNoIiwiVW5yZWdpc3RlciIsIm9sZEluZGV4IiwiZmluZEluZGV4IiwiciIsImZpbmRTaWJsaW5nRWxlbWVudCIsImZvY3VzIiwiU2V0Rm9jdXMiLCJzdGFydEluZGV4IiwiYmFja3dhcmRzIiwiaSIsIm9mZnNldFBhcmVudCIsIlJvdmluZ1RhYkluZGV4UHJvdmlkZXIiLCJjaGlsZHJlbiIsImhhbmRsZUhvbWVFbmQiLCJoYW5kbGVVcERvd24iLCJoYW5kbGVMZWZ0UmlnaHQiLCJvbktleURvd24iLCJjb250ZXh0Iiwib25LZXlEb3duSGFuZGxlciIsImV2IiwiZGVmYXVsdFByZXZlbnRlZCIsImhhbmRsZWQiLCJ0YXJnZXQiLCJ0YWdOYW1lIiwia2V5IiwiS2V5IiwiSE9NRSIsIkVORCIsIkFSUk9XX1VQIiwiQVJST1dfUklHSFQiLCJpZHgiLCJpbmRleE9mIiwiQVJST1dfRE9XTiIsIkFSUk9XX0xFRlQiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsInVzZVJvdmluZ1RhYkluZGV4IiwiaW5wdXRSZWYiLCJvbkZvY3VzIiwiaXNBY3RpdmUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTs7QUFhQTs7QUE4UUE7O0FBQ0E7O0FBQ0E7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ckIsSUFBQUEsT0FBTyxDQUFDcEMsUUFBUixDQUFpQjtBQUNiSyxNQUFBQSxJQUFJLEVBQUVILElBQUksQ0FBQ3VCLFFBREU7QUFFYlgsTUFBQUEsT0FBTyxFQUFFO0FBQUVELFFBQUFBO0FBQUY7QUFGSSxLQUFqQjtBQUlILEdBTGUsRUFLYixDQUFDQSxHQUFELEVBQU11QixPQUFOLENBTGEsQ0FBaEI7QUFPQSxRQUFNc0IsUUFBUSxHQUFHdEIsT0FBTyxDQUFDdkMsS0FBUixDQUFjQyxTQUFkLEtBQTRCZSxHQUE3QztBQUNBLFNBQU8sQ0FBQzRDLE9BQUQsRUFBVUMsUUFBVixFQUFvQjdDLEdBQXBCLENBQVA7QUFDSCxDQWpDTSxDLENBbUNQIiwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDIwIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IFJlYWN0LCB7XG4gICAgY3JlYXRlQ29udGV4dCxcbiAgICB1c2VDYWxsYmFjayxcbiAgICB1c2VDb250ZXh0LFxuICAgIHVzZUxheW91dEVmZmVjdCxcbiAgICB1c2VNZW1vLFxuICAgIHVzZVJlZixcbiAgICB1c2VSZWR1Y2VyLFxuICAgIFJlZHVjZXIsXG4gICAgRGlzcGF0Y2gsXG4gICAgUmVmT2JqZWN0LFxufSBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHsgS2V5IH0gZnJvbSBcIi4uL0tleWJvYXJkXCI7XG5pbXBvcnQgeyBGb2N1c0hhbmRsZXIsIFJlZiB9IGZyb20gXCIuL3JvdmluZy90eXBlc1wiO1xuXG4vKipcbiAqIE1vZHVsZSB0byBzaW1wbGlmeSBpbXBsZW1lbnRpbmcgdGhlIFJvdmluZyBUYWJJbmRleCBhY2Nlc3NpYmlsaXR5IHRlY2huaXF1ZVxuICpcbiAqIFdyYXAgdGhlIFdpZGdldCBpbiBhbiBSb3ZpbmdUYWJJbmRleENvbnRleHRQcm92aWRlclxuICogYW5kIHRoZW4gZm9yIGFsbCBidXR0b25zIG1ha2UgdXNlIG9mIHVzZVJvdmluZ1RhYkluZGV4IG9yIFJvdmluZ1RhYkluZGV4V3JhcHBlci5cbiAqIFRoZSBjb2RlIHdpbGwga2VlcCB0cmFjayBvZiB3aGljaCB0YWJJbmRleCB3YXMgbW9zdCByZWNlbnRseSBmb2N1c2VkIGFuZCBleHBvc2UgdGhhdCBpbmZvcm1hdGlvbiBhcyBgaXNBY3RpdmVgIHdoaWNoXG4gKiBjYW4gdGhlbiBiZSB1c2VkIHRvIG9ubHkgc2V0IHRoZSB0YWJJbmRleCB0byAwIGFzIGV4cGVjdGVkIGJ5IHRoZSByb3ZpbmcgdGFiaW5kZXggdGVjaG5pcXVlLlxuICogV2hlbiB0aGUgYWN0aXZlIGJ1dHRvbiBnZXRzIHVubW91bnRlZCB0aGUgY2xvc2VzdCBidXR0b24gd2lsbCBiZSBjaG9zZW4gYXMgZXhwZWN0ZWQuXG4gKiBJbml0aWFsbHkgdGhlIGZpcnN0IGJ1dHRvbiB0byBtb3VudCB3aWxsIGJlIGdpdmVuIGFjdGl2ZSBzdGF0ZS5cbiAqXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BY2Nlc3NpYmlsaXR5L0tleWJvYXJkLW5hdmlnYWJsZV9KYXZhU2NyaXB0X3dpZGdldHMjVGVjaG5pcXVlXzFfUm92aW5nX3RhYmluZGV4XG4gKi9cblxuY29uc3QgRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HID0gMjtcblxuZXhwb3J0IGludGVyZmFjZSBJU3RhdGUge1xuICAgIGFjdGl2ZVJlZjogUmVmO1xuICAgIHJlZnM6IFJlZltdO1xufVxuXG5pbnRlcmZhY2UgSUNvbnRleHQge1xuICAgIHN0YXRlOiBJU3RhdGU7XG4gICAgZGlzcGF0Y2g6IERpc3BhdGNoPElBY3Rpb24+O1xufVxuXG5jb25zdCBSb3ZpbmdUYWJJbmRleENvbnRleHQgPSBjcmVhdGVDb250ZXh0PElDb250ZXh0Pih7XG4gICAgc3RhdGU6IHtcbiAgICAgICAgYWN0aXZlUmVmOiBudWxsLFxuICAgICAgICByZWZzOiBbXSwgLy8gbGlzdCBvZiByZWZzIGluIERPTSBvcmRlclxuICAgIH0sXG4gICAgZGlzcGF0Y2g6ICgpID0+IHt9LFxufSk7XG5Sb3ZpbmdUYWJJbmRleENvbnRleHQuZGlzcGxheU5hbWUgPSBcIlJvdmluZ1RhYkluZGV4Q29udGV4dFwiO1xuXG5leHBvcnQgZW51bSBUeXBlIHtcbiAgICBSZWdpc3RlciA9IFwiUkVHSVNURVJcIixcbiAgICBVbnJlZ2lzdGVyID0gXCJVTlJFR0lTVEVSXCIsXG4gICAgU2V0Rm9jdXMgPSBcIlNFVF9GT0NVU1wiLFxufVxuXG5pbnRlcmZhY2UgSUFjdGlvbiB7XG4gICAgdHlwZTogVHlwZTtcbiAgICBwYXlsb2FkOiB7XG4gICAgICAgIHJlZjogUmVmO1xuICAgIH07XG59XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VyID0gKHN0YXRlOiBJU3RhdGUsIGFjdGlvbjogSUFjdGlvbikgPT4ge1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSBUeXBlLlJlZ2lzdGVyOiB7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IDA7XG4gICAgICAgICAgICBsZXQgcmlnaHQgPSBzdGF0ZS5yZWZzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBzdGF0ZS5yZWZzLmxlbmd0aDsgLy8gYnkgZGVmYXVsdCBhcHBlbmQgdG8gdGhlIGVuZFxuXG4gICAgICAgICAgICAvLyBkbyBhIGJpbmFyeSBzZWFyY2ggdG8gZmluZCB0aGUgcmlnaHQgc2xvdFxuICAgICAgICAgICAgd2hpbGUgKGxlZnQgPD0gcmlnaHQpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IE1hdGguZmxvb3IoKGxlZnQgKyByaWdodCkgLyAyKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWYgPSBzdGF0ZS5yZWZzW2luZGV4XTtcblxuICAgICAgICAgICAgICAgIGlmIChyZWYgPT09IGFjdGlvbi5wYXlsb2FkLnJlZikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7IC8vIGFscmVhZHkgaW4gcmVmcywgdGhpcyBzaG91bGQgbm90IGhhcHBlblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24ucGF5bG9hZC5yZWYuY3VycmVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihyZWYuY3VycmVudCkgJiBET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9ICsraW5kZXg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBpbmRleCAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXN0YXRlLmFjdGl2ZVJlZikge1xuICAgICAgICAgICAgICAgIC8vIE91ciBsaXN0IG9mIHJlZnMgd2FzIGVtcHR5LCBzZXQgYWN0aXZlUmVmIHRvIHRoaXMgZmlyc3QgaXRlbVxuICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVJlZiA9IGFjdGlvbi5wYXlsb2FkLnJlZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSByZWZzIGxpc3RcbiAgICAgICAgICAgIGlmIChpbmRleCA8IHN0YXRlLnJlZnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUucmVmcy5zcGxpY2UoaW5kZXgsIDAsIGFjdGlvbi5wYXlsb2FkLnJlZik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlLnJlZnMucHVzaChhY3Rpb24ucGF5bG9hZC5yZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgVHlwZS5VbnJlZ2lzdGVyOiB7XG4gICAgICAgICAgICBjb25zdCBvbGRJbmRleCA9IHN0YXRlLnJlZnMuZmluZEluZGV4KHIgPT4gciA9PT0gYWN0aW9uLnBheWxvYWQucmVmKTtcblxuICAgICAgICAgICAgaWYgKG9sZEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTsgLy8gYWxyZWFkeSByZW1vdmVkLCB0aGlzIHNob3VsZCBub3QgaGFwcGVuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZS5yZWZzLnNwbGljZShvbGRJbmRleCwgMSlbMF0gPT09IHN0YXRlLmFjdGl2ZVJlZikge1xuICAgICAgICAgICAgICAgIC8vIHdlIGp1c3QgcmVtb3ZlZCB0aGUgYWN0aXZlIHJlZiwgbmVlZCB0byByZXBsYWNlIGl0XG4gICAgICAgICAgICAgICAgLy8gcGljayB0aGUgcmVmIGNsb3Nlc3QgdG8gdGhlIGluZGV4IHRoZSBvbGQgcmVmIHdhcyBpblxuICAgICAgICAgICAgICAgIGlmIChvbGRJbmRleCA+PSBzdGF0ZS5yZWZzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVSZWYgPSBmaW5kU2libGluZ0VsZW1lbnQoc3RhdGUucmVmcywgc3RhdGUucmVmcy5sZW5ndGggLSAxLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVSZWYgPSBmaW5kU2libGluZ0VsZW1lbnQoc3RhdGUucmVmcywgb2xkSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBmaW5kU2libGluZ0VsZW1lbnQoc3RhdGUucmVmcywgb2xkSW5kZXgsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVSZWY/LmN1cnJlbnQ/LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgcmVmcyBsaXN0XG4gICAgICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBUeXBlLlNldEZvY3VzOiB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgYWN0aXZlIHJlZlxuICAgICAgICAgICAgc3RhdGUuYWN0aXZlUmVmID0gYWN0aW9uLnBheWxvYWQucmVmO1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxufTtcblxuaW50ZXJmYWNlIElQcm9wcyB7XG4gICAgaGFuZGxlSG9tZUVuZD86IGJvb2xlYW47XG4gICAgaGFuZGxlVXBEb3duPzogYm9vbGVhbjtcbiAgICBoYW5kbGVMZWZ0UmlnaHQ/OiBib29sZWFuO1xuICAgIGNoaWxkcmVuKHJlbmRlclByb3BzOiB7XG4gICAgICAgIG9uS2V5RG93bkhhbmRsZXIoZXY6IFJlYWN0LktleWJvYXJkRXZlbnQpO1xuICAgIH0pO1xuICAgIG9uS2V5RG93bj8oZXY6IFJlYWN0LktleWJvYXJkRXZlbnQsIHN0YXRlOiBJU3RhdGUpO1xufVxuXG5leHBvcnQgY29uc3QgZmluZFNpYmxpbmdFbGVtZW50ID0gKFxuICAgIHJlZnM6IFJlZk9iamVjdDxIVE1MRWxlbWVudD5bXSxcbiAgICBzdGFydEluZGV4OiBudW1iZXIsXG4gICAgYmFja3dhcmRzID0gZmFsc2UsXG4pOiBSZWZPYmplY3Q8SFRNTEVsZW1lbnQ+ID0+IHtcbiAgICBpZiAoYmFja3dhcmRzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgcmVmcy5sZW5ndGggJiYgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChyZWZzW2ldLmN1cnJlbnQ/Lm9mZnNldFBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWZzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCByZWZzLmxlbmd0aCAmJiBpID49IDA7IGkrKykge1xuICAgICAgICAgICAgaWYgKHJlZnNbaV0uY3VycmVudD8ub2Zmc2V0UGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZnNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgY29uc3QgUm92aW5nVGFiSW5kZXhQcm92aWRlcjogUmVhY3QuRkM8SVByb3BzPiA9ICh7XG4gICAgY2hpbGRyZW4sXG4gICAgaGFuZGxlSG9tZUVuZCxcbiAgICBoYW5kbGVVcERvd24sXG4gICAgaGFuZGxlTGVmdFJpZ2h0LFxuICAgIG9uS2V5RG93bixcbn0pID0+IHtcbiAgICBjb25zdCBbc3RhdGUsIGRpc3BhdGNoXSA9IHVzZVJlZHVjZXI8UmVkdWNlcjxJU3RhdGUsIElBY3Rpb24+PihyZWR1Y2VyLCB7XG4gICAgICAgIGFjdGl2ZVJlZjogbnVsbCxcbiAgICAgICAgcmVmczogW10sXG4gICAgfSk7XG5cbiAgICBjb25zdCBjb250ZXh0ID0gdXNlTWVtbzxJQ29udGV4dD4oKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pLCBbc3RhdGVdKTtcblxuICAgIGNvbnN0IG9uS2V5RG93bkhhbmRsZXIgPSB1c2VDYWxsYmFjaygoZXYpID0+IHtcbiAgICAgICAgaWYgKG9uS2V5RG93bikge1xuICAgICAgICAgICAgb25LZXlEb3duKGV2LCBjb250ZXh0LnN0YXRlKTtcbiAgICAgICAgICAgIGlmIChldi5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gRG9uJ3QgaW50ZXJmZXJlIHdpdGggaW5wdXQgZGVmYXVsdCBrZXlkb3duIGJlaGF2aW91clxuICAgICAgICBpZiAoZXYudGFyZ2V0LnRhZ05hbWUgIT09IFwiSU5QVVRcIiAmJiBldi50YXJnZXQudGFnTmFtZSAhPT0gXCJURVhUQVJFQVwiKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBhY3R1YWxseSBoYXZlIGFueSBpdGVtc1xuICAgICAgICAgICAgc3dpdGNoIChldi5rZXkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEtleS5IT01FOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlSG9tZUVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIGZvY3VzIHRvIGZpcnN0ICh2aXNpYmxlKSBpdGVtXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5kU2libGluZ0VsZW1lbnQoY29udGV4dC5zdGF0ZS5yZWZzLCAwKT8uY3VycmVudD8uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgS2V5LkVORDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZUhvbWVFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBmb2N1cyB0byBsYXN0ICh2aXNpYmxlKSBpdGVtXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5kU2libGluZ0VsZW1lbnQoY29udGV4dC5zdGF0ZS5yZWZzLCBjb250ZXh0LnN0YXRlLnJlZnMubGVuZ3RoIC0gMSwgdHJ1ZSk/LmN1cnJlbnQ/LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIEtleS5BUlJPV19VUDpcbiAgICAgICAgICAgICAgICBjYXNlIEtleS5BUlJPV19SSUdIVDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKChldi5rZXkgPT09IEtleS5BUlJPV19VUCAmJiBoYW5kbGVVcERvd24pIHx8IChldi5rZXkgPT09IEtleS5BUlJPV19SSUdIVCAmJiBoYW5kbGVMZWZ0UmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnN0YXRlLnJlZnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IGNvbnRleHQuc3RhdGUucmVmcy5pbmRleE9mKGNvbnRleHQuc3RhdGUuYWN0aXZlUmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5kU2libGluZ0VsZW1lbnQoY29udGV4dC5zdGF0ZS5yZWZzLCBpZHggLSAxKT8uY3VycmVudD8uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgS2V5LkFSUk9XX0RPV046XG4gICAgICAgICAgICAgICAgY2FzZSBLZXkuQVJST1dfTEVGVDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKChldi5rZXkgPT09IEtleS5BUlJPV19ET1dOICYmIGhhbmRsZVVwRG93bikgfHwgKGV2LmtleSA9PT0gS2V5LkFSUk9XX0xFRlQgJiYgaGFuZGxlTGVmdFJpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5zdGF0ZS5yZWZzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpZHggPSBjb250ZXh0LnN0YXRlLnJlZnMuaW5kZXhPZihjb250ZXh0LnN0YXRlLmFjdGl2ZVJlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluZFNpYmxpbmdFbGVtZW50KGNvbnRleHQuc3RhdGUucmVmcywgaWR4ICsgMSwgdHJ1ZSk/LmN1cnJlbnQ/LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFuZGxlZCkge1xuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfSwgW2NvbnRleHQuc3RhdGUsIG9uS2V5RG93biwgaGFuZGxlSG9tZUVuZCwgaGFuZGxlVXBEb3duLCBoYW5kbGVMZWZ0UmlnaHRdKTtcblxuICAgIHJldHVybiA8Um92aW5nVGFiSW5kZXhDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0fT5cbiAgICAgICAgeyBjaGlsZHJlbih7IG9uS2V5RG93bkhhbmRsZXIgfSkgfVxuICAgIDwvUm92aW5nVGFiSW5kZXhDb250ZXh0LlByb3ZpZGVyPjtcbn07XG5cbi8vIEhvb2sgdG8gcmVnaXN0ZXIgYSByb3ZpbmcgdGFiIGluZGV4XG4vLyBpbnB1dFJlZiBwYXJhbWV0ZXIgc3BlY2lmaWVzIHRoZSByZWYgdG8gdXNlXG4vLyBvbkZvY3VzIHNob3VsZCBiZSBjYWxsZWQgd2hlbiB0aGUgaW5kZXggZ2FpbmVkIGZvY3VzIGluIGFueSBtYW5uZXJcbi8vIGlzQWN0aXZlIHNob3VsZCBiZSB1c2VkIHRvIHNldCB0YWJJbmRleCBpbiBhIG1hbm5lciBzdWNoIGFzIGB0YWJJbmRleD17aXNBY3RpdmUgPyAwIDogLTF9YFxuLy8gcmVmIHNob3VsZCBiZSBwYXNzZWQgdG8gYSBET00gbm9kZSB3aGljaCB3aWxsIGJlIHVzZWQgZm9yIERPTSBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuZXhwb3J0IGNvbnN0IHVzZVJvdmluZ1RhYkluZGV4ID0gKGlucHV0UmVmPzogUmVmKTogW0ZvY3VzSGFuZGxlciwgYm9vbGVhbiwgUmVmXSA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoUm92aW5nVGFiSW5kZXhDb250ZXh0KTtcbiAgICBsZXQgcmVmID0gdXNlUmVmPEhUTUxFbGVtZW50PihudWxsKTtcblxuICAgIGlmIChpbnB1dFJlZikge1xuICAgICAgICAvLyBpZiB3ZSBhcmUgZ2l2ZW4gYSByZWYsIHVzZSBpdCBpbnN0ZWFkIG9mIG91cnNcbiAgICAgICAgcmVmID0gaW5wdXRSZWY7XG4gICAgfVxuXG4gICAgLy8gc2V0dXAgKGFmdGVyIHJlZnMpXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiBUeXBlLlJlZ2lzdGVyLFxuICAgICAgICAgICAgcGF5bG9hZDogeyByZWYgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHRlYXJkb3duXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUeXBlLlVucmVnaXN0ZXIsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogeyByZWYgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcblxuICAgIGNvbnN0IG9uRm9jdXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogVHlwZS5TZXRGb2N1cyxcbiAgICAgICAgICAgIHBheWxvYWQ6IHsgcmVmIH0sXG4gICAgICAgIH0pO1xuICAgIH0sIFtyZWYsIGNvbnRleHRdKTtcblxuICAgIGNvbnN0IGlzQWN0aXZlID0gY29udGV4dC5zdGF0ZS5hY3RpdmVSZWYgPT09IHJlZjtcbiAgICByZXR1cm4gW29uRm9jdXMsIGlzQWN0aXZlLCByZWZdO1xufTtcblxuLy8gcmUtZXhwb3J0IHRoZSBzZW1hbnRpYyBoZWxwZXIgY29tcG9uZW50cyBmb3Igc2ltcGxpY2l0eVxuZXhwb3J0IHsgUm92aW5nVGFiSW5kZXhXcmFwcGVyIH0gZnJvbSBcIi4vcm92aW5nL1JvdmluZ1RhYkluZGV4V3JhcHBlclwiO1xuZXhwb3J0IHsgUm92aW5nQWNjZXNzaWJsZUJ1dHRvbiB9IGZyb20gXCIuL3JvdmluZy9Sb3ZpbmdBY2Nlc3NpYmxlQnV0dG9uXCI7XG5leHBvcnQgeyBSb3ZpbmdBY2Nlc3NpYmxlVG9vbHRpcEJ1dHRvbiB9IGZyb20gXCIuL3JvdmluZy9Sb3ZpbmdBY2Nlc3NpYmxlVG9vbHRpcEJ1dHRvblwiO1xuIl19