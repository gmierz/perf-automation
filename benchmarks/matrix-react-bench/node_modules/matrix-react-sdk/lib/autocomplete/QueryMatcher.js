"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

var _utils = require("matrix-js-sdk/src/utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Simple search matcher that matches any results with the query string anywhere
 * in the search string. Returns matches in the order the query string appears
 * in the search key, earliest first, then in the order the search key appears
 * in the provided array of keys, then in the order the items appeared in the
 * source array.
 *
 * @param {Object[]} objects Initial list of objects. Equivalent to calling
 *     setObjects() after construction
 * @param {Object} options Options object
 * @param {string[]} options.keys List of keys to use as indexes on the objects
 * @param {function[]} options.funcs List of functions that when called with the
 *     object as an arg will return a string to use as an index
 */
class QueryMatcher {
  constructor(objects, options = {
    keys: []
  }) {
    (0, _defineProperty2.default)(this, "_options", void 0);
    (0, _defineProperty2.default)(this, "_items", void 0);
    this._options = options;
    this.setObjects(objects); // By default, we remove any non-alphanumeric characters ([^A-Za-z0-9_]) from the
    // query and the value being queried before matching

    if (this._options.shouldMatchWordsOnly === undefined) {
      this._options.shouldMatchWordsOnly = true;
    }
  }

  setObjects(objects) {
    this._items = new Map();

    for (const object of objects) {
      // Need to use unsafe coerce here because the objects can have any
      // type for their values. We assume that those values who's keys have
      // been specified will be string. Also, we cannot infer all the
      // types of the keys of the objects at compile.
      const keyValues = (0, _lodash.at)(object, this._options.keys);

      if (this._options.funcs) {
        for (const f of this._options.funcs) {
          const v = f(object);

          if (Array.isArray(v)) {
            keyValues.push(...v);
          } else {
            keyValues.push(v);
          }
        }
      }

      for (const [index, keyValue] of Object.entries(keyValues)) {
        if (!keyValue) continue; // skip falsy keyValues

        const key = this.processQuery(keyValue);

        if (!this._items.has(key)) {
          this._items.set(key, []);
        }

        this._items.get(key).push({
          keyWeight: Number(index),
          object
        });
      }
    }
  }

  match(query, limit = -1) {
    query = this.processQuery(query);

    if (this._options.shouldMatchWordsOnly) {
      query = query.replace(/[^\w]/g, '');
    }

    if (query.length === 0) {
      return [];
    }

    const matches = []; // Iterate through the map & check each key.
    // ES6 Map iteration order is defined to be insertion order, so results
    // here will come out in the order they were put in.

    for (const [key, candidates] of this._items.entries()) {
      let resultKey = key;

      if (this._options.shouldMatchWordsOnly) {
        resultKey = resultKey.replace(/[^\w]/g, '');
      }

      const index = resultKey.indexOf(query);

      if (index !== -1) {
        matches.push(...candidates.map(candidate => _objectSpread({
          index
        }, candidate)));
      }
    } // Sort matches by where the query appeared in the search key, then by
    // where the matched key appeared in the provided array of keys.


    matches.sort((a, b) => {
      if (a.index < b.index) {
        return -1;
      } else if (a.index === b.index) {
        if (a.keyWeight < b.keyWeight) {
          return -1;
        } else if (a.keyWeight === b.keyWeight) {
          return 0;
        }
      }

      return 1;
    }); // Now map the keys to the result objects. Also remove any duplicates.

    const dedupped = (0, _lodash.uniq)(matches.map(match => match.object));
    const maxLength = limit === -1 ? dedupped.length : limit;
    return dedupped.slice(0, maxLength);
  }

  processQuery(query) {
    if (this._options.fuzzy !== false) {
      // lower case both the input and the output for consistency
      return (0, _utils.removeHiddenChars)(query.toLowerCase()).toLowerCase();
    }

    return query.toLowerCase();
  }

}

exports.default = QueryMatcher;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hdXRvY29tcGxldGUvUXVlcnlNYXRjaGVyLnRzIl0sIm5hbWVzIjpbIlF1ZXJ5TWF0Y2hlciIsImNvbnN0cnVjdG9yIiwib2JqZWN0cyIsIm9wdGlvbnMiLCJrZXlzIiwiX29wdGlvbnMiLCJzZXRPYmplY3RzIiwic2hvdWxkTWF0Y2hXb3Jkc09ubHkiLCJ1bmRlZmluZWQiLCJfaXRlbXMiLCJNYXAiLCJvYmplY3QiLCJrZXlWYWx1ZXMiLCJmdW5jcyIsImYiLCJ2IiwiQXJyYXkiLCJpc0FycmF5IiwicHVzaCIsImluZGV4Iiwia2V5VmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwia2V5IiwicHJvY2Vzc1F1ZXJ5IiwiaGFzIiwic2V0IiwiZ2V0Iiwia2V5V2VpZ2h0IiwiTnVtYmVyIiwibWF0Y2giLCJxdWVyeSIsImxpbWl0IiwicmVwbGFjZSIsImxlbmd0aCIsIm1hdGNoZXMiLCJjYW5kaWRhdGVzIiwicmVzdWx0S2V5IiwiaW5kZXhPZiIsIm1hcCIsImNhbmRpZGF0ZSIsInNvcnQiLCJhIiwiYiIsImRlZHVwcGVkIiwibWF4TGVuZ3RoIiwic2xpY2UiLCJmdXp6eSIsInRvTG93ZXJDYXNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWtCQTs7QUFDQTs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlLE1BQU1BLFlBQU4sQ0FBcUM7QUFJaERDLEVBQUFBLFdBQVcsQ0FBQ0MsT0FBRCxFQUFlQyxPQUFvQixHQUFHO0FBQUVDLElBQUFBLElBQUksRUFBRTtBQUFSLEdBQXRDLEVBQW9EO0FBQUE7QUFBQTtBQUMzRCxTQUFLQyxRQUFMLEdBQWdCRixPQUFoQjtBQUVBLFNBQUtHLFVBQUwsQ0FBZ0JKLE9BQWhCLEVBSDJELENBSzNEO0FBQ0E7O0FBQ0EsUUFBSSxLQUFLRyxRQUFMLENBQWNFLG9CQUFkLEtBQXVDQyxTQUEzQyxFQUFzRDtBQUNs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bnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE3IEF2aXJhbCBEYXNndXB0YVxuQ29weXJpZ2h0IDIwMTggTWljaGFlbCBUZWxhdHluc2tpIDw3dDNjaGd1eUBnbWFpbC5jb20+XG5Db3B5cmlnaHQgMjAxOCBOZXcgVmVjdG9yIEx0ZFxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB7IGF0LCB1bmlxIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHJlbW92ZUhpZGRlbkNoYXJzIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL3V0aWxzXCI7XG5pbXBvcnQgeyBUaW1lbGluZVJlbmRlcmluZ1R5cGUgfSBmcm9tICcuLi9jb250ZXh0cy9Sb29tQ29udGV4dCc7XG5cbmludGVyZmFjZSBJT3B0aW9uczxUIGV4dGVuZHMge30+IHtcbiAgICBrZXlzOiBBcnJheTxzdHJpbmcgfCBrZXlvZiBUPjtcbiAgICBmdW5jcz86IEFycmF5PChUKSA9PiBzdHJpbmcgfCBzdHJpbmdbXT47XG4gICAgc2hvdWxkTWF0Y2hXb3Jkc09ubHk/OiBib29sZWFuO1xuICAgIC8vIHdoZXRoZXIgdG8gYXBwbHkgdW5ob21vZ2x5cGggYW5kIHN0cmlwIGRpYWNyaXRpY3MgdG8gZnV6eiB1cCB0aGUgc2VhcmNoLiBEZWZhdWx0cyB0byB0cnVlXG4gICAgZnV6enk/OiBib29sZWFuO1xuICAgIGNvbnRleHQ/OiBUaW1lbGluZVJlbmRlcmluZ1R5cGU7XG59XG5cbi8qKlxuICogU2ltcGxlIHNlYXJjaCBtYXRjaGVyIHRoYXQgbWF0Y2hlcyBhbnkgcmVzdWx0cyB3aXRoIHRoZSBxdWVyeSBzdHJpbmcgYW55d2hlcmVcbiAqIGluIHRoZSBzZWFyY2ggc3RyaW5nLiBSZXR1cm5zIG1hdGNoZXMgaW4gdGhlIG9yZGVyIHRoZSBxdWVyeSBzdHJpbmcgYXBwZWFyc1xuICogaW4gdGhlIHNlYXJjaCBrZXksIGVhcmxpZXN0IGZpcnN0LCB0aGVuIGluIHRoZSBvcmRlciB0aGUgc2VhcmNoIGtleSBhcHBlYXJzXG4gKiBpbiB0aGUgcHJvdmlkZWQgYXJyYXkgb2Yga2V5cywgdGhlbiBpbiB0aGUgb3JkZXIgdGhlIGl0ZW1zIGFwcGVhcmVkIGluIHRoZVxuICogc291cmNlIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0W119IG9iamVjdHMgSW5pdGlhbCBsaXN0IG9mIG9iamVjdHMuIEVxdWl2YWxlbnQgdG8gY2FsbGluZ1xuICogICAgIHNldE9iamVjdHMoKSBhZnRlciBjb25zdHJ1Y3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBvcHRpb25zLmtleXMgTGlzdCBvZiBrZXlzIHRvIHVzZSBhcyBpbmRleGVzIG9uIHRoZSBvYmplY3RzXG4gKiBAcGFyYW0ge2Z1bmN0aW9uW119IG9wdGlvbnMuZnVuY3MgTGlzdCBvZiBmdW5jdGlvbnMgdGhhdCB3aGVuIGNhbGxlZCB3aXRoIHRoZVxuICogICAgIG9iamVjdCBhcyBhbiBhcmcgd2lsbCByZXR1cm4gYSBzdHJpbmcgdG8gdXNlIGFzIGFuIGluZGV4XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1ZXJ5TWF0Y2hlcjxUIGV4dGVuZHMgT2JqZWN0PiB7XG4gICAgcHJpdmF0ZSBfb3B0aW9uczogSU9wdGlvbnM8VD47XG4gICAgcHJpdmF0ZSBfaXRlbXM6IE1hcDxzdHJpbmcsIHtvYmplY3Q6IFQsIGtleVdlaWdodDogbnVtYmVyfVtdPjtcblxuICAgIGNvbnN0cnVjdG9yKG9iamVjdHM6IFRbXSwgb3B0aW9uczogSU9wdGlvbnM8VD4gPSB7IGtleXM6IFtdIH0pIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICAgICAgdGhpcy5zZXRPYmplY3RzKG9iamVjdHMpO1xuXG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHJlbW92ZSBhbnkgbm9uLWFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIChbXkEtWmEtejAtOV9dKSBmcm9tIHRoZVxuICAgICAgICAvLyBxdWVyeSBhbmQgdGhlIHZhbHVlIGJlaW5nIHF1ZXJpZWQgYmVmb3JlIG1hdGNoaW5nXG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLnNob3VsZE1hdGNoV29yZHNPbmx5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuc2hvdWxkTWF0Y2hXb3Jkc09ubHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0T2JqZWN0cyhvYmplY3RzOiBUW10pIHtcbiAgICAgICAgdGhpcy5faXRlbXMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgZm9yIChjb25zdCBvYmplY3Qgb2Ygb2JqZWN0cykge1xuICAgICAgICAgICAgLy8gTmVlZCB0byB1c2UgdW5zYWZlIGNvZXJjZSBoZXJlIGJlY2F1c2UgdGhlIG9iamVjdHMgY2FuIGhhdmUgYW55XG4gICAgICAgICAgICAvLyB0eXBlIGZvciB0aGVpciB2YWx1ZXMuIFdlIGFzc3VtZSB0aGF0IHRob3NlIHZhbHVlcyB3aG8ncyBrZXlzIGhhdmVcbiAgICAgICAgICAgIC8vIGJlZW4gc3BlY2lmaWVkIHdpbGwgYmUgc3RyaW5nLiBBbHNvLCB3ZSBjYW5ub3QgaW5mZXIgYWxsIHRoZVxuICAgICAgICAgICAgLy8gdHlwZXMgb2YgdGhlIGtleXMgb2YgdGhlIG9iamVjdHMgYXQgY29tcGlsZS5cbiAgICAgICAgICAgIGNvbnN0IGtleVZhbHVlcyA9IGF0PHN0cmluZz4oPGFueT5vYmplY3QsIHRoaXMuX29wdGlvbnMua2V5cyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmZ1bmNzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBmIG9mIHRoaXMuX29wdGlvbnMuZnVuY3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IGYob2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleVZhbHVlcy5wdXNoKC4uLnYpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5VmFsdWVzLnB1c2godik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgW2luZGV4LCBrZXlWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoa2V5VmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIGlmICgha2V5VmFsdWUpIGNvbnRpbnVlOyAvLyBza2lwIGZhbHN5IGtleVZhbHVlc1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMucHJvY2Vzc1F1ZXJ5KGtleVZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2l0ZW1zLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1zLnNldChrZXksIFtdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5faXRlbXMuZ2V0KGtleSkucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGtleVdlaWdodDogTnVtYmVyKGluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbWF0Y2gocXVlcnk6IHN0cmluZywgbGltaXQgPSAtMSk6IFRbXSB7XG4gICAgICAgIHF1ZXJ5ID0gdGhpcy5wcm9jZXNzUXVlcnkocXVlcnkpO1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5zaG91bGRNYXRjaFdvcmRzT25seSkge1xuICAgICAgICAgICAgcXVlcnkgPSBxdWVyeS5yZXBsYWNlKC9bXlxcd10vZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChxdWVyeS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgbWFwICYgY2hlY2sgZWFjaCBrZXkuXG4gICAgICAgIC8vIEVTNiBNYXAgaXRlcmF0aW9uIG9yZGVyIGlzIGRlZmluZWQgdG8gYmUgaW5zZXJ0aW9uIG9yZGVyLCBzbyByZXN1bHRzXG4gICAgICAgIC8vIGhlcmUgd2lsbCBjb21lIG91dCBpbiB0aGUgb3JkZXIgdGhleSB3ZXJlIHB1dCBpbi5cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBjYW5kaWRhdGVzXSBvZiB0aGlzLl9pdGVtcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHRLZXkgPSBrZXk7XG4gICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5zaG91bGRNYXRjaFdvcmRzT25seSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdEtleSA9IHJlc3VsdEtleS5yZXBsYWNlKC9bXlxcd10vZywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSByZXN1bHRLZXkuaW5kZXhPZihxdWVyeSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAuLi5jYW5kaWRhdGVzLm1hcCgoY2FuZGlkYXRlKSA9PiAoeyBpbmRleCwgLi4uY2FuZGlkYXRlIH0pKSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU29ydCBtYXRjaGVzIGJ5IHdoZXJlIHRoZSBxdWVyeSBhcHBlYXJlZCBpbiB0aGUgc2VhcmNoIGtleSwgdGhlbiBieVxuICAgICAgICAvLyB3aGVyZSB0aGUgbWF0Y2hlZCBrZXkgYXBwZWFyZWQgaW4gdGhlIHByb3ZpZGVkIGFycmF5IG9mIGtleXMuXG4gICAgICAgIG1hdGNoZXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgaWYgKGEuaW5kZXggPCBiLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhLmluZGV4ID09PSBiLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGEua2V5V2VpZ2h0IDwgYi5rZXlXZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYS5rZXlXZWlnaHQgPT09IGIua2V5V2VpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE5vdyBtYXAgdGhlIGtleXMgdG8gdGhlIHJlc3VsdCBvYmplY3RzLiBBbHNvIHJlbW92ZSBhbnkgZHVwbGljYXRlcy5cbiAgICAgICAgY29uc3QgZGVkdXBwZWQgPSB1bmlxKG1hdGNoZXMubWFwKChtYXRjaCkgPT4gbWF0Y2gub2JqZWN0KSk7XG4gICAgICAgIGNvbnN0IG1heExlbmd0aCA9IGxpbWl0ID09PSAtMSA/IGRlZHVwcGVkLmxlbmd0aCA6IGxpbWl0O1xuXG4gICAgICAgIHJldHVybiBkZWR1cHBlZC5zbGljZSgwLCBtYXhMZW5ndGgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgcHJvY2Vzc1F1ZXJ5KHF1ZXJ5OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5mdXp6eSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIGxvd2VyIGNhc2UgYm90aCB0aGUgaW5wdXQgYW5kIHRoZSBvdXRwdXQgZm9yIGNvbnNpc3RlbmN5XG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlSGlkZGVuQ2hhcnMocXVlcnkudG9Mb3dlckNhc2UoKSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXVlcnkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG59XG4iXX0=