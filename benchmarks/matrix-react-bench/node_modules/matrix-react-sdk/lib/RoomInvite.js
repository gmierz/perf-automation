"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inviteMultipleToRoom = inviteMultipleToRoom;
exports.inviteUsersToRoom = inviteUsersToRoom;
exports.isValid3pidInvite = isValid3pidInvite;
exports.showAnyInviteErrors = showAnyInviteErrors;
exports.showCommunityInviteDialog = showCommunityInviteDialog;
exports.showCommunityRoomInviteDialog = showCommunityRoomInviteDialog;
exports.showRoomInviteDialog = showRoomInviteDialog;
exports.showStartChatInviteDialog = showStartChatInviteDialog;

var _react = _interopRequireDefault(require("react"));

var _MatrixClientPeg = require("./MatrixClientPeg");

var _MultiInviter = _interopRequireDefault(require("./utils/MultiInviter"));

var _Modal = _interopRequireDefault(require("./Modal"));

var _languageHandler = require("./languageHandler");

var _InviteDialog = _interopRequireWildcard(require("./components/views/dialogs/InviteDialog"));

var _CommunityPrototypeInviteDialog = _interopRequireDefault(require("./components/views/dialogs/CommunityPrototypeInviteDialog"));

var _CommunityPrototypeStore = require("./stores/CommunityPrototypeStore");

var _BaseAvatar = _interopRequireDefault(require("./components/views/avatars/BaseAvatar"));

var _Media = require("./customisations/Media");

var _ErrorDialog = _interopRequireDefault(require("./components/views/dialogs/ErrorDialog"));

var _logger = require("matrix-js-sdk/src/logger");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
Copyright 2016 - 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/**
 * Invites multiple addresses to a room
 * Simpler interface to utils/MultiInviter but with
 * no option to cancel.
 *
 * @param {string} roomId The ID of the room to invite to
 * @param {string[]} addresses Array of strings of addresses to invite. May be matrix IDs or 3pids.
 * @param {function} progressCallback optional callback, fired after each invite.
 * @returns {Promise} Promise
 */
function inviteMultipleToRoom(roomId, addresses, progressCallback) {
  const inviter = new _MultiInviter.default(roomId, progressCallback);
  return inviter.invite(addresses).then(states => Promise.resolve({
    states,
    inviter
  }));
}

function showStartChatInviteDialog(initialText = "") {
  // This dialog handles the room creation internally - we don't need to worry about it.
  _Modal.default.createTrackedDialog('Start DM', '', _InviteDialog.default, {
    kind: _InviteDialog.KIND_DM,
    initialText
  },
  /*className=*/
  null,
  /*isPriority=*/
  false,
  /*isStatic=*/
  true);
}

function showRoomInviteDialog(roomId, initialText = "") {
  // This dialog handles the room creation internally - we don't need to worry about it.
  _Modal.default.createTrackedDialog("Invite Users", "", _InviteDialog.default, {
    kind: _InviteDialog.KIND_INVITE,
    initialText,
    roomId
  },
  /*className=*/
  null,
  /*isPriority=*/
  false,
  /*isStatic=*/
  true);
}

function showCommunityRoomInviteDialog(roomId, communityName) {
  _Modal.default.createTrackedDialog('Invite Users to Community', '', _CommunityPrototypeInviteDialog.default, {
    communityName,
    roomId
  },
  /*className=*/
  null,
  /*isPriority=*/
  false,
  /*isStatic=*/
  true);
}

function showCommunityInviteDialog(communityId) {
  const chat = _CommunityPrototypeStore.CommunityPrototypeStore.instance.getGeneralChat(communityId);

  if (chat) {
    const name = _CommunityPrototypeStore.CommunityPrototypeStore.instance.getCommunityName(communityId);

    showCommunityRoomInviteDialog(chat.roomId, name);
  } else {
    throw new Error("Failed to locate appropriate room to start an invite in");
  }
}
/**
 * Checks if the given MatrixEvent is a valid 3rd party user invite.
 * @param {MatrixEvent} event The event to check
 * @returns {boolean} True if valid, false otherwise
 */


function isValid3pidInvite(event) {
  if (!event || event.getType() !== "m.room.third_party_invite") return false; // any events without these keys are not valid 3pid invites, so we ignore them

  const requiredKeys = ['key_validity_url', 'public_key', 'display_name'];

  for (let i = 0; i < requiredKeys.length; ++i) {
    if (!event.getContent()[requiredKeys[i]]) return false;
  } // Valid enough by our standards


  return true;
}

function inviteUsersToRoom(roomId, userIds, progressCallback) {
  return inviteMultipleToRoom(roomId, userIds, progressCallback).then(result => {
    const room = _MatrixClientPeg.MatrixClientPeg.get().getRoom(roomId);

    showAnyInviteErrors(result.states, room, result.inviter);
  }).catch(err => {
    _logger.logger.error(err.stack);

    _Modal.default.createTrackedDialog('Failed to invite', '', _ErrorDialog.default, {
      title: (0, _languageHandler._t)("Failed to invite"),
      description: err && err.message ? err.message : (0, _languageHandler._t)("Operation failed")
    });
  });
}

function showAnyInviteErrors(states, room, inviter, userMap) {
  // Show user any errors
  const failedUsers = Object.keys(states).filter(a => states[a] === 'error');

  if (failedUsers.length === 1 && inviter.fatal) {
    // Just get the first message because there was a fatal problem on the first
    // user. This usually means that no other users were attempted, making it
    // pointless for us to list who failed exactly.
    _Modal.default.createTrackedDialog('Failed to invite users to the room', '', _ErrorDialog.default, {
      title: (0, _languageHandler._t)("Failed to invite users to the room:", {
        roomName: room.name
      }),
      description: inviter.getErrorText(failedUsers[0])
    });

    return false;
  } else {
    const errorList = [];

    for (const addr of failedUsers) {
      if (states[addr] === "error") {
        const reason = inviter.getErrorText(addr);
        errorList.push(addr + ": " + reason);
      }
    }

    const cli = _MatrixClientPeg.MatrixClientPeg.get();

    if (errorList.length > 0) {
      // React 16 doesn't let us use `errorList.join(<br />)` anymore, so this is our solution
      const description = /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_InviteDialog_multiInviterError"
      }, /*#__PURE__*/_react.default.createElement("h4", null, (0, _languageHandler._t)("We sent the others, but the below people couldn't be invited to <RoomName/>", {}, {
        RoomName: () => /*#__PURE__*/_react.default.createElement("b", null, room.name)
      })), /*#__PURE__*/_react.default.createElement("div", null, failedUsers.map(addr => {
        var _getMxcAvatarUrl, _ref;

        const user = (userMap === null || userMap === void 0 ? void 0 : userMap.get(addr)) || cli.getUser(addr);
        const name = user.name || user.rawDisplayName;
        const avatarUrl = ((_getMxcAvatarUrl = (_ref = user).getMxcAvatarUrl) === null || _getMxcAvatarUrl === void 0 ? void 0 : _getMxcAvatarUrl.call(_ref)) || user.avatarUrl;
        return /*#__PURE__*/_react.default.createElement("div", {
          key: addr,
          className: "mx_InviteDialog_multiInviterError_entry"
        }, /*#__PURE__*/_react.default.createElement("div", {
          className: "mx_InviteDialog_multiInviterError_entry_userProfile"
        }, /*#__PURE__*/_react.default.createElement(_BaseAvatar.default, {
          url: avatarUrl ? (0, _Media.mediaFromMxc)(avatarUrl).getSquareThumbnailHttp(24) : null,
          name: name,
          idName: user.userId,
          width: 24,
          height: 24
        }), /*#__PURE__*/_react.default.createElement("span", {
          className: "mx_InviteDialog_multiInviterError_entry_name"
        }, name), /*#__PURE__*/_react.default.createElement("span", {
          className: "mx_InviteDialog_multiInviterError_entry_userId"
        }, user.userId)), /*#__PURE__*/_react.default.createElement("div", {
          className: "mx_InviteDialog_multiInviterError_entry_error"
        }, inviter.getErrorText(addr)));
      })));

      _Modal.default.createTrackedDialog("Some invites could not be sent", "", _ErrorDialog.default, {
        title: (0, _languageHandler._t)("Some invites couldn't be sent"),
        description
      });

      return false;
    }
  }

  return true;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9Sb29tSW52aXRlLnRzeCJdLCJuYW1lcyI6WyJpbnZpdGVNdWx0aXBsZVRvUm9vbSIsInJvb21JZCIsImFkZHJlc3NlcyIsInByb2dyZXNzQ2FsbGJhY2siLCJpbnZpdGVyIiwiTXVsdGlJbnZpdGVyIiwiaW52aXRlIiwidGhlbiIsInN0YXRlcyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2hvd1N0YXJ0Q2hhdEludml0ZURpYWxvZyIsImluaXRpYWxUZXh0IiwiTW9kYWwiLCJjcmVhdGVUcmFja2VkRGlhbG9nIiwiSW52aXRlRGlhbG9nIiwia2luZCIsIktJTkRfRE0iLCJzaG93Um9vbUludml0ZURpYWxvZyIsIktJTkRfSU5WSVRFIiwic2hvd0NvbW11bml0eVJvb21JbnZpdGVEaWFsb2ciLCJjb21tdW5pdHlOYW1lIiwiQ29tbXVuaXR5UHJvdG90eXBlSW52aXRlRGlhbG9nIiwic2hvd0NvbW11bml0eUludml0ZURpYWxvZyIsImNvbW11bml0eUlkIiwiY2hhdCIsIkNvbW11bml0eVByb3RvdHlwZVN0b3JlIiwiaW5zdGFuY2UiLCJnZXRHZW5lcmFsQ2hhdCIsIm5hbWUiLCJnZXRDb21tdW5pdHlOYW1lIiwiRXJyb3IiLCJpc1ZhbGlkM3BpZEludml0ZSIsImV2ZW50IiwiZ2V0VHlwZSIsInJlcXVpcmVkS2V5cyIsImkiLCJsZW5ndGgiLCJnZXRDb250ZW50IiwiaW52aXRlVXNlcnNUb1Jvb20iLCJ1c2VySWRzIiwicmVzdWx0Iiwicm9vbSIsIk1hdHJpeENsaWVudFBlZyIsImdldCIsImdldFJvb20iLCJzaG93QW55SW52aXRlRXJyb3JzIiwiY2F0Y2giLCJlcnIiLCJsb2dnZXIiLCJlcnJvciIsInN0YWNrIiwiRXJyb3JEaWFsb2ciLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwibWVzc2FnZSIsInVzZXJNYXAiLCJmYWlsZWRVc2VycyIsIk9iamVjdCIsImtleXMiLCJmaWx0ZXIiLCJhIiwiZmF0YWwiLCJyb29tTmFtZSIsImdldEVycm9yVGV4dCIsImVycm9yTGlzdCIsImFkZHIiLCJyZWFzb24iLCJwdXNoIiwiY2xpIiwiUm9vbU5hbWUiLCJtYXAiLCJ1c2VyIiwiZ2V0VXNlciIsInJhd0Rpc3BsYXlOYW1lIiwiYXZhdGFyVXJsIiwiZ2V0TXhjQXZhdGFyVXJsIiwiZ2V0U3F1YXJlVGh1bWJuYWlsSHR0cCIsInVzZXJJZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTs7QUFLQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7Ozs7O0FBaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTQSxvQkFBVCxDQUNIQyxNQURHLEVBRUhDLFNBRkcsRUFHSEMsZ0JBSEcsRUFJbUI7QUFDdEIsUUFBTUMsT0FBTyxHQUFHLElBQUlDLHFCQUFKLENBQWlCSixNQUFqQixFQUF5QkUsZ0JBQXpCLENBQWhCO0FBQ0EsU0FBT0MsT0FBTyxDQUFDRSxNQUFSLENBQWVKLFNBQWYsRUFBMEJLLElBQTFCLENBQStCQyxNQUFNLElBQUlDLE9BQU8sQ0FBQ0MsT0FBUixDQUFnQjtBQUFFRixJQUFBQSxNQUFGO0FBQVVKLElBQUFBO0FBQVYsR0FBaEIsQ0FBekMsQ0FBUDtBQUNIOztBQUVNLFNBQVNPLHlCQUFULENBQW1DQyxXQUFXLEdBQUcsRUFBakQsRUFBMkQ7QUFDOUQ7QUFDQUMsaUJBQU1DLG1CQUFOLENBQ0ksVUFESixFQUNnQixFQURoQixFQUNvQkMscUJBRHBCLEVBQ2tDO0FBQUVDLElBQUFBLElBQUksRUFBRUMscUJBQVI7QUFBaUJMLElBQUFBO0FBQWpCLEdBRGxDO0FBRUk7QUFBYyxNQUZsQjtBQUV3QjtBQUFlLE9BRnZDO0FBRThDO0FBQWEsTUFGM0Q7QUFJSDs7QUFFTSxTQUFTTSxv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ZUFTSTtBQUFNLFVBQUEsU0FBUyxFQUFDO0FBQWhCLFdBQW1FMkMsSUFBSSxDQUFDTSxNQUF4RSxDQVRKLENBREcsZUFZSDtBQUFLLFVBQUEsU0FBUyxFQUFDO0FBQWYsV0FDTTFFLE9BQU8sQ0FBQzRELFlBQVIsQ0FBcUJFLElBQXJCLENBRE4sQ0FaRyxDQUFQO0FBZ0JILE9BcEJDLENBRE4sQ0FKZ0IsQ0FBcEI7O0FBNkJBckQscUJBQU1DLG1CQUFOLENBQTBCLGdDQUExQixFQUE0RCxFQUE1RCxFQUFnRXNDLG9CQUFoRSxFQUE2RTtBQUN6RUMsUUFBQUEsS0FBSyxFQUFFLHlCQUFHLCtCQUFILENBRGtFO0FBRXpFQyxRQUFBQTtBQUZ5RSxPQUE3RTs7QUFJQSxhQUFPLEtBQVA7QUFDSDtBQUNKOztBQUVELFNBQU8sSUFBUDtBQUNIIiwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE2IC0gMjAyMSBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IFJvb20gfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvbW9kZWxzL3Jvb21cIjtcbmltcG9ydCB7IE1hdHJpeEV2ZW50IH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL21vZGVscy9ldmVudFwiO1xuaW1wb3J0IHsgVXNlciB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9tb2RlbHMvdXNlclwiO1xuXG5pbXBvcnQgeyBNYXRyaXhDbGllbnRQZWcgfSBmcm9tICcuL01hdHJpeENsaWVudFBlZyc7XG5pbXBvcnQgTXVsdGlJbnZpdGVyLCB7IENvbXBsZXRpb25TdGF0ZXMgfSBmcm9tICcuL3V0aWxzL011bHRpSW52aXRlcic7XG5pbXBvcnQgTW9kYWwgZnJvbSAnLi9Nb2RhbCc7XG5pbXBvcnQgeyBfdCB9IGZyb20gJy4vbGFuZ3VhZ2VIYW5kbGVyJztcbmltcG9ydCBJbnZpdGVEaWFsb2csIHsgS0lORF9ETSwgS0lORF9JTlZJVEUsIE1lbWJlciB9IGZyb20gXCIuL2NvbXBvbmVudHMvdmlld3MvZGlhbG9ncy9JbnZpdGVEaWFsb2dcIjtcbmltcG9ydCBDb21tdW5pdHlQcm90b3R5cGVJbnZpdGVEaWFsb2cgZnJvbSBcIi4vY29tcG9uZW50cy92aWV3cy9kaWFsb2dzL0NvbW11bml0eVByb3RvdHlwZUludml0ZURpYWxvZ1wiO1xuaW1wb3J0IHsgQ29tbXVuaXR5UHJvdG90eXBlU3RvcmUgfSBmcm9tIFwiLi9zdG9yZXMvQ29tbXVuaXR5UHJvdG90eXBlU3RvcmVcIjtcbmltcG9ydCBCYXNlQXZhdGFyIGZyb20gXCIuL2NvbXBvbmVudHMvdmlld3MvYXZhdGFycy9CYXNlQXZhdGFyXCI7XG5pbXBvcnQgeyBtZWRpYUZyb21NeGMgfSBmcm9tIFwiLi9jdXN0b21pc2F0aW9ucy9NZWRpYVwiO1xuaW1wb3J0IEVycm9yRGlhbG9nIGZyb20gXCIuL2NvbXBvbmVudHMvdmlld3MvZGlhbG9ncy9FcnJvckRpYWxvZ1wiO1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvbG9nZ2VyXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUludml0ZVJlc3VsdCB7XG4gICAgc3RhdGVzOiBDb21wbGV0aW9uU3RhdGVzO1xuICAgIGludml0ZXI6IE11bHRpSW52aXRlcjtcbn1cblxuLyoqXG4gKiBJbnZpdGVzIG11bHRpcGxlIGFkZHJlc3NlcyB0byBhIHJvb21cbiAqIFNpbXBsZXIgaW50ZXJmYWNlIHRvIHV0aWxzL011bHRpSW52aXRlciBidXQgd2l0aFxuICogbm8gb3B0aW9uIHRvIGNhbmNlbC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9vbUlkIFRoZSBJRCBvZiB0aGUgcm9vbSB0byBpbnZpdGUgdG9cbiAqIEBwYXJhbSB7c3RyaW5nW119IGFkZHJlc3NlcyBBcnJheSBvZiBzdHJpbmdzIG9mIGFkZHJlc3NlcyB0byBpbnZpdGUuIE1heSBiZSBtYXRyaXggSURzIG9yIDNwaWRzLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gcHJvZ3Jlc3NDYWxsYmFjayBvcHRpb25hbCBjYWxsYmFjaywgZmlyZWQgYWZ0ZXIgZWFjaCBpbnZpdGUuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52aXRlTXVsdGlwbGVUb1Jvb20oXG4gICAgcm9vbUlkOiBzdHJpbmcsXG4gICAgYWRkcmVzc2VzOiBzdHJpbmdbXSxcbiAgICBwcm9ncmVzc0NhbGxiYWNrPzogKCkgPT4gdm9pZCxcbik6IFByb21pc2U8SUludml0ZVJlc3VsdD4ge1xuICAgIGNvbnN0IGludml0ZXIgPSBuZXcgTXVsdGlJbnZpdGVyKHJvb21JZCwgcHJvZ3Jlc3NDYWxsYmFjayk7XG4gICAgcmV0dXJuIGludml0ZXIuaW52aXRlKGFkZHJlc3NlcykudGhlbihzdGF0ZXMgPT4gUHJvbWlzZS5yZXNvbHZlKHsgc3RhdGVzLCBpbnZpdGVyIH0pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNob3dTdGFydENoYXRJbnZpdGVEaWFsb2coaW5pdGlhbFRleHQgPSBcIlwiKTogdm9pZCB7XG4gICAgLy8gVGhpcyBkaWFsb2cgaGFuZGxlcyB0aGUgcm9vbSBjcmVhdGlvbiBpbnRlcm5hbGx5IC0gd2UgZG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCBpdC5cbiAgICBNb2RhbC5jcmVhdGVUcmFja2VkRGlhbG9nKFxuICAgICAgICAnU3RhcnQgRE0nLCAnJywgSW52aXRlRGlhbG9nLCB7IGtpbmQ6IEtJTkRfRE0sIGluaXRpYWxUZXh0IH0sXG4gICAgICAgIC8qY2xhc3NOYW1lPSovbnVsbCwgLyppc1ByaW9yaXR5PSovZmFsc2UsIC8qaXNTdGF0aWM9Ki90cnVlLFxuICAgICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG93Um9vbUludml0ZURpYWxvZyhyb29tSWQ6IHN0cmluZywgaW5pdGlhbFRleHQgPSBcIlwiKTogdm9pZCB7XG4gICAgLy8gVGhpcyBkaWFsb2cgaGFuZGxlcyB0aGUgcm9vbSBjcmVhdGlvbiBpbnRlcm5hbGx5IC0gd2UgZG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCBpdC5cbiAgICBNb2RhbC5jcmVhdGVUcmFja2VkRGlhbG9nKFxuICAgICAgICBcIkludml0ZSBVc2Vyc1wiLCBcIlwiLCBJbnZpdGVEaWFsb2csIHtcbiAgICAgICAgICAgIGtpbmQ6IEtJTkRfSU5WSVRFLFxuICAgICAgICAgICAgaW5pdGlhbFRleHQsXG4gICAgICAgICAgICByb29tSWQsXG4gICAgICAgIH0sXG4gICAgICAgIC8qY2xhc3NOYW1lPSovbnVsbCwgLyppc1ByaW9yaXR5PSovZmFsc2UsIC8qaXNTdGF0aWM9Ki90cnVlLFxuICAgICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG93Q29tbXVuaXR5Um9vbUludml0ZURpYWxvZyhyb29tSWQ6IHN0cmluZywgY29tbXVuaXR5TmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgTW9kYWwuY3JlYXRlVHJhY2tlZERpYWxvZyhcbiAgICAgICAgJ0ludml0ZSBVc2VycyB0byBDb21tdW5pdHknLCAnJywgQ29tbXVuaXR5UHJvdG90eXBlSW52aXRlRGlhbG9nLCB7IGNvbW11bml0eU5hbWUsIHJvb21JZCB9LFxuICAgICAgICAvKmNsYXNzTmFtZT0qL251bGwsIC8qaXNQcmlvcml0eT0qL2ZhbHNlLCAvKmlzU3RhdGljPSovdHJ1ZSxcbiAgICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvd0NvbW11bml0eUludml0ZURpYWxvZyhjb21tdW5pdHlJZDogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgY2hhdCA9IENvbW11bml0eVByb3RvdHlwZVN0b3JlLmluc3RhbmNlLmdldEdlbmVyYWxDaGF0KGNvbW11bml0eUlkKTtcbiAgICBpZiAoY2hhdCkge1xuICAgICAgICBjb25zdCBuYW1lID0gQ29tbXVuaXR5UHJvdG90eXBlU3RvcmUuaW5zdGFuY2UuZ2V0Q29tbXVuaXR5TmFtZShjb21tdW5pdHlJZCk7XG4gICAgICAgIHNob3dDb21tdW5pdHlSb29tSW52aXRlRGlhbG9nKGNoYXQucm9vbUlkLCBuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbG9jYXRlIGFwcHJvcHJpYXRlIHJvb20gdG8gc3RhcnQgYW4gaW52aXRlIGluXCIpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIE1hdHJpeEV2ZW50IGlzIGEgdmFsaWQgM3JkIHBhcnR5IHVzZXIgaW52aXRlLlxuICogQHBhcmFtIHtNYXRyaXhFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkM3BpZEludml0ZShldmVudDogTWF0cml4RXZlbnQpOiBib29sZWFuIHtcbiAgICBpZiAoIWV2ZW50IHx8IGV2ZW50LmdldFR5cGUoKSAhPT0gXCJtLnJvb20udGhpcmRfcGFydHlfaW52aXRlXCIpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIGFueSBldmVudHMgd2l0aG91dCB0aGVzZSBrZXlzIGFyZSBub3QgdmFsaWQgM3BpZCBpbnZpdGVzLCBzbyB3ZSBpZ25vcmUgdGhlbVxuICAgIGNvbnN0IHJlcXVpcmVkS2V5cyA9IFsna2V5X3ZhbGlkaXR5X3VybCcsICdwdWJsaWNfa2V5JywgJ2Rpc3BsYXlfbmFtZSddO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWlyZWRLZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICghZXZlbnQuZ2V0Q29udGVudCgpW3JlcXVpcmVkS2V5c1tpXV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZCBlbm91Z2ggYnkgb3VyIHN0YW5kYXJkc1xuICAgIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW52aXRlVXNlcnNUb1Jvb20ocm9vbUlkOiBzdHJpbmcsIHVzZXJJZHM6IHN0cmluZ1tdLCBwcm9ncmVzc0NhbGxiYWNrPzogKCkgPT4gdm9pZCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBpbnZpdGVNdWx0aXBsZVRvUm9vbShyb29tSWQsIHVzZXJJZHMsIHByb2dyZXNzQ2FsbGJhY2spLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICBjb25zdCByb29tID0gTWF0cml4Q2xpZW50UGVnLmdldCgpLmdldFJvb20ocm9vbUlkKTtcbiAgICAgICAgc2hvd0FueUludml0ZUVycm9ycyhyZXN1bHQuc3RhdGVzLCByb29tLCByZXN1bHQuaW52aXRlcik7XG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBsb2dnZXIuZXJyb3IoZXJyLnN0YWNrKTtcbiAgICAgICAgTW9kYWwuY3JlYXRlVHJhY2tlZERpYWxvZygnRmFpbGVkIHRvIGludml0ZScsICcnLCBFcnJvckRpYWxvZywge1xuICAgICAgICAgICAgdGl0bGU6IF90KFwiRmFpbGVkIHRvIGludml0ZVwiKSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAoKGVyciAmJiBlcnIubWVzc2FnZSkgPyBlcnIubWVzc2FnZSA6IF90KFwiT3BlcmF0aW9uIGZhaWxlZFwiKSksXG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvd0FueUludml0ZUVycm9ycyhcbiAgICBzdGF0ZXM6IENvbXBsZXRpb25TdGF0ZXMsXG4gICAgcm9vbTogUm9vbSxcbiAgICBpbnZpdGVyOiBNdWx0aUludml0ZXIsXG4gICAgdXNlck1hcD86IE1hcDxzdHJpbmcsIE1lbWJlcj4sXG4pOiBib29sZWFuIHtcbiAgICAvLyBTaG93IHVzZXIgYW55IGVycm9yc1xuICAgIGNvbnN0IGZhaWxlZFVzZXJzID0gT2JqZWN0LmtleXMoc3RhdGVzKS5maWx0ZXIoYSA9PiBzdGF0ZXNbYV0gPT09ICdlcnJvcicpO1xuICAgIGlmIChmYWlsZWRVc2Vycy5sZW5ndGggPT09IDEgJiYgaW52aXRlci5mYXRhbCkge1xuICAgICAgICAvLyBKdXN0IGdldCB0aGUgZmlyc3QgbWVzc2FnZSBiZWNhdXNlIHRoZXJlIHdhcyBhIGZhdGFsIHByb2JsZW0gb24gdGhlIGZpcnN0XG4gICAgICAgIC8vIHVzZXIuIFRoaXMgdXN1YWxseSBtZWFucyB0aGF0IG5vIG90aGVyIHVzZXJzIHdlcmUgYXR0ZW1wdGVkLCBtYWtpbmcgaXRcbiAgICAgICAgLy8gcG9pbnRsZXNzIGZvciB1cyB0byBsaXN0IHdobyBmYWlsZWQgZXhhY3RseS5cbiAgICAgICAgTW9kYWwuY3JlYXRlVHJhY2tlZERpYWxvZygnRmFpbGVkIHRvIGludml0ZSB1c2VycyB0byB0aGUgcm9vbScsICcnLCBFcnJvckRpYWxvZywge1xuICAgICAgICAgICAgdGl0bGU6IF90KFwiRmFpbGVkIHRvIGludml0ZSB1c2VycyB0byB0aGUgcm9vbTpcIiwgeyByb29tTmFtZTogcm9vbS5uYW1lIH0pLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGludml0ZXIuZ2V0RXJyb3JUZXh0KGZhaWxlZFVzZXJzWzBdKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBlcnJvckxpc3QgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBhZGRyIG9mIGZhaWxlZFVzZXJzKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGVzW2FkZHJdID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWFzb24gPSBpbnZpdGVyLmdldEVycm9yVGV4dChhZGRyKTtcbiAgICAgICAgICAgICAgICBlcnJvckxpc3QucHVzaChhZGRyICsgXCI6IFwiICsgcmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNsaSA9IE1hdHJpeENsaWVudFBlZy5nZXQoKTtcbiAgICAgICAgaWYgKGVycm9yTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBSZWFjdCAxNiBkb2Vzbid0IGxldCB1cyB1c2UgYGVycm9yTGlzdC5qb2luKDxiciAvPilgIGFueW1vcmUsIHNvIHRoaXMgaXMgb3VyIHNvbHV0aW9uXG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IDxkaXYgY2xhc3NOYW1lPVwibXhfSW52aXRlRGlhbG9nX211bHRpSW52aXRlckVycm9yXCI+XG4gICAgICAgICAgICAgICAgPGg0PnsgX3QoXCJXZSBzZW50IHRoZSBvdGhlcnMsIGJ1dCB0aGUgYmVsb3cgcGVvcGxlIGNvdWxkbid0IGJlIGludml0ZWQgdG8gPFJvb21OYW1lLz5cIiwge30sIHtcbiAgICAgICAgICAgICAgICAgICAgUm9vbU5hbWU6ICgpID0+IDxiPnsgcm9vbS5uYW1lIH08L2I+LFxuICAgICAgICAgICAgICAgIH0pIH08L2g0PlxuICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgIHsgZmFpbGVkVXNlcnMubWFwKGFkZHIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlciA9IHVzZXJNYXA/LmdldChhZGRyKSB8fCBjbGkuZ2V0VXNlcihhZGRyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSAodXNlciBhcyBNZW1iZXIpLm5hbWUgfHwgKHVzZXIgYXMgVXNlcikucmF3RGlzcGxheU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhdmF0YXJVcmwgPSAodXNlciBhcyBNZW1iZXIpLmdldE14Y0F2YXRhclVybD8uKCkgfHwgKHVzZXIgYXMgVXNlcikuYXZhdGFyVXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxkaXYga2V5PXthZGRyfSBjbGFzc05hbWU9XCJteF9JbnZpdGVEaWFsb2dfbXVsdGlJbnZpdGVyRXJyb3JfZW50cnlcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm14X0ludml0ZURpYWxvZ19tdWx0aUludml0ZXJFcnJvcl9lbnRyeV91c2VyUHJvZmlsZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QmFzZUF2YXRhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsPXthdmF0YXJVcmwgPyBtZWRpYUZyb21NeGMoYXZhdGFyVXJsKS5nZXRTcXVhcmVUaHVtYm5haWxIdHRwKDI0KSA6IG51bGx9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPXtuYW1lfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWROYW1lPXt1c2VyLnVzZXJJZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoPXsyNH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodD17MjR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cIm14X0ludml0ZURpYWxvZ19tdWx0aUludml0ZXJFcnJvcl9lbnRyeV9uYW1lXCI+eyBuYW1lIH08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cIm14X0ludml0ZURpYWxvZ19tdWx0aUludml0ZXJFcnJvcl9lbnRyeV91c2VySWRcIj57IHVzZXIudXNlcklkIH08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJteF9JbnZpdGVEaWFsb2dfbXVsdGlJbnZpdGVyRXJyb3JfZW50cnlfZXJyb3JcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBpbnZpdGVyLmdldEVycm9yVGV4dChhZGRyKSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj47XG4gICAgICAgICAgICAgICAgICAgIH0pIH1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PjtcblxuICAgICAgICAgICAgTW9kYWwuY3JlYXRlVHJhY2tlZERpYWxvZyhcIlNvbWUgaW52aXRlcyBjb3VsZCBub3QgYmUgc2VudFwiLCBcIlwiLCBFcnJvckRpYWxvZywge1xuICAgICAgICAgICAgICAgIHRpdGxlOiBfdChcIlNvbWUgaW52aXRlcyBjb3VsZG4ndCBiZSBzZW50XCIpLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbiJdfQ==