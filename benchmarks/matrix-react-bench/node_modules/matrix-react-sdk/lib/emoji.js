"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getEmojiFromUnicode = exports.EMOTICON_TO_EMOJI = exports.EMOJI = exports.DATA_BY_CATEGORY = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _compact = _interopRequireDefault(require("emojibase-data/en/compact.json"));

var _iamcal = _interopRequireDefault(require("emojibase-data/en/shortcodes/iamcal.json"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// The unicode is stored without the variant selector
const UNICODE_TO_EMOJI = new Map(); // not exported as gets for it are handled by getEmojiFromUnicode

const EMOTICON_TO_EMOJI = new Map();
exports.EMOTICON_TO_EMOJI = EMOTICON_TO_EMOJI;

const getEmojiFromUnicode = unicode => UNICODE_TO_EMOJI.get(stripVariation(unicode));

exports.getEmojiFromUnicode = getEmojiFromUnicode;

const isRegionalIndicator = x => {
  // First verify that the string is a single character. We use Array.from
  // to make sure we count by characters, not UTF-8 code units.
  return Array.from(x).length === 1 && // Next verify that the character is within the code point range for
  // regional indicators.
  // http://unicode.org/charts/PDF/Unicode-6.0/U60-1F100.pdf
  x >= '\u{1f1e6}' && x <= '\u{1f1ff}';
};

const EMOJIBASE_GROUP_ID_TO_CATEGORY = ["people", // smileys
"people", // actually people
"control", // modifiers and such, not displayed in picker
"nature", "foods", "places", "activity", "objects", "symbols", "flags"];
const DATA_BY_CATEGORY = {
  "people": [],
  "nature": [],
  "foods": [],
  "places": [],
  "activity": [],
  "objects": [],
  "symbols": [],
  "flags": []
}; // Store various mappings from unicode/emoticon/shortcode to the Emoji objects

exports.DATA_BY_CATEGORY = DATA_BY_CATEGORY;

const EMOJI = _compact.default.map(emojiData => {
  // If there's ever a gap in shortcode coverage, we fudge it by
  // filling it in with the emoji's CLDR annotation
  const shortcodeData = _iamcal.default[emojiData.hexcode] ?? [emojiData.annotation.toLowerCase().replace(/\W+/g, "_")];

  const emoji = _objectSpread(_objectSpread({}, emojiData), {}, {
    // Homogenize shortcodes by ensuring that everything is an array
    shortcodes: typeof shortcodeData === "string" ? [shortcodeData] : shortcodeData
  }); // We manually include regional indicators in the symbols group, since
  // Emojibase intentionally leaves them uncategorized


  const categoryId = EMOJIBASE_GROUP_ID_TO_CATEGORY[emoji.group] ?? (isRegionalIndicator(emoji.unicode) ? "symbols" : null);

  if (DATA_BY_CATEGORY.hasOwnProperty(categoryId)) {
    DATA_BY_CATEGORY[categoryId].push(emoji);
  } // Add mapping from unicode to Emoji object
  // The 'unicode' field that we use in emojibase has either
  // VS15 or VS16 appended to any characters that can take
  // variation selectors. Which one it appends depends
  // on whether emojibase considers their type to be 'text' or
  // 'emoji'. We therefore strip any variation chars from strings
  // both when building the map and when looking up.


  UNICODE_TO_EMOJI.set(stripVariation(emoji.unicode), emoji);

  if (emoji.emoticon) {
    // Add mapping from emoticon to Emoji object
    EMOTICON_TO_EMOJI.set(emoji.emoticon, emoji);
  }

  return emoji;
});
/**
 * Strips variation selectors from the end of given string
 * NB. Skin tone modifiers are not variation selectors:
 * this function does not touch them. (Should it?)
 *
 * @param {string} str string to strip
 * @returns {string} stripped string
 */


exports.EMOJI = EMOJI;

function stripVariation(str) {
  return str.replace(/[\uFE00-\uFE0F]$/, "");
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9lbW9qaS50cyJdLCJuYW1lcyI6WyJVTklDT0RFX1RPX0VNT0pJIiwiTWFwIiwiRU1PVElDT05fVE9fRU1PSkkiLCJnZXRFbW9qaUZyb21Vbmljb2RlIiwidW5pY29kZSIsImdldCIsInN0cmlwVmFyaWF0aW9uIiwiaXNSZWdpb25hbEluZGljYXRvciIsIngiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJFTU9KSUJBU0VfR1JPVVBfSURfVE9fQ0FURUdPUlkiLCJEQVRBX0JZX0NBVEVHT1JZIiwiRU1PSkkiLCJFTU9KSUJBU0UiLCJtYXAiLCJlbW9qaURhdGEiLCJzaG9ydGNvZGVEYXRhIiwiU0hPUlRDT0RFUyIsImhleGNvZGUiLCJhbm5vdGF0aW9uIiwidG9Mb3dlckNhc2UiLCJyZXBsYWNlIiwiZW1vamkiLCJzaG9ydGNvZGVzIiwiY2F0ZWdvcnlJZCIsImdyb3VwIiwiaGFzT3duUHJvcGVydHkiLCJwdXNoIiwic2V0IiwiZW1vdGljb24iLCJzdHIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBZ0JBOztBQUNBOzs7Ozs7QUFjQTtBQUNBLE1BQU1BLGdCQUFnQixHQUFHLElBQUlDLEdBQUosRUFBekIsQyxDQUFvRDs7QUFDN0MsTUFBTUMsaUJBQWlCLEdBQUcsSUFBSUQsR0FBSixFQUExQjs7O0FBRUEsTUFBTUUsbUJBQW1CLEdBQUdDLE9BQU8sSUFBSUosZ0JBQWdCLENBQUNLLEdBQWpCLENBQXFCQyxjQUFjLENBQUNGLE9BQUQsQ0FBbkMsQ0FBdkM7Ozs7QUFFUCxNQUFNRyxtQkFBbUIsR0FBSUMsQ0FBRCxJQUF3QjtBQUNoRDtBQUNBO0FBQ0EsU0FBT0MsS0FBSyxDQUFDQyxJQUFOLENBQVdGLENBQVgsRUFBY0csTUFBZCxLQUF5QixDQUF6QixJQUNIO0FBQ0E7QUFDQTtBQUNBSCxFQUFBQSxDQUFDLElBQUksV0FKRixJQUlpQkEsQ0FBQyxJQUFJLFdBSjdCO0FBS0gsQ0FSRDs7QUFVQSxNQUFNSSw4QkFBOEIsR0FBRyxDQUNuQyxRQURtQyxFQUN6QjtBQUNWLFFBRm1DLEVBRXpCO0FBQ1YsU0FIbUMsRUFHeEI7QUFDWCxRQUptQyxFQUtuQyxPQUxtQyxFQU1uQyxRQU5tQyxFQU9uQyxVQVBtQyxFQVFuQyxTQVJtQyxFQVNuQyxTQVRtQyxFQVVuQyxPQVZtQyxDQUF2QztBQWFPLE1BQU1DLGdCQUFnQixHQUFHO0FBQzVCLFlBQVUsRUFEa0I7QUFFNUIsWUFBVSxFQUZrQjtBQUc1QixXQUFTLEVBSG1CO0FBSTVCLFlBQVUsRUFKa0I7QUFLNUIsY0FBWSxFQUxnQjtBQU01QixhQUFXLEVBTmlCO0FBTzVCLGFBQVcsRUFQaUI7QUFRNUIsV0FBUztBQVJtQixDQUF6QixDLENBV1A7Ozs7QUFDTyxNQUFNQyxLQUFlLEdBQUdDLGlCQUFVQyxHQUFWLENBQWVDLFNBQUQsSUFBMkM7QUFDcEY7QUFDQTtBQUNBLFFBQU1DLGFBQWEsR0FBR0MsZ0JBQVdGLFNBQVMsQ0FBQ0csT0FBckIsS0FDbEIsQ0FBQ0gsU0FBUyxDQUFDSSxVQUFWLENBQXFCQyxXQUFyQixHQUFtQ0MsT0FBbkMsQ0FBMkMsTUFBM0MsRUFBbUQsR0FBbkQsQ0FBRCxDQURKOztBQUdBLFFBQU1DLEtBQWEsbUNBQ1pQLFNBRFk7QUFFZjtBQUNBUSxJQUFBQSxVQUFVLEVBQUUsT0FBT1AsYUFBUCxLQUF5QixRQUF6QixHQUFvQyxDQUFDQSxhQUFELENBQXBDLEdBQXNEQTtBQUhuRCxJQUFuQixDQU5vRixDQVlwRjtBQUNBOzs7QUFDQSxRQUFNUSxVQUFVLEdBQUdkLDhCQUE4QixDQUFDWSxLQUFLLENBQUNHLEtBQVAsQ0FBOUIsS0FDZHBCLG1CQUFtQixDQUFDaUIsS0FBSyxDQUFDcEIsT0FBUCxDQUFuQixHQUFxQyxTQUFyQyxHQUFpRCxJQURuQyxDQUFuQjs7QUFHQSxNQUFJUyxnQkFBZ0IsQ0FBQ2UsY0FBakIsQ0FBZ0NGLFVBQWhDLENBQUosRUFBaUQ7QUFDN0NiLElBQUFBLGdCQUFnQixDQUFDYSxVQUFELENBQWhCLENBQTZCRyxJQUE3QixDQUFrQ0wsS0FBbEM7QUFDSCxHQW5CbUYsQ0FxQnBGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQXhCLEVBQUFBLGdCQUFnQixDQUFDOEIsR0FBakIsQ0FBcUJ4QixjQUFjLENBQUNrQixLQUFLLENBQUNwQixPQUFQLENBQW5DLEVBQW9Eb0IsS0FBcEQ7O0FBRUEsTUFBSUEsS0FBSyxDQUFDTyxRQUFWLEVBQW9CO0FBQ2hCO0FBQ0E3QixJQUFBQSxpQkFBaUIsQ0FBQzRCLEdBQWxCLENBQXNCTixLQUFLLENBQUNPLFFBQTVCLEVBQXNDUCxLQUF0QztBQUNIOztBQUVELFNBQU9BLEtBQVA7QUFDSCxDQXBDOEIsQ0FBeEI7QUFzQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFDQSxTQUFTbEIsY0FBVCxDQUF3QjBCLEdBQXhCLEVBQTZCO0FBQ3pCLFNBQU9BLEdBQUcsQ0FBQ1QsT0FBSixDQUFZLGtCQUFaLEVBQWdDLEVBQWhDLENBQVA7QUFDSCIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxOSBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBFTU9KSUJBU0UgZnJvbSAnZW1vamliYXNlLWRhdGEvZW4vY29tcGFjdC5qc29uJztcbmltcG9ydCBTSE9SVENPREVTIGZyb20gJ2Vtb2ppYmFzZS1kYXRhL2VuL3Nob3J0Y29kZXMvaWFtY2FsLmpzb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIElFbW9qaSB7XG4gICAgYW5ub3RhdGlvbjogc3RyaW5nO1xuICAgIGdyb3VwPzogbnVtYmVyO1xuICAgIGhleGNvZGU6IHN0cmluZztcbiAgICBvcmRlcj86IG51bWJlcjtcbiAgICBzaG9ydGNvZGVzOiBzdHJpbmdbXTtcbiAgICB0YWdzPzogc3RyaW5nW107XG4gICAgdW5pY29kZTogc3RyaW5nO1xuICAgIHNraW5zPzogT21pdDxJRW1vamksIFwic2hvcnRjb2Rlc1wiIHwgXCJ0YWdzXCI+W107IC8vIEN1cnJlbnRseSB1bnVzZWRcbiAgICBlbW90aWNvbj86IHN0cmluZztcbn1cblxuLy8gVGhlIHVuaWNvZGUgaXMgc3RvcmVkIHdpdGhvdXQgdGhlIHZhcmlhbnQgc2VsZWN0b3JcbmNvbnN0IFVOSUNPREVfVE9fRU1PSkkgPSBuZXcgTWFwPHN0cmluZywgSUVtb2ppPigpOyAvLyBub3QgZXhwb3J0ZWQgYXMgZ2V0cyBmb3IgaXQgYXJlIGhhbmRsZWQgYnkgZ2V0RW1vamlGcm9tVW5pY29kZVxuZXhwb3J0IGNvbnN0IEVNT1RJQ09OX1RPX0VNT0pJID0gbmV3IE1hcDxzdHJpbmcsIElFbW9qaT4oKTtcblxuZXhwb3J0IGNvbnN0IGdldEVtb2ppRnJvbVVuaWNvZGUgPSB1bmljb2RlID0+IFVOSUNPREVfVE9fRU1PSkkuZ2V0KHN0cmlwVmFyaWF0aW9uKHVuaWNvZGUpKTtcblxuY29uc3QgaXNSZWdpb25hbEluZGljYXRvciA9ICh4OiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICAvLyBGaXJzdCB2ZXJpZnkgdGhhdCB0aGUgc3RyaW5nIGlzIGEgc2luZ2xlIGNoYXJhY3Rlci4gV2UgdXNlIEFycmF5LmZyb21cbiAgICAvLyB0byBtYWtlIHN1cmUgd2UgY291bnQgYnkgY2hhcmFjdGVycywgbm90IFVURi04IGNvZGUgdW5pdHMuXG4gICAgcmV0dXJuIEFycmF5LmZyb20oeCkubGVuZ3RoID09PSAxICYmXG4gICAgICAgIC8vIE5leHQgdmVyaWZ5IHRoYXQgdGhlIGNoYXJhY3RlciBpcyB3aXRoaW4gdGhlIGNvZGUgcG9pbnQgcmFuZ2UgZm9yXG4gICAgICAgIC8vIHJlZ2lvbmFsIGluZGljYXRvcnMuXG4gICAgICAgIC8vIGh0dHA6Ly91bmljb2RlLm9yZy9jaGFydHMvUERGL1VuaWNvZGUtNi4wL1U2MC0xRjEwMC5wZGZcbiAgICAgICAgeCA+PSAnXFx1ezFmMWU2fScgJiYgeCA8PSAnXFx1ezFmMWZmfSc7XG59O1xuXG5jb25zdCBFTU9KSUJBU0VfR1JPVVBfSURfVE9fQ0FURUdPUlkgPSBbXG4gICAgXCJwZW9wbGVcIiwgLy8gc21pbGV5c1xuICAgIFwicGVvcGxlXCIsIC8vIGFjdHVhbGx5IHBlb3BsZVxuICAgIFwiY29udHJvbFwiLCAvLyBtb2RpZmllcnMgYW5kIHN1Y2gsIG5vdCBkaXNwbGF5ZWQgaW4gcGlja2VyXG4gICAgXCJuYXR1cmVcIixcbiAgICBcImZvb2RzXCIsXG4gICAgXCJwbGFjZXNcIixcbiAgICBcImFjdGl2aXR5XCIsXG4gICAgXCJvYmplY3RzXCIsXG4gICAgXCJzeW1ib2xzXCIsXG4gICAgXCJmbGFnc1wiLFxuXTtcblxuZXhwb3J0IGNvbnN0IERBVEFfQllfQ0FURUdPUlkgPSB7XG4gICAgXCJwZW9wbGVcIjogW10sXG4gICAgXCJuYXR1cmVcIjogW10sXG4gICAgXCJmb29kc1wiOiBbXSxcbiAgICBcInBsYWNlc1wiOiBbXSxcbiAgICBcImFjdGl2aXR5XCI6IFtdLFxuICAgIFwib2JqZWN0c1wiOiBbXSxcbiAgICBcInN5bWJvbHNcIjogW10sXG4gICAgXCJmbGFnc1wiOiBbXSxcbn07XG5cbi8vIFN0b3JlIHZhcmlvdXMgbWFwcGluZ3MgZnJvbSB1bmljb2RlL2Vtb3RpY29uL3Nob3J0Y29kZSB0byB0aGUgRW1vamkgb2JqZWN0c1xuZXhwb3J0IGNvbnN0IEVNT0pJOiBJRW1vamlbXSA9IEVNT0pJQkFTRS5tYXAoKGVtb2ppRGF0YTogT21pdDxJRW1vamksIFwic2hvcnRjb2Rlc1wiPikgPT4ge1xuICAgIC8vIElmIHRoZXJlJ3MgZXZlciBhIGdhcCBpbiBzaG9ydGNvZGUgY292ZXJhZ2UsIHdlIGZ1ZGdlIGl0IGJ5XG4gICAgLy8gZmlsbGluZyBpdCBpbiB3aXRoIHRoZSBlbW9qaSdzIENMRFIgYW5ub3RhdGlvblxuICAgIGNvbnN0IHNob3J0Y29kZURhdGEgPSBTSE9SVENPREVTW2Vtb2ppRGF0YS5oZXhjb2RlXSA/P1xuICAgICAgICBbZW1vamlEYXRhLmFubm90YXRpb24udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXFcrL2csIFwiX1wiKV07XG5cbiAgICBjb25zdCBlbW9qaTogSUVtb2ppID0ge1xuICAgICAgICAuLi5lbW9qaURhdGEsXG4gICAgICAgIC8vIEhvbW9nZW5pemUgc2hvcnRjb2RlcyBieSBlbnN1cmluZyB0aGF0IGV2ZXJ5dGhpbmcgaXMgYW4gYXJyYXlcbiAgICAgICAgc2hvcnRjb2RlczogdHlwZW9mIHNob3J0Y29kZURhdGEgPT09IFwic3RyaW5nXCIgPyBbc2hvcnRjb2RlRGF0YV0gOiBzaG9ydGNvZGVEYXRhLFxuICAgIH07XG5cbiAgICAvLyBXZSBtYW51YWxseSBpbmNsdWRlIHJlZ2lvbmFsIGluZGljYXRvcnMgaW4gdGhlIHN5bWJvbHMgZ3JvdXAsIHNpbmNlXG4gICAgLy8gRW1vamliYXNlIGludGVudGlvbmFsbHkgbGVhdmVzIHRoZW0gdW5jYXRlZ29yaXplZFxuICAgIGNvbnN0IGNhdGVnb3J5SWQgPSBFTU9KSUJBU0VfR1JPVVBfSURfVE9fQ0FURUdPUllbZW1vamkuZ3JvdXBdID8/XG4gICAgICAgIChpc1JlZ2lvbmFsSW5kaWNhdG9yKGVtb2ppLnVuaWNvZGUpID8gXCJzeW1ib2xzXCIgOiBudWxsKTtcblxuICAgIGlmIChEQVRBX0JZX0NBVEVHT1JZLmhhc093blByb3BlcnR5KGNhdGVnb3J5SWQpKSB7XG4gICAgICAgIERBVEFfQllfQ0FURUdPUllbY2F0ZWdvcnlJZF0ucHVzaChlbW9qaSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1hcHBpbmcgZnJvbSB1bmljb2RlIHRvIEVtb2ppIG9iamVjdFxuICAgIC8vIFRoZSAndW5pY29kZScgZmllbGQgdGhhdCB3ZSB1c2UgaW4gZW1vamliYXNlIGhhcyBlaXRoZXJcbiAgICAvLyBWUzE1IG9yIFZTMTYgYXBwZW5kZWQgdG8gYW55IGNoYXJhY3RlcnMgdGhhdCBjYW4gdGFrZVxuICAgIC8vIHZhcmlhdGlvbiBzZWxlY3RvcnMuIFdoaWNoIG9uZSBpdCBhcHBlbmRzIGRlcGVuZHNcbiAgICAvLyBvbiB3aGV0aGVyIGVtb2ppYmFzZSBjb25zaWRlcnMgdGhlaXIgdHlwZSB0byBiZSAndGV4dCcgb3JcbiAgICAvLyAnZW1vamknLiBXZSB0aGVyZWZvcmUgc3RyaXAgYW55IHZhcmlhdGlvbiBjaGFycyBmcm9tIHN0cmluZ3NcbiAgICAvLyBib3RoIHdoZW4gYnVpbGRpbmcgdGhlIG1hcCBhbmQgd2hlbiBsb29raW5nIHVwLlxuICAgIFVOSUNPREVfVE9fRU1PSkkuc2V0KHN0cmlwVmFyaWF0aW9uKGVtb2ppLnVuaWNvZGUpLCBlbW9qaSk7XG5cbiAgICBpZiAoZW1vamkuZW1vdGljb24pIHtcbiAgICAgICAgLy8gQWRkIG1hcHBpbmcgZnJvbSBlbW90aWNvbiB0byBFbW9qaSBvYmplY3RcbiAgICAgICAgRU1PVElDT05fVE9fRU1PSkkuc2V0KGVtb2ppLmVtb3RpY29uLCBlbW9qaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVtb2ppO1xufSk7XG5cbi8qKlxuICogU3RyaXBzIHZhcmlhdGlvbiBzZWxlY3RvcnMgZnJvbSB0aGUgZW5kIG9mIGdpdmVuIHN0cmluZ1xuICogTkIuIFNraW4gdG9uZSBtb2RpZmllcnMgYXJlIG5vdCB2YXJpYXRpb24gc2VsZWN0b3JzOlxuICogdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCB0b3VjaCB0aGVtLiAoU2hvdWxkIGl0PylcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIHN0cmluZyB0byBzdHJpcFxuICogQHJldHVybnMge3N0cmluZ30gc3RyaXBwZWQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHN0cmlwVmFyaWF0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvW1xcdUZFMDAtXFx1RkUwRl0kLywgXCJcIik7XG59XG4iXX0=