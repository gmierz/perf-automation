"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _utils = require("flux/utils");

var _event = require("matrix-js-sdk/src/@types/event");

var _dispatcher = _interopRequireDefault(require("../dispatcher/dispatcher"));

var _actions = require("../dispatcher/actions");

var _GroupStore = _interopRequireDefault(require("./GroupStore"));

var _Analytics = _interopRequireDefault(require("../Analytics"));

var RoomNotifs = _interopRequireWildcard(require("../RoomNotifs"));

var _MatrixClientPeg = require("../MatrixClientPeg");

var _SettingsStore = _interopRequireDefault(require("../settings/SettingsStore"));

var _CreateSpaceFromCommunityDialog = require("../components/views/dialogs/CreateSpaceFromCommunityDialog");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
Copyright 2017 New Vector Ltd

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
const INITIAL_STATE = {
  orderedTags: null,
  orderedTagsAccountData: null,
  hasSynced: false,
  joinedGroupIds: null,
  selectedTags: [],
  // Last selected tag when shift was not being pressed
  anchorTag: null
};
/**
 * A class for storing application state for ordering tags in the GroupFilterPanel.
 */

class GroupFilterOrderStore extends _utils.Store {
  constructor() {
    super(_dispatcher.default); // Initialise state

    this._state = Object.assign({}, INITIAL_STATE);

    _SettingsStore.default.monitorSetting("TagPanel.enableTagPanel", null);
  }

  _setState(newState) {
    this._state = Object.assign(this._state, newState);

    this.__emitChange();
  }

  __onDispatch(payload) {
    // eslint-disable-line @typescript-eslint/naming-convention
    switch (payload.action) {
      // Initialise state after initial sync
      case _actions.Action.ViewRoom:
        {
          const relatedGroupIds = _GroupStore.default.getGroupIdsForRoomId(payload.room_id);

          this._updateBadges(relatedGroupIds);

          break;
        }

      case 'MatrixActions.sync':
        {
          if (payload.state === 'SYNCING' || payload.state === 'PREPARED') {
            this._updateBadges();
          }

          if (!(payload.prevState !== 'PREPARED' && payload.state === 'PREPARED')) {
            break;
          }

          const tagOrderingEvent = payload.matrixClient.getAccountData('im.vector.web.tag_ordering');
          const tagOrderingEventContent = tagOrderingEvent ? tagOrderingEvent.getContent() : {};

          this._setState({
            orderedTagsAccountData: tagOrderingEventContent.tags || null,
            removedTagsAccountData: tagOrderingEventContent.removedTags || null,
            hasSynced: true
          });

          this._updateOrderedTags();

          break;
        }
      // Get ordering from account data

      case 'MatrixActions.accountData':
        {
          if (payload.event_type !== 'im.vector.web.tag_ordering') break; // Ignore remote echos caused by this store so as to avoid setting
          // state back to old state.

          if (payload.event_content._storeId === this.getStoreId()) break;

          this._setState({
            orderedTagsAccountData: payload.event_content ? payload.event_content.tags : null,
            removedTagsAccountData: payload.event_content ? payload.event_content.removedTags : null
          });

          this._updateOrderedTags();

          break;
        }
      // Initialise the state such that if account data is unset, default to joined groups

      case 'GroupActions.fetchJoinedGroups.success':
        {
          this._setState({
            joinedGroupIds: payload.result.groups.sort(),
            // Sort lexically
            hasFetchedJoinedGroups: true
          });

          this._updateOrderedTags();

          break;
        }

      case 'TagOrderActions.moveTag.pending':
        {
          // Optimistic update of a moved tag
          this._setState({
            orderedTags: payload.request.tags,
            removedTagsAccountData: payload.request.removedTags
          });

          break;
        }

      case 'TagOrderActions.removeTag.pending':
        {
          // Optimistic update of a removed tag
          this._setState({
            removedTagsAccountData: payload.request.removedTags
          });

          this._updateOrderedTags();

          break;
        }

      case 'select_tag':
        {
          const allowMultiple = !_SettingsStore.default.getValue("feature_communities_v2_prototypes");
          let newTags = []; // Shift-click semantics

          if (payload.shiftKey && allowMultiple) {
            // Select range of tags
            let start = this._state.orderedTags.indexOf(this._state.anchorTag);

            let end = this._state.orderedTags.indexOf(payload.tag);

            if (start === -1) {
              start = end;
            }

            if (start > end) {
              const temp = start;
              start = end;
              end = temp;
            }

            newTags = payload.ctrlOrCmdKey ? this._state.selectedTags : [];
            newTags = [...new Set(this._state.orderedTags.slice(start, end + 1).concat(newTags))];
          } else {
            if (payload.ctrlOrCmdKey && allowMultiple) {
              // Toggle individual tag
              if (this._state.selectedTags.includes(payload.tag)) {
                newTags = this._state.selectedTags.filter(t => t !== payload.tag);
              } else {
                newTags = [...this._state.selectedTags, payload.tag];
              }
            } else {
              if (this._state.selectedTags.length === 1 && this._state.selectedTags.includes(payload.tag)) {
                // Existing (only) selected tag is being normally clicked again, clear tags
                newTags = [];
              } else {
                // Select individual tag
                newTags = [payload.tag];
              }
            } // Only set the anchor tag if the tag was previously unselected, otherwise
            // the next range starts with an unselected tag.


            if (!this._state.selectedTags.includes(payload.tag)) {
              this._setState({
                anchorTag: payload.tag
              });
            }
          }

          this._setState({
            selectedTags: newTags
          });

          _Analytics.default.trackEvent('FilterStore', 'select_tag');
        }
        break;

      case 'deselect_tags':
        if (payload.tag) {
          // if a tag is passed, only deselect that tag
          this._setState({
            selectedTags: this._state.selectedTags.filter(tag => tag !== payload.tag)
          });
        } else {
          this._setState({
            selectedTags: []
          });
        }

        _Analytics.default.trackEvent('FilterStore', 'deselect_tags');

        break;

      case 'on_client_not_viable':
      case 'on_logged_out':
        {
          // Reset state without pushing an update to the view, which generally assumes that
          // the matrix client isn't `null` and so causing a re-render will cause NPEs.
          this._state = Object.assign({}, INITIAL_STATE);
          break;
        }

      case 'setting_updated':
        if (payload.settingName === 'TagPanel.enableTagPanel' && !payload.newValue) {
          this._setState({
            selectedTags: []
          });

          _Analytics.default.trackEvent('FilterStore', 'disable_tags');
        }

        break;
    }
  }

  _updateBadges(groupIds = this._state.joinedGroupIds) {
    if (groupIds && groupIds.length) {
      const client = _MatrixClientPeg.MatrixClientPeg.get();

      const changedBadges = {};
      groupIds.forEach(groupId => {
        const rooms = _GroupStore.default.getGroupRooms(groupId).map(r => client.getRoom(r.roomId)) // to Room objects
        .filter(r => r !== null && r !== undefined); // filter out rooms we haven't joined from the group


        const badge = rooms && RoomNotifs.aggregateNotificationCount(rooms);
        changedBadges[groupId] = badge && badge.count !== 0 ? badge : undefined;
      });
      const newBadges = Object.assign({}, this._state.badges, changedBadges);

      this._setState({
        badges: newBadges
      });
    }
  }

  _updateOrderedTags() {
    this._setState({
      orderedTags: this._state.hasSynced && this._state.hasFetchedJoinedGroups ? this._mergeGroupsAndTags() : null
    });
  }

  _mergeGroupsAndTags() {
    const groupIds = this._state.joinedGroupIds || [];
    const tags = this._state.orderedTagsAccountData || [];
    const removedTags = new Set(this._state.removedTagsAccountData || []);
    const tagsToKeep = tags.filter(t => (t[0] !== '+' || groupIds.includes(t)) && !removedTags.has(t));

    const cli = _MatrixClientPeg.MatrixClientPeg.get();

    const migratedCommunities = new Set(cli.getRooms().map(r => {
      var _r$currentState$getSt;

      return (_r$currentState$getSt = r.currentState.getStateEvents(_event.EventType.RoomCreate, "")) === null || _r$currentState$getSt === void 0 ? void 0 : _r$currentState$getSt.getContent()[_CreateSpaceFromCommunityDialog.CreateEventField];
    }).filter(Boolean));
    const groupIdsToAdd = groupIds.filter(groupId => !tags.includes(groupId) && !removedTags.has(groupId) && !migratedCommunities.has(groupId));
    return tagsToKeep.concat(groupIdsToAdd);
  }

  getGroupBadge(groupId) {
    const badges = this._state.badges;
    return badges && badges[groupId];
  }

  getOrderedTags() {
    return this._state.orderedTags;
  }

  getRemovedTagsAccountData() {
    return this._state.removedTagsAccountData;
  }

  getStoreId() {
    // Generate a random ID to prevent this store from clobbering its
    // state with redundant remote echos.
    if (!this._id) this._id = Math.random().toString(16).slice(2, 10);
    return this._id;
  }

  getSelectedTags() {
    return this._state.selectedTags;
  }

}

if (global.singletonGroupFilterOrderStore === undefined) {
  global.singletonGroupFilterOrderStore = new GroupFilterOrderStore();
}

var _default = global.singletonGroupFilterOrderStore;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zdG9yZXMvR3JvdXBGaWx0ZXJPcmRlclN0b3JlLmpzIl0sIm5hbWVzIjpbIklOSVRJQUxfU1RBVEUiLCJvcmRlcmVkVGFncyIsIm9yZGVyZWRUYWdzQWNjb3VudERhdGEiLCJoYXNTeW5jZWQiLCJqb2luZWRHcm91cElkcyIsInNlbGVjdGVkVGFncyIsImFuY2hvclRhZyIsIkdyb3VwRmlsdGVyT3JkZXJTdG9yZSIsIlN0b3JlIiwiY29uc3RydWN0b3IiLCJkaXMiLCJfc3RhdGUiLCJPYmplY3QiLCJhc3NpZ24iLCJTZXR0aW5nc1N0b3JlIiwibW9uaXRvclNldHRpbmciLCJfc2V0U3RhdGUiLCJuZXdTdGF0ZSIsIl9fZW1pdENoYW5nZSIsIl9fb25EaXNwYXRjaCIsInBheWxvYWQiLCJhY3Rpb24iLCJBY3Rpb24iLCJWaWV3Um9vbSIsInJlbGF0ZWRHcm91cElkcyIsIkdyb3VwU3RvcmUiLCJnZXRHcm91cElkc0ZvclJvb21JZCIsInJvb21faWQiLCJfdXBkYXRlQmFkZ2VzIiwic3RhdGUiLCJwcmV2U3RhdGUiLCJ0YWdPcmRlcmluZ0V2ZW50IiwibWF0cml4Q2xpZW50IiwiZ2V0QWNjb3VudERhdGEiLCJ0YWdPcmRlcmluZ0V2ZW50Q29udGVudCIsImdldENvbnRlbnQiLCJ0YWdzIiwicmVtb3ZlZFRhZ3NBY2NvdW50RGF0YSIsInJlbW92ZWRUYWdzIiwiX3VwZGF0ZU9yZGVyZWRUYWdzIiwiZXZlbnRfdHlwZSIsImV2ZW50X2NvbnRlbnQiLCJfc3RvcmVJZCIsImdldFN0b3JlSWQiLCJyZXN1bHQiLCJncm91cHMiLCJzb3J0IiwiaGFzRmV0Y2hlZEpvaW5lZEdyb3VwcyIsInJlcXVlc3QiLCJhbGxvd011bHRpcGxlIiwiZ2V0VmFsdWUiLCJuZXdUYWdzIiwic2hpZnRLZXkiLCJzdGFydCIsImluZGV4T2YiLCJlbmQiLCJ0YWciLCJ0ZW1wIiwiY3RybE9yQ21kS2V5IiwiU2V0Iiwic2xpY2UiLCJjb25jYXQiLCJpbmNsdWRlcyIsImZpbHRlciIsInQiLCJsZW5ndGgiLCJBbmFseXRpY3MiLCJ0cmFja0V2ZW50Iiwic2V0dGluZ05hbWUiLCJuZXdWYWx1ZSIsImdyb3VwSWRzIiwiY2xpZW50IiwiTWF0cml4Q2xpZW50UGVnIiwiZ2V0IiwiY2hhbmdlZEJhZGdlcyIsImZvckVhY2giLCJncm91cElkIiwicm9vbXMiLCJnZXRHcm91cFJvb21zIiwibWFwIiwiciIsImdldFJvb20iLCJyb29tSWQiLCJ1bmRlZmluZWQiLCJiYWRnZSIsIlJvb21Ob3RpZnMiLCJhZ2dyZWdhdGVOb3RpZmljYXRpb25Db3VudCIsImNvdW50IiwibmV3QmFkZ2VzIiwiYmFkZ2VzIiwiX21lcmdlR3JvdXBzQW5kVGFncyIsInRhZ3NUb0tlZXAiLCJoYXMiLCJjbGkiLCJtaWdyYXRlZENvbW11bml0aWVzIiwiZ2V0Um9vbXMiLCJjdXJyZW50U3RhdGUiLCJnZXRTdGF0ZUV2ZW50cyIsIkV2ZW50VHlwZSIsIlJvb21DcmVhdGUiLCJDcmVhdGVFdmVudEZpZWxkIiwiQm9vbGVhbiIsImdyb3VwSWRzVG9BZGQiLCJnZXRHcm91cEJhZGdlIiwiZ2V0T3JkZXJlZFRhZ3MiLCJnZXRSZW1vdmVkVGFnc0FjY291bnREYXRhIiwiX2lkIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwiZ2V0U2VsZWN0ZWRUYWdzIiwiZ2xvYmFsIiwic2luZ2xldG9uR3JvdXBGaWx0ZXJPcmRlclN0b3JlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFlQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7O0FBeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVlBLE1BQU1BLGFBQWEsR0FBRztBQUNsQkMsRUFBQUEsV0FBVyxFQUFFLElBREs7QUFFbEJDLEVBQUFBLHNCQUFzQixFQUFFLElBRk47QUFHbEJDLEVBQUFBLFNBQVMsRUFBRSxLQUhPO0FB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NyBOZXcgVmVjdG9yIEx0ZFxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBTdG9yZSB9IGZyb20gJ2ZsdXgvdXRpbHMnO1xuaW1wb3J0IHsgRXZlbnRUeXBlIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL0B0eXBlcy9ldmVudFwiO1xuaW1wb3J0IGRpcyBmcm9tICcuLi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXInO1xuaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAnLi4vZGlzcGF0Y2hlci9hY3Rpb25zJztcbmltcG9ydCBHcm91cFN0b3JlIGZyb20gJy4vR3JvdXBTdG9yZSc7XG5pbXBvcnQgQW5hbHl0aWNzIGZyb20gJy4uL0FuYWx5dGljcyc7XG5pbXBvcnQgKiBhcyBSb29tTm90aWZzIGZyb20gXCIuLi9Sb29tTm90aWZzXCI7XG5pbXBvcnQgeyBNYXRyaXhDbGllbnRQZWcgfSBmcm9tICcuLi9NYXRyaXhDbGllbnRQZWcnO1xuaW1wb3J0IFNldHRpbmdzU3RvcmUgZnJvbSBcIi4uL3NldHRpbmdzL1NldHRpbmdzU3RvcmVcIjtcbmltcG9ydCB7IENyZWF0ZUV2ZW50RmllbGQgfSBmcm9tIFwiLi4vY29tcG9uZW50cy92aWV3cy9kaWFsb2dzL0NyZWF0ZVNwYWNlRnJvbUNvbW11bml0eURpYWxvZ1wiO1xuXG5jb25zdCBJTklUSUFMX1NUQVRFID0ge1xuICAgIG9yZGVyZWRUYWdzOiBudWxsLFxuICAgIG9yZGVyZWRUYWdzQWNjb3VudERhdGE6IG51bGwsXG4gICAgaGFzU3luY2VkOiBmYWxzZSxcbiAgICBqb2luZWRHcm91cElkczogbnVsbCxcblxuICAgIHNlbGVjdGVkVGFnczogW10sXG4gICAgLy8gTGFzdCBzZWxlY3RlZCB0YWcgd2hlbiBzaGlmdCB3YXMgbm90IGJlaW5nIHByZXNzZWRcbiAgICBhbmNob3JUYWc6IG51bGwsXG59O1xuXG4vKipcbiAqIEEgY2xhc3MgZm9yIHN0b3JpbmcgYXBwbGljYXRpb24gc3RhdGUgZm9yIG9yZGVyaW5nIHRhZ3MgaW4gdGhlIEdyb3VwRmlsdGVyUGFuZWwuXG4gKi9cbmNsYXNzIEdyb3VwRmlsdGVyT3JkZXJTdG9yZSBleHRlbmRzIFN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoZGlzKTtcblxuICAgICAgICAvLyBJbml0aWFsaXNlIHN0YXRlXG4gICAgICAgIHRoaXMuX3N0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgSU5JVElBTF9TVEFURSk7XG4gICAgICAgIFNldHRpbmdzU3RvcmUubW9uaXRvclNldHRpbmcoXCJUYWdQYW5lbC5lbmFibGVUYWdQYW5lbFwiLCBudWxsKTtcbiAgICB9XG5cbiAgICBfc2V0U3RhdGUobmV3U3RhdGUpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBPYmplY3QuYXNzaWduKHRoaXMuX3N0YXRlLCBuZXdTdGF0ZSk7XG4gICAgICAgIHRoaXMuX19lbWl0Q2hhbmdlKCk7XG4gICAgfVxuXG4gICAgX19vbkRpc3BhdGNoKHBheWxvYWQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICAgICAgc3dpdGNoIChwYXlsb2FkLmFjdGlvbikge1xuICAgICAgICAgICAgLy8gSW5pdGlhbGlzZSBzdGF0ZSBhZnRlciBpbml0aWFsIHN5bmNcbiAgICAgICAgICAgIGNhc2UgQWN0aW9uLlZpZXdSb29tOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVsYXRlZEdyb3VwSWRzID0gR3JvdXBTdG9yZS5nZXRHcm91cElkc0ZvclJvb21JZChwYXlsb2FkLnJvb21faWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUJhZGdlcyhyZWxhdGVkR3JvdXBJZHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnTWF0cml4QWN0aW9ucy5zeW5jJzoge1xuICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLnN0YXRlID09PSAnU1lOQ0lORycgfHwgcGF5bG9hZC5zdGF0ZSA9PT0gJ1BSRVBBUkVEJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVCYWRnZXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEocGF5bG9hZC5wcmV2U3RhdGUgIT09ICdQUkVQQVJFRCcgJiYgcGF5bG9hZC5zdGF0ZSA9PT0gJ1BSRVBBUkVEJykpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ09yZGVyaW5nRXZlbnQgPSBwYXlsb2FkLm1hdHJpeENsaWVudC5nZXRBY2NvdW50RGF0YSgnaW0udmVjdG9yLndlYi50YWdfb3JkZXJpbmcnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWdPcmRlcmluZ0V2ZW50Q29udGVudCA9IHRhZ09yZGVyaW5nRXZlbnQgPyB0YWdPcmRlcmluZ0V2ZW50LmdldENvbnRlbnQoKSA6IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJlZFRhZ3NBY2NvdW50RGF0YTogdGFnT3JkZXJpbmdFdmVudENvbnRlbnQudGFncyB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkVGFnc0FjY291bnREYXRhOiB0YWdPcmRlcmluZ0V2ZW50Q29udGVudC5yZW1vdmVkVGFncyB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICBoYXNTeW5jZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlT3JkZXJlZFRhZ3MoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCBvcmRlcmluZyBmcm9tIGFjY291bnQgZGF0YVxuICAgICAgICAgICAgY2FzZSAnTWF0cml4QWN0aW9ucy5hY2NvdW50RGF0YSc6IHtcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5ldmVudF90eXBlICE9PSAnaW0udmVjdG9yLndlYi50YWdfb3JkZXJpbmcnKSBicmVhaztcblxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSByZW1vdGUgZWNob3MgY2F1c2VkIGJ5IHRoaXMgc3RvcmUgc28gYXMgdG8gYXZvaWQgc2V0dGluZ1xuICAgICAgICAgICAgICAgIC8vIHN0YXRlIGJhY2sgdG8gb2xkIHN0YXRlLlxuICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLmV2ZW50X2NvbnRlbnQuX3N0b3JlSWQgPT09IHRoaXMuZ2V0U3RvcmVJZCgpKSBicmVhaztcblxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJlZFRhZ3NBY2NvdW50RGF0YTogcGF5bG9hZC5ldmVudF9jb250ZW50ID8gcGF5bG9hZC5ldmVudF9jb250ZW50LnRhZ3MgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkVGFnc0FjY291bnREYXRhOiBwYXlsb2FkLmV2ZW50X2NvbnRlbnQgPyBwYXlsb2FkLmV2ZW50X2NvbnRlbnQucmVtb3ZlZFRhZ3MgOiBudWxsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZU9yZGVyZWRUYWdzKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbml0aWFsaXNlIHRoZSBzdGF0ZSBzdWNoIHRoYXQgaWYgYWNjb3VudCBkYXRhIGlzIHVuc2V0LCBkZWZhdWx0IHRvIGpvaW5lZCBncm91cHNcbiAgICAgICAgICAgIGNhc2UgJ0dyb3VwQWN0aW9ucy5mZXRjaEpvaW5lZEdyb3Vwcy5zdWNjZXNzJzoge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgam9pbmVkR3JvdXBJZHM6IHBheWxvYWQucmVzdWx0Lmdyb3Vwcy5zb3J0KCksIC8vIFNvcnQgbGV4aWNhbGx5XG4gICAgICAgICAgICAgICAgICAgIGhhc0ZldGNoZWRKb2luZWRHcm91cHM6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlT3JkZXJlZFRhZ3MoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1RhZ09yZGVyQWN0aW9ucy5tb3ZlVGFnLnBlbmRpbmcnOiB7XG4gICAgICAgICAgICAgICAgLy8gT3B0aW1pc3RpYyB1cGRhdGUgb2YgYSBtb3ZlZCB0YWdcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG9yZGVyZWRUYWdzOiBwYXlsb2FkLnJlcXVlc3QudGFncyxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZFRhZ3NBY2NvdW50RGF0YTogcGF5bG9hZC5yZXF1ZXN0LnJlbW92ZWRUYWdzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnVGFnT3JkZXJBY3Rpb25zLnJlbW92ZVRhZy5wZW5kaW5nJzoge1xuICAgICAgICAgICAgICAgIC8vIE9wdGltaXN0aWMgdXBkYXRlIG9mIGEgcmVtb3ZlZCB0YWdcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWRUYWdzQWNjb3VudERhdGE6IHBheWxvYWQucmVxdWVzdC5yZW1vdmVkVGFncyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVPcmRlcmVkVGFncygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc2VsZWN0X3RhZyc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxvd011bHRpcGxlID0gIVNldHRpbmdzU3RvcmUuZ2V0VmFsdWUoXCJmZWF0dXJlX2NvbW11bml0aWVzX3YyX3Byb3RvdHlwZXNcIik7XG5cbiAgICAgICAgICAgICAgICBsZXQgbmV3VGFncyA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIFNoaWZ0LWNsaWNrIHNlbWFudGljc1xuICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLnNoaWZ0S2V5ICYmIGFsbG93TXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0IHJhbmdlIG9mIHRhZ3NcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5fc3RhdGUub3JkZXJlZFRhZ3MuaW5kZXhPZih0aGlzLl9zdGF0ZS5hbmNob3JUYWcpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kID0gdGhpcy5fc3RhdGUub3JkZXJlZFRhZ3MuaW5kZXhPZihwYXlsb2FkLnRhZyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZW1wID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHRlbXA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV3VGFncyA9IHBheWxvYWQuY3RybE9yQ21kS2V5ID8gdGhpcy5fc3RhdGUuc2VsZWN0ZWRUYWdzIDogW107XG4gICAgICAgICAgICAgICAgICAgIG5ld1RhZ3MgPSBbLi4ubmV3IFNldChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlLm9yZGVyZWRUYWdzLnNsaWNlKHN0YXJ0LCBlbmQgKyAxKS5jb25jYXQobmV3VGFncyksXG4gICAgICAgICAgICAgICAgICAgICldO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLmN0cmxPckNtZEtleSAmJiBhbGxvd011bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUb2dnbGUgaW5kaXZpZHVhbCB0YWdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZWxlY3RlZFRhZ3MuaW5jbHVkZXMocGF5bG9hZC50YWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VGFncyA9IHRoaXMuX3N0YXRlLnNlbGVjdGVkVGFncy5maWx0ZXIoKHQpID0+IHQgIT09IHBheWxvYWQudGFnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VGFncyA9IFsuLi50aGlzLl9zdGF0ZS5zZWxlY3RlZFRhZ3MsIHBheWxvYWQudGFnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZWxlY3RlZFRhZ3MubGVuZ3RoID09PSAxICYmIHRoaXMuX3N0YXRlLnNlbGVjdGVkVGFncy5pbmNsdWRlcyhwYXlsb2FkLnRhZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeGlzdGluZyAob25seSkgc2VsZWN0ZWQgdGFnIGlzIGJlaW5nIG5vcm1hbGx5IGNsaWNrZWQgYWdhaW4sIGNsZWFyIHRhZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdUYWdzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdCBpbmRpdmlkdWFsIHRhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RhZ3MgPSBbcGF5bG9hZC50YWddO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgc2V0IHRoZSBhbmNob3IgdGFnIGlmIHRoZSB0YWcgd2FzIHByZXZpb3VzbHkgdW5zZWxlY3RlZCwgb3RoZXJ3aXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuZXh0IHJhbmdlIHN0YXJ0cyB3aXRoIGFuIHVuc2VsZWN0ZWQgdGFnLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXRlLnNlbGVjdGVkVGFncy5pbmNsdWRlcyhwYXlsb2FkLnRhZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3JUYWc6IHBheWxvYWQudGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkVGFnczogbmV3VGFncyxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIEFuYWx5dGljcy50cmFja0V2ZW50KCdGaWx0ZXJTdG9yZScsICdzZWxlY3RfdGFnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkZXNlbGVjdF90YWdzJzpcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC50YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgYSB0YWcgaXMgcGFzc2VkLCBvbmx5IGRlc2VsZWN0IHRoYXQgdGFnXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkVGFnczogdGhpcy5fc3RhdGUuc2VsZWN0ZWRUYWdzLmZpbHRlcih0YWcgPT4gdGFnICE9PSBwYXlsb2FkLnRhZyksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkVGFnczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBBbmFseXRpY3MudHJhY2tFdmVudCgnRmlsdGVyU3RvcmUnLCAnZGVzZWxlY3RfdGFncycpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnb25fY2xpZW50X25vdF92aWFibGUnOlxuICAgICAgICAgICAgY2FzZSAnb25fbG9nZ2VkX291dCc6IHtcbiAgICAgICAgICAgICAgICAvLyBSZXNldCBzdGF0ZSB3aXRob3V0IHB1c2hpbmcgYW4gdXBkYXRlIHRvIHRoZSB2aWV3LCB3aGljaCBnZW5lcmFsbHkgYXNzdW1lcyB0aGF0XG4gICAgICAgICAgICAgICAgLy8gdGhlIG1hdHJpeCBjbGllbnQgaXNuJ3QgYG51bGxgIGFuZCBzbyBjYXVzaW5nIGEgcmUtcmVuZGVyIHdpbGwgY2F1c2UgTlBFcy5cbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIElOSVRJQUxfU1RBVEUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc2V0dGluZ191cGRhdGVkJzpcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5zZXR0aW5nTmFtZSA9PT0gJ1RhZ1BhbmVsLmVuYWJsZVRhZ1BhbmVsJyAmJiAhcGF5bG9hZC5uZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFRhZ3M6IFtdLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgQW5hbHl0aWNzLnRyYWNrRXZlbnQoJ0ZpbHRlclN0b3JlJywgJ2Rpc2FibGVfdGFncycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF91cGRhdGVCYWRnZXMoZ3JvdXBJZHMgPSB0aGlzLl9zdGF0ZS5qb2luZWRHcm91cElkcykge1xuICAgICAgICBpZiAoZ3JvdXBJZHMgJiYgZ3JvdXBJZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSBNYXRyaXhDbGllbnRQZWcuZ2V0KCk7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VkQmFkZ2VzID0ge307XG4gICAgICAgICAgICBncm91cElkcy5mb3JFYWNoKGdyb3VwSWQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvb21zID1cbiAgICAgICAgICAgICAgICAgICAgR3JvdXBTdG9yZS5nZXRHcm91cFJvb21zKGdyb3VwSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKHIgPT4gY2xpZW50LmdldFJvb20oci5yb29tSWQpKSAvLyB0byBSb29tIG9iamVjdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIociA9PiByICE9PSBudWxsICYmIHIgIT09IHVuZGVmaW5lZCk7ICAgLy8gZmlsdGVyIG91dCByb29tcyB3ZSBoYXZlbid0IGpvaW5lZCBmcm9tIHRoZSBncm91cFxuICAgICAgICAgICAgICAgIGNvbnN0IGJhZGdlID0gcm9vbXMgJiYgUm9vbU5vdGlmcy5hZ2dyZWdhdGVOb3RpZmljYXRpb25Db3VudChyb29tcyk7XG4gICAgICAgICAgICAgICAgY2hhbmdlZEJhZGdlc1tncm91cElkXSA9IChiYWRnZSAmJiBiYWRnZS5jb3VudCAhPT0gMCkgPyBiYWRnZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbmV3QmFkZ2VzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fc3RhdGUuYmFkZ2VzLCBjaGFuZ2VkQmFkZ2VzKTtcbiAgICAgICAgICAgIHRoaXMuX3NldFN0YXRlKHsgYmFkZ2VzOiBuZXdCYWRnZXMgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfdXBkYXRlT3JkZXJlZFRhZ3MoKSB7XG4gICAgICAgIHRoaXMuX3NldFN0YXRlKHtcbiAgICAgICAgICAgIG9yZGVyZWRUYWdzOlxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlLmhhc1N5bmNlZCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlLmhhc0ZldGNoZWRKb2luZWRHcm91cHMgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXJnZUdyb3Vwc0FuZFRhZ3MoKSA6IG51bGwsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9tZXJnZUdyb3Vwc0FuZFRhZ3MoKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwSWRzID0gdGhpcy5fc3RhdGUuam9pbmVkR3JvdXBJZHMgfHwgW107XG4gICAgICAgIGNvbnN0IHRhZ3MgPSB0aGlzLl9zdGF0ZS5vcmRlcmVkVGFnc0FjY291bnREYXRhIHx8IFtdO1xuICAgICAgICBjb25zdCByZW1vdmVkVGFncyA9IG5ldyBTZXQodGhpcy5fc3RhdGUucmVtb3ZlZFRhZ3NBY2NvdW50RGF0YSB8fCBbXSk7XG5cbiAgICAgICAgY29uc3QgdGFnc1RvS2VlcCA9IHRhZ3MuZmlsdGVyKFxuICAgICAgICAgICAgKHQpID0+ICh0WzBdICE9PSAnKycgfHwgZ3JvdXBJZHMuaW5jbHVkZXModCkpICYmICFyZW1vdmVkVGFncy5oYXModCksXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgY2xpID0gTWF0cml4Q2xpZW50UGVnLmdldCgpO1xuICAgICAgICBjb25zdCBtaWdyYXRlZENvbW11bml0aWVzID0gbmV3IFNldChjbGkuZ2V0Um9vbXMoKS5tYXAociA9PiB7XG4gICAgICAgICAgICByZXR1cm4gci5jdXJyZW50U3RhdGUuZ2V0U3RhdGVFdmVudHMoRXZlbnRUeXBlLlJvb21DcmVhdGUsIFwiXCIpPy5nZXRDb250ZW50KClbQ3JlYXRlRXZlbnRGaWVsZF07XG4gICAgICAgIH0pLmZpbHRlcihCb29sZWFuKSk7XG4gICAgICAgIGNvbnN0IGdyb3VwSWRzVG9BZGQgPSBncm91cElkcy5maWx0ZXIoXG4gICAgICAgICAgICAoZ3JvdXBJZCkgPT4gIXRhZ3MuaW5jbHVkZXMoZ3JvdXBJZCkgJiYgIXJlbW92ZWRUYWdzLmhhcyhncm91cElkKSAmJiAhbWlncmF0ZWRDb21tdW5pdGllcy5oYXMoZ3JvdXBJZCksXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHRhZ3NUb0tlZXAuY29uY2F0KGdyb3VwSWRzVG9BZGQpO1xuICAgIH1cblxuICAgIGdldEdyb3VwQmFkZ2UoZ3JvdXBJZCkge1xuICAgICAgICBjb25zdCBiYWRnZXMgPSB0aGlzLl9zdGF0ZS5iYWRnZXM7XG4gICAgICAgIHJldHVybiBiYWRnZXMgJiYgYmFkZ2VzW2dyb3VwSWRdO1xuICAgIH1cblxuICAgIGdldE9yZGVyZWRUYWdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUub3JkZXJlZFRhZ3M7XG4gICAgfVxuXG4gICAgZ2V0UmVtb3ZlZFRhZ3NBY2NvdW50RGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLnJlbW92ZWRUYWdzQWNjb3VudERhdGE7XG4gICAgfVxuXG4gICAgZ2V0U3RvcmVJZCgpIHtcbiAgICAgICAgLy8gR2VuZXJhdGUgYSByYW5kb20gSUQgdG8gcHJldmVudCB0aGlzIHN0b3JlIGZyb20gY2xvYmJlcmluZyBpdHNcbiAgICAgICAgLy8gc3RhdGUgd2l0aCByZWR1bmRhbnQgcmVtb3RlIGVjaG9zLlxuICAgICAgICBpZiAoIXRoaXMuX2lkKSB0aGlzLl9pZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMTYpLnNsaWNlKDIsIDEwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgIH1cblxuICAgIGdldFNlbGVjdGVkVGFncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLnNlbGVjdGVkVGFncztcbiAgICB9XG59XG5cbmlmIChnbG9iYWwuc2luZ2xldG9uR3JvdXBGaWx0ZXJPcmRlclN0b3JlID09PSB1bmRlZmluZWQpIHtcbiAgICBnbG9iYWwuc2luZ2xldG9uR3JvdXBGaWx0ZXJPcmRlclN0b3JlID0gbmV3IEdyb3VwRmlsdGVyT3JkZXJTdG9yZSgpO1xufVxuZXhwb3J0IGRlZmF1bHQgZ2xvYmFsLnNpbmdsZXRvbkdyb3VwRmlsdGVyT3JkZXJTdG9yZTtcbiJdfQ==