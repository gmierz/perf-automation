"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.RoomListStoreClass = exports.LISTS_UPDATE_EVENT = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _SettingsStore = _interopRequireDefault(require("../../settings/SettingsStore"));

var _models = require("./models");

var _models2 = require("./algorithms/models");

var _dispatcher = _interopRequireDefault(require("../../dispatcher/dispatcher"));

var _readReceipts = require("../../utils/read-receipts");

var _IFilterCondition = require("./filters/IFilterCondition");

var _TagWatcher = require("./TagWatcher");

var _RoomViewStore = _interopRequireDefault(require("../RoomViewStore"));

var _Algorithm = require("./algorithms/Algorithm");

var _membership = require("../../utils/membership");

var _utils = require("matrix-js-sdk/src/utils");

var _RoomListLayoutStore = _interopRequireDefault(require("./RoomListLayoutStore"));

var _MarkedExecution = require("../../utils/MarkedExecution");

var _AsyncStoreWithClient = require("../AsyncStoreWithClient");

var _NameFilterCondition = require("./filters/NameFilterCondition");

var _RoomNotificationStateStore = require("../notifications/RoomNotificationStateStore");

var _VisibilityProvider = require("./filters/VisibilityProvider");

var _SpaceWatcher = require("./SpaceWatcher");

var _SpaceStore = _interopRequireDefault(require("../spaces/SpaceStore"));

var _actions = require("../../dispatcher/actions");

var _logger = require("matrix-js-sdk/src/logger");

/*
Copyright 2018-2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/**
 * The event/channel which is called when the room lists have been changed. Raised
 * with one argument: the instance of the store.
 */
const LISTS_UPDATE_EVENT = "lists_update";
exports.LISTS_UPDATE_EVENT = LISTS_UPDATE_EVENT;

class RoomListStoreClass extends _AsyncStoreWithClient.AsyncStoreWithClient {
  /**
   * Set to true if you're running tests on the store. Should not be touched in
   * any other environment.
   */
  constructor() {
    super(_dispatcher.default);
    (0, _defineProperty2.default)(this, "initialListsGenerated", false);
    (0, _defineProperty2.default)(this, "algorithm", new _Algorithm.Algorithm());
    (0, _defineProperty2.default)(this, "filterConditions", []);
    (0, _defineProperty2.default)(this, "prefilterConditions", []);
    (0, _defineProperty2.default)(this, "tagWatcher", void 0);
    (0, _defineProperty2.default)(this, "spaceWatcher", void 0);
    (0, _defineProperty2.default)(this, "updateFn", new _MarkedExecution.MarkedExecution(() => {
      for (const tagId of Object.keys(this.orderedLists)) {
        _RoomNotificationStateStore.RoomNotificationStateStore.instance.getListState(tagId).setRooms(this.orderedLists[tagId]);
      }

      this.emit(LISTS_UPDATE_EVENT);
    }));
    (0, _defineProperty2.default)(this, "watchedSettings", ['feature_custom_tags']);
    (0, _defineProperty2.default)(this, "onAlgorithmListUpdated", () => {
      this.updateFn.mark();
    });
    (0, _defineProperty2.default)(this, "onAlgorithmFilterUpdated", () => {
      // The filter can happen off-cycle, so trigger an update. The filter will have
      // already caused a mark.
      this.updateFn.trigger();
    });
    (0, _defineProperty2.default)(this, "onPrefilterUpdated", async () => {
      await this.recalculatePrefiltering();
      this.updateFn.trigger();
    });
    this.setMaxListeners(20); // CustomRoomTagStore + RoomList + LeftPanel + 8xRoomSubList + spares
  }

  setupWatchers() {
    if (_SpaceStore.default.spacesEnabled) {
      this.spaceWatcher = new _SpaceWatcher.SpaceWatcher(this);
    } else {
      this.tagWatcher = new _TagWatcher.TagWatcher(this);
    }
  }

  get unfilteredLists() {
    if (!this.algorithm) return {}; // No tags yet.

    return this.algorithm.getUnfilteredRooms();
  }

  get orderedLists() {
    if (!this.algorithm) return {}; // No tags yet.

    return this.algorithm.getOrderedRooms();
  } // Intended for test usage


  async resetStore() {
    await this.reset();
    this.filterConditions = [];
    this.prefilterConditions = [];
    this.initialListsGenerated = false;
    this.setupWatchers();
    this.algorithm.off(_Algorithm.LIST_UPDATED_EVENT, this.onAlgorithmListUpdated);
    this.algorithm.off(_IFilterCondition.FILTER_CHANGED, this.onAlgorithmListUpdated);
    this.algorithm = new _Algorithm.Algorithm();
    this.algorithm.on(_Algorithm.LIST_UPDATED_EVENT, this.onAlgorithmListUpdated);
    this.algorithm.on(_IFilterCondition.FILTER_CHANGED, this.onAlgorithmListUpdated); // Reset state without causing updates as the client will have been destroyed
    // and downstream code will throw NPE errors.

    await this.reset(null, true);
  } // Public for test usage. Do not call this.


  async makeReady(forcedClient) {
    if (forcedClient) {
      this.readyStore.useUnitTestClient(forcedClient);
    }

    for (const settingName of this.watchedSettings) _SettingsStore.default.monitorSetting(settingName, null);

    _RoomViewStore.default.addListener(() => this.handleRVSUpdate({}));

    this.algorithm.on(_Algorithm.LIST_UPDATED_EVENT, this.onAlgorithmListUpdated);
    this.algorithm.on(_IFilterCondition.FILTER_CHANGED, this.onAlgorithmFilterUpdated);
    this.setupWatchers(); // Update any settings here, as some may have happened before we were logically ready.
    // Update any settings here, as some may have happened before we were logically ready.

    _logger.logger.log("Regenerating room lists: Startup");

    await this.readAndCacheSettingsFromStore();
    this.regenerateAllLists({
      trigger: false
    });
    this.handleRVSUpdate({
      trigger: false
    }); // fake an RVS update to adjust sticky room, if needed

    this.updateFn.mark(); // we almost certainly want to trigger an update.

    this.updateFn.trigger();
  }

  async readAndCacheSettingsFromStore() {
    const tagsEnabled = _SettingsStore.default.getValue("feature_custom_tags");

    await this.updateState({
      tagsEnabled
    });
    this.updateAlgorithmInstances();
  }
  /**
   * Handles suspected RoomViewStore changes.
   * @param trigger Set to false to prevent a list update from being sent. Should only
   * be used if the calling code will manually trigger the update.
   */


  handleRVSUpdate({
    trigger = true
  }) {
    if (!this.matrixClient) return; // We assume there won't be RVS updates without a client

    const activeRoomId = _RoomViewStore.default.getRoomId();

    if (!activeRoomId && this.algorithm.stickyRoom) {
      this.algorithm.setStickyRoom(null);
    } else if (activeRoomId) {
      const activeRoom = this.matrixClient.getRoom(activeRoomId);

      if (!activeRoom) {
        _logger.logger.warn(`${activeRoomId} is current in RVS but missing from client - clearing sticky room`);

        this.algorithm.setStickyRoom(null);
      } else if (activeRoom !== this.algorithm.stickyRoom) {
        this.algorithm.setStickyRoom(activeRoom);
      }
    }

    if (trigger) this.updateFn.trigger();
  }

  async onReady() {
    await this.makeReady();
  }

  async onNotReady() {
    await this.resetStore();
  }

  async onAction(payload) {
    // If we're not remotely ready, don't even bother scheduling the dispatch handling.
    // This is repeated in the handler just in case things change between a decision here and
    // when the timer fires.
    const logicallyReady = this.matrixClient && this.initialListsGenerated;
    if (!logicallyReady) return; // When we're running tests we can't reliably use setImmediate out of timing concerns.
    // As such, we use a more synchronous model.

    if (RoomListStoreClass.TEST_MODE) {
      await this.onDispatchAsync(payload);
      return;
    } // We do this to intentionally break out of the current event loop task, allowing
    // us to instead wait for a more convenient time to run our updates.


    setImmediate(() => this.onDispatchAsync(payload));
  }

  async onDispatchAsync(payload) {
    // Everything here requires a MatrixClient or some sort of logical readiness.
    const logicallyReady = this.matrixClient && this.initialListsGenerated;
    if (!logicallyReady) return;

    if (payload.action === _actions.Action.SettingUpdated) {
      const settingUpdatedPayload = payload;

      if (this.watchedSettings.includes(settingUpdatedPayload.settingName)) {
        _logger.logger.log("Regenerating room lists: Settings changed");

        await this.readAndCacheSettingsFromStore();
        this.regenerateAllLists({
          trigger: false
        }); // regenerate the lists now

        this.updateFn.trigger();
      }
    }

    if (!this.algorithm) {
      // This shouldn't happen because `initialListsGenerated` implies we have an algorithm.
      throw new Error("Room list store has no algorithm to process dispatcher update with");
    }

    if (payload.action === 'MatrixActions.Room.receipt') {
      // First see if the receipt event is for our own user. If it was, trigger
      // a room update (we probably read the room on a different device).
      if ((0, _readReceipts.readReceiptChangeIsFor)(payload.event, this.matrixClient)) {
        const room = payload.room;

        if (!room) {
          _logger.logger.warn(`Own read receipt was in unknown room ${room.roomId}`);

          return;
        }

        await this.handleRoomUpdate(room, _models.RoomUpdateCause.ReadReceipt);
        this.updateFn.trigger();
        return;
      }
    } else if (payload.action === 'MatrixActions.Room.tags') {
      const roomPayload = payload; // TODO: Type out the dispatcher types

      await this.handleRoomUpdate(roomPayload.room, _models.RoomUpdateCause.PossibleTagChange);
      this.updateFn.trigger();
    } else if (payload.action === 'MatrixActions.Room.timeline') {
      const eventPayload = payload; // TODO: Type out the dispatcher types
      // Ignore non-live events (backfill)

      if (!eventPayload.isLiveEvent || !payload.isLiveUnfilteredRoomTimelineEvent) return;
      const roomId = eventPayload.event.getRoomId();
      const room = this.matrixClient.getRoom(roomId);

      const tryUpdate = async updatedRoom => {
        if (eventPayload.event.getType() === 'm.room.tombstone' && eventPayload.event.getStateKey() === '') {
          const newRoom = this.matrixClient.getRoom(eventPayload.event.getContent()['replacement_room']);

          if (newRoom) {
            // If we have the new room, then the new room check will have seen the predecessor
            // and did the required updates, so do nothing here.
            return;
          }
        }

        await this.handleRoomUpdate(updatedRoom, _models.RoomUpdateCause.Timeline);
        this.updateFn.trigger();
      };

      if (!room) {
        _logger.logger.warn(`Live timeline event ${eventPayload.event.getId()} received without associated room`);

        _logger.logger.warn(`Queuing failed room update for retry as a result.`);

        setTimeout(async () => {
          const updatedRoom = this.matrixClient.getRoom(roomId);
          await tryUpdate(updatedRoom);
        }, 100); // 100ms should be enough for the room to show up

        return;
      } else {
        await tryUpdate(room);
      }
    } else if (payload.action === 'MatrixActions.Event.decrypted') {
      const eventPayload = payload; // TODO: Type out the dispatcher types

      const roomId = eventPayload.event.getRoomId();

      if (!roomId) {
        return;
      }

      const room = this.matrixClient.getRoom(roomId);

      if (!room) {
        _logger.logger.warn(`Event ${eventPayload.event.getId()} was decrypted in an unknown room ${roomId}`);

        return;
      }

      await this.handleRoomUpdate(room, _models.RoomUpdateCause.Timeline);
      this.updateFn.trigger();
    } else if (payload.action === 'MatrixActions.accountData' && payload.event_type === 'm.direct') {
      const eventPayload = payload; // TODO: Type out the dispatcher types

      const dmMap = eventPayload.event.getContent();

      for (const userId of Object.keys(dmMap)) {
        const roomIds = dmMap[userId];

        for (const roomId of roomIds) {
          const room = this.matrixClient.getRoom(roomId);

          if (!room) {
            _logger.logger.warn(`${roomId} was found in DMs but the room is not in the store`);

            continue;
          } // We expect this RoomUpdateCause to no-op if there's no change, and we don't expect
          // the user to have hundreds of rooms to update in one event. As such, we just hammer
          // away at updates until the problem is solved. If we were expecting more than a couple
          // of rooms to be updated at once, we would consider batching the rooms up.


          await this.handleRoomUpdate(room, _models.RoomUpdateCause.PossibleTagChange);
        }
      }

      this.updateFn.trigger();
    } else if (payload.action === 'MatrixActions.Room.myMembership') {
      const membershipPayload = payload; // TODO: Type out the dispatcher types

      const oldMembership = (0, _membership.getEffectiveMembership)(membershipPayload.oldMembership);
      const newMembership = (0, _membership.getEffectiveMembership)(membershipPayload.membership);

      if (oldMembership !== _membership.EffectiveMembership.Join && newMembership === _membership.EffectiveMembership.Join) {
        // If we're joining an upgraded room, we'll want to make sure we don't proliferate
        // the dead room in the list.
        const createEvent = membershipPayload.room.currentState.getStateEvents("m.room.create", "");

        if (createEvent && createEvent.getContent()['predecessor']) {
          const prevRoom = this.matrixClient.getRoom(createEvent.getContent()['predecessor']['room_id']);

          if (prevRoom) {
            const isSticky = this.algorithm.stickyRoom === prevRoom;

            if (isSticky) {
              this.algorithm.setStickyRoom(null);
            } // Note: we hit the algorithm instead of our handleRoomUpdate() function to
            // avoid redundant updates.


            this.algorithm.handleRoomUpdate(prevRoom, _models.RoomUpdateCause.RoomRemoved);
          }
        }

        await this.handleRoomUpdate(membershipPayload.room, _models.RoomUpdateCause.NewRoom);
        this.updateFn.trigger();
        return;
      }

      if (oldMembership !== _membership.EffectiveMembership.Invite && newMembership === _membership.EffectiveMembership.Invite) {
        await this.handleRoomUpdate(membershipPayload.room, _models.RoomUpdateCause.NewRoom);
        this.updateFn.trigger();
        return;
      } // If it's not a join, it's transitioning into a different list (possibly historical)


      if (oldMembership !== newMembership) {
        await this.handleRoomUpdate(membershipPayload.room, _models.RoomUpdateCause.PossibleTagChange);
        this.updateFn.trigger();
        return;
      }
    }
  }

  async handleRoomUpdate(room, cause) {
    if (cause === _models.RoomUpdateCause.NewRoom && room.getMyMembership() === "invite") {
      // Let the visibility provider know that there is a new invited room. It would be nice
      // if this could just be an event that things listen for but the point of this is that
      // we delay doing anything about this room until the VoipUserMapper had had a chance
      // to do the things it needs to do to decide if we should show this room or not, so
      // an even wouldn't et us do that.
      await _VisibilityProvider.VisibilityProvider.instance.onNewInvitedRoom(room);
    }

    if (!_VisibilityProvider.VisibilityProvider.instance.isRoomVisible(room)) {
      return; // don't do anything on rooms that aren't visible
    }

    if ((cause === _models.RoomUpdateCause.NewRoom || cause === _models.RoomUpdateCause.PossibleTagChange) && !this.prefilterConditions.every(c => c.isVisible(room))) {
      return; // don't do anything on new/moved rooms which ought not to be shown
    }

    const shouldUpdate = this.algorithm.handleRoomUpdate(room, cause);

    if (shouldUpdate) {
      this.updateFn.mark();
    }
  }

  async recalculatePrefiltering() {
    if (!this.algorithm) return;
    if (!this.algorithm.hasTagSortingMap) return; // we're still loading
    // Inhibit updates because we're about to lie heavily to the algorithm

    this.algorithm.updatesInhibited = true; // Figure out which rooms are about to be valid, and the state of affairs

    const rooms = this.getPlausibleRooms();
    const currentSticky = this.algorithm.stickyRoom;
    const stickyIsStillPresent = currentSticky && rooms.includes(currentSticky); // Reset the sticky room before resetting the known rooms so the algorithm
    // doesn't freak out.

    this.algorithm.setStickyRoom(null);
    this.algorithm.setKnownRooms(rooms); // Set the sticky room back, if needed, now that we have updated the store.
    // This will use relative stickyness to the new room set.

    if (stickyIsStillPresent) {
      this.algorithm.setStickyRoom(currentSticky);
    } // Finally, mark an update and resume updates from the algorithm


    this.updateFn.mark();
    this.algorithm.updatesInhibited = false;
  }

  async setTagSorting(tagId, sort) {
    this.setAndPersistTagSorting(tagId, sort);
    this.updateFn.trigger();
  }

  setAndPersistTagSorting(tagId, sort) {
    this.algorithm.setTagSorting(tagId, sort); // TODO: Per-account? https://github.com/vector-im/element-web/issues/14114

    localStorage.setItem(`mx_tagSort_${tagId}`, sort);
  }

  getTagSorting(tagId) {
    return this.algorithm.getTagSorting(tagId);
  } // noinspection JSMethodCanBeStatic


  getStoredTagSorting(tagId) {
    // TODO: Per-account? https://github.com/vector-im/element-web/issues/14114
    return localStorage.getItem(`mx_tagSort_${tagId}`);
  } // logic must match calculateListOrder


  calculateTagSorting(tagId) {
    const isDefaultRecent = tagId === _models.DefaultTagID.Invite || tagId === _models.DefaultTagID.DM;
    const defaultSort = isDefaultRecent ? _models2.SortAlgorithm.Recent : _models2.SortAlgorithm.Alphabetic;

    const settingAlphabetical = _SettingsStore.default.getValue("RoomList.orderAlphabetically", null, true);

    const definedSort = this.getTagSorting(tagId);
    const storedSort = this.getStoredTagSorting(tagId); // We use the following order to determine which of the 4 flags to use:
    // Stored > Settings > Defined > Default

    let tagSort = defaultSort;

    if (storedSort) {
      tagSort = storedSort;
    } else if (!(0, _utils.isNullOrUndefined)(settingAlphabetical)) {
      tagSort = settingAlphabetical ? _models2.SortAlgorithm.Alphabetic : _models2.SortAlgorithm.Recent;
    } else if (definedSort) {
      tagSort = definedSort;
    } // else default (already set)


    return tagSort;
  }

  setListOrder(tagId, order) {
    this.setAndPersistListOrder(tagId, order);
    this.updateFn.trigger();
  }

  setAndPersistListOrder(tagId, order) {
    this.algorithm.setListOrdering(tagId, order); // TODO: Per-account? https://github.com/vector-im/element-web/issues/14114

    localStorage.setItem(`mx_listOrder_${tagId}`, order);
  }

  getListOrder(tagId) {
    return this.algorithm.getListOrdering(tagId);
  } // noinspection JSMethodCanBeStatic


  getStoredListOrder(tagId) {
    // TODO: Per-account? https://github.com/vector-im/element-web/issues/14114
    return localStorage.getItem(`mx_listOrder_${tagId}`);
  } // logic must match calculateTagSorting


  calculateListOrder(tagId) {
    const defaultOrder = _models2.ListAlgorithm.Natural;

    const settingImportance = _SettingsStore.default.getValue("RoomList.orderByImportance", null, true);

    const definedOrder = this.getListOrder(tagId);
    const storedOrder = this.getStoredListOrder(tagId); // We use the following order to determine which of the 4 flags to use:
    // Stored > Settings > Defined > Default

    let listOrder = defaultOrder;

    if (storedOrder) {
      listOrder = storedOrder;
    } else if (!(0, _utils.isNullOrUndefined)(settingImportance)) {
      listOrder = settingImportance ? _models2.ListAlgorithm.Importance : _models2.ListAlgorithm.Natural;
    } else if (definedOrder) {
      listOrder = definedOrder;
    } // else default (already set)


    return listOrder;
  }

  updateAlgorithmInstances() {
    // We'll require an update, so mark for one. Marking now also prevents the calls
    // to setTagSorting and setListOrder from causing triggers.
    this.updateFn.mark();

    for (const tag of Object.keys(this.orderedLists)) {
      const definedSort = this.getTagSorting(tag);
      const definedOrder = this.getListOrder(tag);
      const tagSort = this.calculateTagSorting(tag);
      const listOrder = this.calculateListOrder(tag);

      if (tagSort !== definedSort) {
        this.setAndPersistTagSorting(tag, tagSort);
      }

      if (listOrder !== definedOrder) {
        this.setAndPersistListOrder(tag, listOrder);
      }
    }
  }

  getPlausibleRooms() {
    if (!this.matrixClient) return [];
    let rooms = this.matrixClient.getVisibleRooms().filter(r => _VisibilityProvider.VisibilityProvider.instance.isRoomVisible(r)); // if spaces are enabled only consider the prefilter conditions when there are no runtime conditions
    // for the search all spaces feature

    if (this.prefilterConditions.length > 0 && (!_SpaceStore.default.spacesEnabled || !this.filterConditions.length)) {
      rooms = rooms.filter(r => {
        for (const filter of this.prefilterConditions) {
          if (!filter.isVisible(r)) {
            return false;
          }
        }

        return true;
      });
    }

    return rooms;
  }
  /**
   * Regenerates the room whole room list, discarding any previous results.
   *
   * Note: This is only exposed externally for the tests. Do not call this from within
   * the app.
   * @param trigger Set to false to prevent a list update from being sent. Should only
   * be used if the calling code will manually trigger the update.
   */


  regenerateAllLists({
    trigger = true
  }) {
    _logger.logger.warn("Regenerating all room lists");

    const rooms = this.getPlausibleRooms();
    const customTags = new Set();

    if (this.state.tagsEnabled) {
      for (const room of rooms) {
        if (!room.tags) continue;
        const tags = Object.keys(room.tags).filter(t => (0, _models.isCustomTag)(t));
        tags.forEach(t => customTags.add(t));
      }
    }

    const sorts = {};
    const orders = {};
    const allTags = [..._models.OrderedDefaultTagIDs, ...Array.from(customTags)];

    for (const tagId of allTags) {
      sorts[tagId] = this.calculateTagSorting(tagId);
      orders[tagId] = this.calculateListOrder(tagId);

      _RoomListLayoutStore.default.instance.ensureLayoutExists(tagId);
    }

    this.algorithm.populateTags(sorts, orders);
    this.algorithm.setKnownRooms(rooms);
    this.initialListsGenerated = true;
    if (trigger) this.updateFn.trigger();
  }
  /**
   * Adds a filter condition to the room list store. Filters may be applied async,
   * and thus might not cause an update to the store immediately.
   * @param {IFilterCondition} filter The filter condition to add.
   */


  async addFilter(filter) {
    let promise = Promise.resolve();

    if (filter.kind === _IFilterCondition.FilterKind.Prefilter) {
      filter.on(_IFilterCondition.FILTER_CHANGED, this.onPrefilterUpdated);
      this.prefilterConditions.push(filter);
      promise = this.recalculatePrefiltering();
    } else {
      this.filterConditions.push(filter); // Runtime filters with spaces disable prefiltering for the search all spaces feature

      if (_SpaceStore.default.spacesEnabled) {
        // this has to be awaited so that `setKnownRooms` is called in time for the `addFilterCondition` below
        // this way the runtime filters are only evaluated on one dataset and not both.
        await this.recalculatePrefiltering();
      }

      if (this.algorithm) {
        this.algorithm.addFilterCondition(filter);
      }
    }

    promise.then(() => this.updateFn.trigger());
  }
  /**
   * Removes a filter condition from the room list store. If the filter was
   * not previously added to the room list store, this will no-op. The effects
   * of removing a filter may be applied async and therefore might not cause
   * an update right away.
   * @param {IFilterCondition} filter The filter condition to remove.
   */


  removeFilter(filter) {
    let promise = Promise.resolve();
    let idx = this.filterConditions.indexOf(filter);
    let removed = false;

    if (idx >= 0) {
      this.filterConditions.splice(idx, 1);

      if (this.algorithm) {
        this.algorithm.removeFilterCondition(filter);
      } // Runtime filters with spaces disable prefiltering for the search all spaces feature


      if (_SpaceStore.default.spacesEnabled) {
        promise = this.recalculatePrefiltering();
      }

      removed = true;
    }

    idx = this.prefilterConditions.indexOf(filter);

    if (idx >= 0) {
      filter.off(_IFilterCondition.FILTER_CHANGED, this.onPrefilterUpdated);
      this.prefilterConditions.splice(idx, 1);
      promise = this.recalculatePrefiltering();
      removed = true;
    }

    if (removed) {
      promise.then(() => this.updateFn.trigger());
    }
  }
  /**
   * Gets the first (and ideally only) name filter condition. If one isn't present,
   * this returns null.
   * @returns The first name filter condition, or null if none.
   */


  getFirstNameFilterCondition() {
    for (const filter of this.filterConditions) {
      if (filter instanceof _NameFilterCondition.NameFilterCondition) {
        return filter;
      }
    }

    return null;
  }
  /**
   * Gets the tags for a room identified by the store. The returned set
   * should never be empty, and will contain DefaultTagID.Untagged if
   * the store is not aware of any tags.
   * @param room The room to get the tags for.
   * @returns The tags for the room.
   */


  getTagsForRoom(room) {
    const algorithmTags = this.algorithm.getTagsForRoom(room);
    if (!algorithmTags) return [_models.DefaultTagID.Untagged];
    return algorithmTags;
  }
  /**
   * Manually update a room with a given cause. This should only be used if the
   * room list store would otherwise be incapable of doing the update itself. Note
   * that this may race with the room list's regular operation.
   * @param {Room} room The room to update.
   * @param {RoomUpdateCause} cause The cause to update for.
   */


  async manualRoomUpdate(room, cause) {
    await this.handleRoomUpdate(room, cause);
    this.updateFn.trigger();
  }

}

exports.RoomListStoreClass = RoomListStoreClass;
(0, _defineProperty2.default)(RoomListStoreClass, "TEST_MODE", false);

class RoomListStore {
  static get instance() {
    if (!RoomListStore.internalInstance) {
      RoomListStore.internalInstance = new RoomListStoreClass();
    }

    return RoomListStore.internalInstance;
  }

}

exports.default = RoomListStore;
(0, _defineProperty2.default)(RoomListStore, "internalInstance", void 0);
window.mxRoomListStore = RoomListStore.instance;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zdG9yZXMvcm9vbS1saXN0L1Jvb21MaXN0U3RvcmUudHMiXSwibmFtZXMiOlsiTElTVFNfVVBEQVRFX0VWRU5UIiwiUm9vbUxpc3RTdG9yZUNsYXNzIiwiQXN5bmNTdG9yZVdpdGhDbGllbnQiLCJjb25zdHJ1Y3RvciIsImRlZmF1bHREaXNwYXRjaGVyIiwiQWxnb3JpdGhtIiwiTWFya2VkRXhlY3V0aW9uIiwidGFnSWQiLCJPYmplY3QiLCJrZXlzIiwib3JkZXJlZExpc3RzIiwiUm9vbU5vdGlmaWNhdGlvblN0YXRlU3RvcmUiLCJpbnN0YW5jZSIsImdldExpc3RTdGF0ZSIsInNldFJvb21zIiwiZW1pdCIsInVwZGF0ZUZuIiwibWFyayIsInRyaWdnZXIiLCJyZWNhbGN1bGF0ZVByZWZpbHRlcmluZyIsInNldE1heExpc3RlbmVycyIsInNldHVwV2F0Y2hlcnMiLCJTcGFjZVN0b3JlIiwic3BhY2VzRW5hYmxlZCIsInNwYWNlV2F0Y2hlciIsIlNwYWNlV2F0Y2hlciIsInRhZ1dhdGNoZXIiLCJUYWdXYXRjaGVyIiwidW5maWx0ZXJlZExpc3RzIiwiYWxnb3JpdGhtIiwiZ2V0VW5maWx0ZXJlZFJvb21zIiwiZ2V0T3JkZXJlZFJvb21zIiwicmVzZXRTdG9yZSIsInJlc2V0IiwiZmlsdGVyQ29uZGl0aW9ucyIsInByZWZpbHRlckNvbmRpdGlvbnMiLCJpbml0aWFsTGlzdHNHZW5lcmF0ZWQiLCJvZmYiLCJMSVNUX1VQREFURURfRVZFTlQiLCJvbkFsZ29yaXRobUxpc3RVcGRhdGVkIiwiRklMVEVSX0NIQU5HRUQiLCJvbiIsIm1ha2VSZWFkeSIsImZvcmNlZENsaWVudCIsInJlYWR5U3RvcmUiLCJ1c2VVbml0VGVzdENsaWVudCIsInNldHRpbmdOYW1lIiwid2F0Y2hlZFNldHRpbmdzIiwiU2V0dGluZ3NTdG9yZSIsIm1vbml0b3JTZXR0aW5nIiwiUm9vbVZpZXdTdG9yZSIsImFkZExpc3RlbmVyIiwiaGFuZGxlUlZTVXBkYXRlIiwib25BbGdvcml0aG1GaWx0ZXJVcGRhdGVkIiwibG9nZ2VyIiwibG9nIiwicmVhZEFuZENhY2hlU2V0dGluZ3NGcm9tU3RvcmUiLCJyZWdlbmVyYXRlQWxsTGlzdHMiLCJ0YWdzRW5hYmxlZCIsImdldFZhbHVlIiwidXBkYXRlU3RhdGUiLCJ1cGRhdGVBbGdvcml0aG1JbnN0YW5jZXMiLCJtYXRyaXhDbGllbnQiLCJhY3RpdmVSb29tSWQiLCJnZXRSb29tSWQiLCJzdGlja3lSb29tIiwic2V0U3RpY2t5Um9vbSIsImFjdGl2ZVJvb20iLCJnZXRSb29tIiwid2FybiIsIm9uUmVhZHkiLCJvbk5vdFJlYWR5Iiwib25BY3Rpb24iLCJwYXlsb2FkIiwibG9naWNhbGx5UmVhZHkiLCJURVNUX01PREUiLCJvbkRpc3BhdGNoQXN5bmMiLCJzZXRJbW1lZGlhdGUiLCJhY3Rpb24iLCJBY3Rpb24iLCJTZXR0aW5nVXBkYXRlZCIsInNldHRpbmdVcGRhdGVkUGF5bG9hZCIsImluY2x1ZGVzIiwiRXJyb3IiLCJldmVudCIsInJvb20iLCJyb29tSWQiLCJoYW5kbGVSb29tVXBkYXRlIiwiUm9vbVVwZGF0ZUNhdXNlIiwiUmVhZFJlY2VpcHQiLCJyb29tUGF5bG9hZCIsIlBvc3NpYmxlVGFnQ2hhbmdlIiwiZXZlbnRQYXlsb2FkIiwiaXNMaXZlRXZlbnQiLCJpc0xpdmVVbmZpbHRlcmVkUm9vbVRpbWVsaW5lRXZlbnQiLCJ0cnlVcGRhdGUiLCJ1cGRhdGVkUm9vbSIsImdldFR5cGUiLCJnZXRTdGF0ZUtleSIsIm5ld1Jvb20iLCJnZXRDb250ZW50IiwiVGltZWxpbmUiLCJnZXRJZCIsInNldFRpbWVvdXQiLCJldmVudF90eXBlIiwiZG1NYXAiLCJ1c2VySWQiLCJyb29tSWRzIiwibWVtYmVyc2hpcFBheWxvYWQiLCJvbGRNZW1iZXJzaGlwIiwibmV3TWVtYmVyc2hpcCIsIm1lbWJlcnNoaXAiLCJFZmZlY3RpdmVNZW1iZXJzaGlwIiwiSm9pbiIsImNyZWF0ZUV2ZW50IiwiY3VycmVudFN0YXRlIiwiZ2V0U3RhdGVFdmVudHMiLCJwcmV2Um9vbSIsImlzU3RpY2t5IiwiUm9vbVJlbW92ZWQiLCJOZXdSb29tIiwiSW52aXRlIiwiY2F1c2UiLCJnZXRNeU1lbWJlcnNoaXAiLCJWaXNpYmlsaXR5UHJvdmlkZXIiLCJvbk5ld0ludml0ZWRSb29tIiwiaXNSb29tVmlzaWJsZSIsImV2ZXJ5IiwiYyIsImlzVmlzaWJsZSIsInNob3VsZFVwZGF0ZSIsImhhc1RhZ1NvcnRpbmdNYXAiLCJ1cGRhdGVzSW5oaWJpdGVkIiwicm9vbXMiLCJnZXRQbGF1c2libGVSb29tcyIsImN1cnJlbnRTdGlja3kiLCJzdGlja3lJc1N0aWxsUHJlc2VudCIsInNldEtub3duUm9vbXMiLCJzZXRUYWdTb3J0aW5nIiwic29ydCIsInNldEFuZFBlcnNpc3RUYWdTb3J0aW5nIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsImdldFRhZ1NvcnRpbmciLCJnZXRTdG9yZWRUYWdTb3J0aW5nIiwiZ2V0SXRlbSIsImNhbGN1bGF0ZVRhZ1NvcnRpbmciLCJpc0RlZmF1bHRSZWNlbnQiLCJEZWZhdWx0VGFnSUQiLCJETSIsImRlZmF1bHRTb3J0IiwiU29ydEFsZ29yaXRobSIsIlJlY2VudCIsIkFscGhhYmV0aWMiLCJzZXR0aW5nQWxwaGFiZXRpY2FsIiwiZGVmaW5lZFNvcnQiLCJzdG9yZWRTb3J0IiwidGFnU29ydCIsInNldExpc3RPcmRlciIsIm9yZGVyIiwic2V0QW5kUGVyc2lzdExpc3RPcmRlciIsInNldExpc3RPcmRlcmluZyIsImdldExpc3RPcmRlciIsImdldExpc3RPcmRlcmluZyIsImdldFN0b3JlZExpc3RPcmRlciIsImNhbGN1bGF0ZUxpc3RPcmRlciIsImRlZmF1bHRPcmRlciIsIkxpc3RBbGdvcml0aG0iLCJOYXR1cmFsIiwic2V0dGluZ0ltcG9ydGFuY2UiLCJkZWZpbmVkT3JkZXIiLCJzdG9yZWRPcmRlciIsImxpc3RPcmRlciIsIkltcG9ydGFuY2UiLCJ0YWciLCJnZXRWaXNpYmxlUm9vbXMiLCJmaWx0ZXIiLCJyIiwibGVuZ3RoIiwiY3VzdG9tVGFncyIsIlNldCIsInN0YXRlIiwidGFncyIsInQiLCJmb3JFYWNoIiwiYWRkIiwic29ydHMiLCJvcmRlcnMiLCJhbGxUYWdzIiwiT3JkZXJlZERlZmF1bHRUYWdJRHMiLCJBcnJheSIsImZyb20iLCJSb29tTGlzdExheW91dFN0b3JlIiwiZW5zdXJlTGF5b3V0RXhpc3RzIiwicG9wdWxhdGVUYWdzIiwiYWRkRmlsdGVyIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwia2luZCIsIkZpbHRlcktpbmQiLCJQcmVmaWx0ZXIiLCJvblByZWZpbHRlclVwZGF0ZWQiLCJwdXNoIiwiYWRkRmlsdGVyQ29uZGl0aW9uIiwidGhlbiIsInJlbW92ZUZpbHRlciIsImlkeCIsImluZGV4T2YiLCJyZW1vdmVkIiwic3BsaWNlIiwicmVtb3ZlRmlsdGVyQ29uZGl0aW9uIiwiZ2V0Rmlyc3ROYW1lRmlsdGVyQ29uZGl0aW9uIiwiTmFtZUZpbHRlckNvbmRpdGlvbiIsImdldFRhZ3NGb3JSb29tIiwiYWxnb3JpdGhtVGFncyIsIlVudGFnZ2VkIiwibWFudWFsUm9vbVVwZGF0ZSIsIlJvb21MaXN0U3RvcmUiLCJpbnRlcm5hbEluc3RhbmNlIiwid2luZG93IiwibXhSb29tTGlzdFN0b3JlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWlCQTs7QUFDQTs7QUFFQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFHQTs7QUF6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU1BLGtCQUFrQixHQUFHLGNBQTNCOzs7QUFFQSxNQUFNQyxrQkFBTixTQUFpQ0MsMENBQWpDLENBQThEO0FBQ2pFO0FBQ0o7QUFDQTtBQUNBO0FBb0JJQyxF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QVEsR0FBdUI7QUFDN0MsUUFBSSxDQUFDOE0sYUFBYSxDQUFDQyxnQkFBbkIsRUFBcUM7QUFDakNELE1BQUFBLGFBQWEsQ0FBQ0MsZ0JBQWQsR0FBaUMsSUFBSTFOLGtCQUFKLEVBQWpDO0FBQ0g7O0FBRUQsV0FBT3lOLGFBQWEsQ0FBQ0MsZ0JBQXJCO0FBQ0g7O0FBVDhCOzs7OEJBQWRELGE7QUFZckJFLE1BQU0sQ0FBQ0MsZUFBUCxHQUF5QkgsYUFBYSxDQUFDOU0sUUFBdkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMTgtMjAyMSBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB7IE1hdHJpeENsaWVudCB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9jbGllbnRcIjtcbmltcG9ydCBTZXR0aW5nc1N0b3JlIGZyb20gXCIuLi8uLi9zZXR0aW5ncy9TZXR0aW5nc1N0b3JlXCI7XG5pbXBvcnQgeyBEZWZhdWx0VGFnSUQsIGlzQ3VzdG9tVGFnLCBPcmRlcmVkRGVmYXVsdFRhZ0lEcywgUm9vbVVwZGF0ZUNhdXNlLCBUYWdJRCB9IGZyb20gXCIuL21vZGVsc1wiO1xuaW1wb3J0IHsgUm9vbSB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9tb2RlbHMvcm9vbVwiO1xuaW1wb3J0IHsgSUxpc3RPcmRlcmluZ01hcCwgSVRhZ01hcCwgSVRhZ1NvcnRpbmdNYXAsIExpc3RBbGdvcml0aG0sIFNvcnRBbGdvcml0aG0gfSBmcm9tIFwiLi9hbGdvcml0aG1zL21vZGVsc1wiO1xuaW1wb3J0IHsgQWN0aW9uUGF5bG9hZCB9IGZyb20gXCIuLi8uLi9kaXNwYXRjaGVyL3BheWxvYWRzXCI7XG5pbXBvcnQgZGVmYXVsdERpc3BhdGNoZXIgZnJvbSBcIi4uLy4uL2Rpc3BhdGNoZXIvZGlzcGF0Y2hlclwiO1xuaW1wb3J0IHsgcmVhZFJlY2VpcHRDaGFuZ2VJc0ZvciB9IGZyb20gXCIuLi8uLi91dGlscy9yZWFkLXJlY2VpcHRzXCI7XG5pbXBvcnQgeyBGSUxURVJfQ0hBTkdFRCwgRmlsdGVyS2luZCwgSUZpbHRlckNvbmRpdGlvbiB9IGZyb20gXCIuL2ZpbHRlcnMvSUZpbHRlckNvbmRpdGlvblwiO1xuaW1wb3J0IHsgVGFnV2F0Y2hlciB9IGZyb20gXCIuL1RhZ1dhdGNoZXJcIjtcbmltcG9ydCBSb29tVmlld1N0b3JlIGZyb20gXCIuLi9Sb29tVmlld1N0b3JlXCI7XG5pbXBvcnQgeyBBbGdvcml0aG0sIExJU1RfVVBEQVRFRF9FVkVOVCB9IGZyb20gXCIuL2FsZ29yaXRobXMvQWxnb3JpdGhtXCI7XG5pbXBvcnQgeyBFZmZlY3RpdmVNZW1iZXJzaGlwLCBnZXRFZmZlY3RpdmVNZW1iZXJzaGlwIH0gZnJvbSBcIi4uLy4uL3V0aWxzL21lbWJlcnNoaXBcIjtcbmltcG9ydCB7IGlzTnVsbE9yVW5kZWZpbmVkIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL3V0aWxzXCI7XG5pbXBvcnQgUm9vbUxpc3RMYXlvdXRTdG9yZSBmcm9tIFwiLi9Sb29tTGlzdExheW91dFN0b3JlXCI7XG5pbXBvcnQgeyBNYXJrZWRFeGVjdXRpb24gfSBmcm9tIFwiLi4vLi4vdXRpbHMvTWFya2VkRXhlY3V0aW9uXCI7XG5pbXBvcnQgeyBBc3luY1N0b3JlV2l0aENsaWVudCB9IGZyb20gXCIuLi9Bc3luY1N0b3JlV2l0aENsaWVudFwiO1xuaW1wb3J0IHsgTmFtZUZpbHRlckNvbmRpdGlvbiB9IGZyb20gXCIuL2ZpbHRlcnMvTmFtZUZpbHRlckNvbmRpdGlvblwiO1xuaW1wb3J0IHsgUm9vbU5vdGlmaWNhdGlvblN0YXRlU3RvcmUgfSBmcm9tIFwiLi4vbm90aWZpY2F0aW9ucy9Sb29tTm90aWZpY2F0aW9uU3RhdGVTdG9yZVwiO1xuaW1wb3J0IHsgVmlzaWJpbGl0eVByb3ZpZGVyIH0gZnJvbSBcIi4vZmlsdGVycy9WaXNpYmlsaXR5UHJvdmlkZXJcIjtcbmltcG9ydCB7IFNwYWNlV2F0Y2hlciB9IGZyb20gXCIuL1NwYWNlV2F0Y2hlclwiO1xuaW1wb3J0IFNwYWNlU3RvcmUgZnJvbSBcIi4uL3NwYWNlcy9TcGFjZVN0b3JlXCI7XG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tIFwiLi4vLi4vZGlzcGF0Y2hlci9hY3Rpb25zXCI7XG5pbXBvcnQgeyBTZXR0aW5nVXBkYXRlZFBheWxvYWQgfSBmcm9tIFwiLi4vLi4vZGlzcGF0Y2hlci9wYXlsb2Fkcy9TZXR0aW5nVXBkYXRlZFBheWxvYWRcIjtcblxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL2xvZ2dlclwiO1xuXG5pbnRlcmZhY2UgSVN0YXRlIHtcbiAgICB0YWdzRW5hYmxlZD86IGJvb2xlYW47XG59XG5cbi8qKlxuICogVGhlIGV2ZW50L2NoYW5uZWwgd2hpY2ggaXMgY2FsbGVkIHdoZW4gdGhlIHJvb20gbGlzdHMgaGF2ZSBiZWVuIGNoYW5nZWQuIFJhaXNlZFxuICogd2l0aCBvbmUgYXJndW1lbnQ6IHRoZSBpbnN0YW5jZSBvZiB0aGUgc3RvcmUuXG4gKi9cbmV4cG9ydCBjb25zdCBMSVNUU19VUERBVEVfRVZFTlQgPSBcImxpc3RzX3VwZGF0ZVwiO1xuXG5leHBvcnQgY2xhc3MgUm9vbUxpc3RTdG9yZUNsYXNzIGV4dGVuZHMgQXN5bmNTdG9yZVdpdGhDbGllbnQ8SVN0YXRlPiB7XG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgaWYgeW91J3JlIHJ1bm5pbmcgdGVzdHMgb24gdGhlIHN0b3JlLiBTaG91bGQgbm90IGJlIHRvdWNoZWQgaW5cbiAgICAgKiBhbnkgb3RoZXIgZW52aXJvbm1lbnQuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBURVNUX01PREUgPSBmYWxzZTtcblxuICAgIHByaXZhdGUgaW5pdGlhbExpc3RzR2VuZXJhdGVkID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBhbGdvcml0aG0gPSBuZXcgQWxnb3JpdGhtKCk7XG4gICAgcHJpdmF0ZSBmaWx0ZXJDb25kaXRpb25zOiBJRmlsdGVyQ29uZGl0aW9uW10gPSBbXTtcbiAgICBwcml2YXRlIHByZWZpbHRlckNvbmRpdGlvbnM6IElGaWx0ZXJDb25kaXRpb25bXSA9IFtdO1xuICAgIHByaXZhdGUgdGFnV2F0Y2hlcjogVGFnV2F0Y2hlcjtcbiAgICBwcml2YXRlIHNwYWNlV2F0Y2hlcjogU3BhY2VXYXRjaGVyO1xuICAgIHByaXZhdGUgdXBkYXRlRm4gPSBuZXcgTWFya2VkRXhlY3V0aW9uKCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCB0YWdJZCBvZiBPYmplY3Qua2V5cyh0aGlzLm9yZGVyZWRMaXN0cykpIHtcbiAgICAgICAgICAgIFJvb21Ob3RpZmljYXRpb25TdGF0ZVN0b3JlLmluc3RhbmNlLmdldExpc3RTdGF0ZSh0YWdJZCkuc2V0Um9vbXModGhpcy5vcmRlcmVkTGlzdHNbdGFnSWRdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoTElTVFNfVVBEQVRFX0VWRU5UKTtcbiAgICB9KTtcblxuICAgIHByaXZhdGUgcmVhZG9ubHkgd2F0Y2hlZFNldHRpbmdzID0gW1xuICAgICAgICAnZmVhdHVyZV9jdXN0b21fdGFncycsXG4gICAgXTtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihkZWZhdWx0RGlzcGF0Y2hlcik7XG4gICAgICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKDIwKTsgLy8gQ3VzdG9tUm9vbVRhZ1N0b3JlICsgUm9vbUxpc3QgKyBMZWZ0UGFuZWwgKyA4eFJvb21TdWJMaXN0ICsgc3BhcmVzXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXR1cFdhdGNoZXJzKCkge1xuICAgICAgICBpZiAoU3BhY2VTdG9yZS5zcGFjZXNFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNwYWNlV2F0Y2hlciA9IG5ldyBTcGFjZVdhdGNoZXIodGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRhZ1dhdGNoZXIgPSBuZXcgVGFnV2F0Y2hlcih0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgdW5maWx0ZXJlZExpc3RzKCk6IElUYWdNYXAge1xuICAgICAgICBpZiAoIXRoaXMuYWxnb3JpdGhtKSByZXR1cm4ge307IC8vIE5vIHRhZ3MgeWV0LlxuICAgICAgICByZXR1cm4gdGhpcy5hbGdvcml0aG0uZ2V0VW5maWx0ZXJlZFJvb21zKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBvcmRlcmVkTGlzdHMoKTogSVRhZ01hcCB7XG4gICAgICAgIGlmICghdGhpcy5hbGdvcml0aG0pIHJldHVybiB7fTsgLy8gTm8gdGFncyB5ZXQuXG4gICAgICAgIHJldHVybiB0aGlzLmFsZ29yaXRobS5nZXRPcmRlcmVkUm9vbXMoKTtcbiAgICB9XG5cbiAgICAvLyBJbnRlbmRlZCBmb3IgdGVzdCB1c2FnZVxuICAgIHB1YmxpYyBhc3luYyByZXNldFN0b3JlKCkge1xuICAgICAgICBhd2FpdCB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuZmlsdGVyQ29uZGl0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnByZWZpbHRlckNvbmRpdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5pbml0aWFsTGlzdHNHZW5lcmF0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZXR1cFdhdGNoZXJzKCk7XG5cbiAgICAgICAgdGhpcy5hbGdvcml0aG0ub2ZmKExJU1RfVVBEQVRFRF9FVkVOVCwgdGhpcy5vbkFsZ29yaXRobUxpc3RVcGRhdGVkKTtcbiAgICAgICAgdGhpcy5hbGdvcml0aG0ub2ZmKEZJTFRFUl9DSEFOR0VELCB0aGlzLm9uQWxnb3JpdGhtTGlzdFVwZGF0ZWQpO1xuICAgICAgICB0aGlzLmFsZ29yaXRobSA9IG5ldyBBbGdvcml0aG0oKTtcbiAgICAgICAgdGhpcy5hbGdvcml0aG0ub24oTElTVF9VUERBVEVEX0VWRU5ULCB0aGlzLm9uQWxnb3JpdGhtTGlzdFVwZGF0ZWQpO1xuICAgICAgICB0aGlzLmFsZ29yaXRobS5vbihGSUxURVJfQ0hBTkdFRCwgdGhpcy5vbkFsZ29yaXRobUxpc3RVcGRhdGVkKTtcblxuICAgICAgICAvLyBSZXNldCBzdGF0ZSB3aXRob3V0IGNhdXNpbmcgdXBkYXRlcyBhcyB0aGUgY2xpZW50IHdpbGwgaGF2ZSBiZWVuIGRlc3Ryb3llZFxuICAgICAgICAvLyBhbmQgZG93bnN0cmVhbSBjb2RlIHdpbGwgdGhyb3cgTlBFIGVycm9ycy5cbiAgICAgICAgYXdhaXQgdGhpcy5yZXNldChudWxsLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBQdWJsaWMgZm9yIHRlc3QgdXNhZ2UuIERvIG5vdCBjYWxsIHRoaXMuXG4gICAgcHVibGljIGFzeW5jIG1ha2VSZWFkeShmb3JjZWRDbGllbnQ/OiBNYXRyaXhDbGllbnQpIHtcbiAgICAgICAgaWYgKGZvcmNlZENsaWVudCkge1xuICAgICAgICAgICAgdGhpcy5yZWFkeVN0b3JlLnVzZVVuaXRUZXN0Q2xpZW50KGZvcmNlZENsaWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IHNldHRpbmdOYW1lIG9mIHRoaXMud2F0Y2hlZFNldHRpbmdzKSBTZXR0aW5nc1N0b3JlLm1vbml0b3JTZXR0aW5nKHNldHRpbmdOYW1lLCBudWxsKTtcbiAgICAgICAgUm9vbVZpZXdTdG9yZS5hZGRMaXN0ZW5lcigoKSA9PiB0aGlzLmhhbmRsZVJWU1VwZGF0ZSh7fSkpO1xuICAgICAgICB0aGlzLmFsZ29yaXRobS5vbihMSVNUX1VQREFURURfRVZFTlQsIHRoaXMub25BbGdvcml0aG1MaXN0VXBkYXRlZCk7XG4gICAgICAgIHRoaXMuYWxnb3JpdGhtLm9uKEZJTFRFUl9DSEFOR0VELCB0aGlzLm9uQWxnb3JpdGhtRmlsdGVyVXBkYXRlZCk7XG4gICAgICAgIHRoaXMuc2V0dXBXYXRjaGVycygpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBhbnkgc2V0dGluZ3MgaGVyZSwgYXMgc29tZSBtYXkgaGF2ZSBoYXBwZW5lZCBiZWZvcmUgd2Ugd2VyZSBsb2dpY2FsbHkgcmVhZHkuXG4gICAgICAgIC8vIFVwZGF0ZSBhbnkgc2V0dGluZ3MgaGVyZSwgYXMgc29tZSBtYXkgaGF2ZSBoYXBwZW5lZCBiZWZvcmUgd2Ugd2VyZSBsb2dpY2FsbHkgcmVhZHkuXG4gICAgICAgIGxvZ2dlci5sb2coXCJSZWdlbmVyYXRpbmcgcm9vbSBsaXN0czogU3RhcnR1cFwiKTtcbiAgICAgICAgYXdhaXQgdGhpcy5yZWFkQW5kQ2FjaGVTZXR0aW5nc0Zyb21TdG9yZSgpO1xuICAgICAgICB0aGlzLnJlZ2VuZXJhdGVBbGxMaXN0cyh7IHRyaWdnZXI6IGZhbHNlIH0pO1xuICAgICAgICB0aGlzLmhhbmRsZVJWU1VwZGF0ZSh7IHRyaWdnZXI6IGZhbHNlIH0pOyAvLyBmYWtlIGFuIFJWUyB1cGRhdGUgdG8gYWRqdXN0IHN0aWNreSByb29tLCBpZiBuZWVkZWRcblxuICAgICAgICB0aGlzLnVwZGF0ZUZuLm1hcmsoKTsgLy8gd2UgYWxtb3N0IGNlcnRhaW5seSB3YW50IHRvIHRyaWdnZXIgYW4gdXBkYXRlLlxuICAgICAgICB0aGlzLnVwZGF0ZUZuLnRyaWdnZXIoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIHJlYWRBbmRDYWNoZVNldHRpbmdzRnJvbVN0b3JlKCkge1xuICAgICAgICBjb25zdCB0YWdzRW5hYmxlZCA9IFNldHRpbmdzU3RvcmUuZ2V0VmFsdWUoXCJmZWF0dXJlX2N1c3RvbV90YWdzXCIpO1xuICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICAgICAgICAgIHRhZ3NFbmFibGVkLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVBbGdvcml0aG1JbnN0YW5jZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHN1c3BlY3RlZCBSb29tVmlld1N0b3JlIGNoYW5nZXMuXG4gICAgICogQHBhcmFtIHRyaWdnZXIgU2V0IHRvIGZhbHNlIHRvIHByZXZlbnQgYSBsaXN0IHVwZGF0ZSBmcm9tIGJlaW5nIHNlbnQuIFNob3VsZCBvbmx5XG4gICAgICogYmUgdXNlZCBpZiB0aGUgY2FsbGluZyBjb2RlIHdpbGwgbWFudWFsbHkgdHJpZ2dlciB0aGUgdXBkYXRlLlxuICAgICAqL1xuICAgIHByaXZhdGUgaGFuZGxlUlZTVXBkYXRlKHsgdHJpZ2dlciA9IHRydWUgfSkge1xuICAgICAgICBpZiAoIXRoaXMubWF0cml4Q2xpZW50KSByZXR1cm47IC8vIFdlIGFzc3VtZSB0aGVyZSB3b24ndCBiZSBSVlMgdXBkYXRlcyB3aXRob3V0IGEgY2xpZW50XG5cbiAgICAgICAgY29uc3QgYWN0aXZlUm9vbUlkID0gUm9vbVZpZXdTdG9yZS5nZXRSb29tSWQoKTtcbiAgICAgICAgaWYgKCFhY3RpdmVSb29tSWQgJiYgdGhpcy5hbGdvcml0aG0uc3RpY2t5Um9vbSkge1xuICAgICAgICAgICAgdGhpcy5hbGdvcml0aG0uc2V0U3RpY2t5Um9vbShudWxsKTtcbiAgICAgICAgfSBlbHNlIGlmIChhY3RpdmVSb29tSWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZVJvb20gPSB0aGlzLm1hdHJpeENsaWVudC5nZXRSb29tKGFjdGl2ZVJvb21JZCk7XG4gICAgICAgICAgICBpZiAoIWFjdGl2ZVJvb20pIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgJHthY3RpdmVSb29tSWR9IGlzIGN1cnJlbnQgaW4gUlZTIGJ1dCBtaXNzaW5nIGZyb20gY2xpZW50IC0gY2xlYXJpbmcgc3RpY2t5IHJvb21gKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFsZ29yaXRobS5zZXRTdGlja3lSb29tKG51bGwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhY3RpdmVSb29tICE9PSB0aGlzLmFsZ29yaXRobS5zdGlja3lSb29tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGdvcml0aG0uc2V0U3RpY2t5Um9vbShhY3RpdmVSb29tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmlnZ2VyKSB0aGlzLnVwZGF0ZUZuLnRyaWdnZXIoKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgYXN5bmMgb25SZWFkeSgpOiBQcm9taXNlPGFueT4ge1xuICAgICAgICBhd2FpdCB0aGlzLm1ha2VSZWFkeSgpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBhc3luYyBvbk5vdFJlYWR5KCk6IFByb21pc2U8YW55PiB7XG4gICAgICAgIGF3YWl0IHRoaXMucmVzZXRTdG9yZSgpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBhc3luYyBvbkFjdGlvbihwYXlsb2FkOiBBY3Rpb25QYXlsb2FkKSB7XG4gICAgICAgIC8vIElmIHdlJ3JlIG5vdCByZW1vdGVseSByZWFkeSwgZG9uJ3QgZXZlbiBib3RoZXIgc2NoZWR1bGluZyB0aGUgZGlzcGF0Y2ggaGFuZGxpbmcuXG4gICAgICAgIC8vIFRoaXMgaXMgcmVwZWF0ZWQgaW4gdGhlIGhhbmRsZXIganVzdCBpbiBjYXNlIHRoaW5ncyBjaGFuZ2UgYmV0d2VlbiBhIGRlY2lzaW9uIGhlcmUgYW5kXG4gICAgICAgIC8vIHdoZW4gdGhlIHRpbWVyIGZpcmVzLlxuICAgICAgICBjb25zdCBsb2dpY2FsbHlSZWFkeSA9IHRoaXMubWF0cml4Q2xpZW50ICYmIHRoaXMuaW5pdGlhbExpc3RzR2VuZXJhdGVkO1xuICAgICAgICBpZiAoIWxvZ2ljYWxseVJlYWR5KSByZXR1cm47XG5cbiAgICAgICAgLy8gV2hlbiB3ZSdyZSBydW5uaW5nIHRlc3RzIHdlIGNhbid0IHJlbGlhYmx5IHVzZSBzZXRJbW1lZGlhdGUgb3V0IG9mIHRpbWluZyBjb25jZXJucy5cbiAgICAgICAgLy8gQXMgc3VjaCwgd2UgdXNlIGEgbW9yZSBzeW5jaHJvbm91cyBtb2RlbC5cbiAgICAgICAgaWYgKFJvb21MaXN0U3RvcmVDbGFzcy5URVNUX01PREUpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMub25EaXNwYXRjaEFzeW5jKHBheWxvYWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgZG8gdGhpcyB0byBpbnRlbnRpb25hbGx5IGJyZWFrIG91dCBvZiB0aGUgY3VycmVudCBldmVudCBsb29wIHRhc2ssIGFsbG93aW5nXG4gICAgICAgIC8vIHVzIHRvIGluc3RlYWQgd2FpdCBmb3IgYSBtb3JlIGNvbnZlbmllbnQgdGltZSB0byBydW4gb3VyIHVwZGF0ZXMuXG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLm9uRGlzcGF0Y2hBc3luYyhwYXlsb2FkKSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGFzeW5jIG9uRGlzcGF0Y2hBc3luYyhwYXlsb2FkOiBBY3Rpb25QYXlsb2FkKSB7XG4gICAgICAgIC8vIEV2ZXJ5dGhpbmcgaGVyZSByZXF1aXJlcyBhIE1hdHJpeENsaWVudCBvciBzb21lIHNvcnQgb2YgbG9naWNhbCByZWFkaW5lc3MuXG4gICAgICAgIGNvbnN0IGxvZ2ljYWxseVJlYWR5ID0gdGhpcy5tYXRyaXhDbGllbnQgJiYgdGhpcy5pbml0aWFsTGlzdHNHZW5lcmF0ZWQ7XG4gICAgICAgIGlmICghbG9naWNhbGx5UmVhZHkpIHJldHVybjtcblxuICAgICAgICBpZiAocGF5bG9hZC5hY3Rpb24gPT09IEFjdGlvbi5TZXR0aW5nVXBkYXRlZCkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ1VwZGF0ZWRQYXlsb2FkID0gcGF5bG9hZCBhcyBTZXR0aW5nVXBkYXRlZFBheWxvYWQ7XG4gICAgICAgICAgICBpZiAodGhpcy53YXRjaGVkU2V0dGluZ3MuaW5jbHVkZXMoc2V0dGluZ1VwZGF0ZWRQYXlsb2FkLnNldHRpbmdOYW1lKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coXCJSZWdlbmVyYXRpbmcgcm9vbSBsaXN0czogU2V0dGluZ3MgY2hhbmdlZFwiKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlYWRBbmRDYWNoZVNldHRpbmdzRnJvbVN0b3JlKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2VuZXJhdGVBbGxMaXN0cyh7IHRyaWdnZXI6IGZhbHNlIH0pOyAvLyByZWdlbmVyYXRlIHRoZSBsaXN0cyBub3dcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUZuLnRyaWdnZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5hbGdvcml0aG0pIHtcbiAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkbid0IGhhcHBlbiBiZWNhdXNlIGBpbml0aWFsTGlzdHNHZW5lcmF0ZWRgIGltcGxpZXMgd2UgaGF2ZSBhbiBhbGdvcml0aG0uXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb29tIGxpc3Qgc3RvcmUgaGFzIG5vIGFsZ29yaXRobSB0byBwcm9jZXNzIGRpc3BhdGNoZXIgdXBkYXRlIHdpdGhcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGF5bG9hZC5hY3Rpb24gPT09ICdNYXRyaXhBY3Rpb25zLlJvb20ucmVjZWlwdCcpIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IHNlZSBpZiB0aGUgcmVjZWlwdCBldmVudCBpcyBmb3Igb3VyIG93biB1c2VyLiBJZiBpdCB3YXMsIHRyaWdnZXJcbiAgICAgICAgICAgIC8vIGEgcm9vbSB1cGRhdGUgKHdlIHByb2JhYmx5IHJlYWQgdGhlIHJvb20gb24gYSBkaWZmZXJlbnQgZGV2aWNlKS5cbiAgICAgICAgICAgIGlmIChyZWFkUmVjZWlwdENoYW5nZUlzRm9yKHBheWxvYWQuZXZlbnQsIHRoaXMubWF0cml4Q2xpZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvb20gPSBwYXlsb2FkLnJvb207XG4gICAgICAgICAgICAgICAgaWYgKCFyb29tKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBPd24gcmVhZCByZWNlaXB0IHdhcyBpbiB1bmtub3duIHJvb20gJHtyb29tLnJvb21JZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZVJvb21VcGRhdGUocm9vbSwgUm9vbVVwZGF0ZUNhdXNlLlJlYWRSZWNlaXB0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUZuLnRyaWdnZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocGF5bG9hZC5hY3Rpb24gPT09ICdNYXRyaXhBY3Rpb25zLlJvb20udGFncycpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb21QYXlsb2FkID0gKDxhbnk+cGF5bG9hZCk7IC8vIFRPRE86IFR5cGUgb3V0IHRoZSBkaXNwYXRjaGVyIHR5cGVzXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZVJvb21VcGRhdGUocm9vbVBheWxvYWQucm9vbSwgUm9vbVVwZGF0ZUNhdXNlLlBvc3NpYmxlVGFnQ2hhbmdlKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRm4udHJpZ2dlcigpO1xuICAgICAgICB9IGVsc2UgaWYgKHBheWxvYWQuYWN0aW9uID09PSAnTWF0cml4QWN0aW9ucy5Sb29tLnRpbWVsaW5lJykge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRQYXlsb2FkID0gKDxhbnk+cGF5bG9hZCk7IC8vIFRPRE86IFR5cGUgb3V0IHRoZSBkaXNwYXRjaGVyIHR5cGVzXG5cbiAgICAgICAgICAgIC8vIElnbm9yZSBub24tbGl2ZSBldmVudHMgKGJhY2tmaWxsKVxuICAgICAgICAgICAgaWYgKCFldmVudFBheWxvYWQuaXNMaXZlRXZlbnQgfHwgIXBheWxvYWQuaXNMaXZlVW5maWx0ZXJlZFJvb21UaW1lbGluZUV2ZW50KSByZXR1cm47XG5cbiAgICAgICAgICAgIGNvbnN0IHJvb21JZCA9IGV2ZW50UGF5bG9hZC5ldmVudC5nZXRSb29tSWQoKTtcbiAgICAgICAgICAgIGNvbnN0IHJvb20gPSB0aGlzLm1hdHJpeENsaWVudC5nZXRSb29tKHJvb21JZCk7XG4gICAgICAgICAgICBjb25zdCB0cnlVcGRhdGUgPSBhc3luYyAodXBkYXRlZFJvb206IFJvb20pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRQYXlsb2FkLmV2ZW50LmdldFR5cGUoKSA9PT0gJ20ucm9vbS50b21ic3RvbmUnICYmIGV2ZW50UGF5bG9hZC5ldmVudC5nZXRTdGF0ZUtleSgpID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdSb29tID0gdGhpcy5tYXRyaXhDbGllbnQuZ2V0Um9vbShldmVudFBheWxvYWQuZXZlbnQuZ2V0Q29udGVudCgpWydyZXBsYWNlbWVudF9yb29tJ10pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3Um9vbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSB0aGUgbmV3IHJvb20sIHRoZW4gdGhlIG5ldyByb29tIGNoZWNrIHdpbGwgaGF2ZSBzZWVuIHRoZSBwcmVkZWNlc3NvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGRpZCB0aGUgcmVxdWlyZWQgdXBkYXRlcywgc28gZG8gbm90aGluZyBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlUm9vbVVwZGF0ZSh1cGRhdGVkUm9vbSwgUm9vbVVwZGF0ZUNhdXNlLlRpbWVsaW5lKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUZuLnRyaWdnZXIoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXJvb20pIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgTGl2ZSB0aW1lbGluZSBldmVudCAke2V2ZW50UGF5bG9hZC5ldmVudC5nZXRJZCgpfSByZWNlaXZlZCB3aXRob3V0IGFzc29jaWF0ZWQgcm9vbWApO1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBRdWV1aW5nIGZhaWxlZCByb29tIHVwZGF0ZSBmb3IgcmV0cnkgYXMgYSByZXN1bHQuYCk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRSb29tID0gdGhpcy5tYXRyaXhDbGllbnQuZ2V0Um9vbShyb29tSWQpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0cnlVcGRhdGUodXBkYXRlZFJvb20pO1xuICAgICAgICAgICAgICAgIH0sIDEwMCk7IC8vIDEwMG1zIHNob3VsZCBiZSBlbm91Z2ggZm9yIHRoZSByb29tIHRvIHNob3cgdXBcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRyeVVwZGF0ZShyb29tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwYXlsb2FkLmFjdGlvbiA9PT0gJ01hdHJpeEFjdGlvbnMuRXZlbnQuZGVjcnlwdGVkJykge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRQYXlsb2FkID0gKDxhbnk+cGF5bG9hZCk7IC8vIFRPRE86IFR5cGUgb3V0IHRoZSBkaXNwYXRjaGVyIHR5cGVzXG4gICAgICAgICAgICBjb25zdCByb29tSWQgPSBldmVudFBheWxvYWQuZXZlbnQuZ2V0Um9vbUlkKCk7XG4gICAgICAgICAgICBpZiAoIXJvb21JZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJvb20gPSB0aGlzLm1hdHJpeENsaWVudC5nZXRSb29tKHJvb21JZCk7XG4gICAgICAgICAgICBpZiAoIXJvb20pIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgRXZlbnQgJHtldmVudFBheWxvYWQuZXZlbnQuZ2V0SWQoKX0gd2FzIGRlY3J5cHRlZCBpbiBhbiB1bmtub3duIHJvb20gJHtyb29tSWR9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5oYW5kbGVSb29tVXBkYXRlKHJvb20sIFJvb21VcGRhdGVDYXVzZS5UaW1lbGluZSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZuLnRyaWdnZXIoKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXlsb2FkLmFjdGlvbiA9PT0gJ01hdHJpeEFjdGlvbnMuYWNjb3VudERhdGEnICYmIHBheWxvYWQuZXZlbnRfdHlwZSA9PT0gJ20uZGlyZWN0Jykge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRQYXlsb2FkID0gKDxhbnk+cGF5bG9hZCk7IC8vIFRPRE86IFR5cGUgb3V0IHRoZSBkaXNwYXRjaGVyIHR5cGVzXG4gICAgICAgICAgICBjb25zdCBkbU1hcCA9IGV2ZW50UGF5bG9hZC5ldmVudC5nZXRDb250ZW50KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHVzZXJJZCBvZiBPYmplY3Qua2V5cyhkbU1hcCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByb29tSWRzID0gZG1NYXBbdXNlcklkXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJvb21JZCBvZiByb29tSWRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvb20gPSB0aGlzLm1hdHJpeENsaWVudC5nZXRSb29tKHJvb21JZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcm9vbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYCR7cm9vbUlkfSB3YXMgZm91bmQgaW4gRE1zIGJ1dCB0aGUgcm9vbSBpcyBub3QgaW4gdGhlIHN0b3JlYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGV4cGVjdCB0aGlzIFJvb21VcGRhdGVDYXVzZSB0byBuby1vcCBpZiB0aGVyZSdzIG5vIGNoYW5nZSwgYW5kIHdlIGRvbid0IGV4cGVjdFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdXNlciB0byBoYXZlIGh1bmRyZWRzIG9mIHJvb21zIHRvIHVwZGF0ZSBpbiBvbmUgZXZlbnQuIEFzIHN1Y2gsIHdlIGp1c3QgaGFtbWVyXG4gICAgICAgICAgICAgICAgICAgIC8vIGF3YXkgYXQgdXBkYXRlcyB1bnRpbCB0aGUgcHJvYmxlbSBpcyBzb2x2ZWQuIElmIHdlIHdlcmUgZXhwZWN0aW5nIG1vcmUgdGhhbiBhIGNvdXBsZVxuICAgICAgICAgICAgICAgICAgICAvLyBvZiByb29tcyB0byBiZSB1cGRhdGVkIGF0IG9uY2UsIHdlIHdvdWxkIGNvbnNpZGVyIGJhdGNoaW5nIHRoZSByb29tcyB1cC5cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5oYW5kbGVSb29tVXBkYXRlKHJvb20sIFJvb21VcGRhdGVDYXVzZS5Qb3NzaWJsZVRhZ0NoYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVGbi50cmlnZ2VyKCk7XG4gICAgICAgIH0gZWxzZSBpZiAocGF5bG9hZC5hY3Rpb24gPT09ICdNYXRyaXhBY3Rpb25zLlJvb20ubXlNZW1iZXJzaGlwJykge1xuICAgICAgICAgICAgY29uc3QgbWVtYmVyc2hpcFBheWxvYWQgPSAoPGFueT5wYXlsb2FkKTsgLy8gVE9ETzogVHlwZSBvdXQgdGhlIGRpc3BhdGNoZXIgdHlwZXNcbiAgICAgICAgICAgIGNvbnN0IG9sZE1lbWJlcnNoaXAgPSBnZXRFZmZlY3RpdmVNZW1iZXJzaGlwKG1lbWJlcnNoaXBQYXlsb2FkLm9sZE1lbWJlcnNoaXApO1xuICAgICAgICAgICAgY29uc3QgbmV3TWVtYmVyc2hpcCA9IGdldEVmZmVjdGl2ZU1lbWJlcnNoaXAobWVtYmVyc2hpcFBheWxvYWQubWVtYmVyc2hpcCk7XG4gICAgICAgICAgICBpZiAob2xkTWVtYmVyc2hpcCAhPT0gRWZmZWN0aXZlTWVtYmVyc2hpcC5Kb2luICYmIG5ld01lbWJlcnNoaXAgPT09IEVmZmVjdGl2ZU1lbWJlcnNoaXAuSm9pbikge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIGpvaW5pbmcgYW4gdXBncmFkZWQgcm9vbSwgd2UnbGwgd2FudCB0byBtYWtlIHN1cmUgd2UgZG9uJ3QgcHJvbGlmZXJhdGVcbiAgICAgICAgICAgICAgICAvLyB0aGUgZGVhZCByb29tIGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgICAgIGNvbnN0IGNyZWF0ZUV2ZW50ID0gbWVtYmVyc2hpcFBheWxvYWQucm9vbS5jdXJyZW50U3RhdGUuZ2V0U3RhdGVFdmVudHMoXCJtLnJvb20uY3JlYXRlXCIsIFwiXCIpO1xuICAgICAgICAgICAgICAgIGlmIChjcmVhdGVFdmVudCAmJiBjcmVhdGVFdmVudC5nZXRDb250ZW50KClbJ3ByZWRlY2Vzc29yJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldlJvb20gPSB0aGlzLm1hdHJpeENsaWVudC5nZXRSb29tKGNyZWF0ZUV2ZW50LmdldENvbnRlbnQoKVsncHJlZGVjZXNzb3InXVsncm9vbV9pZCddKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZSb29tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1N0aWNreSA9IHRoaXMuYWxnb3JpdGhtLnN0aWNreVJvb20gPT09IHByZXZSb29tO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RpY2t5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGdvcml0aG0uc2V0U3RpY2t5Um9vbShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogd2UgaGl0IHRoZSBhbGdvcml0aG0gaW5zdGVhZCBvZiBvdXIgaGFuZGxlUm9vbVVwZGF0ZSgpIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhdm9pZCByZWR1bmRhbnQgdXBkYXRlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWxnb3JpdGhtLmhhbmRsZVJvb21VcGRhdGUocHJldlJvb20sIFJvb21VcGRhdGVDYXVzZS5Sb29tUmVtb3ZlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZVJvb21VcGRhdGUobWVtYmVyc2hpcFBheWxvYWQucm9vbSwgUm9vbVVwZGF0ZUNhdXNlLk5ld1Jvb20pO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRm4udHJpZ2dlcigpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9sZE1lbWJlcnNoaXAgIT09IEVmZmVjdGl2ZU1lbWJlcnNoaXAuSW52aXRlICYmIG5ld01lbWJlcnNoaXAgPT09IEVmZmVjdGl2ZU1lbWJlcnNoaXAuSW52aXRlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5oYW5kbGVSb29tVXBkYXRlKG1lbWJlcnNoaXBQYXlsb2FkLnJvb20sIFJvb21VcGRhdGVDYXVzZS5OZXdSb29tKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUZuLnRyaWdnZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGl0J3Mgbm90IGEgam9pbiwgaXQncyB0cmFuc2l0aW9uaW5nIGludG8gYSBkaWZmZXJlbnQgbGlzdCAocG9zc2libHkgaGlzdG9yaWNhbClcbiAgICAgICAgICAgIGlmIChvbGRNZW1iZXJzaGlwICE9PSBuZXdNZW1iZXJzaGlwKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5oYW5kbGVSb29tVXBkYXRlKG1lbWJlcnNoaXBQYXlsb2FkLnJvb20sIFJvb21VcGRhdGVDYXVzZS5Qb3NzaWJsZVRhZ0NoYW5nZSk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVGbi50cmlnZ2VyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBoYW5kbGVSb29tVXBkYXRlKHJvb206IFJvb20sIGNhdXNlOiBSb29tVXBkYXRlQ2F1c2UpOiBQcm9taXNlPGFueT4ge1xuICAgICAgICBpZiAoY2F1c2UgPT09IFJvb21VcGRhdGVDYXVzZS5OZXdSb29tICYmIHJvb20uZ2V0TXlNZW1iZXJzaGlwKCkgPT09IFwiaW52aXRlXCIpIHtcbiAgICAgICAgICAgIC8vIExldCB0aGUgdmlzaWJpbGl0eSBwcm92aWRlciBrbm93IHRoYXQgdGhlcmUgaXMgYSBuZXcgaW52aXRlZCByb29tLiBJdCB3b3VsZCBiZSBuaWNlXG4gICAgICAgICAgICAvLyBpZiB0aGlzIGNvdWxkIGp1c3QgYmUgYW4gZXZlbnQgdGhhdCB0aGluZ3MgbGlzdGVuIGZvciBidXQgdGhlIHBvaW50IG9mIHRoaXMgaXMgdGhhdFxuICAgICAgICAgICAgLy8gd2UgZGVsYXkgZG9pbmcgYW55dGhpbmcgYWJvdXQgdGhpcyByb29tIHVudGlsIHRoZSBWb2lwVXNlck1hcHBlciBoYWQgaGFkIGEgY2hhbmNlXG4gICAgICAgICAgICAvLyB0byBkbyB0aGUgdGhpbmdzIGl0IG5lZWRzIHRvIGRvIHRvIGRlY2lkZSBpZiB3ZSBzaG91bGQgc2hvdyB0aGlzIHJvb20gb3Igbm90LCBzb1xuICAgICAgICAgICAgLy8gYW4gZXZlbiB3b3VsZG4ndCBldCB1cyBkbyB0aGF0LlxuICAgICAgICAgICAgYXdhaXQgVmlzaWJpbGl0eVByb3ZpZGVyLmluc3RhbmNlLm9uTmV3SW52aXRlZFJvb20ocm9vbSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIVZpc2liaWxpdHlQcm92aWRlci5pbnN0YW5jZS5pc1Jvb21WaXNpYmxlKHJvb20pKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIGRvbid0IGRvIGFueXRoaW5nIG9uIHJvb21zIHRoYXQgYXJlbid0IHZpc2libGVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoY2F1c2UgPT09IFJvb21VcGRhdGVDYXVzZS5OZXdSb29tIHx8IGNhdXNlID09PSBSb29tVXBkYXRlQ2F1c2UuUG9zc2libGVUYWdDaGFuZ2UpICYmXG4gICAgICAgICAgICAhdGhpcy5wcmVmaWx0ZXJDb25kaXRpb25zLmV2ZXJ5KGMgPT4gYy5pc1Zpc2libGUocm9vbSkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBkb24ndCBkbyBhbnl0aGluZyBvbiBuZXcvbW92ZWQgcm9vbXMgd2hpY2ggb3VnaHQgbm90IHRvIGJlIHNob3duXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzaG91bGRVcGRhdGUgPSB0aGlzLmFsZ29yaXRobS5oYW5kbGVSb29tVXBkYXRlKHJvb20sIGNhdXNlKTtcbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGbi5tYXJrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIHJlY2FsY3VsYXRlUHJlZmlsdGVyaW5nKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWxnb3JpdGhtKSByZXR1cm47XG4gICAgICAgIGlmICghdGhpcy5hbGdvcml0aG0uaGFzVGFnU29ydGluZ01hcCkgcmV0dXJuOyAvLyB3ZSdyZSBzdGlsbCBsb2FkaW5nXG5cbiAgICAgICAgLy8gSW5oaWJpdCB1cGRhdGVzIGJlY2F1c2Ugd2UncmUgYWJvdXQgdG8gbGllIGhlYXZpbHkgdG8gdGhlIGFsZ29yaXRobVxuICAgICAgICB0aGlzLmFsZ29yaXRobS51cGRhdGVzSW5oaWJpdGVkID0gdHJ1ZTtcblxuICAgICAgICAvLyBGaWd1cmUgb3V0IHdoaWNoIHJvb21zIGFyZSBhYm91dCB0byBiZSB2YWxpZCwgYW5kIHRoZSBzdGF0ZSBvZiBhZmZhaXJzXG4gICAgICAgIGNvbnN0IHJvb21zID0gdGhpcy5nZXRQbGF1c2libGVSb29tcygpO1xuICAgICAgICBjb25zdCBjdXJyZW50U3RpY2t5ID0gdGhpcy5hbGdvcml0aG0uc3RpY2t5Um9vbTtcbiAgICAgICAgY29uc3Qgc3RpY2t5SXNTdGlsbFByZXNlbnQgPSBjdXJyZW50U3RpY2t5ICYmIHJvb21zLmluY2x1ZGVzKGN1cnJlbnRTdGlja3kpO1xuXG4gICAgICAgIC8vIFJlc2V0IHRoZSBzdGlja3kgcm9vbSBiZWZvcmUgcmVzZXR0aW5nIHRoZSBrbm93biByb29tcyBzbyB0aGUgYWxnb3JpdGhtXG4gICAgICAgIC8vIGRvZXNuJ3QgZnJlYWsgb3V0LlxuICAgICAgICB0aGlzLmFsZ29yaXRobS5zZXRTdGlja3lSb29tKG51bGwpO1xuICAgICAgICB0aGlzLmFsZ29yaXRobS5zZXRLbm93blJvb21zKHJvb21zKTtcblxuICAgICAgICAvLyBTZXQgdGhlIHN0aWNreSByb29tIGJhY2ssIGlmIG5lZWRlZCwgbm93IHRoYXQgd2UgaGF2ZSB1cGRhdGVkIHRoZSBzdG9yZS5cbiAgICAgICAgLy8gVGhpcyB3aWxsIHVzZSByZWxhdGl2ZSBzdGlja3luZXNzIHRvIHRoZSBuZXcgcm9vbSBzZXQuXG4gICAgICAgIGlmIChzdGlja3lJc1N0aWxsUHJlc2VudCkge1xuICAgICAgICAgICAgdGhpcy5hbGdvcml0aG0uc2V0U3RpY2t5Um9vbShjdXJyZW50U3RpY2t5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmFsbHksIG1hcmsgYW4gdXBkYXRlIGFuZCByZXN1bWUgdXBkYXRlcyBmcm9tIHRoZSBhbGdvcml0aG1cbiAgICAgICAgdGhpcy51cGRhdGVGbi5tYXJrKCk7XG4gICAgICAgIHRoaXMuYWxnb3JpdGhtLnVwZGF0ZXNJbmhpYml0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgc2V0VGFnU29ydGluZyh0YWdJZDogVGFnSUQsIHNvcnQ6IFNvcnRBbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5zZXRBbmRQZXJzaXN0VGFnU29ydGluZyh0YWdJZCwgc29ydCk7XG4gICAgICAgIHRoaXMudXBkYXRlRm4udHJpZ2dlcigpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0QW5kUGVyc2lzdFRhZ1NvcnRpbmcodGFnSWQ6IFRhZ0lELCBzb3J0OiBTb3J0QWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuYWxnb3JpdGhtLnNldFRhZ1NvcnRpbmcodGFnSWQsIHNvcnQpO1xuICAgICAgICAvLyBUT0RPOiBQZXItYWNjb3VudD8gaHR0cHM6Ly9naXRodWIuY29tL3ZlY3Rvci1pbS9lbGVtZW50LXdlYi9pc3N1ZXMvMTQxMTRcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oYG14X3RhZ1NvcnRfJHt0YWdJZH1gLCBzb3J0KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0VGFnU29ydGluZyh0YWdJZDogVGFnSUQpOiBTb3J0QWxnb3JpdGhtIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxnb3JpdGhtLmdldFRhZ1NvcnRpbmcodGFnSWQpO1xuICAgIH1cblxuICAgIC8vIG5vaW5zcGVjdGlvbiBKU01ldGhvZENhbkJlU3RhdGljXG4gICAgcHJpdmF0ZSBnZXRTdG9yZWRUYWdTb3J0aW5nKHRhZ0lkOiBUYWdJRCk6IFNvcnRBbGdvcml0aG0ge1xuICAgICAgICAvLyBUT0RPOiBQZXItYWNjb3VudD8gaHR0cHM6Ly9naXRodWIuY29tL3ZlY3Rvci1pbS9lbGVtZW50LXdlYi9pc3N1ZXMvMTQxMTRcbiAgICAgICAgcmV0dXJuIDxTb3J0QWxnb3JpdGhtPmxvY2FsU3RvcmFnZS5nZXRJdGVtKGBteF90YWdTb3J0XyR7dGFnSWR9YCk7XG4gICAgfVxuXG4gICAgLy8gbG9naWMgbXVzdCBtYXRjaCBjYWxjdWxhdGVMaXN0T3JkZXJcbiAgICBwcml2YXRlIGNhbGN1bGF0ZVRhZ1NvcnRpbmcodGFnSWQ6IFRhZ0lEKTogU29ydEFsZ29yaXRobSB7XG4gICAgICAgIGNvbnN0IGlzRGVmYXVsdFJlY2VudCA9IHRhZ0lkID09PSBEZWZhdWx0VGFnSUQuSW52aXRlIHx8IHRhZ0lkID09PSBEZWZhdWx0VGFnSUQuRE07XG4gICAgICAgIGNvbnN0IGRlZmF1bHRTb3J0ID0gaXNEZWZhdWx0UmVjZW50ID8gU29ydEFsZ29yaXRobS5SZWNlbnQgOiBTb3J0QWxnb3JpdGhtLkFscGhhYmV0aWM7XG4gICAgICAgIGNvbnN0IHNldHRpbmdBbHBoYWJldGljYWwgPSBTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFwiUm9vbUxpc3Qub3JkZXJBbHBoYWJldGljYWxseVwiLCBudWxsLCB0cnVlKTtcbiAgICAgICAgY29uc3QgZGVmaW5lZFNvcnQgPSB0aGlzLmdldFRhZ1NvcnRpbmcodGFnSWQpO1xuICAgICAgICBjb25zdCBzdG9yZWRTb3J0ID0gdGhpcy5nZXRTdG9yZWRUYWdTb3J0aW5nKHRhZ0lkKTtcblxuICAgICAgICAvLyBXZSB1c2UgdGhlIGZvbGxvd2luZyBvcmRlciB0byBkZXRlcm1pbmUgd2hpY2ggb2YgdGhlIDQgZmxhZ3MgdG8gdXNlOlxuICAgICAgICAvLyBTdG9yZWQgPiBTZXR0aW5ncyA+IERlZmluZWQgPiBEZWZhdWx0XG5cbiAgICAgICAgbGV0IHRhZ1NvcnQgPSBkZWZhdWx0U29ydDtcbiAgICAgICAgaWYgKHN0b3JlZFNvcnQpIHtcbiAgICAgICAgICAgIHRhZ1NvcnQgPSBzdG9yZWRTb3J0O1xuICAgICAgICB9IGVsc2UgaWYgKCFpc051bGxPclVuZGVmaW5lZChzZXR0aW5nQWxwaGFiZXRpY2FsKSkge1xuICAgICAgICAgICAgdGFnU29ydCA9IHNldHRpbmdBbHBoYWJldGljYWwgPyBTb3J0QWxnb3JpdGhtLkFscGhhYmV0aWMgOiBTb3J0QWxnb3JpdGhtLlJlY2VudDtcbiAgICAgICAgfSBlbHNlIGlmIChkZWZpbmVkU29ydCkge1xuICAgICAgICAgICAgdGFnU29ydCA9IGRlZmluZWRTb3J0O1xuICAgICAgICB9IC8vIGVsc2UgZGVmYXVsdCAoYWxyZWFkeSBzZXQpXG5cbiAgICAgICAgcmV0dXJuIHRhZ1NvcnQ7XG4gICAgfVxuXG4gICAgcHVibGljIHNldExpc3RPcmRlcih0YWdJZDogVGFnSUQsIG9yZGVyOiBMaXN0QWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuc2V0QW5kUGVyc2lzdExpc3RPcmRlcih0YWdJZCwgb3JkZXIpO1xuICAgICAgICB0aGlzLnVwZGF0ZUZuLnRyaWdnZXIoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldEFuZFBlcnNpc3RMaXN0T3JkZXIodGFnSWQ6IFRhZ0lELCBvcmRlcjogTGlzdEFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmFsZ29yaXRobS5zZXRMaXN0T3JkZXJpbmcodGFnSWQsIG9yZGVyKTtcbiAgICAgICAgLy8gVE9ETzogUGVyLWFjY291bnQ/IGh0dHBzOi8vZ2l0aHViLmNvbS92ZWN0b3ItaW0vZWxlbWVudC13ZWIvaXNzdWVzLzE0MTE0XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGBteF9saXN0T3JkZXJfJHt0YWdJZH1gLCBvcmRlcik7XG4gICAgfVxuXG4gICAgcHVibGljIGdldExpc3RPcmRlcih0YWdJZDogVGFnSUQpOiBMaXN0QWxnb3JpdGhtIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxnb3JpdGhtLmdldExpc3RPcmRlcmluZyh0YWdJZCk7XG4gICAgfVxuXG4gICAgLy8gbm9pbnNwZWN0aW9uIEpTTWV0aG9kQ2FuQmVTdGF0aWNcbiAgICBwcml2YXRlIGdldFN0b3JlZExpc3RPcmRlcih0YWdJZDogVGFnSUQpOiBMaXN0QWxnb3JpdGhtIHtcbiAgICAgICAgLy8gVE9ETzogUGVyLWFjY291bnQ/IGh0dHBzOi8vZ2l0aHViLmNvbS92ZWN0b3ItaW0vZWxlbWVudC13ZWIvaXNzdWVzLzE0MTE0XG4gICAgICAgIHJldHVybiA8TGlzdEFsZ29yaXRobT5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShgbXhfbGlzdE9yZGVyXyR7dGFnSWR9YCk7XG4gICAgfVxuXG4gICAgLy8gbG9naWMgbXVzdCBtYXRjaCBjYWxjdWxhdGVUYWdTb3J0aW5nXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVMaXN0T3JkZXIodGFnSWQ6IFRhZ0lEKTogTGlzdEFsZ29yaXRobSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRPcmRlciA9IExpc3RBbGdvcml0aG0uTmF0dXJhbDtcbiAgICAgICAgY29uc3Qgc2V0dGluZ0ltcG9ydGFuY2UgPSBTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFwiUm9vbUxpc3Qub3JkZXJCeUltcG9ydGFuY2VcIiwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGRlZmluZWRPcmRlciA9IHRoaXMuZ2V0TGlzdE9yZGVyKHRhZ0lkKTtcbiAgICAgICAgY29uc3Qgc3RvcmVkT3JkZXIgPSB0aGlzLmdldFN0b3JlZExpc3RPcmRlcih0YWdJZCk7XG5cbiAgICAgICAgLy8gV2UgdXNlIHRoZSBmb2xsb3dpbmcgb3JkZXIgdG8gZGV0ZXJtaW5lIHdoaWNoIG9mIHRoZSA0IGZsYWdzIHRvIHVzZTpcbiAgICAgICAgLy8gU3RvcmVkID4gU2V0dGluZ3MgPiBEZWZpbmVkID4gRGVmYXVsdFxuXG4gICAgICAgIGxldCBsaXN0T3JkZXIgPSBkZWZhdWx0T3JkZXI7XG4gICAgICAgIGlmIChzdG9yZWRPcmRlcikge1xuICAgICAgICAgICAgbGlzdE9yZGVyID0gc3RvcmVkT3JkZXI7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHNldHRpbmdJbXBvcnRhbmNlKSkge1xuICAgICAgICAgICAgbGlzdE9yZGVyID0gc2V0dGluZ0ltcG9ydGFuY2UgPyBMaXN0QWxnb3JpdGhtLkltcG9ydGFuY2UgOiBMaXN0QWxnb3JpdGhtLk5hdHVyYWw7XG4gICAgICAgIH0gZWxzZSBpZiAoZGVmaW5lZE9yZGVyKSB7XG4gICAgICAgICAgICBsaXN0T3JkZXIgPSBkZWZpbmVkT3JkZXI7XG4gICAgICAgIH0gLy8gZWxzZSBkZWZhdWx0IChhbHJlYWR5IHNldClcblxuICAgICAgICByZXR1cm4gbGlzdE9yZGVyO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlQWxnb3JpdGhtSW5zdGFuY2VzKCkge1xuICAgICAgICAvLyBXZSdsbCByZXF1aXJlIGFuIHVwZGF0ZSwgc28gbWFyayBmb3Igb25lLiBNYXJraW5nIG5vdyBhbHNvIHByZXZlbnRzIHRoZSBjYWxsc1xuICAgICAgICAvLyB0byBzZXRUYWdTb3J0aW5nIGFuZCBzZXRMaXN0T3JkZXIgZnJvbSBjYXVzaW5nIHRyaWdnZXJzLlxuICAgICAgICB0aGlzLnVwZGF0ZUZuLm1hcmsoKTtcblxuICAgICAgICBmb3IgKGNvbnN0IHRhZyBvZiBPYmplY3Qua2V5cyh0aGlzLm9yZGVyZWRMaXN0cykpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmluZWRTb3J0ID0gdGhpcy5nZXRUYWdTb3J0aW5nKHRhZyk7XG4gICAgICAgICAgICBjb25zdCBkZWZpbmVkT3JkZXIgPSB0aGlzLmdldExpc3RPcmRlcih0YWcpO1xuXG4gICAgICAgICAgICBjb25zdCB0YWdTb3J0ID0gdGhpcy5jYWxjdWxhdGVUYWdTb3J0aW5nKHRhZyk7XG4gICAgICAgICAgICBjb25zdCBsaXN0T3JkZXIgPSB0aGlzLmNhbGN1bGF0ZUxpc3RPcmRlcih0YWcpO1xuXG4gICAgICAgICAgICBpZiAodGFnU29ydCAhPT0gZGVmaW5lZFNvcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEFuZFBlcnNpc3RUYWdTb3J0aW5nKHRhZywgdGFnU29ydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGlzdE9yZGVyICE9PSBkZWZpbmVkT3JkZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEFuZFBlcnNpc3RMaXN0T3JkZXIodGFnLCBsaXN0T3JkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvbkFsZ29yaXRobUxpc3RVcGRhdGVkID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZUZuLm1hcmsoKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbkFsZ29yaXRobUZpbHRlclVwZGF0ZWQgPSAoKSA9PiB7XG4gICAgICAgIC8vIFRoZSBmaWx0ZXIgY2FuIGhhcHBlbiBvZmYtY3ljbGUsIHNvIHRyaWdnZXIgYW4gdXBkYXRlLiBUaGUgZmlsdGVyIHdpbGwgaGF2ZVxuICAgICAgICAvLyBhbHJlYWR5IGNhdXNlZCBhIG1hcmsuXG4gICAgICAgIHRoaXMudXBkYXRlRm4udHJpZ2dlcigpO1xuICAgIH07XG5cbiAgICBwcml2YXRlIG9uUHJlZmlsdGVyVXBkYXRlZCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZWNhbGN1bGF0ZVByZWZpbHRlcmluZygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUZuLnRyaWdnZXIoKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBnZXRQbGF1c2libGVSb29tcygpOiBSb29tW10ge1xuICAgICAgICBpZiAoIXRoaXMubWF0cml4Q2xpZW50KSByZXR1cm4gW107XG5cbiAgICAgICAgbGV0IHJvb21zID0gdGhpcy5tYXRyaXhDbGllbnQuZ2V0VmlzaWJsZVJvb21zKCkuZmlsdGVyKHIgPT4gVmlzaWJpbGl0eVByb3ZpZGVyLmluc3RhbmNlLmlzUm9vbVZpc2libGUocikpO1xuXG4gICAgICAgIC8vIGlmIHNwYWNlcyBhcmUgZW5hYmxlZCBvbmx5IGNvbnNpZGVyIHRoZSBwcmVmaWx0ZXIgY29uZGl0aW9ucyB3aGVuIHRoZXJlIGFyZSBubyBydW50aW1lIGNvbmRpdGlvbnNcbiAgICAgICAgLy8gZm9yIHRoZSBzZWFyY2ggYWxsIHNwYWNlcyBmZWF0dXJlXG4gICAgICAgIGlmICh0aGlzLnByZWZpbHRlckNvbmRpdGlvbnMubGVuZ3RoID4gMCAmJiAoIVNwYWNlU3RvcmUuc3BhY2VzRW5hYmxlZCB8fCAhdGhpcy5maWx0ZXJDb25kaXRpb25zLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHJvb21zID0gcm9vbXMuZmlsdGVyKHIgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIHRoaXMucHJlZmlsdGVyQ29uZGl0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbHRlci5pc1Zpc2libGUocikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJvb21zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2VuZXJhdGVzIHRoZSByb29tIHdob2xlIHJvb20gbGlzdCwgZGlzY2FyZGluZyBhbnkgcHJldmlvdXMgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgaXMgb25seSBleHBvc2VkIGV4dGVybmFsbHkgZm9yIHRoZSB0ZXN0cy4gRG8gbm90IGNhbGwgdGhpcyBmcm9tIHdpdGhpblxuICAgICAqIHRoZSBhcHAuXG4gICAgICogQHBhcmFtIHRyaWdnZXIgU2V0IHRvIGZhbHNlIHRvIHByZXZlbnQgYSBsaXN0IHVwZGF0ZSBmcm9tIGJlaW5nIHNlbnQuIFNob3VsZCBvbmx5XG4gICAgICogYmUgdXNlZCBpZiB0aGUgY2FsbGluZyBjb2RlIHdpbGwgbWFudWFsbHkgdHJpZ2dlciB0aGUgdXBkYXRlLlxuICAgICAqL1xuICAgIHB1YmxpYyByZWdlbmVyYXRlQWxsTGlzdHMoeyB0cmlnZ2VyID0gdHJ1ZSB9KSB7XG4gICAgICAgIGxvZ2dlci53YXJuKFwiUmVnZW5lcmF0aW5nIGFsbCByb29tIGxpc3RzXCIpO1xuXG4gICAgICAgIGNvbnN0IHJvb21zID0gdGhpcy5nZXRQbGF1c2libGVSb29tcygpO1xuXG4gICAgICAgIGNvbnN0IGN1c3RvbVRhZ3MgPSBuZXcgU2V0PFRhZ0lEPigpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS50YWdzRW5hYmxlZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCByb29tIG9mIHJvb21zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyb29tLnRhZ3MpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ3MgPSBPYmplY3Qua2V5cyhyb29tLnRhZ3MpLmZpbHRlcih0ID0+IGlzQ3VzdG9tVGFnKHQpKTtcbiAgICAgICAgICAgICAgICB0YWdzLmZvckVhY2godCA9PiBjdXN0b21UYWdzLmFkZCh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzb3J0czogSVRhZ1NvcnRpbmdNYXAgPSB7fTtcbiAgICAgICAgY29uc3Qgb3JkZXJzOiBJTGlzdE9yZGVyaW5nTWFwID0ge307XG4gICAgICAgIGNvbnN0IGFsbFRhZ3MgPSBbLi4uT3JkZXJlZERlZmF1bHRUYWdJRHMsIC4uLkFycmF5LmZyb20oY3VzdG9tVGFncyldO1xuICAgICAgICBmb3IgKGNvbnN0IHRhZ0lkIG9mIGFsbFRhZ3MpIHtcbiAgICAgICAgICAgIHNvcnRzW3RhZ0lkXSA9IHRoaXMuY2FsY3VsYXRlVGFnU29ydGluZyh0YWdJZCk7XG4gICAgICAgICAgICBvcmRlcnNbdGFnSWRdID0gdGhpcy5jYWxjdWxhdGVMaXN0T3JkZXIodGFnSWQpO1xuXG4gICAgICAgICAgICBSb29tTGlzdExheW91dFN0b3JlLmluc3RhbmNlLmVuc3VyZUxheW91dEV4aXN0cyh0YWdJZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFsZ29yaXRobS5wb3B1bGF0ZVRhZ3Moc29ydHMsIG9yZGVycyk7XG4gICAgICAgIHRoaXMuYWxnb3JpdGhtLnNldEtub3duUm9vbXMocm9vbXMpO1xuXG4gICAgICAgIHRoaXMuaW5pdGlhbExpc3RzR2VuZXJhdGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAodHJpZ2dlcikgdGhpcy51cGRhdGVGbi50cmlnZ2VyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGZpbHRlciBjb25kaXRpb24gdG8gdGhlIHJvb20gbGlzdCBzdG9yZS4gRmlsdGVycyBtYXkgYmUgYXBwbGllZCBhc3luYyxcbiAgICAgKiBhbmQgdGh1cyBtaWdodCBub3QgY2F1c2UgYW4gdXBkYXRlIHRvIHRoZSBzdG9yZSBpbW1lZGlhdGVseS5cbiAgICAgKiBAcGFyYW0ge0lGaWx0ZXJDb25kaXRpb259IGZpbHRlciBUaGUgZmlsdGVyIGNvbmRpdGlvbiB0byBhZGQuXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIGFkZEZpbHRlcihmaWx0ZXI6IElGaWx0ZXJDb25kaXRpb24pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgaWYgKGZpbHRlci5raW5kID09PSBGaWx0ZXJLaW5kLlByZWZpbHRlcikge1xuICAgICAgICAgICAgZmlsdGVyLm9uKEZJTFRFUl9DSEFOR0VELCB0aGlzLm9uUHJlZmlsdGVyVXBkYXRlZCk7XG4gICAgICAgICAgICB0aGlzLnByZWZpbHRlckNvbmRpdGlvbnMucHVzaChmaWx0ZXIpO1xuICAgICAgICAgICAgcHJvbWlzZSA9IHRoaXMucmVjYWxjdWxhdGVQcmVmaWx0ZXJpbmcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyQ29uZGl0aW9ucy5wdXNoKGZpbHRlcik7XG4gICAgICAgICAgICAvLyBSdW50aW1lIGZpbHRlcnMgd2l0aCBzcGFjZXMgZGlzYWJsZSBwcmVmaWx0ZXJpbmcgZm9yIHRoZSBzZWFyY2ggYWxsIHNwYWNlcyBmZWF0dXJlXG4gICAgICAgICAgICBpZiAoU3BhY2VTdG9yZS5zcGFjZXNFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBoYXMgdG8gYmUgYXdhaXRlZCBzbyB0aGF0IGBzZXRLbm93blJvb21zYCBpcyBjYWxsZWQgaW4gdGltZSBmb3IgdGhlIGBhZGRGaWx0ZXJDb25kaXRpb25gIGJlbG93XG4gICAgICAgICAgICAgICAgLy8gdGhpcyB3YXkgdGhlIHJ1bnRpbWUgZmlsdGVycyBhcmUgb25seSBldmFsdWF0ZWQgb24gb25lIGRhdGFzZXQgYW5kIG5vdCBib3RoLlxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVjYWxjdWxhdGVQcmVmaWx0ZXJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFsZ29yaXRobSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWxnb3JpdGhtLmFkZEZpbHRlckNvbmRpdGlvbihmaWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByb21pc2UudGhlbigoKSA9PiB0aGlzLnVwZGF0ZUZuLnRyaWdnZXIoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGZpbHRlciBjb25kaXRpb24gZnJvbSB0aGUgcm9vbSBsaXN0IHN0b3JlLiBJZiB0aGUgZmlsdGVyIHdhc1xuICAgICAqIG5vdCBwcmV2aW91c2x5IGFkZGVkIHRvIHRoZSByb29tIGxpc3Qgc3RvcmUsIHRoaXMgd2lsbCBuby1vcC4gVGhlIGVmZmVjdHNcbiAgICAgKiBvZiByZW1vdmluZyBhIGZpbHRlciBtYXkgYmUgYXBwbGllZCBhc3luYyBhbmQgdGhlcmVmb3JlIG1pZ2h0IG5vdCBjYXVzZVxuICAgICAqIGFuIHVwZGF0ZSByaWdodCBhd2F5LlxuICAgICAqIEBwYXJhbSB7SUZpbHRlckNvbmRpdGlvbn0gZmlsdGVyIFRoZSBmaWx0ZXIgY29uZGl0aW9uIHRvIHJlbW92ZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVtb3ZlRmlsdGVyKGZpbHRlcjogSUZpbHRlckNvbmRpdGlvbik6IHZvaWQge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICBsZXQgaWR4ID0gdGhpcy5maWx0ZXJDb25kaXRpb25zLmluZGV4T2YoZmlsdGVyKTtcbiAgICAgICAgbGV0IHJlbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlckNvbmRpdGlvbnMuc3BsaWNlKGlkeCwgMSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmFsZ29yaXRobSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWxnb3JpdGhtLnJlbW92ZUZpbHRlckNvbmRpdGlvbihmaWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUnVudGltZSBmaWx0ZXJzIHdpdGggc3BhY2VzIGRpc2FibGUgcHJlZmlsdGVyaW5nIGZvciB0aGUgc2VhcmNoIGFsbCBzcGFjZXMgZmVhdHVyZVxuICAgICAgICAgICAgaWYgKFNwYWNlU3RvcmUuc3BhY2VzRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHByb21pc2UgPSB0aGlzLnJlY2FsY3VsYXRlUHJlZmlsdGVyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlkeCA9IHRoaXMucHJlZmlsdGVyQ29uZGl0aW9ucy5pbmRleE9mKGZpbHRlcik7XG4gICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgZmlsdGVyLm9mZihGSUxURVJfQ0hBTkdFRCwgdGhpcy5vblByZWZpbHRlclVwZGF0ZWQpO1xuICAgICAgICAgICAgdGhpcy5wcmVmaWx0ZXJDb25kaXRpb25zLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgcHJvbWlzZSA9IHRoaXMucmVjYWxjdWxhdGVQcmVmaWx0ZXJpbmcoKTtcbiAgICAgICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICAgIHByb21pc2UudGhlbigoKSA9PiB0aGlzLnVwZGF0ZUZuLnRyaWdnZXIoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmaXJzdCAoYW5kIGlkZWFsbHkgb25seSkgbmFtZSBmaWx0ZXIgY29uZGl0aW9uLiBJZiBvbmUgaXNuJ3QgcHJlc2VudCxcbiAgICAgKiB0aGlzIHJldHVybnMgbnVsbC5cbiAgICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgbmFtZSBmaWx0ZXIgY29uZGl0aW9uLCBvciBudWxsIGlmIG5vbmUuXG4gICAgICovXG4gICAgcHVibGljIGdldEZpcnN0TmFtZUZpbHRlckNvbmRpdGlvbigpOiBOYW1lRmlsdGVyQ29uZGl0aW9uIHwgbnVsbCB7XG4gICAgICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIHRoaXMuZmlsdGVyQ29uZGl0aW9ucykge1xuICAgICAgICAgICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIE5hbWVGaWx0ZXJDb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHRhZ3MgZm9yIGEgcm9vbSBpZGVudGlmaWVkIGJ5IHRoZSBzdG9yZS4gVGhlIHJldHVybmVkIHNldFxuICAgICAqIHNob3VsZCBuZXZlciBiZSBlbXB0eSwgYW5kIHdpbGwgY29udGFpbiBEZWZhdWx0VGFnSUQuVW50YWdnZWQgaWZcbiAgICAgKiB0aGUgc3RvcmUgaXMgbm90IGF3YXJlIG9mIGFueSB0YWdzLlxuICAgICAqIEBwYXJhbSByb29tIFRoZSByb29tIHRvIGdldCB0aGUgdGFncyBmb3IuXG4gICAgICogQHJldHVybnMgVGhlIHRhZ3MgZm9yIHRoZSByb29tLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRUYWdzRm9yUm9vbShyb29tOiBSb29tKTogVGFnSURbXSB7XG4gICAgICAgIGNvbnN0IGFsZ29yaXRobVRhZ3MgPSB0aGlzLmFsZ29yaXRobS5nZXRUYWdzRm9yUm9vbShyb29tKTtcbiAgICAgICAgaWYgKCFhbGdvcml0aG1UYWdzKSByZXR1cm4gW0RlZmF1bHRUYWdJRC5VbnRhZ2dlZF07XG4gICAgICAgIHJldHVybiBhbGdvcml0aG1UYWdzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hbnVhbGx5IHVwZGF0ZSBhIHJvb20gd2l0aCBhIGdpdmVuIGNhdXNlLiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgaWYgdGhlXG4gICAgICogcm9vbSBsaXN0IHN0b3JlIHdvdWxkIG90aGVyd2lzZSBiZSBpbmNhcGFibGUgb2YgZG9pbmcgdGhlIHVwZGF0ZSBpdHNlbGYuIE5vdGVcbiAgICAgKiB0aGF0IHRoaXMgbWF5IHJhY2Ugd2l0aCB0aGUgcm9vbSBsaXN0J3MgcmVndWxhciBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtSb29tfSByb29tIFRoZSByb29tIHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0ge1Jvb21VcGRhdGVDYXVzZX0gY2F1c2UgVGhlIGNhdXNlIHRvIHVwZGF0ZSBmb3IuXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIG1hbnVhbFJvb21VcGRhdGUocm9vbTogUm9vbSwgY2F1c2U6IFJvb21VcGRhdGVDYXVzZSkge1xuICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZVJvb21VcGRhdGUocm9vbSwgY2F1c2UpO1xuICAgICAgICB0aGlzLnVwZGF0ZUZuLnRyaWdnZXIoKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJvb21MaXN0U3RvcmUge1xuICAgIHByaXZhdGUgc3RhdGljIGludGVybmFsSW5zdGFuY2U6IFJvb21MaXN0U3RvcmVDbGFzcztcblxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IGluc3RhbmNlKCk6IFJvb21MaXN0U3RvcmVDbGFzcyB7XG4gICAgICAgIGlmICghUm9vbUxpc3RTdG9yZS5pbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICAgICAgICBSb29tTGlzdFN0b3JlLmludGVybmFsSW5zdGFuY2UgPSBuZXcgUm9vbUxpc3RTdG9yZUNsYXNzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUm9vbUxpc3RTdG9yZS5pbnRlcm5hbEluc3RhbmNlO1xuICAgIH1cbn1cblxud2luZG93Lm14Um9vbUxpc3RTdG9yZSA9IFJvb21MaXN0U3RvcmUuaW5zdGFuY2U7XG4iXX0=