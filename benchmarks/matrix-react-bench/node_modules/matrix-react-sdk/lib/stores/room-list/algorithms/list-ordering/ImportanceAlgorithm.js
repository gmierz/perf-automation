"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ImportanceAlgorithm = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _models = require("../../models");

var _models2 = require("../models");

var _tagSorting = require("../tag-sorting");

var _OrderingAlgorithm = require("./OrderingAlgorithm");

var _NotificationColor = require("../../../notifications/NotificationColor");

var _RoomNotificationStateStore = require("../../../notifications/RoomNotificationStateStore");

var _logger = require("matrix-js-sdk/src/logger");

/*
Copyright 2018, 2019 New Vector Ltd
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// Caution: changing this means you'll need to update a bunch of assumptions and
// comments! Check the usage of Category carefully to figure out what needs changing
// if you're going to change this array's order.
const CATEGORY_ORDER = [_NotificationColor.NotificationColor.Unsent, _NotificationColor.NotificationColor.Red, _NotificationColor.NotificationColor.Grey, _NotificationColor.NotificationColor.Bold, _NotificationColor.NotificationColor.None // idle
];
/**
 * An implementation of the "importance" algorithm for room list sorting. Where
 * the tag sorting algorithm does not interfere, rooms will be ordered into
 * categories of varying importance to the user. Alphabetical sorting does not
 * interfere with this algorithm, however manual ordering does.
 *
 * The importance of a room is defined by the kind of notifications, if any, are
 * present on the room. These are classified internally as Unsent, Red, Grey,
 * Bold, and Idle. 'Unsent' rooms have unsent messages, Red rooms have mentions,
 * grey have unread messages, bold is a less noisy version of grey, and idle
 * means all activity has been seen by the user.
 *
 * The algorithm works by monitoring all room changes, including new messages in
 * tracked rooms, to determine if it needs a new category or different placement
 * within the same category. For more information, see the comments contained
 * within the class.
 */

class ImportanceAlgorithm extends _OrderingAlgorithm.OrderingAlgorithm {
  // This tracks the category for the tag it represents by tracking the index of
  // each category within the list, where zero is the top of the list. This then
  // tracks when rooms change categories and splices the orderedRooms array as
  // needed, preventing many ordering operations.
  constructor(tagId, initialSortingAlgorithm) {
    super(tagId, initialSortingAlgorithm);
    (0, _defineProperty2.default)(this, "indices", {});
  } // noinspection JSMethodCanBeStatic


  categorizeRooms(rooms) {
    const map = {
      [_NotificationColor.NotificationColor.Unsent]: [],
      [_NotificationColor.NotificationColor.Red]: [],
      [_NotificationColor.NotificationColor.Grey]: [],
      [_NotificationColor.NotificationColor.Bold]: [],
      [_NotificationColor.NotificationColor.None]: []
    };

    for (const room of rooms) {
      const category = this.getRoomCategory(room);
      map[category].push(room);
    }

    return map;
  } // noinspection JSMethodCanBeStatic


  getRoomCategory(room) {
    // It's fine for us to call this a lot because it's cached, and we shouldn't be
    // wasting anything by doing so as the store holds single references
    const state = _RoomNotificationStateStore.RoomNotificationStateStore.instance.getRoomState(room);

    return state.color;
  }

  setRooms(rooms) {
    if (this.sortingAlgorithm === _models2.SortAlgorithm.Manual) {
      this.cachedOrderedRooms = (0, _tagSorting.sortRoomsWithAlgorithm)(rooms, this.tagId, this.sortingAlgorithm);
    } else {
      // Every other sorting type affects the categories, not the whole tag.
      const categorized = this.categorizeRooms(rooms);

      for (const category of Object.keys(categorized)) {
        const roomsToOrder = categorized[category];
        categorized[category] = (0, _tagSorting.sortRoomsWithAlgorithm)(roomsToOrder, this.tagId, this.sortingAlgorithm);
      }

      const newlyOrganized = [];
      const newIndices = {};

      for (const category of CATEGORY_ORDER) {
        newIndices[category] = newlyOrganized.length;
        newlyOrganized.push(...categorized[category]);
      }

      this.indices = newIndices;
      this.cachedOrderedRooms = newlyOrganized;
    }
  }

  handleSplice(room, cause) {
    if (cause === _models.RoomUpdateCause.NewRoom) {
      const category = this.getRoomCategory(room);
      this.alterCategoryPositionBy(category, 1, this.indices);
      this.cachedOrderedRooms.splice(this.indices[category], 0, room); // splice in the new room (pre-adjusted)

      this.sortCategory(category);
    } else if (cause === _models.RoomUpdateCause.RoomRemoved) {
      const roomIdx = this.getRoomIndex(room);

      if (roomIdx === -1) {
        _logger.logger.warn(`Tried to remove unknown room from ${this.tagId}: ${room.roomId}`);

        return false; // no change
      }

      const oldCategory = this.getCategoryFromIndices(roomIdx, this.indices);
      this.alterCategoryPositionBy(oldCategory, -1, this.indices);
      this.cachedOrderedRooms.splice(roomIdx, 1); // remove the room
    } else {
      throw new Error(`Unhandled splice: ${cause}`);
    } // changes have been made if we made it here, so say so


    return true;
  }

  handleRoomUpdate(room, cause) {
    if (cause === _models.RoomUpdateCause.NewRoom || cause === _models.RoomUpdateCause.RoomRemoved) {
      return this.handleSplice(room, cause);
    }

    if (cause !== _models.RoomUpdateCause.Timeline && cause !== _models.RoomUpdateCause.ReadReceipt) {
      throw new Error(`Unsupported update cause: ${cause}`);
    }

    const category = this.getRoomCategory(room);

    if (this.sortingAlgorithm === _models2.SortAlgorithm.Manual) {
      return; // Nothing to do here.
    }

    const roomIdx = this.getRoomIndex(room);

    if (roomIdx === -1) {
      throw new Error(`Room ${room.roomId} has no index in ${this.tagId}`);
    } // Try to avoid doing array operations if we don't have to: only move rooms within
    // the categories if we're jumping categories


    const oldCategory = this.getCategoryFromIndices(roomIdx, this.indices);

    if (oldCategory !== category) {
      // Move the room and update the indices
      this.moveRoomIndexes(1, oldCategory, category, this.indices);
      this.cachedOrderedRooms.splice(roomIdx, 1); // splice out the old index (fixed position)

      this.cachedOrderedRooms.splice(this.indices[category], 0, room); // splice in the new room (pre-adjusted)
      // Note: if moveRoomIndexes() is called after the splice then the insert operation
      // will happen in the wrong place. Because we would have already adjusted the index
      // for the category, we don't need to determine how the room is moving in the list.
      // If we instead tried to insert before updating the indices, we'd have to determine
      // whether the room was moving later (towards IDLE) or earlier (towards RED) from its
      // current position, as it'll affect the category's start index after we remove the
      // room from the array.
    } // Sort the category now that we've dumped the room in


    this.sortCategory(category);
    return true; // change made
  }

  sortCategory(category) {
    // This should be relatively quick because the room is usually inserted at the top of the
    // category, and most popular sorting algorithms will deal with trying to keep the active
    // room at the top/start of the category. For the few algorithms that will have to move the
    // thing quite far (alphabetic with a Z room for example), the list should already be sorted
    // well enough that it can rip through the array and slot the changed room in quickly.
    const nextCategoryStartIdx = category === CATEGORY_ORDER[CATEGORY_ORDER.length - 1] ? Number.MAX_SAFE_INTEGER : this.indices[CATEGORY_ORDER[CATEGORY_ORDER.indexOf(category) + 1]];
    const startIdx = this.indices[category];
    const numSort = nextCategoryStartIdx - startIdx; // splice() returns up to the max, so MAX_SAFE_INT is fine

    const unsortedSlice = this.cachedOrderedRooms.splice(startIdx, numSort);
    const sorted = (0, _tagSorting.sortRoomsWithAlgorithm)(unsortedSlice, this.tagId, this.sortingAlgorithm);
    this.cachedOrderedRooms.splice(startIdx, 0, ...sorted);
  } // noinspection JSMethodCanBeStatic


  getCategoryFromIndices(index, indices) {
    for (let i = 0; i < CATEGORY_ORDER.length; i++) {
      const category = CATEGORY_ORDER[i];
      const isLast = i === CATEGORY_ORDER.length - 1;
      const startIdx = indices[category];
      const endIdx = isLast ? Number.MAX_SAFE_INTEGER : indices[CATEGORY_ORDER[i + 1]];

      if (index >= startIdx && index < endIdx) {
        return category;
      }
    } // "Should never happen" disclaimer goes here


    throw new Error("Programming error: somehow you've ended up with an index that isn't in a category");
  } // noinspection JSMethodCanBeStatic


  moveRoomIndexes(nRooms, fromCategory, toCategory, indices) {
    // We have to update the index of the category *after* the from/toCategory variables
    // in order to update the indices correctly. Because the room is moving from/to those
    // categories, the next category's index will change - not the category we're modifying.
    // We also need to update subsequent categories as they'll all shift by nRooms, so we
    // loop over the order to achieve that.
    this.alterCategoryPositionBy(fromCategory, -nRooms, indices);
    this.alterCategoryPositionBy(toCategory, +nRooms, indices);
  }

  alterCategoryPositionBy(category, n, indices) {
    // Note: when we alter a category's index, we actually have to modify the ones following
    // the target and not the target itself.
    // XXX: If this ever actually gets more than one room passed to it, it'll need more index
    // handling. For instance, if 45 rooms are removed from the middle of a 50 room list, the
    // index for the categories will be way off.
    const nextOrderIndex = CATEGORY_ORDER.indexOf(category) + 1;

    if (n > 0) {
      for (let i = nextOrderIndex; i < CATEGORY_ORDER.length; i++) {
        const nextCategory = CATEGORY_ORDER[i];
        indices[nextCategory] += Math.abs(n);
      }
    } else if (n < 0) {
      for (let i = nextOrderIndex; i < CATEGORY_ORDER.length; i++) {
        const nextCategory = CATEGORY_ORDER[i];
        indices[nextCategory] -= Math.abs(n);
      }
    } // Do a quick check to see if we've completely broken the index


    for (let i = 1; i <= CATEGORY_ORDER.length; i++) {
      const lastCat = CATEGORY_ORDER[i - 1];
      const thisCat = CATEGORY_ORDER[i];

      if (indices[lastCat] > indices[thisCat]) {
        // "should never happen" disclaimer goes here
        _logger.logger.warn(`!! Room list index corruption: ${lastCat} (i:${indices[lastCat]}) is greater ` + `than ${thisCat} (i:${indices[thisCat]}) - category indices are likely desynced from reality`); // TODO: Regenerate index when this happens: https://github.com/vector-im/element-web/issues/14234

      }
    }
  }

}

exports.ImportanceAlgorithm = ImportanceAlgorithm;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9zdG9yZXMvcm9vbS1saXN0L2FsZ29yaXRobXMvbGlzdC1vcmRlcmluZy9JbXBvcnRhbmNlQWxnb3JpdGhtLnRzIl0sIm5hbWVzIjpbIkNBVEVHT1JZX09SREVSIiwiTm90aWZpY2F0aW9uQ29sb3IiLCJVbnNlbnQiLCJSZWQiLCJHcmV5IiwiQm9sZCIsIk5vbmUiLCJJbXBvcnRhbmNlQWxnb3JpdGhtIiwiT3JkZXJpbmdBbGdvcml0aG0iLCJjb25zdHJ1Y3RvciIsInRhZ0lkIiwiaW5pdGlhbFNvcnRpbmdBbGdvcml0aG0iLCJjYXRlZ29yaXplUm9vbXMiLCJyb29tcyIsIm1hcCIsInJvb20iLCJjYXRlZ29yeSIsImdldFJvb21DYXRlZ29yeSIsInB1c2giLCJzdGF0ZSIsIlJvb21Ob3RpZmljYXRpb25TdGF0ZVN0b3JlIiwiaW5zdGFuY2UiLCJnZXRSb29tU3RhdGUiLCJjb2xvciIsInNldFJvb21zIiwic29ydGluZ0FsZ29yaXRobSIsIlNvcnRBbGdvcml0aG0iLCJNYW51YWwiLCJjYWNoZWRPcmRlcmVkUm9vbXMiLCJjYXRlZ29yaXplZCIsIk9iamVjdCIsImtleXMiLCJyb29tc1RvT3JkZXIiLCJuZXdseU9yZ2FuaXplZCIsIm5ld0luZGljZXMiLCJsZW5ndGgiLCJpbmRpY2VzIiwiaGFuZGxlU3BsaWNlIiwiY2F1c2UiLCJSb29tVXBkYXRlQ2F1c2UiLCJOZXdSb29tIiwiYWx0ZXJDYXRlZ29yeVBvc2l0aW9uQnkiLCJzcGxpY2UiLCJzb3J0Q2F0ZWdvcnkiLCJSb29tUmVtb3ZlZCIsInJvb21JZHgiLCJnZXRSb29tSW5kZXgiLCJsb2dnZXIiLCJ3YXJuIiwicm9vbUlkIiwib2xkQ2F0ZWdvcnkiLCJnZXRDYXRlZ29yeUZyb21JbmRpY2VzIiwiRXJyb3IiLCJoYW5kbGVSb29tVXBkYXRlIiwiVGltZWxpbmUiLCJSZWFkUmVjZWlwdCIsIm1vdmVSb29tSW5kZXhlcyIsIm5leHRDYXRlZ29yeVN0YXJ0SWR4IiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsImluZGV4T2YiLCJzdGFydElkeCIsIm51bVNvcnQiLCJ1bnNvcnRlZFNsaWNlIiwic29ydGVkIiwiaW5kZXgiLCJpIiwiaXNMYXN0IiwiZW5kSWR4IiwiblJvb21zIiwiZnJvbUNhdGVnb3J5IiwidG9DYXRlZ29yeSIsIm4iLCJuZXh0T3JkZXJJbmRleCIsIm5leHRDYXRlZ29yeSIsIk1hdGgiLCJhYnMiLCJsYXN0Q2F0IiwidGhpc0NhdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFrQkE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBc0JBO0FBQ0E7QUFDQTtBQUNBLE1BQU1BLGNBQWMsR0FBRyxDQUNuQkMscUNBQWtCQyxNQURDLEVBRW5CRCxxQ0FBa0JFLEdBRkMsRUFHbkJGLHFDQUFrQkcsSUFIQyxFQUluQkgscUNBQWtCSSxJQUpDLEVBS25CSixxQ0FBa0JLLElBTEMsQ0FLSztBQUxMLENBQXZCO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDTyxNQUFNQyxtQkFBTixTQUFrQ0Msb0NBQWxDLENBQW9EO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBSU9DLEVBQUFBLFdBQVcsQ0FBQ0MsS0FBRCxFQUFlQyx1QkFBZixFQUF1RDtBQUNyRSxVQUFNRCxLQUFOLEVBQWFDLHVCQUFiO0FBRHFFLG1EQUZ2QyxFQUV1QztBQUV4RSxHQVZzRCxDQVl2RDs7O0FBQ1FDLEVBQUFBLGVBQWUsQ0FBQ0MsS0FBRCxFQUFxQztBQUN4RCxVQUFNQyxHQUF3QixHQUFHO0FBQzdCLE9BQUNiLHFDQUFrQkMsTUFBbkIsR0FBNEIsRUFEQztBQUU3QixPQUFDRCxxQ0FBa0JFLEdBQW5CLEdBQXlC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Q0FBQyxJQUFJbEUsY0FBYyxDQUFDbUMsTUFBcEMsRUFBNEMrQixDQUFDLEVBQTdDLEVBQWlEO0FBQzdDLFlBQU1XLE9BQU8sR0FBRzdFLGNBQWMsQ0FBQ2tFLENBQUMsR0FBRyxDQUFMLENBQTlCO0FBQ0EsWUFBTVksT0FBTyxHQUFHOUUsY0FBYyxDQUFDa0UsQ0FBRCxDQUE5Qjs7QUFFQSxVQUFJOUIsT0FBTyxDQUFDeUMsT0FBRCxDQUFQLEdBQW1CekMsT0FBTyxDQUFDMEMsT0FBRCxDQUE5QixFQUF5QztBQUNyQztBQUNBL0IsdUJBQU9DLElBQVAsQ0FDSyxrQ0FBaUM2QixPQUFRLE9BQU16QyxPQUFPLENBQUN5QyxPQUFELENBQVUsZUFBakUsR0FDQyxRQUFPQyxPQUFRLE9BQU0xQyxPQUFPLENBQUMwQyxPQUFELENBQVUsdURBRjNDLEVBRnFDLENBTXJDOztBQUNIO0FBQ0o7QUFDSjs7QUFqTnNEIiwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE4LCAyMDE5IE5ldyBWZWN0b3IgTHRkXG5Db3B5cmlnaHQgMjAyMCBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB7IFJvb20gfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvbW9kZWxzL3Jvb21cIjtcbmltcG9ydCB7IFJvb21VcGRhdGVDYXVzZSwgVGFnSUQgfSBmcm9tIFwiLi4vLi4vbW9kZWxzXCI7XG5pbXBvcnQgeyBTb3J0QWxnb3JpdGhtIH0gZnJvbSBcIi4uL21vZGVsc1wiO1xuaW1wb3J0IHsgc29ydFJvb21zV2l0aEFsZ29yaXRobSB9IGZyb20gXCIuLi90YWctc29ydGluZ1wiO1xuaW1wb3J0IHsgT3JkZXJpbmdBbGdvcml0aG0gfSBmcm9tIFwiLi9PcmRlcmluZ0FsZ29yaXRobVwiO1xuaW1wb3J0IHsgTm90aWZpY2F0aW9uQ29sb3IgfSBmcm9tIFwiLi4vLi4vLi4vbm90aWZpY2F0aW9ucy9Ob3RpZmljYXRpb25Db2xvclwiO1xuaW1wb3J0IHsgUm9vbU5vdGlmaWNhdGlvblN0YXRlU3RvcmUgfSBmcm9tIFwiLi4vLi4vLi4vbm90aWZpY2F0aW9ucy9Sb29tTm90aWZpY2F0aW9uU3RhdGVTdG9yZVwiO1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvbG9nZ2VyXCI7XG5cbmludGVyZmFjZSBJQ2F0ZWdvcml6ZWRSb29tTWFwIHtcbiAgICAvLyBAdHMtaWdub3JlIC0gVFMgd2FudHMgdGhpcyB0byBiZSBhIHN0cmluZywgYnV0IHdlIGtub3cgYmV0dGVyXG4gICAgW2NhdGVnb3J5OiBOb3RpZmljYXRpb25Db2xvcl06IFJvb21bXTtcbn1cblxuaW50ZXJmYWNlIElDYXRlZ29yeUluZGV4IHtcbiAgICAvLyBAdHMtaWdub3JlIC0gVFMgd2FudHMgdGhpcyB0byBiZSBhIHN0cmluZywgYnV0IHdlIGtub3cgYmV0dGVyXG4gICAgW2NhdGVnb3J5OiBOb3RpZmljYXRpb25Db2xvcl06IG51bWJlcjsgLy8gaW50ZWdlclxufVxuXG4vLyBDYXV0aW9uOiBjaGFuZ2luZyB0aGlzIG1lYW5zIHlvdSdsbCBuZWVkIHRvIHVwZGF0ZSBhIGJ1bmNoIG9mIGFzc3VtcHRpb25zIGFuZFxuLy8gY29tbWVudHMhIENoZWNrIHRoZSB1c2FnZSBvZiBDYXRlZ29yeSBjYXJlZnVsbHkgdG8gZmlndXJlIG91dCB3aGF0IG5lZWRzIGNoYW5naW5nXG4vLyBpZiB5b3UncmUgZ29pbmcgdG8gY2hhbmdlIHRoaXMgYXJyYXkncyBvcmRlci5cbmNvbnN0IENBVEVHT1JZX09SREVSID0gW1xuICAgIE5vdGlmaWNhdGlvbkNvbG9yLlVuc2VudCxcbiAgICBOb3RpZmljYXRpb25Db2xvci5SZWQsXG4gICAgTm90aWZpY2F0aW9uQ29sb3IuR3JleSxcbiAgICBOb3RpZmljYXRpb25Db2xvci5Cb2xkLFxuICAgIE5vdGlmaWNhdGlvbkNvbG9yLk5vbmUsIC8vIGlkbGVcbl07XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIFwiaW1wb3J0YW5jZVwiIGFsZ29yaXRobSBmb3Igcm9vbSBsaXN0IHNvcnRpbmcuIFdoZXJlXG4gKiB0aGUgdGFnIHNvcnRpbmcgYWxnb3JpdGhtIGRvZXMgbm90IGludGVyZmVyZSwgcm9vbXMgd2lsbCBiZSBvcmRlcmVkIGludG9cbiAqIGNhdGVnb3JpZXMgb2YgdmFyeWluZyBpbXBvcnRhbmNlIHRvIHRoZSB1c2VyLiBBbHBoYWJldGljYWwgc29ydGluZyBkb2VzIG5vdFxuICogaW50ZXJmZXJlIHdpdGggdGhpcyBhbGdvcml0aG0sIGhvd2V2ZXIgbWFudWFsIG9yZGVyaW5nIGRvZXMuXG4gKlxuICogVGhlIGltcG9ydGFuY2Ugb2YgYSByb29tIGlzIGRlZmluZWQgYnkgdGhlIGtpbmQgb2Ygbm90aWZpY2F0aW9ucywgaWYgYW55LCBhcmVcbiAqIHByZXNlbnQgb24gdGhlIHJvb20uIFRoZXNlIGFyZSBjbGFzc2lmaWVkIGludGVybmFsbHkgYXMgVW5zZW50LCBSZWQsIEdyZXksXG4gKiBCb2xkLCBhbmQgSWRsZS4gJ1Vuc2VudCcgcm9vbXMgaGF2ZSB1bnNlbnQgbWVzc2FnZXMsIFJlZCByb29tcyBoYXZlIG1lbnRpb25zLFxuICogZ3JleSBoYXZlIHVucmVhZCBtZXNzYWdlcywgYm9sZCBpcyBhIGxlc3Mgbm9pc3kgdmVyc2lvbiBvZiBncmV5LCBhbmQgaWRsZVxuICogbWVhbnMgYWxsIGFjdGl2aXR5IGhhcyBiZWVuIHNlZW4gYnkgdGhlIHVzZXIuXG4gKlxuICogVGhlIGFsZ29yaXRobSB3b3JrcyBieSBtb25pdG9yaW5nIGFsbCByb29tIGNoYW5nZXMsIGluY2x1ZGluZyBuZXcgbWVzc2FnZXMgaW5cbiAqIHRyYWNrZWQgcm9vbXMsIHRvIGRldGVybWluZSBpZiBpdCBuZWVkcyBhIG5ldyBjYXRlZ29yeSBvciBkaWZmZXJlbnQgcGxhY2VtZW50XG4gKiB3aXRoaW4gdGhlIHNhbWUgY2F0ZWdvcnkuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIGNvbW1lbnRzIGNvbnRhaW5lZFxuICogd2l0aGluIHRoZSBjbGFzcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEltcG9ydGFuY2VBbGdvcml0aG0gZXh0ZW5kcyBPcmRlcmluZ0FsZ29yaXRobSB7XG4gICAgLy8gVGhpcyB0cmFja3MgdGhlIGNhdGVnb3J5IGZvciB0aGUgdGFnIGl0IHJlcHJlc2VudHMgYnkgdHJhY2tpbmcgdGhlIGluZGV4IG9mXG4gICAgLy8gZWFjaCBjYXRlZ29yeSB3aXRoaW4gdGhlIGxpc3QsIHdoZXJlIHplcm8gaXMgdGhlIHRvcCBvZiB0aGUgbGlzdC4gVGhpcyB0aGVuXG4gICAgLy8gdHJhY2tzIHdoZW4gcm9vbXMgY2hhbmdlIGNhdGVnb3JpZXMgYW5kIHNwbGljZXMgdGhlIG9yZGVyZWRSb29tcyBhcnJheSBhc1xuICAgIC8vIG5lZWRlZCwgcHJldmVudGluZyBtYW55IG9yZGVyaW5nIG9wZXJhdGlvbnMuXG5cbiAgICBwcml2YXRlIGluZGljZXM6IElDYXRlZ29yeUluZGV4ID0ge307XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IodGFnSWQ6IFRhZ0lELCBpbml0aWFsU29ydGluZ0FsZ29yaXRobTogU29ydEFsZ29yaXRobSkge1xuICAgICAgICBzdXBlcih0YWdJZCwgaW5pdGlhbFNvcnRpbmdBbGdvcml0aG0pO1xuICAgIH1cblxuICAgIC8vIG5vaW5zcGVjdGlvbiBKU01ldGhvZENhbkJlU3RhdGljXG4gICAgcHJpdmF0ZSBjYXRlZ29yaXplUm9vbXMocm9vbXM6IFJvb21bXSk6IElDYXRlZ29yaXplZFJvb21NYXAge1xuICAgICAgICBjb25zdCBtYXA6IElDYXRlZ29yaXplZFJvb21NYXAgPSB7XG4gICAgICAgICAgICBbTm90aWZpY2F0aW9uQ29sb3IuVW5zZW50XTogW10sXG4gICAgICAgICAgICBbTm90aWZpY2F0aW9uQ29sb3IuUmVkXTogW10sXG4gICAgICAgICAgICBbTm90aWZpY2F0aW9uQ29sb3IuR3JleV06IFtdLFxuICAgICAgICAgICAgW05vdGlmaWNhdGlvbkNvbG9yLkJvbGRdOiBbXSxcbiAgICAgICAgICAgIFtOb3RpZmljYXRpb25Db2xvci5Ob25lXTogW10sXG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3Qgcm9vbSBvZiByb29tcykge1xuICAgICAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSB0aGlzLmdldFJvb21DYXRlZ29yeShyb29tKTtcbiAgICAgICAgICAgIG1hcFtjYXRlZ29yeV0ucHVzaChyb29tKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cblxuICAgIC8vIG5vaW5zcGVjdGlvbiBKU01ldGhvZENhbkJlU3RhdGljXG4gICAgcHJpdmF0ZSBnZXRSb29tQ2F0ZWdvcnkocm9vbTogUm9vbSk6IE5vdGlmaWNhdGlvbkNvbG9yIHtcbiAgICAgICAgLy8gSXQncyBmaW5lIGZvciB1cyB0byBjYWxsIHRoaXMgYSBsb3QgYmVjYXVzZSBpdCdzIGNhY2hlZCwgYW5kIHdlIHNob3VsZG4ndCBiZVxuICAgICAgICAvLyB3YXN0aW5nIGFueXRoaW5nIGJ5IGRvaW5nIHNvIGFzIHRoZSBzdG9yZSBob2xkcyBzaW5nbGUgcmVmZXJlbmNlc1xuICAgICAgICBjb25zdCBzdGF0ZSA9IFJvb21Ob3RpZmljYXRpb25TdGF0ZVN0b3JlLmluc3RhbmNlLmdldFJvb21TdGF0ZShyb29tKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmNvbG9yO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXRSb29tcyhyb29tczogUm9vbVtdKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnNvcnRpbmdBbGdvcml0aG0gPT09IFNvcnRBbGdvcml0aG0uTWFudWFsKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlZE9yZGVyZWRSb29tcyA9IHNvcnRSb29tc1dpdGhBbGdvcml0aG0ocm9vbXMsIHRoaXMudGFnSWQsIHRoaXMuc29ydGluZ0FsZ29yaXRobSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBFdmVyeSBvdGhlciBzb3J0aW5nIHR5cGUgYWZmZWN0cyB0aGUgY2F0ZWdvcmllcywgbm90IHRoZSB3aG9sZSB0YWcuXG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yaXplZCA9IHRoaXMuY2F0ZWdvcml6ZVJvb21zKHJvb21zKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2F0ZWdvcnkgb2YgT2JqZWN0LmtleXMoY2F0ZWdvcml6ZWQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm9vbXNUb09yZGVyID0gY2F0ZWdvcml6ZWRbY2F0ZWdvcnldO1xuICAgICAgICAgICAgICAgIGNhdGVnb3JpemVkW2NhdGVnb3J5XSA9IHNvcnRSb29tc1dpdGhBbGdvcml0aG0ocm9vbXNUb09yZGVyLCB0aGlzLnRhZ0lkLCB0aGlzLnNvcnRpbmdBbGdvcml0aG0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBuZXdseU9yZ2FuaXplZDogUm9vbVtdID0gW107XG4gICAgICAgICAgICBjb25zdCBuZXdJbmRpY2VzOiBJQ2F0ZWdvcnlJbmRleCA9IHt9O1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNhdGVnb3J5IG9mIENBVEVHT1JZX09SREVSKSB7XG4gICAgICAgICAgICAgICAgbmV3SW5kaWNlc1tjYXRlZ29yeV0gPSBuZXdseU9yZ2FuaXplZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbmV3bHlPcmdhbml6ZWQucHVzaCguLi5jYXRlZ29yaXplZFtjYXRlZ29yeV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmluZGljZXMgPSBuZXdJbmRpY2VzO1xuICAgICAgICAgICAgdGhpcy5jYWNoZWRPcmRlcmVkUm9vbXMgPSBuZXdseU9yZ2FuaXplZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlU3BsaWNlKHJvb206IFJvb20sIGNhdXNlOiBSb29tVXBkYXRlQ2F1c2UpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKGNhdXNlID09PSBSb29tVXBkYXRlQ2F1c2UuTmV3Um9vbSkge1xuICAgICAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSB0aGlzLmdldFJvb21DYXRlZ29yeShyb29tKTtcbiAgICAgICAgICAgIHRoaXMuYWx0ZXJDYXRlZ29yeVBvc2l0aW9uQnkoY2F0ZWdvcnksIDEsIHRoaXMuaW5kaWNlcyk7XG4gICAgICAgICAgICB0aGlzLmNhY2hlZE9yZGVyZWRSb29tcy5zcGxpY2UodGhpcy5pbmRpY2VzW2NhdGVnb3J5XSwgMCwgcm9vbSk7IC8vIHNwbGljZSBpbiB0aGUgbmV3IHJvb20gKHByZS1hZGp1c3RlZClcbiAgICAgICAgICAgIHRoaXMuc29ydENhdGVnb3J5KGNhdGVnb3J5KTtcbiAgICAgICAgfSBlbHNlIGlmIChjYXVzZSA9PT0gUm9vbVVwZGF0ZUNhdXNlLlJvb21SZW1vdmVkKSB7XG4gICAgICAgICAgICBjb25zdCByb29tSWR4ID0gdGhpcy5nZXRSb29tSW5kZXgocm9vbSk7XG4gICAgICAgICAgICBpZiAocm9vbUlkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgVHJpZWQgdG8gcmVtb3ZlIHVua25vd24gcm9vbSBmcm9tICR7dGhpcy50YWdJZH06ICR7cm9vbS5yb29tSWR9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBubyBjaGFuZ2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9sZENhdGVnb3J5ID0gdGhpcy5nZXRDYXRlZ29yeUZyb21JbmRpY2VzKHJvb21JZHgsIHRoaXMuaW5kaWNlcyk7XG4gICAgICAgICAgICB0aGlzLmFsdGVyQ2F0ZWdvcnlQb3NpdGlvbkJ5KG9sZENhdGVnb3J5LCAtMSwgdGhpcy5pbmRpY2VzKTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkT3JkZXJlZFJvb21zLnNwbGljZShyb29tSWR4LCAxKTsgLy8gcmVtb3ZlIHRoZSByb29tXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaGFuZGxlZCBzcGxpY2U6ICR7Y2F1c2V9YCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGFuZ2VzIGhhdmUgYmVlbiBtYWRlIGlmIHdlIG1hZGUgaXQgaGVyZSwgc28gc2F5IHNvXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBoYW5kbGVSb29tVXBkYXRlKHJvb206IFJvb20sIGNhdXNlOiBSb29tVXBkYXRlQ2F1c2UpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKGNhdXNlID09PSBSb29tVXBkYXRlQ2F1c2UuTmV3Um9vbSB8fCBjYXVzZSA9PT0gUm9vbVVwZGF0ZUNhdXNlLlJvb21SZW1vdmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTcGxpY2Uocm9vbSwgY2F1c2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhdXNlICE9PSBSb29tVXBkYXRlQ2F1c2UuVGltZWxpbmUgJiYgY2F1c2UgIT09IFJvb21VcGRhdGVDYXVzZS5SZWFkUmVjZWlwdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB1cGRhdGUgY2F1c2U6ICR7Y2F1c2V9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjYXRlZ29yeSA9IHRoaXMuZ2V0Um9vbUNhdGVnb3J5KHJvb20pO1xuICAgICAgICBpZiAodGhpcy5zb3J0aW5nQWxnb3JpdGhtID09PSBTb3J0QWxnb3JpdGhtLk1hbnVhbCkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBOb3RoaW5nIHRvIGRvIGhlcmUuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByb29tSWR4ID0gdGhpcy5nZXRSb29tSW5kZXgocm9vbSk7XG4gICAgICAgIGlmIChyb29tSWR4ID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSb29tICR7cm9vbS5yb29tSWR9IGhhcyBubyBpbmRleCBpbiAke3RoaXMudGFnSWR9YCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcnkgdG8gYXZvaWQgZG9pbmcgYXJyYXkgb3BlcmF0aW9ucyBpZiB3ZSBkb24ndCBoYXZlIHRvOiBvbmx5IG1vdmUgcm9vbXMgd2l0aGluXG4gICAgICAgIC8vIHRoZSBjYXRlZ29yaWVzIGlmIHdlJ3JlIGp1bXBpbmcgY2F0ZWdvcmllc1xuICAgICAgICBjb25zdCBvbGRDYXRlZ29yeSA9IHRoaXMuZ2V0Q2F0ZWdvcnlGcm9tSW5kaWNlcyhyb29tSWR4LCB0aGlzLmluZGljZXMpO1xuICAgICAgICBpZiAob2xkQ2F0ZWdvcnkgIT09IGNhdGVnb3J5KSB7XG4gICAgICAgICAgICAvLyBNb3ZlIHRoZSByb29tIGFuZCB1cGRhdGUgdGhlIGluZGljZXNcbiAgICAgICAgICAgIHRoaXMubW92ZVJvb21JbmRleGVzKDEsIG9sZENhdGVnb3J5LCBjYXRlZ29yeSwgdGhpcy5pbmRpY2VzKTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkT3JkZXJlZFJvb21zLnNwbGljZShyb29tSWR4LCAxKTsgLy8gc3BsaWNlIG91dCB0aGUgb2xkIGluZGV4IChmaXhlZCBwb3NpdGlvbilcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkT3JkZXJlZFJvb21zLnNwbGljZSh0aGlzLmluZGljZXNbY2F0ZWdvcnldLCAwLCByb29tKTsgLy8gc3BsaWNlIGluIHRoZSBuZXcgcm9vbSAocHJlLWFkanVzdGVkKVxuICAgICAgICAgICAgLy8gTm90ZTogaWYgbW92ZVJvb21JbmRleGVzKCkgaXMgY2FsbGVkIGFmdGVyIHRoZSBzcGxpY2UgdGhlbiB0aGUgaW5zZXJ0IG9wZXJhdGlvblxuICAgICAgICAgICAgLy8gd2lsbCBoYXBwZW4gaW4gdGhlIHdyb25nIHBsYWNlLiBCZWNhdXNlIHdlIHdvdWxkIGhhdmUgYWxyZWFkeSBhZGp1c3RlZCB0aGUgaW5kZXhcbiAgICAgICAgICAgIC8vIGZvciB0aGUgY2F0ZWdvcnksIHdlIGRvbid0IG5lZWQgdG8gZGV0ZXJtaW5lIGhvdyB0aGUgcm9vbSBpcyBtb3ZpbmcgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICAvLyBJZiB3ZSBpbnN0ZWFkIHRyaWVkIHRvIGluc2VydCBiZWZvcmUgdXBkYXRpbmcgdGhlIGluZGljZXMsIHdlJ2QgaGF2ZSB0byBkZXRlcm1pbmVcbiAgICAgICAgICAgIC8vIHdoZXRoZXIgdGhlIHJvb20gd2FzIG1vdmluZyBsYXRlciAodG93YXJkcyBJRExFKSBvciBlYXJsaWVyICh0b3dhcmRzIFJFRCkgZnJvbSBpdHNcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgcG9zaXRpb24sIGFzIGl0J2xsIGFmZmVjdCB0aGUgY2F0ZWdvcnkncyBzdGFydCBpbmRleCBhZnRlciB3ZSByZW1vdmUgdGhlXG4gICAgICAgICAgICAvLyByb29tIGZyb20gdGhlIGFycmF5LlxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU29ydCB0aGUgY2F0ZWdvcnkgbm93IHRoYXQgd2UndmUgZHVtcGVkIHRoZSByb29tIGluXG4gICAgICAgIHRoaXMuc29ydENhdGVnb3J5KGNhdGVnb3J5KTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gY2hhbmdlIG1hZGVcbiAgICB9XG5cbiAgICBwcml2YXRlIHNvcnRDYXRlZ29yeShjYXRlZ29yeTogTm90aWZpY2F0aW9uQ29sb3IpIHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgYmUgcmVsYXRpdmVseSBxdWljayBiZWNhdXNlIHRoZSByb29tIGlzIHVzdWFsbHkgaW5zZXJ0ZWQgYXQgdGhlIHRvcCBvZiB0aGVcbiAgICAgICAgLy8gY2F0ZWdvcnksIGFuZCBtb3N0IHBvcHVsYXIgc29ydGluZyBhbGdvcml0aG1zIHdpbGwgZGVhbCB3aXRoIHRyeWluZyB0byBrZWVwIHRoZSBhY3RpdmVcbiAgICAgICAgLy8gcm9vbSBhdCB0aGUgdG9wL3N0YXJ0IG9mIHRoZSBjYXRlZ29yeS4gRm9yIHRoZSBmZXcgYWxnb3JpdGhtcyB0aGF0IHdpbGwgaGF2ZSB0byBtb3ZlIHRoZVxuICAgICAgICAvLyB0aGluZyBxdWl0ZSBmYXIgKGFscGhhYmV0aWMgd2l0aCBhIFogcm9vbSBmb3IgZXhhbXBsZSksIHRoZSBsaXN0IHNob3VsZCBhbHJlYWR5IGJlIHNvcnRlZFxuICAgICAgICAvLyB3ZWxsIGVub3VnaCB0aGF0IGl0IGNhbiByaXAgdGhyb3VnaCB0aGUgYXJyYXkgYW5kIHNsb3QgdGhlIGNoYW5nZWQgcm9vbSBpbiBxdWlja2x5LlxuICAgICAgICBjb25zdCBuZXh0Q2F0ZWdvcnlTdGFydElkeCA9IGNhdGVnb3J5ID09PSBDQVRFR09SWV9PUkRFUltDQVRFR09SWV9PUkRFUi5sZW5ndGggLSAxXVxuICAgICAgICAgICAgPyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICAgICAgICAgICAgOiB0aGlzLmluZGljZXNbQ0FURUdPUllfT1JERVJbQ0FURUdPUllfT1JERVIuaW5kZXhPZihjYXRlZ29yeSkgKyAxXV07XG4gICAgICAgIGNvbnN0IHN0YXJ0SWR4ID0gdGhpcy5pbmRpY2VzW2NhdGVnb3J5XTtcbiAgICAgICAgY29uc3QgbnVtU29ydCA9IG5leHRDYXRlZ29yeVN0YXJ0SWR4IC0gc3RhcnRJZHg7IC8vIHNwbGljZSgpIHJldHVybnMgdXAgdG8gdGhlIG1heCwgc28gTUFYX1NBRkVfSU5UIGlzIGZpbmVcbiAgICAgICAgY29uc3QgdW5zb3J0ZWRTbGljZSA9IHRoaXMuY2FjaGVkT3JkZXJlZFJvb21zLnNwbGljZShzdGFydElkeCwgbnVtU29ydCk7XG4gICAgICAgIGNvbnN0IHNvcnRlZCA9IHNvcnRSb29tc1dpdGhBbGdvcml0aG0odW5zb3J0ZWRTbGljZSwgdGhpcy50YWdJZCwgdGhpcy5zb3J0aW5nQWxnb3JpdGhtKTtcbiAgICAgICAgdGhpcy5jYWNoZWRPcmRlcmVkUm9vbXMuc3BsaWNlKHN0YXJ0SWR4LCAwLCAuLi5zb3J0ZWQpO1xuICAgIH1cblxuICAgIC8vIG5vaW5zcGVjdGlvbiBKU01ldGhvZENhbkJlU3RhdGljXG4gICAgcHJpdmF0ZSBnZXRDYXRlZ29yeUZyb21JbmRpY2VzKGluZGV4OiBudW1iZXIsIGluZGljZXM6IElDYXRlZ29yeUluZGV4KTogTm90aWZpY2F0aW9uQ29sb3Ige1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENBVEVHT1JZX09SREVSLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yeSA9IENBVEVHT1JZX09SREVSW2ldO1xuICAgICAgICAgICAgY29uc3QgaXNMYXN0ID0gaSA9PT0gKENBVEVHT1JZX09SREVSLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRJZHggPSBpbmRpY2VzW2NhdGVnb3J5XTtcbiAgICAgICAgICAgIGNvbnN0IGVuZElkeCA9IGlzTGFzdCA/IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIDogaW5kaWNlc1tDQVRFR09SWV9PUkRFUltpICsgMV1dO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IHN0YXJ0SWR4ICYmIGluZGV4IDwgZW5kSWR4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdGVnb3J5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gXCJTaG91bGQgbmV2ZXIgaGFwcGVuXCIgZGlzY2xhaW1lciBnb2VzIGhlcmVcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvZ3JhbW1pbmcgZXJyb3I6IHNvbWVob3cgeW91J3ZlIGVuZGVkIHVwIHdpdGggYW4gaW5kZXggdGhhdCBpc24ndCBpbiBhIGNhdGVnb3J5XCIpO1xuICAgIH1cblxuICAgIC8vIG5vaW5zcGVjdGlvbiBKU01ldGhvZENhbkJlU3RhdGljXG4gICAgcHJpdmF0ZSBtb3ZlUm9vbUluZGV4ZXMoXG4gICAgICAgIG5Sb29tczogbnVtYmVyLFxuICAgICAgICBmcm9tQ2F0ZWdvcnk6IE5vdGlmaWNhdGlvbkNvbG9yLFxuICAgICAgICB0b0NhdGVnb3J5OiBOb3RpZmljYXRpb25Db2xvcixcbiAgICAgICAgaW5kaWNlczogSUNhdGVnb3J5SW5kZXgsXG4gICAgKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgdG8gdXBkYXRlIHRoZSBpbmRleCBvZiB0aGUgY2F0ZWdvcnkgKmFmdGVyKiB0aGUgZnJvbS90b0NhdGVnb3J5IHZhcmlhYmxlc1xuICAgICAgICAvLyBpbiBvcmRlciB0byB1cGRhdGUgdGhlIGluZGljZXMgY29ycmVjdGx5LiBCZWNhdXNlIHRoZSByb29tIGlzIG1vdmluZyBmcm9tL3RvIHRob3NlXG4gICAgICAgIC8vIGNhdGVnb3JpZXMsIHRoZSBuZXh0IGNhdGVnb3J5J3MgaW5kZXggd2lsbCBjaGFuZ2UgLSBub3QgdGhlIGNhdGVnb3J5IHdlJ3JlIG1vZGlmeWluZy5cbiAgICAgICAgLy8gV2UgYWxzbyBuZWVkIHRvIHVwZGF0ZSBzdWJzZXF1ZW50IGNhdGVnb3JpZXMgYXMgdGhleSdsbCBhbGwgc2hpZnQgYnkgblJvb21zLCBzbyB3ZVxuICAgICAgICAvLyBsb29wIG92ZXIgdGhlIG9yZGVyIHRvIGFjaGlldmUgdGhhdC5cblxuICAgICAgICB0aGlzLmFsdGVyQ2F0ZWdvcnlQb3NpdGlvbkJ5KGZyb21DYXRlZ29yeSwgLW5Sb29tcywgaW5kaWNlcyk7XG4gICAgICAgIHRoaXMuYWx0ZXJDYXRlZ29yeVBvc2l0aW9uQnkodG9DYXRlZ29yeSwgK25Sb29tcywgaW5kaWNlcyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhbHRlckNhdGVnb3J5UG9zaXRpb25CeShjYXRlZ29yeTogTm90aWZpY2F0aW9uQ29sb3IsIG46IG51bWJlciwgaW5kaWNlczogSUNhdGVnb3J5SW5kZXgpIHtcbiAgICAgICAgLy8gTm90ZTogd2hlbiB3ZSBhbHRlciBhIGNhdGVnb3J5J3MgaW5kZXgsIHdlIGFjdHVhbGx5IGhhdmUgdG8gbW9kaWZ5IHRoZSBvbmVzIGZvbGxvd2luZ1xuICAgICAgICAvLyB0aGUgdGFyZ2V0IGFuZCBub3QgdGhlIHRhcmdldCBpdHNlbGYuXG5cbiAgICAgICAgLy8gWFhYOiBJZiB0aGlzIGV2ZXIgYWN0dWFsbHkgZ2V0cyBtb3JlIHRoYW4gb25lIHJvb20gcGFzc2VkIHRvIGl0LCBpdCdsbCBuZWVkIG1vcmUgaW5kZXhcbiAgICAgICAgLy8gaGFuZGxpbmcuIEZvciBpbnN0YW5jZSwgaWYgNDUgcm9vbXMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgbWlkZGxlIG9mIGEgNTAgcm9vbSBsaXN0LCB0aGVcbiAgICAgICAgLy8gaW5kZXggZm9yIHRoZSBjYXRlZ29yaWVzIHdpbGwgYmUgd2F5IG9mZi5cblxuICAgICAgICBjb25zdCBuZXh0T3JkZXJJbmRleCA9IENBVEVHT1JZX09SREVSLmluZGV4T2YoY2F0ZWdvcnkpICsgMTtcbiAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbmV4dE9yZGVySW5kZXg7IGkgPCBDQVRFR09SWV9PUkRFUi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDYXRlZ29yeSA9IENBVEVHT1JZX09SREVSW2ldO1xuICAgICAgICAgICAgICAgIGluZGljZXNbbmV4dENhdGVnb3J5XSArPSBNYXRoLmFicyhuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChuIDwgMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IG5leHRPcmRlckluZGV4OyBpIDwgQ0FURUdPUllfT1JERVIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2F0ZWdvcnkgPSBDQVRFR09SWV9PUkRFUltpXTtcbiAgICAgICAgICAgICAgICBpbmRpY2VzW25leHRDYXRlZ29yeV0gLT0gTWF0aC5hYnMobik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEbyBhIHF1aWNrIGNoZWNrIHRvIHNlZSBpZiB3ZSd2ZSBjb21wbGV0ZWx5IGJyb2tlbiB0aGUgaW5kZXhcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gQ0FURUdPUllfT1JERVIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RDYXQgPSBDQVRFR09SWV9PUkRFUltpIC0gMV07XG4gICAgICAgICAgICBjb25zdCB0aGlzQ2F0ID0gQ0FURUdPUllfT1JERVJbaV07XG5cbiAgICAgICAgICAgIGlmIChpbmRpY2VzW2xhc3RDYXRdID4gaW5kaWNlc1t0aGlzQ2F0XSkge1xuICAgICAgICAgICAgICAgIC8vIFwic2hvdWxkIG5ldmVyIGhhcHBlblwiIGRpc2NsYWltZXIgZ29lcyBoZXJlXG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAgICAgICAgIGAhISBSb29tIGxpc3QgaW5kZXggY29ycnVwdGlvbjogJHtsYXN0Q2F0fSAoaToke2luZGljZXNbbGFzdENhdF19KSBpcyBncmVhdGVyIGAgK1xuICAgICAgICAgICAgICAgICAgICBgdGhhbiAke3RoaXNDYXR9IChpOiR7aW5kaWNlc1t0aGlzQ2F0XX0pIC0gY2F0ZWdvcnkgaW5kaWNlcyBhcmUgbGlrZWx5IGRlc3luY2VkIGZyb20gcmVhbGl0eWApO1xuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogUmVnZW5lcmF0ZSBpbmRleCB3aGVuIHRoaXMgaGFwcGVuczogaHR0cHM6Ly9naXRodWIuY29tL3ZlY3Rvci1pbS9lbGVtZW50LXdlYi9pc3N1ZXMvMTQyMzRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==