"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LIST_UPDATED_EVENT = exports.Algorithm = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _utils = require("matrix-js-sdk/src/utils");

var _events = require("events");

var _DMRoomMap = _interopRequireDefault(require("../../../utils/DMRoomMap"));

var _arrays = require("../../../utils/arrays");

var _models = require("../models");

var _IFilterCondition = require("../filters/IFilterCondition");

var _membership = require("../../../utils/membership");

var _listOrdering = require("./list-ordering");

var _VisibilityProvider = require("../filters/VisibilityProvider");

var _SpaceStore = _interopRequireDefault(require("../../spaces/SpaceStore"));

var _logger = require("matrix-js-sdk/src/logger");

/*
Copyright 2020, 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/**
 * Fired when the Algorithm has determined a list has been updated.
 */
const LIST_UPDATED_EVENT = "list_updated_event"; // These are the causes which require a room to be known in order for us to handle them. If
// a cause in this list is raised and we don't know about the room, we don't handle the update.
//
// Note: these typically happen when a new room is coming in, such as the user creating or
// joining the room. For these cases, we need to know about the room prior to handling it otherwise
// we'll make bad assumptions.

exports.LIST_UPDATED_EVENT = LIST_UPDATED_EVENT;
const CAUSES_REQUIRING_ROOM = [_models.RoomUpdateCause.Timeline, _models.RoomUpdateCause.ReadReceipt];

/**
 * Represents a list ordering algorithm. This class will take care of tag
 * management (which rooms go in which tags) and ask the implementation to
 * deal with ordering mechanics.
 */
class Algorithm extends _events.EventEmitter {
  // a clone of the _cachedRooms, with the sticky room
  // only not-null when changing the sticky room

  /**
   * Set to true to suspend emissions of algorithm updates.
   */
  constructor() {
    super();
    (0, _defineProperty2.default)(this, "_cachedRooms", {});
    (0, _defineProperty2.default)(this, "_cachedStickyRooms", {});
    (0, _defineProperty2.default)(this, "filteredRooms", {});
    (0, _defineProperty2.default)(this, "_stickyRoom", null);
    (0, _defineProperty2.default)(this, "_lastStickyRoom", null);
    (0, _defineProperty2.default)(this, "sortAlgorithms", void 0);
    (0, _defineProperty2.default)(this, "listAlgorithms", void 0);
    (0, _defineProperty2.default)(this, "algorithms", void 0);
    (0, _defineProperty2.default)(this, "rooms", []);
    (0, _defineProperty2.default)(this, "roomIdsToTags", {});
    (0, _defineProperty2.default)(this, "allowedByFilter", new Map());
    (0, _defineProperty2.default)(this, "allowedRoomsByFilters", new Set());
    (0, _defineProperty2.default)(this, "updatesInhibited", false);
  }

  get stickyRoom() {
    return this._stickyRoom ? this._stickyRoom.room : null;
  }

  get knownRooms() {
    return this.rooms;
  }

  get hasTagSortingMap() {
    return !!this.sortAlgorithms;
  }

  get hasFilters() {
    return this.allowedByFilter.size > 0;
  }

  set cachedRooms(val) {
    this._cachedRooms = val;
    this.recalculateFilteredRooms();
    this.recalculateStickyRoom();
  }

  get cachedRooms() {
    // 🐉 Here be dragons.
    // Note: this is used by the underlying algorithm classes, so don't make it return
    // the sticky room cache. If it ends up returning the sticky room cache, we end up
    // corrupting our caches and confusing them.
    return this._cachedRooms;
  }
  /**
   * Awaitable version of the sticky room setter.
   * @param val The new room to sticky.
   */


  setStickyRoom(val) {
    try {
      this.updateStickyRoom(val);
    } catch (e) {
      _logger.logger.warn("Failed to update sticky room", e);
    }
  }

  getTagSorting(tagId) {
    if (!this.sortAlgorithms) return null;
    return this.sortAlgorithms[tagId];
  }

  setTagSorting(tagId, sort) {
    if (!tagId) throw new Error("Tag ID must be defined");
    if (!sort) throw new Error("Algorithm must be defined");
    this.sortAlgorithms[tagId] = sort;
    const algorithm = this.algorithms[tagId];
    algorithm.setSortAlgorithm(sort);
    this._cachedRooms[tagId] = algorithm.orderedRooms;
    this.recalculateFilteredRoomsForTag(tagId); // update filter to re-sort the list

    this.recalculateStickyRoom(tagId); // update sticky room to make sure it appears if needed
  }

  getListOrdering(tagId) {
    if (!this.listAlgorithms) return null;
    return this.listAlgorithms[tagId];
  }

  setListOrdering(tagId, order) {
    if (!tagId) throw new Error("Tag ID must be defined");
    if (!order) throw new Error("Algorithm must be defined");
    this.listAlgorithms[tagId] = order;
    const algorithm = (0, _listOrdering.getListAlgorithmInstance)(order, tagId, this.sortAlgorithms[tagId]);
    this.algorithms[tagId] = algorithm;
    algorithm.setRooms(this._cachedRooms[tagId]);
    this._cachedRooms[tagId] = algorithm.orderedRooms;
    this.recalculateFilteredRoomsForTag(tagId); // update filter to re-sort the list

    this.recalculateStickyRoom(tagId); // update sticky room to make sure it appears if needed
  }

  addFilterCondition(filterCondition) {
    // Populate the cache of the new filter
    this.allowedByFilter.set(filterCondition, this.rooms.filter(r => filterCondition.isVisible(r)));
    this.recalculateFilteredRooms();
    filterCondition.on(_IFilterCondition.FILTER_CHANGED, this.handleFilterChange.bind(this));
  }

  removeFilterCondition(filterCondition) {
    filterCondition.off(_IFilterCondition.FILTER_CHANGED, this.handleFilterChange.bind(this));

    if (this.allowedByFilter.has(filterCondition)) {
      this.allowedByFilter.delete(filterCondition);
      this.recalculateFilteredRooms(); // If we removed the last filter, tell consumers that we've "updated" our filtered
      // view. This will trick them into getting the complete room list.

      if (!this.hasFilters && !this.updatesInhibited) {
        this.emit(LIST_UPDATED_EVENT);
      }
    }
  }

  handleFilterChange() {
    this.recalculateFilteredRooms(); // re-emit the update so the list store can fire an off-cycle update if needed

    if (this.updatesInhibited) return;
    this.emit(_IFilterCondition.FILTER_CHANGED);
  }

  updateStickyRoom(val) {
    this.doUpdateStickyRoom(val);
    this._lastStickyRoom = null; // clear to indicate we're done changing
  }

  doUpdateStickyRoom(val) {
    var _val, _this$roomIdsToTags$v;

    if (_SpaceStore.default.spacesEnabled && (_val = val) !== null && _val !== void 0 && _val.isSpaceRoom() && val.getMyMembership() !== "invite") {
      // no-op sticky rooms for spaces - they're effectively virtual rooms
      val = null;
    }

    if (val && !_VisibilityProvider.VisibilityProvider.instance.isRoomVisible(val)) {
      val = null; // the room isn't visible - lie to the rest of this function
    } // Set the last sticky room to indicate that we're in a change. The code throughout the
    // class can safely handle a null room, so this should be safe to do as a backup.


    this._lastStickyRoom = this._stickyRoom || {}; // It's possible to have no selected room. In that case, clear the sticky room

    if (!val) {
      if (this._stickyRoom) {
        const stickyRoom = this._stickyRoom.room;
        this._stickyRoom = null; // clear before we go to update the algorithm
        // Lie to the algorithm and re-add the room to the algorithm

        this.handleRoomUpdate(stickyRoom, _models.RoomUpdateCause.NewRoom);
        return;
      }

      return;
    } // When we do have a room though, we expect to be able to find it


    let tag = (_this$roomIdsToTags$v = this.roomIdsToTags[val.roomId]) === null || _this$roomIdsToTags$v === void 0 ? void 0 : _this$roomIdsToTags$v[0];
    if (!tag) throw new Error(`${val.roomId} does not belong to a tag and cannot be sticky`); // We specifically do NOT use the ordered rooms set as it contains the sticky room, which
    // means we'll be off by 1 when the user is switching rooms. This leads to visual jumping
    // when the user is moving south in the list (not north, because of math).

    const tagList = this.getOrderedRoomsWithoutSticky()[tag] || []; // can be null if filtering

    let position = tagList.indexOf(val); // We do want to see if a tag change happened though - if this did happen then we'll want
    // to force the position to zero (top) to ensure we can properly handle it.

    const wasSticky = this._lastStickyRoom.room ? this._lastStickyRoom.room.roomId === val.roomId : false;

    if (this._lastStickyRoom.tag && tag !== this._lastStickyRoom.tag && wasSticky && position < 0) {
      _logger.logger.warn(`Sticky room ${val.roomId} changed tags during sticky room handling`);

      position = 0;
    } // Sanity check the position to make sure the room is qualified for being sticky


    if (position < 0) throw new Error(`${val.roomId} does not appear to be known and cannot be sticky`); // 🐉 Here be dragons.
    // Before we can go through with lying to the underlying algorithm about a room
    // we need to ensure that when we do we're ready for the inevitable sticky room
    // update we'll receive. To prepare for that, we first remove the sticky room and
    // recalculate the state ourselves so that when the underlying algorithm calls for
    // the same thing it no-ops. After we're done calling the algorithm, we'll issue
    // a new update for ourselves.

    const lastStickyRoom = this._stickyRoom;
    this._stickyRoom = null; // clear before we update the algorithm

    this.recalculateStickyRoom(); // When we do have the room, re-add the old room (if needed) to the algorithm
    // and remove the sticky room from the algorithm. This is so the underlying
    // algorithm doesn't try and confuse itself with the sticky room concept.
    // We don't add the new room if the sticky room isn't changing because that's
    // an easy way to cause duplication. We have to do room ID checks instead of
    // referential checks as the references can differ through the lifecycle.

    if (lastStickyRoom && lastStickyRoom.room && lastStickyRoom.room.roomId !== val.roomId) {
      // Lie to the algorithm and re-add the room to the algorithm
      this.handleRoomUpdate(lastStickyRoom.room, _models.RoomUpdateCause.NewRoom);
    } // Lie to the algorithm and remove the room from it's field of view


    this.handleRoomUpdate(val, _models.RoomUpdateCause.RoomRemoved); // Check for tag & position changes while we're here. We also check the room to ensure
    // it is still the same room.

    if (this._stickyRoom) {
      if (this._stickyRoom.room !== val) {
        // Check the room IDs just in case
        if (this._stickyRoom.room.roomId === val.roomId) {
          _logger.logger.warn("Sticky room changed references");
        } else {
          throw new Error("Sticky room changed while the sticky room was changing");
        }
      }

      _logger.logger.warn(`Sticky room changed tag & position from ${tag} / ${position} ` + `to ${this._stickyRoom.tag} / ${this._stickyRoom.position}`);

      tag = this._stickyRoom.tag;
      position = this._stickyRoom.position;
    } // Now that we're done lying to the algorithm, we need to update our position
    // marker only if the user is moving further down the same list. If they're switching
    // lists, or moving upwards, the position marker will splice in just fine but if
    // they went downwards in the same list we'll be off by 1 due to the shifting rooms.


    if (lastStickyRoom && lastStickyRoom.tag === tag && lastStickyRoom.position <= position) {
      position++;
    }

    this._stickyRoom = {
      room: val,
      position: position,
      tag: tag
    }; // We update the filtered rooms just in case, as otherwise users will end up visiting
    // a room while filtering and it'll disappear. We don't update the filter earlier in
    // this function simply because we don't have to.

    this.recalculateFilteredRoomsForTag(tag);
    if (lastStickyRoom && lastStickyRoom.tag !== tag) this.recalculateFilteredRoomsForTag(lastStickyRoom.tag);
    this.recalculateStickyRoom(); // Finally, trigger an update

    if (this.updatesInhibited) return;
    this.emit(LIST_UPDATED_EVENT);
  }

  recalculateFilteredRooms() {
    if (!this.hasFilters) {
      return;
    }

    _logger.logger.warn("Recalculating filtered room list");

    const filters = Array.from(this.allowedByFilter.keys());
    const newMap = {};

    for (const tagId of Object.keys(this.cachedRooms)) {
      // Cheaply clone the rooms so we can more easily do operations on the list.
      // We optimize our lookups by trying to reduce sample size as much as possible
      // to the rooms we know will be deduped by the Set.
      const rooms = this.cachedRooms[tagId].map(r => r); // cheap clone

      this.tryInsertStickyRoomToFilterSet(rooms, tagId);
      const remainingRooms = rooms.map(r => r);
      const allowedRoomsInThisTag = [];

      for (const filter of filters) {
        const filteredRooms = remainingRooms.filter(r => filter.isVisible(r));

        for (const room of filteredRooms) {
          const idx = remainingRooms.indexOf(room);
          if (idx >= 0) remainingRooms.splice(idx, 1);
          allowedRoomsInThisTag.push(room);
        }
      }

      newMap[tagId] = allowedRoomsInThisTag;
    }

    const allowedRooms = Object.values(newMap).reduce((rv, v) => {
      rv.push(...v);
      return rv;
    }, []);
    this.allowedRoomsByFilters = new Set(allowedRooms);
    this.filteredRooms = newMap;
    if (this.updatesInhibited) return;
    this.emit(LIST_UPDATED_EVENT);
  }

  recalculateFilteredRoomsForTag(tagId) {
    if (!this.hasFilters) return; // don't bother doing work if there's nothing to do

    delete this.filteredRooms[tagId];
    const rooms = this.cachedRooms[tagId].map(r => r); // cheap clone

    this.tryInsertStickyRoomToFilterSet(rooms, tagId);
    const filteredRooms = rooms.filter(r => this.allowedRoomsByFilters.has(r));

    if (filteredRooms.length > 0) {
      this.filteredRooms[tagId] = filteredRooms;
    }
  }

  tryInsertStickyRoomToFilterSet(rooms, tagId) {
    if (!this._stickyRoom || !this._stickyRoom.room || this._stickyRoom.tag !== tagId) return;
    const position = this._stickyRoom.position;

    if (position >= rooms.length) {
      rooms.push(this._stickyRoom.room);
    } else {
      rooms.splice(position, 0, this._stickyRoom.room);
    }
  }
  /**
   * Recalculate the sticky room position. If this is being called in relation to
   * a specific tag being updated, it should be given to this function to optimize
   * the call.
   * @param updatedTag The tag that was updated, if possible.
   */


  recalculateStickyRoom(updatedTag = null) {
    // 🐉 Here be dragons.
    // This function does far too much for what it should, and is called by many places.
    // Not only is this responsible for ensuring the sticky room is held in place at all
    // times, it is also responsible for ensuring our clone of the cachedRooms is up to
    // date. If either of these desyncs, we see weird behaviour like duplicated rooms,
    // outdated lists, and other nonsensical issues that aren't necessarily obvious.
    if (!this._stickyRoom) {
      // If there's no sticky room, just do nothing useful.
      if (!!this._cachedStickyRooms) {
        // Clear the cache if we won't be needing it
        this._cachedStickyRooms = null;
        if (this.updatesInhibited) return;
        this.emit(LIST_UPDATED_EVENT);
      }

      return;
    }

    if (!this._cachedStickyRooms || !updatedTag) {
      const stickiedTagMap = {};

      for (const tagId of Object.keys(this.cachedRooms)) {
        stickiedTagMap[tagId] = this.cachedRooms[tagId].map(r => r); // shallow clone
      }

      this._cachedStickyRooms = stickiedTagMap;
    }

    if (updatedTag) {
      // Update the tag indicated by the caller, if possible. This is mostly to ensure
      // our cache is up to date.
      this._cachedStickyRooms[updatedTag] = this.cachedRooms[updatedTag].map(r => r); // shallow clone
    } // Now try to insert the sticky room, if we need to.
    // We need to if there's no updated tag (we regenned the whole cache) or if the tag
    // we might have updated from the cache is also our sticky room.


    const sticky = this._stickyRoom;

    if (!updatedTag || updatedTag === sticky.tag) {
      this._cachedStickyRooms[sticky.tag].splice(sticky.position, 0, sticky.room);
    } // Finally, trigger an update


    if (this.updatesInhibited) return;
    this.emit(LIST_UPDATED_EVENT);
  }
  /**
   * Asks the Algorithm to regenerate all lists, using the tags given
   * as reference for which lists to generate and which way to generate
   * them.
   * @param {ITagSortingMap} tagSortingMap The tags to generate.
   * @param {IListOrderingMap} listOrderingMap The ordering of those tags.
   */


  populateTags(tagSortingMap, listOrderingMap) {
    if (!tagSortingMap) throw new Error(`Sorting map cannot be null or empty`);
    if (!listOrderingMap) throw new Error(`Ordering ma cannot be null or empty`);

    if ((0, _arrays.arrayHasDiff)(Object.keys(tagSortingMap), Object.keys(listOrderingMap))) {
      throw new Error(`Both maps must contain the exact same tags`);
    }

    this.sortAlgorithms = tagSortingMap;
    this.listAlgorithms = listOrderingMap;
    this.algorithms = {};

    for (const tag of Object.keys(tagSortingMap)) {
      this.algorithms[tag] = (0, _listOrdering.getListAlgorithmInstance)(this.listAlgorithms[tag], tag, this.sortAlgorithms[tag]);
    }

    return this.setKnownRooms(this.rooms);
  }
  /**
   * Gets an ordered set of rooms for the all known tags, filtered.
   * @returns {ITagMap} The cached list of rooms, ordered,
   * for each tag. May be empty, but never null/undefined.
   */


  getOrderedRooms() {
    if (!this.hasFilters) {
      return this._cachedStickyRooms || this.cachedRooms;
    }

    return this.filteredRooms;
  }

  getUnfilteredRooms() {
    return this._cachedStickyRooms || this.cachedRooms;
  }
  /**
   * This returns the same as getOrderedRooms(), but without the sticky room
   * map as it causes issues for sticky room handling (see sticky room handling
   * for more information).
   * @returns {ITagMap} The cached list of rooms, ordered,
   * for each tag. May be empty, but never null/undefined.
   */


  getOrderedRoomsWithoutSticky() {
    if (!this.hasFilters) {
      return this.cachedRooms;
    }

    return this.filteredRooms;
  }
  /**
   * Seeds the Algorithm with a set of rooms. The algorithm will discard all
   * previously known information and instead use these rooms instead.
   * @param {Room[]} rooms The rooms to force the algorithm to use.
   */


  setKnownRooms(rooms) {
    if ((0, _utils.isNullOrUndefined)(rooms)) throw new Error(`Array of rooms cannot be null`);
    if (!this.sortAlgorithms) throw new Error(`Cannot set known rooms without a tag sorting map`);

    if (!this.updatesInhibited) {
      // We only log this if we're expecting to be publishing updates, which means that
      // this could be an unexpected invocation. If we're inhibited, then this is probably
      // an intentional invocation.
      _logger.logger.warn("Resetting known rooms, initiating regeneration");
    } // Before we go any further we need to clear (but remember) the sticky room to
    // avoid accidentally duplicating it in the list.


    const oldStickyRoom = this._stickyRoom;
    if (oldStickyRoom) this.updateStickyRoom(null);
    this.rooms = rooms;
    const newTags = {};

    for (const tagId in this.sortAlgorithms) {
      // noinspection JSUnfilteredForInLoop
      newTags[tagId] = [];
    } // If we can avoid doing work, do so.


    if (!rooms.length) {
      this.generateFreshTags(newTags); // just in case it wants to do something

      this.cachedRooms = newTags;
      return;
    } // Split out the easy rooms first (leave and invite)


    const memberships = (0, _membership.splitRoomsByMembership)(rooms);

    for (const room of memberships[_membership.EffectiveMembership.Invite]) {
      newTags[_models.DefaultTagID.Invite].push(room);
    }

    for (const room of memberships[_membership.EffectiveMembership.Leave]) {
      newTags[_models.DefaultTagID.Archived].push(room);
    } // Now process all the joined rooms. This is a bit more complicated


    for (const room of memberships[_membership.EffectiveMembership.Join]) {
      const tags = this.getTagsOfJoinedRoom(room);
      let inTag = false;

      if (tags.length > 0) {
        for (const tag of tags) {
          if (!(0, _utils.isNullOrUndefined)(newTags[tag])) {
            newTags[tag].push(room);
            inTag = true;
          }
        }
      }

      if (!inTag) {
        if (_DMRoomMap.default.shared().getUserIdForRoomId(room.roomId)) {
          newTags[_models.DefaultTagID.DM].push(room);
        } else {
          newTags[_models.DefaultTagID.Untagged].push(room);
        }
      }
    }

    this.generateFreshTags(newTags);
    this.cachedRooms = newTags; // this recalculates the filtered rooms for us

    this.updateTagsFromCache(); // Now that we've finished generation, we need to update the sticky room to what
    // it was. It's entirely possible that it changed lists though, so if it did then
    // we also have to update the position of it.

    if (oldStickyRoom && oldStickyRoom.room) {
      this.updateStickyRoom(oldStickyRoom.room);

      if (this._stickyRoom && this._stickyRoom.room) {
        // just in case the update doesn't go according to plan
        if (this._stickyRoom.tag !== oldStickyRoom.tag) {
          // We put the sticky room at the top of the list to treat it as an obvious tag change.
          this._stickyRoom.position = 0;
          this.recalculateStickyRoom(this._stickyRoom.tag);
        }
      }
    }
  }

  getTagsForRoom(room) {
    const tags = [];
    const membership = (0, _membership.getEffectiveMembership)(room.getMyMembership());

    if (membership === _membership.EffectiveMembership.Invite) {
      tags.push(_models.DefaultTagID.Invite);
    } else if (membership === _membership.EffectiveMembership.Leave) {
      tags.push(_models.DefaultTagID.Archived);
    } else {
      tags.push(...this.getTagsOfJoinedRoom(room));
    }

    if (!tags.length) tags.push(_models.DefaultTagID.Untagged);
    return tags;
  }

  getTagsOfJoinedRoom(room) {
    let tags = Object.keys(room.tags || {});

    if (tags.length === 0) {
      // Check to see if it's a DM if it isn't anything else
      if (_DMRoomMap.default.shared().getUserIdForRoomId(room.roomId)) {
        tags = [_models.DefaultTagID.DM];
      }
    }

    return tags;
  }
  /**
   * Updates the roomsToTags map
   */


  updateTagsFromCache() {
    const newMap = {};
    const tags = Object.keys(this.cachedRooms);

    for (const tagId of tags) {
      const rooms = this.cachedRooms[tagId];

      for (const room of rooms) {
        if (!newMap[room.roomId]) newMap[room.roomId] = [];
        newMap[room.roomId].push(tagId);
      }
    }

    this.roomIdsToTags = newMap;
  }
  /**
   * Called when the Algorithm believes a complete regeneration of the existing
   * lists is needed.
   * @param {ITagMap} updatedTagMap The tag map which needs populating. Each tag
   * will already have the rooms which belong to it - they just need ordering. Must
   * be mutated in place.
   */


  generateFreshTags(updatedTagMap) {
    if (!this.algorithms) throw new Error("Not ready: no algorithms to determine tags from");

    for (const tag of Object.keys(updatedTagMap)) {
      const algorithm = this.algorithms[tag];
      if (!algorithm) throw new Error(`No algorithm for ${tag}`);
      algorithm.setRooms(updatedTagMap[tag]);
      updatedTagMap[tag] = algorithm.orderedRooms;
    }
  }
  /**
   * Asks the Algorithm to update its knowledge of a room. For example, when
   * a user tags a room, joins/creates a room, or leaves a room the Algorithm
   * should be told that the room's info might have changed. The Algorithm
   * may no-op this request if no changes are required.
   * @param {Room} room The room which might have affected sorting.
   * @param {RoomUpdateCause} cause The reason for the update being triggered.
   * @returns {Promise<boolean>} A boolean of whether or not getOrderedRooms()
   * should be called after processing.
   */


  handleRoomUpdate(room, cause) {
    var _this$_stickyRoom, _this$_stickyRoom$roo;

    if (!this.algorithms) throw new Error("Not ready: no algorithms to determine tags from"); // Note: check the isSticky against the room ID just in case the reference is wrong

    const isSticky = ((_this$_stickyRoom = this._stickyRoom) === null || _this$_stickyRoom === void 0 ? void 0 : (_this$_stickyRoom$roo = _this$_stickyRoom.room) === null || _this$_stickyRoom$roo === void 0 ? void 0 : _this$_stickyRoom$roo.roomId) === room.roomId;

    if (cause === _models.RoomUpdateCause.NewRoom) {
      var _this$_lastStickyRoom;

      const isForLastSticky = ((_this$_lastStickyRoom = this._lastStickyRoom) === null || _this$_lastStickyRoom === void 0 ? void 0 : _this$_lastStickyRoom.room) === room;
      const roomTags = this.roomIdsToTags[room.roomId];
      const hasTags = roomTags && roomTags.length > 0; // Don't change the cause if the last sticky room is being re-added. If we fail to
      // pass the cause through as NewRoom, we'll fail to lie to the algorithm and thus
      // lose the room.

      if (hasTags && !isForLastSticky) {
        _logger.logger.warn(`${room.roomId} is reportedly new but is already known - assuming TagChange instead`);

        cause = _models.RoomUpdateCause.PossibleTagChange;
      } // Check to see if the room is known first


      let knownRoomRef = this.rooms.includes(room);

      if (hasTags && !knownRoomRef) {
        _logger.logger.warn(`${room.roomId} might be a reference change - attempting to update reference`);

        this.rooms = this.rooms.map(r => r.roomId === room.roomId ? room : r);
        knownRoomRef = this.rooms.includes(room);

        if (!knownRoomRef) {
          _logger.logger.warn(`${room.roomId} is still not referenced. It may be sticky.`);
        }
      } // If we have tags for a room and don't have the room referenced, something went horribly
      // wrong - the reference should have been updated above.


      if (hasTags && !knownRoomRef && !isSticky) {
        throw new Error(`${room.roomId} is missing from room array but is known - trying to find duplicate`);
      } // Like above, update the reference to the sticky room if we need to


      if (hasTags && isSticky) {
        // Go directly in and set the sticky room's new reference, being careful not
        // to trigger a sticky room update ourselves.
        this._stickyRoom.room = room;
      } // If after all that we're still a NewRoom update, add the room if applicable.
      // We don't do this for the sticky room (because it causes duplication issues)
      // or if we know about the reference (as it should be replaced).


      if (cause === _models.RoomUpdateCause.NewRoom && !isSticky && !knownRoomRef) {
        this.rooms.push(room);
      }
    }

    let didTagChange = false;

    if (cause === _models.RoomUpdateCause.PossibleTagChange) {
      const oldTags = this.roomIdsToTags[room.roomId] || [];
      const newTags = this.getTagsForRoom(room);
      const diff = (0, _arrays.arrayDiff)(oldTags, newTags);

      if (diff.removed.length > 0 || diff.added.length > 0) {
        for (const rmTag of diff.removed) {
          const algorithm = this.algorithms[rmTag];
          if (!algorithm) throw new Error(`No algorithm for ${rmTag}`);
          algorithm.handleRoomUpdate(room, _models.RoomUpdateCause.RoomRemoved);
          this._cachedRooms[rmTag] = algorithm.orderedRooms;
          this.recalculateFilteredRoomsForTag(rmTag); // update filter to re-sort the list

          this.recalculateStickyRoom(rmTag); // update sticky room to make sure it moves if needed
        }

        for (const addTag of diff.added) {
          const algorithm = this.algorithms[addTag];
          if (!algorithm) throw new Error(`No algorithm for ${addTag}`);
          algorithm.handleRoomUpdate(room, _models.RoomUpdateCause.NewRoom);
          this._cachedRooms[addTag] = algorithm.orderedRooms;
        } // Update the tag map so we don't regen it in a moment


        this.roomIdsToTags[room.roomId] = newTags;
        cause = _models.RoomUpdateCause.Timeline;
        didTagChange = true;
      } else {
        // This is a tag change update and no tags were changed, nothing to do!
        return false;
      }

      if (didTagChange && isSticky) {
        // Manually update the tag for the sticky room without triggering a sticky room
        // update. The update will be handled implicitly by the sticky room handling and
        // requires no changes on our part, if we're in the middle of a sticky room change.
        if (this._lastStickyRoom) {
          this._stickyRoom = {
            room,
            tag: this.roomIdsToTags[room.roomId][0],
            position: 0 // right at the top as it changed tags

          };
        } else {
          // We have to clear the lock as the sticky room change will trigger updates.
          this.setStickyRoom(room);
        }
      }
    } // If the update is for a room change which might be the sticky room, prevent it. We
    // need to make sure that the causes (NewRoom and RoomRemoved) are still triggered though
    // as the sticky room relies on this.


    if (cause !== _models.RoomUpdateCause.NewRoom && cause !== _models.RoomUpdateCause.RoomRemoved) {
      if (this.stickyRoom === room) {
        return false;
      }
    }

    if (!this.roomIdsToTags[room.roomId]) {
      if (CAUSES_REQUIRING_ROOM.includes(cause)) {
        return false;
      } // Get the tags for the room and populate the cache


      const roomTags = this.getTagsForRoom(room).filter(t => !(0, _utils.isNullOrUndefined)(this.cachedRooms[t])); // "This should never happen" condition - we specify DefaultTagID.Untagged in getTagsForRoom(),
      // which means we should *always* have a tag to go off of.

      if (!roomTags.length) throw new Error(`Tags cannot be determined for ${room.roomId}`);
      this.roomIdsToTags[room.roomId] = roomTags;
    }

    const tags = this.roomIdsToTags[room.roomId];

    if (!tags) {
      _logger.logger.warn(`No tags known for "${room.name}" (${room.roomId})`);

      return false;
    }

    let changed = didTagChange;

    for (const tag of tags) {
      const algorithm = this.algorithms[tag];
      if (!algorithm) throw new Error(`No algorithm for ${tag}`);
      algorithm.handleRoomUpdate(room, cause);
      this._cachedRooms[tag] = algorithm.orderedRooms; // Flag that we've done something

      this.recalculateFilteredRoomsForTag(tag); // update filter to re-sort the list

      this.recalculateStickyRoom(tag); // update sticky room to make sure it appears if needed

      changed = true;
    }

    return changed;
  }

}

exports.Algorithm = Algorithm;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9zdG9yZXMvcm9vbS1saXN0L2FsZ29yaXRobXMvQWxnb3JpdGhtLnRzIl0sIm5hbWVzIjpbIkxJU1RfVVBEQVRFRF9FVkVOVCIsIkNBVVNFU19SRVFVSVJJTkdfUk9PTSIsIlJvb21VcGRhdGVDYXVzZSIsIlRpbWVsaW5lIiwiUmVhZFJlY2VpcHQiLCJBbGdvcml0aG0iLCJFdmVudEVtaXR0ZXIiLCJjb25zdHJ1Y3RvciIsIk1hcCIsIlNldCIsInN0aWNreVJvb20iLCJfc3RpY2t5Um9vbSIsInJvb20iLCJrbm93blJvb21zIiwicm9vbXMiLCJoYXNUYWdTb3J0aW5nTWFwIiwic29ydEFsZ29yaXRobXMiLCJoYXNGaWx0ZXJzIiwiYWxsb3dlZEJ5RmlsdGVyIiwic2l6ZSIsImNhY2hlZFJvb21zIiwidmFsIiwiX2NhY2hlZFJvb21zIiwicmVjYWxjdWxhdGVGaWx0ZXJlZFJvb21zIiwicmVjYWxjdWxhdGVTdGlja3lSb29tIiwic2V0U3RpY2t5Um9vbSIsInVwZGF0ZVN0aWNreVJvb20iLCJlIiwibG9nZ2VyIiwid2FybiIsImdldFRhZ1NvcnRpbmciLCJ0YWdJZCIsInNldFRhZ1NvcnRpbmciLCJzb3J0IiwiRXJyb3IiLCJhbGdvcml0aG0iLCJhbGdvcml0aG1zIiwic2V0U29ydEFsZ29yaXRobSIsIm9yZGVyZWRSb29tcyIsInJlY2FsY3VsYXRlRmlsdGVyZWRSb29tc0ZvclRhZyIsImdldExpc3RPcmRlcmluZyIsImxpc3RBbGdvcml0aG1zIiwic2V0TGlzdE9yZGVyaW5nIiwib3JkZXIiLCJzZXRSb29tcyIsImFkZEZpbHRlckNvbmRpdGlvbiIsImZpbHRlckNvbmRpdGlvbiIsInNldCIsImZpbHRlciIsInIiLCJpc1Zpc2libGUiLCJvbiIsIkZJTFRFUl9DSEFOR0VEIiwiaGFuZGxlRmlsdGVyQ2hhbmdlIiwiYmluZCIsInJlbW92ZUZpbHRlckNvbmRpdGlvbiIsIm9mZiIsImhhcyIsImRlbGV0ZSIsInVwZGF0ZXNJbmhpYml0ZWQiLCJlbWl0IiwiZG9VcGRhdGVTdGlja3lSb29tIiwiX2xhc3RTdGlja3lSb29tIiwiU3BhY2VTdG9yZSIsInNwYWNlc0VuYWJsZWQiLCJpc1NwYWNlUm9vbSIsImdldE15TWVtYmVyc2hpcCIsIlZpc2liaWxpdHlQcm92aWRlciIsImluc3RhbmNlIiwiaXNSb29tVmlzaWJsZSIsImhhbmRsZVJvb21VcGRhdGUiLCJOZXdSb29tIiwidGFnIiwicm9vbUlkc1RvVGFncyIsInJvb21JZCIsInRhZ0xpc3QiLCJnZXRPcmRlcmVkUm9vbXNXaXRob3V0U3RpY2t5IiwicG9zaXRpb24iLCJpbmRleE9mIiwid2FzU3RpY2t5IiwibGFzdFN0aWNreVJvb20iLCJSb29tUmVtb3ZlZCIsImZpbHRlcnMiLCJBcnJheSIsImZyb20iLCJrZXlzIiwibmV3TWFwIiwiT2JqZWN0IiwibWFwIiwidHJ5SW5zZXJ0U3RpY2t5Um9vbVRvRmlsdGVyU2V0IiwicmVtYWluaW5nUm9vbXMiLCJhbGxvd2VkUm9vbXNJblRoaXNUYWciLCJmaWx0ZXJlZFJvb21zIiwiaWR4Iiwic3BsaWNlIiwicHVzaCIsImFsbG93ZWRSb29tcyIsInZhbHVlcyIsInJlZHVjZSIsInJ2IiwidiIsImFsbG93ZWRSb29tc0J5RmlsdGVycyIsImxlbmd0aCIsInVwZGF0ZWRUYWciLCJfY2FjaGVkU3RpY2t5Um9vbXMiLCJzdGlja2llZFRhZ01hcCIsInN0aWNreSIsInBvcHVsYXRlVGFncyIsInRhZ1NvcnRpbmdNYXAiLCJsaXN0T3JkZXJpbmdNYXAiLCJzZXRLbm93blJvb21zIiwiZ2V0T3JkZXJlZFJvb21zIiwiZ2V0VW5maWx0ZXJlZFJvb21zIiwib2xkU3RpY2t5Um9vbSIsIm5ld1RhZ3MiLCJnZW5lcmF0ZUZyZXNoVGFncyIsIm1lbWJlcnNoaXBzIiwiRWZmZWN0aXZlTWVtYmVyc2hpcCIsIkludml0ZSIsIkRlZmF1bHRUYWdJRCIsIkxlYXZlIiwiQXJjaGl2ZWQiLCJKb2luIiwidGFncyIsImdldFRhZ3NPZkpvaW5lZFJvb20iLCJpblRhZyIsIkRNUm9vbU1hcCIsInNoYXJlZCIsImdldFVzZXJJZEZvclJvb21JZCIsIkRNIiwiVW50YWdnZWQiLCJ1cGRhdGVUYWdzRnJvbUNhY2hlIiwiZ2V0VGFnc0ZvclJvb20iLCJtZW1iZXJzaGlwIiwidXBkYXRlZFRhZ01hcCIsImNhdXNlIiwiaXNTdGlja3kiLCJpc0Zvckxhc3RTdGlja3kiLCJyb29tVGFncyIsImhhc1RhZ3MiLCJQb3NzaWJsZVRhZ0NoYW5nZSIsImtub3duUm9vbVJlZiIsImluY2x1ZGVzIiwiZGlkVGFnQ2hhbmdlIiwib2xkVGFncyIsImRpZmYiLCJyZW1vdmVkIiwiYWRkZWQiLCJybVRhZyIsImFkZFRhZyIsInQiLCJuYW1lIiwiY2hhbmdlZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFpQkE7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBU0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUEwQkE7QUFDQTtBQUNBO0FBQ08sTUFBTUEsa0JBQWtCLEdBQUcsb0JBQTNCLEMsQ0FFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1DLHFCQUFxQixHQUFHLENBQzFCQyx3QkFBZ0JDLFFBRFUsRUFFMUJELHdCQUFnQkUsV0FGVSxDQUE5Qjs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sTUFBTUMsU0FBTixTQUF3QkMsb0JBQXhCLENBQXFDO0FBRUU7QUFHRzs7QUFXN0M7QUFDSjtBQUNBO0FBR1dDLEVBQUFBLFdBQVcsR0FBRztBQUNqQjtBQURpQix3REFwQlcsRUFvQlg7QUFBQSw4REFuQmlCLEVBbUJqQjtBQUFBLHlEQWxCWSxFQWtCWjtBQUFBLHVEQWpCYyxJQWlCZDtBQUFBLDJEQWhCa0IsSUFnQmxCO0FBQUE7QUFBQTtBQUFBO0FBQUEsaURBWkcsRUFZSDtBQUFBLHlEQVRqQixFQVNpQjtB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LFFBQUksQ0FBQ2lELElBQUwsRUFBVztBQUNQL0YscUJBQU9DLElBQVAsQ0FBYSxzQkFBcUJqQixJQUFJLENBQUMySSxJQUFLLE1BQUszSSxJQUFJLENBQUM4RCxNQUFPLEdBQTdEOztBQUNBLGFBQU8sS0FBUDtBQUNIOztBQUVELFFBQUk4RSxPQUFPLEdBQUdULFlBQWQ7O0FBQ0EsU0FBSyxNQUFNdkUsR0FBWCxJQUFrQm1ELElBQWxCLEVBQXdCO0FBQ3BCLFlBQU14RixTQUE0QixHQUFHLEtBQUtDLFVBQUwsQ0FBZ0JvQyxHQUFoQixDQUFyQztBQUNBLFVBQUksQ0FBQ3JDLFNBQUwsRUFBZ0IsTUFBTSxJQUFJRCxLQUFKLENBQVcsb0JBQW1Cc0MsR0FBSSxFQUFsQyxDQUFOO0FBRWhCckMsTUFBQUEsU0FBUyxDQUFDbUMsZ0JBQVYsQ0FBMkIxRCxJQUEzQixFQUFpQzJILEtBQWpDO0FBQ0EsV0FBS2pILFlBQUwsQ0FBa0JrRCxHQUFsQixJQUF5QnJDLFNBQVMsQ0FBQ0csWUFBbkMsQ0FMb0IsQ0FPcEI7O0FBQ0EsV0FBS0MsOEJBQUwsQ0FBb0NpQyxHQUFwQyxFQVJvQixDQVFzQjs7QUFDMUMsV0FBS2hELHFCQUFMLENBQTJCZ0QsR0FBM0IsRUFUb0IsQ0FTYTs7QUFDakNnRixNQUFBQSxPQUFPLEdBQUcsSUFBVjtBQUNIOztBQUVELFdBQU9BLE9BQVA7QUFDSDs7QUFudEJ1QyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAyMCwgMjAyMSBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB7IFJvb20gfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvbW9kZWxzL3Jvb21cIjtcbmltcG9ydCB7IGlzTnVsbE9yVW5kZWZpbmVkIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL3V0aWxzXCI7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tIFwiZXZlbnRzXCI7XG5cbmltcG9ydCBETVJvb21NYXAgZnJvbSBcIi4uLy4uLy4uL3V0aWxzL0RNUm9vbU1hcFwiO1xuaW1wb3J0IHsgYXJyYXlEaWZmLCBhcnJheUhhc0RpZmYgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvYXJyYXlzXCI7XG5pbXBvcnQgeyBEZWZhdWx0VGFnSUQsIFJvb21VcGRhdGVDYXVzZSwgVGFnSUQgfSBmcm9tIFwiLi4vbW9kZWxzXCI7XG5pbXBvcnQge1xuICAgIElMaXN0T3JkZXJpbmdNYXAsXG4gICAgSU9yZGVyaW5nQWxnb3JpdGhtTWFwLFxuICAgIElUYWdNYXAsXG4gICAgSVRhZ1NvcnRpbmdNYXAsXG4gICAgTGlzdEFsZ29yaXRobSxcbiAgICBTb3J0QWxnb3JpdGhtLFxufSBmcm9tIFwiLi9tb2RlbHNcIjtcbmltcG9ydCB7IEZJTFRFUl9DSEFOR0VELCBJRmlsdGVyQ29uZGl0aW9uIH0gZnJvbSBcIi4uL2ZpbHRlcnMvSUZpbHRlckNvbmRpdGlvblwiO1xuaW1wb3J0IHsgRWZmZWN0aXZlTWVtYmVyc2hpcCwgZ2V0RWZmZWN0aXZlTWVtYmVyc2hpcCwgc3BsaXRSb29tc0J5TWVtYmVyc2hpcCB9IGZyb20gXCIuLi8uLi8uLi91dGlscy9tZW1iZXJzaGlwXCI7XG5pbXBvcnQgeyBPcmRlcmluZ0FsZ29yaXRobSB9IGZyb20gXCIuL2xpc3Qtb3JkZXJpbmcvT3JkZXJpbmdBbGdvcml0aG1cIjtcbmltcG9ydCB7IGdldExpc3RBbGdvcml0aG1JbnN0YW5jZSB9IGZyb20gXCIuL2xpc3Qtb3JkZXJpbmdcIjtcbmltcG9ydCB7IFZpc2liaWxpdHlQcm92aWRlciB9IGZyb20gXCIuLi9maWx0ZXJzL1Zpc2liaWxpdHlQcm92aWRlclwiO1xuaW1wb3J0IFNwYWNlU3RvcmUgZnJvbSBcIi4uLy4uL3NwYWNlcy9TcGFjZVN0b3JlXCI7XG5cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9sb2dnZXJcIjtcblxuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSBBbGdvcml0aG0gaGFzIGRldGVybWluZWQgYSBsaXN0IGhhcyBiZWVuIHVwZGF0ZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBMSVNUX1VQREFURURfRVZFTlQgPSBcImxpc3RfdXBkYXRlZF9ldmVudFwiO1xuXG4vLyBUaGVzZSBhcmUgdGhlIGNhdXNlcyB3aGljaCByZXF1aXJlIGEgcm9vbSB0byBiZSBrbm93biBpbiBvcmRlciBmb3IgdXMgdG8gaGFuZGxlIHRoZW0uIElmXG4vLyBhIGNhdXNlIGluIHRoaXMgbGlzdCBpcyByYWlzZWQgYW5kIHdlIGRvbid0IGtub3cgYWJvdXQgdGhlIHJvb20sIHdlIGRvbid0IGhhbmRsZSB0aGUgdXBkYXRlLlxuLy9cbi8vIE5vdGU6IHRoZXNlIHR5cGljYWxseSBoYXBwZW4gd2hlbiBhIG5ldyByb29tIGlzIGNvbWluZyBpbiwgc3VjaCBhcyB0aGUgdXNlciBjcmVhdGluZyBvclxuLy8gam9pbmluZyB0aGUgcm9vbS4gRm9yIHRoZXNlIGNhc2VzLCB3ZSBuZWVkIHRvIGtub3cgYWJvdXQgdGhlIHJvb20gcHJpb3IgdG8gaGFuZGxpbmcgaXQgb3RoZXJ3aXNlXG4vLyB3ZSdsbCBtYWtlIGJhZCBhc3N1bXB0aW9ucy5cbmNvbnN0IENBVVNFU19SRVFVSVJJTkdfUk9PTSA9IFtcbiAgICBSb29tVXBkYXRlQ2F1c2UuVGltZWxpbmUsXG4gICAgUm9vbVVwZGF0ZUNhdXNlLlJlYWRSZWNlaXB0LFxuXTtcblxuaW50ZXJmYWNlIElTdGlja3lSb29tIHtcbiAgICByb29tOiBSb29tO1xuICAgIHBvc2l0aW9uOiBudW1iZXI7XG4gICAgdGFnOiBUYWdJRDtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgbGlzdCBvcmRlcmluZyBhbGdvcml0aG0uIFRoaXMgY2xhc3Mgd2lsbCB0YWtlIGNhcmUgb2YgdGFnXG4gKiBtYW5hZ2VtZW50ICh3aGljaCByb29tcyBnbyBpbiB3aGljaCB0YWdzKSBhbmQgYXNrIHRoZSBpbXBsZW1lbnRhdGlvbiB0b1xuICogZGVhbCB3aXRoIG9yZGVyaW5nIG1lY2hhbmljcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFsZ29yaXRobSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgcHJpdmF0ZSBfY2FjaGVkUm9vbXM6IElUYWdNYXAgPSB7fTtcbiAgICBwcml2YXRlIF9jYWNoZWRTdGlja3lSb29tczogSVRhZ01hcCA9IHt9OyAvLyBhIGNsb25lIG9mIHRoZSBfY2FjaGVkUm9vbXMsIHdpdGggdGhlIHN0aWNreSByb29tXG4gICAgcHJpdmF0ZSBmaWx0ZXJlZFJvb21zOiBJVGFnTWFwID0ge307XG4gICAgcHJpdmF0ZSBfc3RpY2t5Um9vbTogSVN0aWNreVJvb20gPSBudWxsO1xuICAgIHByaXZhdGUgX2xhc3RTdGlja3lSb29tOiBJU3RpY2t5Um9vbSA9IG51bGw7IC8vIG9ubHkgbm90LW51bGwgd2hlbiBjaGFuZ2luZyB0aGUgc3RpY2t5IHJvb21cbiAgICBwcml2YXRlIHNvcnRBbGdvcml0aG1zOiBJVGFnU29ydGluZ01hcDtcbiAgICBwcml2YXRlIGxpc3RBbGdvcml0aG1zOiBJTGlzdE9yZGVyaW5nTWFwO1xuICAgIHByaXZhdGUgYWxnb3JpdGhtczogSU9yZGVyaW5nQWxnb3JpdGhtTWFwO1xuICAgIHByaXZhdGUgcm9vbXM6IFJvb21bXSA9IFtdO1xuICAgIHByaXZhdGUgcm9vbUlkc1RvVGFnczoge1xuICAgICAgICBbcm9vbUlkOiBzdHJpbmddOiBUYWdJRFtdO1xuICAgIH0gPSB7fTtcbiAgICBwcml2YXRlIGFsbG93ZWRCeUZpbHRlcjogTWFwPElGaWx0ZXJDb25kaXRpb24sIFJvb21bXT4gPSBuZXcgTWFwPElGaWx0ZXJDb25kaXRpb24sIFJvb21bXT4oKTtcbiAgICBwcml2YXRlIGFsbG93ZWRSb29tc0J5RmlsdGVyczogU2V0PFJvb20+ID0gbmV3IFNldDxSb29tPigpO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gc3VzcGVuZCBlbWlzc2lvbnMgb2YgYWxnb3JpdGhtIHVwZGF0ZXMuXG4gICAgICovXG4gICAgcHVibGljIHVwZGF0ZXNJbmhpYml0ZWQgPSBmYWxzZTtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHN0aWNreVJvb20oKTogUm9vbSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGlja3lSb29tID8gdGhpcy5fc3RpY2t5Um9vbS5yb29tIDogbnVsbDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGtub3duUm9vbXMoKTogUm9vbVtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vbXM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBoYXNUYWdTb3J0aW5nTWFwKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gISF0aGlzLnNvcnRBbGdvcml0aG1zO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXQgaGFzRmlsdGVycygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsb3dlZEJ5RmlsdGVyLnNpemUgPiAwO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBzZXQgY2FjaGVkUm9vbXModmFsOiBJVGFnTWFwKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZFJvb21zID0gdmFsO1xuICAgICAgICB0aGlzLnJlY2FsY3VsYXRlRmlsdGVyZWRSb29tcygpO1xuICAgICAgICB0aGlzLnJlY2FsY3VsYXRlU3RpY2t5Um9vbSgpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXQgY2FjaGVkUm9vbXMoKTogSVRhZ01hcCB7XG4gICAgICAgIC8vIPCfkIkgSGVyZSBiZSBkcmFnb25zLlxuICAgICAgICAvLyBOb3RlOiB0aGlzIGlzIHVzZWQgYnkgdGhlIHVuZGVybHlpbmcgYWxnb3JpdGhtIGNsYXNzZXMsIHNvIGRvbid0IG1ha2UgaXQgcmV0dXJuXG4gICAgICAgIC8vIHRoZSBzdGlja3kgcm9vbSBjYWNoZS4gSWYgaXQgZW5kcyB1cCByZXR1cm5pbmcgdGhlIHN0aWNreSByb29tIGNhY2hlLCB3ZSBlbmQgdXBcbiAgICAgICAgLy8gY29ycnVwdGluZyBvdXIgY2FjaGVzIGFuZCBjb25mdXNpbmcgdGhlbS5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZFJvb21zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF3YWl0YWJsZSB2ZXJzaW9uIG9mIHRoZSBzdGlja3kgcm9vbSBzZXR0ZXIuXG4gICAgICogQHBhcmFtIHZhbCBUaGUgbmV3IHJvb20gdG8gc3RpY2t5LlxuICAgICAqL1xuICAgIHB1YmxpYyBzZXRTdGlja3lSb29tKHZhbDogUm9vbSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGlja3lSb29tKHZhbCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiRmFpbGVkIHRvIHVwZGF0ZSBzdGlja3kgcm9vbVwiLCBlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXRUYWdTb3J0aW5nKHRhZ0lkOiBUYWdJRCk6IFNvcnRBbGdvcml0aG0ge1xuICAgICAgICBpZiAoIXRoaXMuc29ydEFsZ29yaXRobXMpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5zb3J0QWxnb3JpdGhtc1t0YWdJZF07XG4gICAgfVxuXG4gICAgcHVibGljIHNldFRhZ1NvcnRpbmcodGFnSWQ6IFRhZ0lELCBzb3J0OiBTb3J0QWxnb3JpdGhtKSB7XG4gICAgICAgIGlmICghdGFnSWQpIHRocm93IG5ldyBFcnJvcihcIlRhZyBJRCBtdXN0IGJlIGRlZmluZWRcIik7XG4gICAgICAgIGlmICghc29ydCkgdGhyb3cgbmV3IEVycm9yKFwiQWxnb3JpdGhtIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgdGhpcy5zb3J0QWxnb3JpdGhtc1t0YWdJZF0gPSBzb3J0O1xuXG4gICAgICAgIGNvbnN0IGFsZ29yaXRobTogT3JkZXJpbmdBbGdvcml0aG0gPSB0aGlzLmFsZ29yaXRobXNbdGFnSWRdO1xuICAgICAgICBhbGdvcml0aG0uc2V0U29ydEFsZ29yaXRobShzb3J0KTtcbiAgICAgICAgdGhpcy5fY2FjaGVkUm9vbXNbdGFnSWRdID0gYWxnb3JpdGhtLm9yZGVyZWRSb29tcztcbiAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZUZpbHRlcmVkUm9vbXNGb3JUYWcodGFnSWQpOyAvLyB1cGRhdGUgZmlsdGVyIHRvIHJlLXNvcnQgdGhlIGxpc3RcbiAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZVN0aWNreVJvb20odGFnSWQpOyAvLyB1cGRhdGUgc3RpY2t5IHJvb20gdG8gbWFrZSBzdXJlIGl0IGFwcGVhcnMgaWYgbmVlZGVkXG4gICAgfVxuXG4gICAgcHVibGljIGdldExpc3RPcmRlcmluZyh0YWdJZDogVGFnSUQpOiBMaXN0QWxnb3JpdGhtIHtcbiAgICAgICAgaWYgKCF0aGlzLmxpc3RBbGdvcml0aG1zKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdEFsZ29yaXRobXNbdGFnSWRdO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXRMaXN0T3JkZXJpbmcodGFnSWQ6IFRhZ0lELCBvcmRlcjogTGlzdEFsZ29yaXRobSkge1xuICAgICAgICBpZiAoIXRhZ0lkKSB0aHJvdyBuZXcgRXJyb3IoXCJUYWcgSUQgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICBpZiAoIW9yZGVyKSB0aHJvdyBuZXcgRXJyb3IoXCJBbGdvcml0aG0gbXVzdCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICB0aGlzLmxpc3RBbGdvcml0aG1zW3RhZ0lkXSA9IG9yZGVyO1xuXG4gICAgICAgIGNvbnN0IGFsZ29yaXRobSA9IGdldExpc3RBbGdvcml0aG1JbnN0YW5jZShvcmRlciwgdGFnSWQsIHRoaXMuc29ydEFsZ29yaXRobXNbdGFnSWRdKTtcbiAgICAgICAgdGhpcy5hbGdvcml0aG1zW3RhZ0lkXSA9IGFsZ29yaXRobTtcblxuICAgICAgICBhbGdvcml0aG0uc2V0Um9vbXModGhpcy5fY2FjaGVkUm9vbXNbdGFnSWRdKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkUm9vbXNbdGFnSWRdID0gYWxnb3JpdGhtLm9yZGVyZWRSb29tcztcbiAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZUZpbHRlcmVkUm9vbXNGb3JUYWcodGFnSWQpOyAvLyB1cGRhdGUgZmlsdGVyIHRvIHJlLXNvcnQgdGhlIGxpc3RcbiAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZVN0aWNreVJvb20odGFnSWQpOyAvLyB1cGRhdGUgc3RpY2t5IHJvb20gdG8gbWFrZSBzdXJlIGl0IGFwcGVhcnMgaWYgbmVlZGVkXG4gICAgfVxuXG4gICAgcHVibGljIGFkZEZpbHRlckNvbmRpdGlvbihmaWx0ZXJDb25kaXRpb246IElGaWx0ZXJDb25kaXRpb24pOiB2b2lkIHtcbiAgICAgICAgLy8gUG9wdWxhdGUgdGhlIGNhY2hlIG9mIHRoZSBuZXcgZmlsdGVyXG4gICAgICAgIHRoaXMuYWxsb3dlZEJ5RmlsdGVyLnNldChmaWx0ZXJDb25kaXRpb24sIHRoaXMucm9vbXMuZmlsdGVyKHIgPT4gZmlsdGVyQ29uZGl0aW9uLmlzVmlzaWJsZShyKSkpO1xuICAgICAgICB0aGlzLnJlY2FsY3VsYXRlRmlsdGVyZWRSb29tcygpO1xuICAgICAgICBmaWx0ZXJDb25kaXRpb24ub24oRklMVEVSX0NIQU5HRUQsIHRoaXMuaGFuZGxlRmlsdGVyQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIHB1YmxpYyByZW1vdmVGaWx0ZXJDb25kaXRpb24oZmlsdGVyQ29uZGl0aW9uOiBJRmlsdGVyQ29uZGl0aW9uKTogdm9pZCB7XG4gICAgICAgIGZpbHRlckNvbmRpdGlvbi5vZmYoRklMVEVSX0NIQU5HRUQsIHRoaXMuaGFuZGxlRmlsdGVyQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgICAgICBpZiAodGhpcy5hbGxvd2VkQnlGaWx0ZXIuaGFzKGZpbHRlckNvbmRpdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMuYWxsb3dlZEJ5RmlsdGVyLmRlbGV0ZShmaWx0ZXJDb25kaXRpb24pO1xuICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZUZpbHRlcmVkUm9vbXMoKTtcblxuICAgICAgICAgICAgLy8gSWYgd2UgcmVtb3ZlZCB0aGUgbGFzdCBmaWx0ZXIsIHRlbGwgY29uc3VtZXJzIHRoYXQgd2UndmUgXCJ1cGRhdGVkXCIgb3VyIGZpbHRlcmVkXG4gICAgICAgICAgICAvLyB2aWV3LiBUaGlzIHdpbGwgdHJpY2sgdGhlbSBpbnRvIGdldHRpbmcgdGhlIGNvbXBsZXRlIHJvb20gbGlzdC5cbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNGaWx0ZXJzICYmICF0aGlzLnVwZGF0ZXNJbmhpYml0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoTElTVF9VUERBVEVEX0VWRU5UKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlRmlsdGVyQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLnJlY2FsY3VsYXRlRmlsdGVyZWRSb29tcygpO1xuXG4gICAgICAgIC8vIHJlLWVtaXQgdGhlIHVwZGF0ZSBzbyB0aGUgbGlzdCBzdG9yZSBjYW4gZmlyZSBhbiBvZmYtY3ljbGUgdXBkYXRlIGlmIG5lZWRlZFxuICAgICAgICBpZiAodGhpcy51cGRhdGVzSW5oaWJpdGVkKSByZXR1cm47XG4gICAgICAgIHRoaXMuZW1pdChGSUxURVJfQ0hBTkdFRCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVTdGlja3lSb29tKHZhbDogUm9vbSkge1xuICAgICAgICB0aGlzLmRvVXBkYXRlU3RpY2t5Um9vbSh2YWwpO1xuICAgICAgICB0aGlzLl9sYXN0U3RpY2t5Um9vbSA9IG51bGw7IC8vIGNsZWFyIHRvIGluZGljYXRlIHdlJ3JlIGRvbmUgY2hhbmdpbmdcbiAgICB9XG5cbiAgICBwcml2YXRlIGRvVXBkYXRlU3RpY2t5Um9vbSh2YWw6IFJvb20pIHtcbiAgICAgICAgaWYgKFNwYWNlU3RvcmUuc3BhY2VzRW5hYmxlZCAmJiB2YWw/LmlzU3BhY2VSb29tKCkgJiYgdmFsLmdldE15TWVtYmVyc2hpcCgpICE9PSBcImludml0ZVwiKSB7XG4gICAgICAgICAgICAvLyBuby1vcCBzdGlja3kgcm9vbXMgZm9yIHNwYWNlcyAtIHRoZXkncmUgZWZmZWN0aXZlbHkgdmlydHVhbCByb29tc1xuICAgICAgICAgICAgdmFsID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgJiYgIVZpc2liaWxpdHlQcm92aWRlci5pbnN0YW5jZS5pc1Jvb21WaXNpYmxlKHZhbCkpIHtcbiAgICAgICAgICAgIHZhbCA9IG51bGw7IC8vIHRoZSByb29tIGlzbid0IHZpc2libGUgLSBsaWUgdG8gdGhlIHJlc3Qgb2YgdGhpcyBmdW5jdGlvblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHRoZSBsYXN0IHN0aWNreSByb29tIHRvIGluZGljYXRlIHRoYXQgd2UncmUgaW4gYSBjaGFuZ2UuIFRoZSBjb2RlIHRocm91Z2hvdXQgdGhlXG4gICAgICAgIC8vIGNsYXNzIGNhbiBzYWZlbHkgaGFuZGxlIGEgbnVsbCByb29tLCBzbyB0aGlzIHNob3VsZCBiZSBzYWZlIHRvIGRvIGFzIGEgYmFja3VwLlxuICAgICAgICB0aGlzLl9sYXN0U3RpY2t5Um9vbSA9IHRoaXMuX3N0aWNreVJvb20gfHwgPElTdGlja3lSb29tPnt9O1xuXG4gICAgICAgIC8vIEl0J3MgcG9zc2libGUgdG8gaGF2ZSBubyBzZWxlY3RlZCByb29tLiBJbiB0aGF0IGNhc2UsIGNsZWFyIHRoZSBzdGlja3kgcm9vbVxuICAgICAgICBpZiAoIXZhbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0aWNreVJvb20pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGlja3lSb29tID0gdGhpcy5fc3RpY2t5Um9vbS5yb29tO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0aWNreVJvb20gPSBudWxsOyAvLyBjbGVhciBiZWZvcmUgd2UgZ28gdG8gdXBkYXRlIHRoZSBhbGdvcml0aG1cblxuICAgICAgICAgICAgICAgIC8vIExpZSB0byB0aGUgYWxnb3JpdGhtIGFuZCByZS1hZGQgdGhlIHJvb20gdG8gdGhlIGFsZ29yaXRobVxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUm9vbVVwZGF0ZShzdGlja3lSb29tLCBSb29tVXBkYXRlQ2F1c2UuTmV3Um9vbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2hlbiB3ZSBkbyBoYXZlIGEgcm9vbSB0aG91Z2gsIHdlIGV4cGVjdCB0byBiZSBhYmxlIHRvIGZpbmQgaXRcbiAgICAgICAgbGV0IHRhZyA9IHRoaXMucm9vbUlkc1RvVGFnc1t2YWwucm9vbUlkXT8uWzBdO1xuICAgICAgICBpZiAoIXRhZykgdGhyb3cgbmV3IEVycm9yKGAke3ZhbC5yb29tSWR9IGRvZXMgbm90IGJlbG9uZyB0byBhIHRhZyBhbmQgY2Fubm90IGJlIHN0aWNreWApO1xuXG4gICAgICAgIC8vIFdlIHNwZWNpZmljYWxseSBkbyBOT1QgdXNlIHRoZSBvcmRlcmVkIHJvb21zIHNldCBhcyBpdCBjb250YWlucyB0aGUgc3RpY2t5IHJvb20sIHdoaWNoXG4gICAgICAgIC8vIG1lYW5zIHdlJ2xsIGJlIG9mZiBieSAxIHdoZW4gdGhlIHVzZXIgaXMgc3dpdGNoaW5nIHJvb21zLiBUaGlzIGxlYWRzIHRvIHZpc3VhbCBqdW1waW5nXG4gICAgICAgIC8vIHdoZW4gdGhlIHVzZXIgaXMgbW92aW5nIHNvdXRoIGluIHRoZSBsaXN0IChub3Qgbm9ydGgsIGJlY2F1c2Ugb2YgbWF0aCkuXG4gICAgICAgIGNvbnN0IHRhZ0xpc3QgPSB0aGlzLmdldE9yZGVyZWRSb29tc1dpdGhvdXRTdGlja3koKVt0YWddIHx8IFtdOyAvLyBjYW4gYmUgbnVsbCBpZiBmaWx0ZXJpbmdcbiAgICAgICAgbGV0IHBvc2l0aW9uID0gdGFnTGlzdC5pbmRleE9mKHZhbCk7XG5cbiAgICAgICAgLy8gV2UgZG8gd2FudCB0byBzZWUgaWYgYSB0YWcgY2hhbmdlIGhhcHBlbmVkIHRob3VnaCAtIGlmIHRoaXMgZGlkIGhhcHBlbiB0aGVuIHdlJ2xsIHdhbnRcbiAgICAgICAgLy8gdG8gZm9yY2UgdGhlIHBvc2l0aW9uIHRvIHplcm8gKHRvcCkgdG8gZW5zdXJlIHdlIGNhbiBwcm9wZXJseSBoYW5kbGUgaXQuXG4gICAgICAgIGNvbnN0IHdhc1N0aWNreSA9IHRoaXMuX2xhc3RTdGlja3lSb29tLnJvb20gPyB0aGlzLl9sYXN0U3RpY2t5Um9vbS5yb29tLnJvb21JZCA9PT0gdmFsLnJvb21JZCA6IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fbGFzdFN0aWNreVJvb20udGFnICYmIHRhZyAhPT0gdGhpcy5fbGFzdFN0aWNreVJvb20udGFnICYmIHdhc1N0aWNreSAmJiBwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBTdGlja3kgcm9vbSAke3ZhbC5yb29tSWR9IGNoYW5nZWQgdGFncyBkdXJpbmcgc3RpY2t5IHJvb20gaGFuZGxpbmdgKTtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNhbml0eSBjaGVjayB0aGUgcG9zaXRpb24gdG8gbWFrZSBzdXJlIHRoZSByb29tIGlzIHF1YWxpZmllZCBmb3IgYmVpbmcgc3RpY2t5XG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHRocm93IG5ldyBFcnJvcihgJHt2YWwucm9vbUlkfSBkb2VzIG5vdCBhcHBlYXIgdG8gYmUga25vd24gYW5kIGNhbm5vdCBiZSBzdGlja3lgKTtcblxuICAgICAgICAvLyDwn5CJIEhlcmUgYmUgZHJhZ29ucy5cbiAgICAgICAgLy8gQmVmb3JlIHdlIGNhbiBnbyB0aHJvdWdoIHdpdGggbHlpbmcgdG8gdGhlIHVuZGVybHlpbmcgYWxnb3JpdGhtIGFib3V0IGEgcm9vbVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHdoZW4gd2UgZG8gd2UncmUgcmVhZHkgZm9yIHRoZSBpbmV2aXRhYmxlIHN0aWNreSByb29tXG4gICAgICAgIC8vIHVwZGF0ZSB3ZSdsbCByZWNlaXZlLiBUbyBwcmVwYXJlIGZvciB0aGF0LCB3ZSBmaXJzdCByZW1vdmUgdGhlIHN0aWNreSByb29tIGFuZFxuICAgICAgICAvLyByZWNhbGN1bGF0ZSB0aGUgc3RhdGUgb3Vyc2VsdmVzIHNvIHRoYXQgd2hlbiB0aGUgdW5kZXJseWluZyBhbGdvcml0aG0gY2FsbHMgZm9yXG4gICAgICAgIC8vIHRoZSBzYW1lIHRoaW5nIGl0IG5vLW9wcy4gQWZ0ZXIgd2UncmUgZG9uZSBjYWxsaW5nIHRoZSBhbGdvcml0aG0sIHdlJ2xsIGlzc3VlXG4gICAgICAgIC8vIGEgbmV3IHVwZGF0ZSBmb3Igb3Vyc2VsdmVzLlxuICAgICAgICBjb25zdCBsYXN0U3RpY2t5Um9vbSA9IHRoaXMuX3N0aWNreVJvb207XG4gICAgICAgIHRoaXMuX3N0aWNreVJvb20gPSBudWxsOyAvLyBjbGVhciBiZWZvcmUgd2UgdXBkYXRlIHRoZSBhbGdvcml0aG1cbiAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZVN0aWNreVJvb20oKTtcblxuICAgICAgICAvLyBXaGVuIHdlIGRvIGhhdmUgdGhlIHJvb20sIHJlLWFkZCB0aGUgb2xkIHJvb20gKGlmIG5lZWRlZCkgdG8gdGhlIGFsZ29yaXRobVxuICAgICAgICAvLyBhbmQgcmVtb3ZlIHRoZSBzdGlja3kgcm9vbSBmcm9tIHRoZSBhbGdvcml0aG0uIFRoaXMgaXMgc28gdGhlIHVuZGVybHlpbmdcbiAgICAgICAgLy8gYWxnb3JpdGhtIGRvZXNuJ3QgdHJ5IGFuZCBjb25mdXNlIGl0c2VsZiB3aXRoIHRoZSBzdGlja3kgcm9vbSBjb25jZXB0LlxuICAgICAgICAvLyBXZSBkb24ndCBhZGQgdGhlIG5ldyByb29tIGlmIHRoZSBzdGlja3kgcm9vbSBpc24ndCBjaGFuZ2luZyBiZWNhdXNlIHRoYXQnc1xuICAgICAgICAvLyBhbiBlYXN5IHdheSB0byBjYXVzZSBkdXBsaWNhdGlvbi4gV2UgaGF2ZSB0byBkbyByb29tIElEIGNoZWNrcyBpbnN0ZWFkIG9mXG4gICAgICAgIC8vIHJlZmVyZW50aWFsIGNoZWNrcyBhcyB0aGUgcmVmZXJlbmNlcyBjYW4gZGlmZmVyIHRocm91Z2ggdGhlIGxpZmVjeWNsZS5cbiAgICAgICAgaWYgKGxhc3RTdGlja3lSb29tICYmIGxhc3RTdGlja3lSb29tLnJvb20gJiYgbGFzdFN0aWNreVJvb20ucm9vbS5yb29tSWQgIT09IHZhbC5yb29tSWQpIHtcbiAgICAgICAgICAgIC8vIExpZSB0byB0aGUgYWxnb3JpdGhtIGFuZCByZS1hZGQgdGhlIHJvb20gdG8gdGhlIGFsZ29yaXRobVxuICAgICAgICAgICAgdGhpcy5oYW5kbGVSb29tVXBkYXRlKGxhc3RTdGlja3lSb29tLnJvb20sIFJvb21VcGRhdGVDYXVzZS5OZXdSb29tKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMaWUgdG8gdGhlIGFsZ29yaXRobSBhbmQgcmVtb3ZlIHRoZSByb29tIGZyb20gaXQncyBmaWVsZCBvZiB2aWV3XG4gICAgICAgIHRoaXMuaGFuZGxlUm9vbVVwZGF0ZSh2YWwsIFJvb21VcGRhdGVDYXVzZS5Sb29tUmVtb3ZlZCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHRhZyAmIHBvc2l0aW9uIGNoYW5nZXMgd2hpbGUgd2UncmUgaGVyZS4gV2UgYWxzbyBjaGVjayB0aGUgcm9vbSB0byBlbnN1cmVcbiAgICAgICAgLy8gaXQgaXMgc3RpbGwgdGhlIHNhbWUgcm9vbS5cbiAgICAgICAgaWYgKHRoaXMuX3N0aWNreVJvb20pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGlja3lSb29tLnJvb20gIT09IHZhbCkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSByb29tIElEcyBqdXN0IGluIGNhc2VcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RpY2t5Um9vbS5yb29tLnJvb21JZCA9PT0gdmFsLnJvb21JZCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIlN0aWNreSByb29tIGNoYW5nZWQgcmVmZXJlbmNlc1wiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGlja3kgcm9vbSBjaGFuZ2VkIHdoaWxlIHRoZSBzdGlja3kgcm9vbSB3YXMgY2hhbmdpbmdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsb2dnZXIud2FybihgU3RpY2t5IHJvb20gY2hhbmdlZCB0YWcgJiBwb3NpdGlvbiBmcm9tICR7dGFnfSAvICR7cG9zaXRpb259IGBcbiAgICAgICAgICAgICAgICArIGB0byAke3RoaXMuX3N0aWNreVJvb20udGFnfSAvICR7dGhpcy5fc3RpY2t5Um9vbS5wb3NpdGlvbn1gKTtcblxuICAgICAgICAgICAgdGFnID0gdGhpcy5fc3RpY2t5Um9vbS50YWc7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuX3N0aWNreVJvb20ucG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3cgdGhhdCB3ZSdyZSBkb25lIGx5aW5nIHRvIHRoZSBhbGdvcml0aG0sIHdlIG5lZWQgdG8gdXBkYXRlIG91ciBwb3NpdGlvblxuICAgICAgICAvLyBtYXJrZXIgb25seSBpZiB0aGUgdXNlciBpcyBtb3ZpbmcgZnVydGhlciBkb3duIHRoZSBzYW1lIGxpc3QuIElmIHRoZXkncmUgc3dpdGNoaW5nXG4gICAgICAgIC8vIGxpc3RzLCBvciBtb3ZpbmcgdXB3YXJkcywgdGhlIHBvc2l0aW9uIG1hcmtlciB3aWxsIHNwbGljZSBpbiBqdXN0IGZpbmUgYnV0IGlmXG4gICAgICAgIC8vIHRoZXkgd2VudCBkb3dud2FyZHMgaW4gdGhlIHNhbWUgbGlzdCB3ZSdsbCBiZSBvZmYgYnkgMSBkdWUgdG8gdGhlIHNoaWZ0aW5nIHJvb21zLlxuICAgICAgICBpZiAobGFzdFN0aWNreVJvb20gJiYgbGFzdFN0aWNreVJvb20udGFnID09PSB0YWcgJiYgbGFzdFN0aWNreVJvb20ucG9zaXRpb24gPD0gcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdGlja3lSb29tID0ge1xuICAgICAgICAgICAgcm9vbTogdmFsLFxuICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gV2UgdXBkYXRlIHRoZSBmaWx0ZXJlZCByb29tcyBqdXN0IGluIGNhc2UsIGFzIG90aGVyd2lzZSB1c2VycyB3aWxsIGVuZCB1cCB2aXNpdGluZ1xuICAgICAgICAvLyBhIHJvb20gd2hpbGUgZmlsdGVyaW5nIGFuZCBpdCdsbCBkaXNhcHBlYXIuIFdlIGRvbid0IHVwZGF0ZSB0aGUgZmlsdGVyIGVhcmxpZXIgaW5cbiAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiBzaW1wbHkgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHRvLlxuICAgICAgICB0aGlzLnJlY2FsY3VsYXRlRmlsdGVyZWRSb29tc0ZvclRhZyh0YWcpO1xuICAgICAgICBpZiAobGFzdFN0aWNreVJvb20gJiYgbGFzdFN0aWNreVJvb20udGFnICE9PSB0YWcpIHRoaXMucmVjYWxjdWxhdGVGaWx0ZXJlZFJvb21zRm9yVGFnKGxhc3RTdGlja3lSb29tLnRhZyk7XG4gICAgICAgIHRoaXMucmVjYWxjdWxhdGVTdGlja3lSb29tKCk7XG5cbiAgICAgICAgLy8gRmluYWxseSwgdHJpZ2dlciBhbiB1cGRhdGVcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlc0luaGliaXRlZCkgcmV0dXJuO1xuICAgICAgICB0aGlzLmVtaXQoTElTVF9VUERBVEVEX0VWRU5UKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcmVjYWxjdWxhdGVGaWx0ZXJlZFJvb21zKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzRmlsdGVycykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9nZ2VyLndhcm4oXCJSZWNhbGN1bGF0aW5nIGZpbHRlcmVkIHJvb20gbGlzdFwiKTtcbiAgICAgICAgY29uc3QgZmlsdGVycyA9IEFycmF5LmZyb20odGhpcy5hbGxvd2VkQnlGaWx0ZXIua2V5cygpKTtcbiAgICAgICAgY29uc3QgbmV3TWFwOiBJVGFnTWFwID0ge307XG4gICAgICAgIGZvciAoY29uc3QgdGFnSWQgb2YgT2JqZWN0LmtleXModGhpcy5jYWNoZWRSb29tcykpIHtcbiAgICAgICAgICAgIC8vIENoZWFwbHkgY2xvbmUgdGhlIHJvb21zIHNvIHdlIGNhbiBtb3JlIGVhc2lseSBkbyBvcGVyYXRpb25zIG9uIHRoZSBsaXN0LlxuICAgICAgICAgICAgLy8gV2Ugb3B0aW1pemUgb3VyIGxvb2t1cHMgYnkgdHJ5aW5nIHRvIHJlZHVjZSBzYW1wbGUgc2l6ZSBhcyBtdWNoIGFzIHBvc3NpYmxlXG4gICAgICAgICAgICAvLyB0byB0aGUgcm9vbXMgd2Uga25vdyB3aWxsIGJlIGRlZHVwZWQgYnkgdGhlIFNldC5cbiAgICAgICAgICAgIGNvbnN0IHJvb21zID0gdGhpcy5jYWNoZWRSb29tc1t0YWdJZF0ubWFwKHIgPT4gcik7IC8vIGNoZWFwIGNsb25lXG4gICAgICAgICAgICB0aGlzLnRyeUluc2VydFN0aWNreVJvb21Ub0ZpbHRlclNldChyb29tcywgdGFnSWQpO1xuICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nUm9vbXMgPSByb29tcy5tYXAociA9PiByKTtcbiAgICAgICAgICAgIGNvbnN0IGFsbG93ZWRSb29tc0luVGhpc1RhZyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgZmlsdGVycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkUm9vbXMgPSByZW1haW5pbmdSb29tcy5maWx0ZXIociA9PiBmaWx0ZXIuaXNWaXNpYmxlKHIpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJvb20gb2YgZmlsdGVyZWRSb29tcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZHggPSByZW1haW5pbmdSb29tcy5pbmRleE9mKHJvb20pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ID49IDApIHJlbWFpbmluZ1Jvb21zLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBhbGxvd2VkUm9vbXNJblRoaXNUYWcucHVzaChyb29tKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdNYXBbdGFnSWRdID0gYWxsb3dlZFJvb21zSW5UaGlzVGFnO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYWxsb3dlZFJvb21zID0gT2JqZWN0LnZhbHVlcyhuZXdNYXApLnJlZHVjZSgocnYsIHYpID0+IHsgcnYucHVzaCguLi52KTsgcmV0dXJuIHJ2OyB9LCA8Um9vbVtdPltdKTtcbiAgICAgICAgdGhpcy5hbGxvd2VkUm9vbXNCeUZpbHRlcnMgPSBuZXcgU2V0KGFsbG93ZWRSb29tcyk7XG4gICAgICAgIHRoaXMuZmlsdGVyZWRSb29tcyA9IG5ld01hcDtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlc0luaGliaXRlZCkgcmV0dXJuO1xuICAgICAgICB0aGlzLmVtaXQoTElTVF9VUERBVEVEX0VWRU5UKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcmVjYWxjdWxhdGVGaWx0ZXJlZFJvb21zRm9yVGFnKHRhZ0lkOiBUYWdJRCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuaGFzRmlsdGVycykgcmV0dXJuOyAvLyBkb24ndCBib3RoZXIgZG9pbmcgd29yayBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gZG9cblxuICAgICAgICBkZWxldGUgdGhpcy5maWx0ZXJlZFJvb21zW3RhZ0lkXTtcbiAgICAgICAgY29uc3Qgcm9vbXMgPSB0aGlzLmNhY2hlZFJvb21zW3RhZ0lkXS5tYXAociA9PiByKTsgLy8gY2hlYXAgY2xvbmVcbiAgICAgICAgdGhpcy50cnlJbnNlcnRTdGlja3lSb29tVG9GaWx0ZXJTZXQocm9vbXMsIHRhZ0lkKTtcbiAgICAgICAgY29uc3QgZmlsdGVyZWRSb29tcyA9IHJvb21zLmZpbHRlcihyID0+IHRoaXMuYWxsb3dlZFJvb21zQnlGaWx0ZXJzLmhhcyhyKSk7XG4gICAgICAgIGlmIChmaWx0ZXJlZFJvb21zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRSb29tc1t0YWdJZF0gPSBmaWx0ZXJlZFJvb21zO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHRyeUluc2VydFN0aWNreVJvb21Ub0ZpbHRlclNldChyb29tczogUm9vbVtdLCB0YWdJZDogVGFnSUQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zdGlja3lSb29tIHx8ICF0aGlzLl9zdGlja3lSb29tLnJvb20gfHwgdGhpcy5fc3RpY2t5Um9vbS50YWcgIT09IHRhZ0lkKSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLl9zdGlja3lSb29tLnBvc2l0aW9uO1xuICAgICAgICBpZiAocG9zaXRpb24gPj0gcm9vbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByb29tcy5wdXNoKHRoaXMuX3N0aWNreVJvb20ucm9vbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByb29tcy5zcGxpY2UocG9zaXRpb24sIDAsIHRoaXMuX3N0aWNreVJvb20ucm9vbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZSB0aGUgc3RpY2t5IHJvb20gcG9zaXRpb24uIElmIHRoaXMgaXMgYmVpbmcgY2FsbGVkIGluIHJlbGF0aW9uIHRvXG4gICAgICogYSBzcGVjaWZpYyB0YWcgYmVpbmcgdXBkYXRlZCwgaXQgc2hvdWxkIGJlIGdpdmVuIHRvIHRoaXMgZnVuY3Rpb24gdG8gb3B0aW1pemVcbiAgICAgKiB0aGUgY2FsbC5cbiAgICAgKiBAcGFyYW0gdXBkYXRlZFRhZyBUaGUgdGFnIHRoYXQgd2FzIHVwZGF0ZWQsIGlmIHBvc3NpYmxlLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCByZWNhbGN1bGF0ZVN0aWNreVJvb20odXBkYXRlZFRhZzogVGFnSUQgPSBudWxsKTogdm9pZCB7XG4gICAgICAgIC8vIPCfkIkgSGVyZSBiZSBkcmFnb25zLlxuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGRvZXMgZmFyIHRvbyBtdWNoIGZvciB3aGF0IGl0IHNob3VsZCwgYW5kIGlzIGNhbGxlZCBieSBtYW55IHBsYWNlcy5cbiAgICAgICAgLy8gTm90IG9ubHkgaXMgdGhpcyByZXNwb25zaWJsZSBmb3IgZW5zdXJpbmcgdGhlIHN0aWNreSByb29tIGlzIGhlbGQgaW4gcGxhY2UgYXQgYWxsXG4gICAgICAgIC8vIHRpbWVzLCBpdCBpcyBhbHNvIHJlc3BvbnNpYmxlIGZvciBlbnN1cmluZyBvdXIgY2xvbmUgb2YgdGhlIGNhY2hlZFJvb21zIGlzIHVwIHRvXG4gICAgICAgIC8vIGRhdGUuIElmIGVpdGhlciBvZiB0aGVzZSBkZXN5bmNzLCB3ZSBzZWUgd2VpcmQgYmVoYXZpb3VyIGxpa2UgZHVwbGljYXRlZCByb29tcyxcbiAgICAgICAgLy8gb3V0ZGF0ZWQgbGlzdHMsIGFuZCBvdGhlciBub25zZW5zaWNhbCBpc3N1ZXMgdGhhdCBhcmVuJ3QgbmVjZXNzYXJpbHkgb2J2aW91cy5cblxuICAgICAgICBpZiAoIXRoaXMuX3N0aWNreVJvb20pIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gc3RpY2t5IHJvb20sIGp1c3QgZG8gbm90aGluZyB1c2VmdWwuXG4gICAgICAgICAgICBpZiAoISF0aGlzLl9jYWNoZWRTdGlja3lSb29tcykge1xuICAgICAgICAgICAgICAgIC8vIENsZWFyIHRoZSBjYWNoZSBpZiB3ZSB3b24ndCBiZSBuZWVkaW5nIGl0XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkU3RpY2t5Um9vbXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVwZGF0ZXNJbmhpYml0ZWQpIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoTElTVF9VUERBVEVEX0VWRU5UKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fY2FjaGVkU3RpY2t5Um9vbXMgfHwgIXVwZGF0ZWRUYWcpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0aWNraWVkVGFnTWFwOiBJVGFnTWFwID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhZ0lkIG9mIE9iamVjdC5rZXlzKHRoaXMuY2FjaGVkUm9vbXMpKSB7XG4gICAgICAgICAgICAgICAgc3RpY2tpZWRUYWdNYXBbdGFnSWRdID0gdGhpcy5jYWNoZWRSb29tc1t0YWdJZF0ubWFwKHIgPT4gcik7IC8vIHNoYWxsb3cgY2xvbmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZFN0aWNreVJvb21zID0gc3RpY2tpZWRUYWdNYXA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXBkYXRlZFRhZykge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB0YWcgaW5kaWNhdGVkIGJ5IHRoZSBjYWxsZXIsIGlmIHBvc3NpYmxlLiBUaGlzIGlzIG1vc3RseSB0byBlbnN1cmVcbiAgICAgICAgICAgIC8vIG91ciBjYWNoZSBpcyB1cCB0byBkYXRlLlxuICAgICAgICAgICAgdGhpcy5fY2FjaGVkU3RpY2t5Um9vbXNbdXBkYXRlZFRhZ10gPSB0aGlzLmNhY2hlZFJvb21zW3VwZGF0ZWRUYWddLm1hcChyID0+IHIpOyAvLyBzaGFsbG93IGNsb25lXG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3cgdHJ5IHRvIGluc2VydCB0aGUgc3RpY2t5IHJvb20sIGlmIHdlIG5lZWQgdG8uXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gaWYgdGhlcmUncyBubyB1cGRhdGVkIHRhZyAod2UgcmVnZW5uZWQgdGhlIHdob2xlIGNhY2hlKSBvciBpZiB0aGUgdGFnXG4gICAgICAgIC8vIHdlIG1pZ2h0IGhhdmUgdXBkYXRlZCBmcm9tIHRoZSBjYWNoZSBpcyBhbHNvIG91ciBzdGlja3kgcm9vbS5cbiAgICAgICAgY29uc3Qgc3RpY2t5ID0gdGhpcy5fc3RpY2t5Um9vbTtcbiAgICAgICAgaWYgKCF1cGRhdGVkVGFnIHx8IHVwZGF0ZWRUYWcgPT09IHN0aWNreS50YWcpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZFN0aWNreVJvb21zW3N0aWNreS50YWddLnNwbGljZShzdGlja3kucG9zaXRpb24sIDAsIHN0aWNreS5yb29tKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmFsbHksIHRyaWdnZXIgYW4gdXBkYXRlXG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZXNJbmhpYml0ZWQpIHJldHVybjtcbiAgICAgICAgdGhpcy5lbWl0KExJU1RfVVBEQVRFRF9FVkVOVCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNrcyB0aGUgQWxnb3JpdGhtIHRvIHJlZ2VuZXJhdGUgYWxsIGxpc3RzLCB1c2luZyB0aGUgdGFncyBnaXZlblxuICAgICAqIGFzIHJlZmVyZW5jZSBmb3Igd2hpY2ggbGlzdHMgdG8gZ2VuZXJhdGUgYW5kIHdoaWNoIHdheSB0byBnZW5lcmF0ZVxuICAgICAqIHRoZW0uXG4gICAgICogQHBhcmFtIHtJVGFnU29ydGluZ01hcH0gdGFnU29ydGluZ01hcCBUaGUgdGFncyB0byBnZW5lcmF0ZS5cbiAgICAgKiBAcGFyYW0ge0lMaXN0T3JkZXJpbmdNYXB9IGxpc3RPcmRlcmluZ01hcCBUaGUgb3JkZXJpbmcgb2YgdGhvc2UgdGFncy5cbiAgICAgKi9cbiAgICBwdWJsaWMgcG9wdWxhdGVUYWdzKHRhZ1NvcnRpbmdNYXA6IElUYWdTb3J0aW5nTWFwLCBsaXN0T3JkZXJpbmdNYXA6IElMaXN0T3JkZXJpbmdNYXApOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0YWdTb3J0aW5nTWFwKSB0aHJvdyBuZXcgRXJyb3IoYFNvcnRpbmcgbWFwIGNhbm5vdCBiZSBudWxsIG9yIGVtcHR5YCk7XG4gICAgICAgIGlmICghbGlzdE9yZGVyaW5nTWFwKSB0aHJvdyBuZXcgRXJyb3IoYE9yZGVyaW5nIG1hIGNhbm5vdCBiZSBudWxsIG9yIGVtcHR5YCk7XG4gICAgICAgIGlmIChhcnJheUhhc0RpZmYoT2JqZWN0LmtleXModGFnU29ydGluZ01hcCksIE9iamVjdC5rZXlzKGxpc3RPcmRlcmluZ01hcCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJvdGggbWFwcyBtdXN0IGNvbnRhaW4gdGhlIGV4YWN0IHNhbWUgdGFnc2ApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc29ydEFsZ29yaXRobXMgPSB0YWdTb3J0aW5nTWFwO1xuICAgICAgICB0aGlzLmxpc3RBbGdvcml0aG1zID0gbGlzdE9yZGVyaW5nTWFwO1xuICAgICAgICB0aGlzLmFsZ29yaXRobXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB0YWcgb2YgT2JqZWN0LmtleXModGFnU29ydGluZ01hcCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWxnb3JpdGhtc1t0YWddID0gZ2V0TGlzdEFsZ29yaXRobUluc3RhbmNlKHRoaXMubGlzdEFsZ29yaXRobXNbdGFnXSwgdGFnLCB0aGlzLnNvcnRBbGdvcml0aG1zW3RhZ10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNldEtub3duUm9vbXModGhpcy5yb29tcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbiBvcmRlcmVkIHNldCBvZiByb29tcyBmb3IgdGhlIGFsbCBrbm93biB0YWdzLCBmaWx0ZXJlZC5cbiAgICAgKiBAcmV0dXJucyB7SVRhZ01hcH0gVGhlIGNhY2hlZCBsaXN0IG9mIHJvb21zLCBvcmRlcmVkLFxuICAgICAqIGZvciBlYWNoIHRhZy4gTWF5IGJlIGVtcHR5LCBidXQgbmV2ZXIgbnVsbC91bmRlZmluZWQuXG4gICAgICovXG4gICAgcHVibGljIGdldE9yZGVyZWRSb29tcygpOiBJVGFnTWFwIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZpbHRlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRTdGlja3lSb29tcyB8fCB0aGlzLmNhY2hlZFJvb21zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcmVkUm9vbXM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFVuZmlsdGVyZWRSb29tcygpOiBJVGFnTWFwIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZFN0aWNreVJvb21zIHx8IHRoaXMuY2FjaGVkUm9vbXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyByZXR1cm5zIHRoZSBzYW1lIGFzIGdldE9yZGVyZWRSb29tcygpLCBidXQgd2l0aG91dCB0aGUgc3RpY2t5IHJvb21cbiAgICAgKiBtYXAgYXMgaXQgY2F1c2VzIGlzc3VlcyBmb3Igc3RpY2t5IHJvb20gaGFuZGxpbmcgKHNlZSBzdGlja3kgcm9vbSBoYW5kbGluZ1xuICAgICAqIGZvciBtb3JlIGluZm9ybWF0aW9uKS5cbiAgICAgKiBAcmV0dXJucyB7SVRhZ01hcH0gVGhlIGNhY2hlZCBsaXN0IG9mIHJvb21zLCBvcmRlcmVkLFxuICAgICAqIGZvciBlYWNoIHRhZy4gTWF5IGJlIGVtcHR5LCBidXQgbmV2ZXIgbnVsbC91bmRlZmluZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXRPcmRlcmVkUm9vbXNXaXRob3V0U3RpY2t5KCk6IElUYWdNYXAge1xuICAgICAgICBpZiAoIXRoaXMuaGFzRmlsdGVycykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkUm9vbXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyZWRSb29tcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWVkcyB0aGUgQWxnb3JpdGhtIHdpdGggYSBzZXQgb2Ygcm9vbXMuIFRoZSBhbGdvcml0aG0gd2lsbCBkaXNjYXJkIGFsbFxuICAgICAqIHByZXZpb3VzbHkga25vd24gaW5mb3JtYXRpb24gYW5kIGluc3RlYWQgdXNlIHRoZXNlIHJvb21zIGluc3RlYWQuXG4gICAgICogQHBhcmFtIHtSb29tW119IHJvb21zIFRoZSByb29tcyB0byBmb3JjZSB0aGUgYWxnb3JpdGhtIHRvIHVzZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0S25vd25Sb29tcyhyb29tczogUm9vbVtdKTogdm9pZCB7XG4gICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZChyb29tcykpIHRocm93IG5ldyBFcnJvcihgQXJyYXkgb2Ygcm9vbXMgY2Fubm90IGJlIG51bGxgKTtcbiAgICAgICAgaWYgKCF0aGlzLnNvcnRBbGdvcml0aG1zKSB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzZXQga25vd24gcm9vbXMgd2l0aG91dCBhIHRhZyBzb3J0aW5nIG1hcGApO1xuXG4gICAgICAgIGlmICghdGhpcy51cGRhdGVzSW5oaWJpdGVkKSB7XG4gICAgICAgICAgICAvLyBXZSBvbmx5IGxvZyB0aGlzIGlmIHdlJ3JlIGV4cGVjdGluZyB0byBiZSBwdWJsaXNoaW5nIHVwZGF0ZXMsIHdoaWNoIG1lYW5zIHRoYXRcbiAgICAgICAgICAgIC8vIHRoaXMgY291bGQgYmUgYW4gdW5leHBlY3RlZCBpbnZvY2F0aW9uLiBJZiB3ZSdyZSBpbmhpYml0ZWQsIHRoZW4gdGhpcyBpcyBwcm9iYWJseVxuICAgICAgICAgICAgLy8gYW4gaW50ZW50aW9uYWwgaW52b2NhdGlvbi5cbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiUmVzZXR0aW5nIGtub3duIHJvb21zLCBpbml0aWF0aW5nIHJlZ2VuZXJhdGlvblwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlZm9yZSB3ZSBnbyBhbnkgZnVydGhlciB3ZSBuZWVkIHRvIGNsZWFyIChidXQgcmVtZW1iZXIpIHRoZSBzdGlja3kgcm9vbSB0b1xuICAgICAgICAvLyBhdm9pZCBhY2NpZGVudGFsbHkgZHVwbGljYXRpbmcgaXQgaW4gdGhlIGxpc3QuXG4gICAgICAgIGNvbnN0IG9sZFN0aWNreVJvb20gPSB0aGlzLl9zdGlja3lSb29tO1xuICAgICAgICBpZiAob2xkU3RpY2t5Um9vbSkgdGhpcy51cGRhdGVTdGlja3lSb29tKG51bGwpO1xuXG4gICAgICAgIHRoaXMucm9vbXMgPSByb29tcztcblxuICAgICAgICBjb25zdCBuZXdUYWdzOiBJVGFnTWFwID0ge307XG4gICAgICAgIGZvciAoY29uc3QgdGFnSWQgaW4gdGhpcy5zb3J0QWxnb3JpdGhtcykge1xuICAgICAgICAgICAgLy8gbm9pbnNwZWN0aW9uIEpTVW5maWx0ZXJlZEZvckluTG9vcFxuICAgICAgICAgICAgbmV3VGFnc1t0YWdJZF0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGNhbiBhdm9pZCBkb2luZyB3b3JrLCBkbyBzby5cbiAgICAgICAgaWYgKCFyb29tcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVGcmVzaFRhZ3MobmV3VGFncyk7IC8vIGp1c3QgaW4gY2FzZSBpdCB3YW50cyB0byBkbyBzb21ldGhpbmdcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkUm9vbXMgPSBuZXdUYWdzO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3BsaXQgb3V0IHRoZSBlYXN5IHJvb21zIGZpcnN0IChsZWF2ZSBhbmQgaW52aXRlKVxuICAgICAgICBjb25zdCBtZW1iZXJzaGlwcyA9IHNwbGl0Um9vbXNCeU1lbWJlcnNoaXAocm9vbXMpO1xuICAgICAgICBmb3IgKGNvbnN0IHJvb20gb2YgbWVtYmVyc2hpcHNbRWZmZWN0aXZlTWVtYmVyc2hpcC5JbnZpdGVdKSB7XG4gICAgICAgICAgICBuZXdUYWdzW0RlZmF1bHRUYWdJRC5JbnZpdGVdLnB1c2gocm9vbSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCByb29tIG9mIG1lbWJlcnNoaXBzW0VmZmVjdGl2ZU1lbWJlcnNoaXAuTGVhdmVdKSB7XG4gICAgICAgICAgICBuZXdUYWdzW0RlZmF1bHRUYWdJRC5BcmNoaXZlZF0ucHVzaChyb29tKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdyBwcm9jZXNzIGFsbCB0aGUgam9pbmVkIHJvb21zLiBUaGlzIGlzIGEgYml0IG1vcmUgY29tcGxpY2F0ZWRcbiAgICAgICAgZm9yIChjb25zdCByb29tIG9mIG1lbWJlcnNoaXBzW0VmZmVjdGl2ZU1lbWJlcnNoaXAuSm9pbl0pIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZ3MgPSB0aGlzLmdldFRhZ3NPZkpvaW5lZFJvb20ocm9vbSk7XG5cbiAgICAgICAgICAgIGxldCBpblRhZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRhZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdGFnIG9mIHRhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChuZXdUYWdzW3RhZ10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdUYWdzW3RhZ10ucHVzaChyb29tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluVGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpblRhZykge1xuICAgICAgICAgICAgICAgIGlmIChETVJvb21NYXAuc2hhcmVkKCkuZ2V0VXNlcklkRm9yUm9vbUlkKHJvb20ucm9vbUlkKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdUYWdzW0RlZmF1bHRUYWdJRC5ETV0ucHVzaChyb29tKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdUYWdzW0RlZmF1bHRUYWdJRC5VbnRhZ2dlZF0ucHVzaChyb29tKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdlbmVyYXRlRnJlc2hUYWdzKG5ld1RhZ3MpO1xuXG4gICAgICAgIHRoaXMuY2FjaGVkUm9vbXMgPSBuZXdUYWdzOyAvLyB0aGlzIHJlY2FsY3VsYXRlcyB0aGUgZmlsdGVyZWQgcm9vbXMgZm9yIHVzXG4gICAgICAgIHRoaXMudXBkYXRlVGFnc0Zyb21DYWNoZSgpO1xuXG4gICAgICAgIC8vIE5vdyB0aGF0IHdlJ3ZlIGZpbmlzaGVkIGdlbmVyYXRpb24sIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBzdGlja3kgcm9vbSB0byB3aGF0XG4gICAgICAgIC8vIGl0IHdhcy4gSXQncyBlbnRpcmVseSBwb3NzaWJsZSB0aGF0IGl0IGNoYW5nZWQgbGlzdHMgdGhvdWdoLCBzbyBpZiBpdCBkaWQgdGhlblxuICAgICAgICAvLyB3ZSBhbHNvIGhhdmUgdG8gdXBkYXRlIHRoZSBwb3NpdGlvbiBvZiBpdC5cbiAgICAgICAgaWYgKG9sZFN0aWNreVJvb20gJiYgb2xkU3RpY2t5Um9vbS5yb29tKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0aWNreVJvb20ob2xkU3RpY2t5Um9vbS5yb29tKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGlja3lSb29tICYmIHRoaXMuX3N0aWNreVJvb20ucm9vbSkgeyAvLyBqdXN0IGluIGNhc2UgdGhlIHVwZGF0ZSBkb2Vzbid0IGdvIGFjY29yZGluZyB0byBwbGFuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0aWNreVJvb20udGFnICE9PSBvbGRTdGlja3lSb29tLnRhZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBwdXQgdGhlIHN0aWNreSByb29tIGF0IHRoZSB0b3Agb2YgdGhlIGxpc3QgdG8gdHJlYXQgaXQgYXMgYW4gb2J2aW91cyB0YWcgY2hhbmdlLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGlja3lSb29tLnBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZVN0aWNreVJvb20odGhpcy5fc3RpY2t5Um9vbS50YWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXRUYWdzRm9yUm9vbShyb29tOiBSb29tKTogVGFnSURbXSB7XG4gICAgICAgIGNvbnN0IHRhZ3M6IFRhZ0lEW10gPSBbXTtcblxuICAgICAgICBjb25zdCBtZW1iZXJzaGlwID0gZ2V0RWZmZWN0aXZlTWVtYmVyc2hpcChyb29tLmdldE15TWVtYmVyc2hpcCgpKTtcbiAgICAgICAgaWYgKG1lbWJlcnNoaXAgPT09IEVmZmVjdGl2ZU1lbWJlcnNoaXAuSW52aXRlKSB7XG4gICAgICAgICAgICB0YWdzLnB1c2goRGVmYXVsdFRhZ0lELkludml0ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVtYmVyc2hpcCA9PT0gRWZmZWN0aXZlTWVtYmVyc2hpcC5MZWF2ZSkge1xuICAgICAgICAgICAgdGFncy5wdXNoKERlZmF1bHRUYWdJRC5BcmNoaXZlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YWdzLnB1c2goLi4udGhpcy5nZXRUYWdzT2ZKb2luZWRSb29tKHJvb20pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGFncy5sZW5ndGgpIHRhZ3MucHVzaChEZWZhdWx0VGFnSUQuVW50YWdnZWQpO1xuXG4gICAgICAgIHJldHVybiB0YWdzO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VGFnc09mSm9pbmVkUm9vbShyb29tOiBSb29tKTogVGFnSURbXSB7XG4gICAgICAgIGxldCB0YWdzID0gT2JqZWN0LmtleXMocm9vbS50YWdzIHx8IHt9KTtcblxuICAgICAgICBpZiAodGFncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIGEgRE0gaWYgaXQgaXNuJ3QgYW55dGhpbmcgZWxzZVxuICAgICAgICAgICAgaWYgKERNUm9vbU1hcC5zaGFyZWQoKS5nZXRVc2VySWRGb3JSb29tSWQocm9vbS5yb29tSWQpKSB7XG4gICAgICAgICAgICAgICAgdGFncyA9IFtEZWZhdWx0VGFnSUQuRE1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhZ3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcm9vbXNUb1RhZ3MgbWFwXG4gICAgICovXG4gICAgcHJpdmF0ZSB1cGRhdGVUYWdzRnJvbUNhY2hlKCkge1xuICAgICAgICBjb25zdCBuZXdNYXAgPSB7fTtcblxuICAgICAgICBjb25zdCB0YWdzID0gT2JqZWN0LmtleXModGhpcy5jYWNoZWRSb29tcyk7XG4gICAgICAgIGZvciAoY29uc3QgdGFnSWQgb2YgdGFncykge1xuICAgICAgICAgICAgY29uc3Qgcm9vbXMgPSB0aGlzLmNhY2hlZFJvb21zW3RhZ0lkXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgcm9vbSBvZiByb29tcykge1xuICAgICAgICAgICAgICAgIGlmICghbmV3TWFwW3Jvb20ucm9vbUlkXSkgbmV3TWFwW3Jvb20ucm9vbUlkXSA9IFtdO1xuICAgICAgICAgICAgICAgIG5ld01hcFtyb29tLnJvb21JZF0ucHVzaCh0YWdJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJvb21JZHNUb1RhZ3MgPSBuZXdNYXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIEFsZ29yaXRobSBiZWxpZXZlcyBhIGNvbXBsZXRlIHJlZ2VuZXJhdGlvbiBvZiB0aGUgZXhpc3RpbmdcbiAgICAgKiBsaXN0cyBpcyBuZWVkZWQuXG4gICAgICogQHBhcmFtIHtJVGFnTWFwfSB1cGRhdGVkVGFnTWFwIFRoZSB0YWcgbWFwIHdoaWNoIG5lZWRzIHBvcHVsYXRpbmcuIEVhY2ggdGFnXG4gICAgICogd2lsbCBhbHJlYWR5IGhhdmUgdGhlIHJvb21zIHdoaWNoIGJlbG9uZyB0byBpdCAtIHRoZXkganVzdCBuZWVkIG9yZGVyaW5nLiBNdXN0XG4gICAgICogYmUgbXV0YXRlZCBpbiBwbGFjZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIGdlbmVyYXRlRnJlc2hUYWdzKHVwZGF0ZWRUYWdNYXA6IElUYWdNYXApOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsZ29yaXRobXMpIHRocm93IG5ldyBFcnJvcihcIk5vdCByZWFkeTogbm8gYWxnb3JpdGhtcyB0byBkZXRlcm1pbmUgdGFncyBmcm9tXCIpO1xuXG4gICAgICAgIGZvciAoY29uc3QgdGFnIG9mIE9iamVjdC5rZXlzKHVwZGF0ZWRUYWdNYXApKSB7XG4gICAgICAgICAgICBjb25zdCBhbGdvcml0aG06IE9yZGVyaW5nQWxnb3JpdGhtID0gdGhpcy5hbGdvcml0aG1zW3RhZ107XG4gICAgICAgICAgICBpZiAoIWFsZ29yaXRobSkgdGhyb3cgbmV3IEVycm9yKGBObyBhbGdvcml0aG0gZm9yICR7dGFnfWApO1xuXG4gICAgICAgICAgICBhbGdvcml0aG0uc2V0Um9vbXModXBkYXRlZFRhZ01hcFt0YWddKTtcbiAgICAgICAgICAgIHVwZGF0ZWRUYWdNYXBbdGFnXSA9IGFsZ29yaXRobS5vcmRlcmVkUm9vbXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc2tzIHRoZSBBbGdvcml0aG0gdG8gdXBkYXRlIGl0cyBrbm93bGVkZ2Ugb2YgYSByb29tLiBGb3IgZXhhbXBsZSwgd2hlblxuICAgICAqIGEgdXNlciB0YWdzIGEgcm9vbSwgam9pbnMvY3JlYXRlcyBhIHJvb20sIG9yIGxlYXZlcyBhIHJvb20gdGhlIEFsZ29yaXRobVxuICAgICAqIHNob3VsZCBiZSB0b2xkIHRoYXQgdGhlIHJvb20ncyBpbmZvIG1pZ2h0IGhhdmUgY2hhbmdlZC4gVGhlIEFsZ29yaXRobVxuICAgICAqIG1heSBuby1vcCB0aGlzIHJlcXVlc3QgaWYgbm8gY2hhbmdlcyBhcmUgcmVxdWlyZWQuXG4gICAgICogQHBhcmFtIHtSb29tfSByb29tIFRoZSByb29tIHdoaWNoIG1pZ2h0IGhhdmUgYWZmZWN0ZWQgc29ydGluZy5cbiAgICAgKiBAcGFyYW0ge1Jvb21VcGRhdGVDYXVzZX0gY2F1c2UgVGhlIHJlYXNvbiBmb3IgdGhlIHVwZGF0ZSBiZWluZyB0cmlnZ2VyZWQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IEEgYm9vbGVhbiBvZiB3aGV0aGVyIG9yIG5vdCBnZXRPcmRlcmVkUm9vbXMoKVxuICAgICAqIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgcHJvY2Vzc2luZy5cbiAgICAgKi9cbiAgICBwdWJsaWMgaGFuZGxlUm9vbVVwZGF0ZShyb29tOiBSb29tLCBjYXVzZTogUm9vbVVwZGF0ZUNhdXNlKTogYm9vbGVhbiB7XG4gICAgICAgIGlmICghdGhpcy5hbGdvcml0aG1zKSB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgcmVhZHk6IG5vIGFsZ29yaXRobXMgdG8gZGV0ZXJtaW5lIHRhZ3MgZnJvbVwiKTtcblxuICAgICAgICAvLyBOb3RlOiBjaGVjayB0aGUgaXNTdGlja3kgYWdhaW5zdCB0aGUgcm9vbSBJRCBqdXN0IGluIGNhc2UgdGhlIHJlZmVyZW5jZSBpcyB3cm9uZ1xuICAgICAgICBjb25zdCBpc1N0aWNreSA9IHRoaXMuX3N0aWNreVJvb20/LnJvb20/LnJvb21JZCA9PT0gcm9vbS5yb29tSWQ7XG4gICAgICAgIGlmIChjYXVzZSA9PT0gUm9vbVVwZGF0ZUNhdXNlLk5ld1Jvb20pIHtcbiAgICAgICAgICAgIGNvbnN0IGlzRm9yTGFzdFN0aWNreSA9IHRoaXMuX2xhc3RTdGlja3lSb29tPy5yb29tID09PSByb29tO1xuICAgICAgICAgICAgY29uc3Qgcm9vbVRhZ3MgPSB0aGlzLnJvb21JZHNUb1RhZ3Nbcm9vbS5yb29tSWRdO1xuICAgICAgICAgICAgY29uc3QgaGFzVGFncyA9IHJvb21UYWdzICYmIHJvb21UYWdzLmxlbmd0aCA+IDA7XG5cbiAgICAgICAgICAgIC8vIERvbid0IGNoYW5nZSB0aGUgY2F1c2UgaWYgdGhlIGxhc3Qgc3RpY2t5IHJvb20gaXMgYmVpbmcgcmUtYWRkZWQuIElmIHdlIGZhaWwgdG9cbiAgICAgICAgICAgIC8vIHBhc3MgdGhlIGNhdXNlIHRocm91Z2ggYXMgTmV3Um9vbSwgd2UnbGwgZmFpbCB0byBsaWUgdG8gdGhlIGFsZ29yaXRobSBhbmQgdGh1c1xuICAgICAgICAgICAgLy8gbG9zZSB0aGUgcm9vbS5cbiAgICAgICAgICAgIGlmIChoYXNUYWdzICYmICFpc0Zvckxhc3RTdGlja3kpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgJHtyb29tLnJvb21JZH0gaXMgcmVwb3J0ZWRseSBuZXcgYnV0IGlzIGFscmVhZHkga25vd24gLSBhc3N1bWluZyBUYWdDaGFuZ2UgaW5zdGVhZGApO1xuICAgICAgICAgICAgICAgIGNhdXNlID0gUm9vbVVwZGF0ZUNhdXNlLlBvc3NpYmxlVGFnQ2hhbmdlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhlIHJvb20gaXMga25vd24gZmlyc3RcbiAgICAgICAgICAgIGxldCBrbm93blJvb21SZWYgPSB0aGlzLnJvb21zLmluY2x1ZGVzKHJvb20pO1xuICAgICAgICAgICAgaWYgKGhhc1RhZ3MgJiYgIWtub3duUm9vbVJlZikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGAke3Jvb20ucm9vbUlkfSBtaWdodCBiZSBhIHJlZmVyZW5jZSBjaGFuZ2UgLSBhdHRlbXB0aW5nIHRvIHVwZGF0ZSByZWZlcmVuY2VgKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb21zID0gdGhpcy5yb29tcy5tYXAociA9PiByLnJvb21JZCA9PT0gcm9vbS5yb29tSWQgPyByb29tIDogcik7XG4gICAgICAgICAgICAgICAga25vd25Sb29tUmVmID0gdGhpcy5yb29tcy5pbmNsdWRlcyhyb29tKTtcbiAgICAgICAgICAgICAgICBpZiAoIWtub3duUm9vbVJlZikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgJHtyb29tLnJvb21JZH0gaXMgc3RpbGwgbm90IHJlZmVyZW5jZWQuIEl0IG1heSBiZSBzdGlja3kuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIHRhZ3MgZm9yIGEgcm9vbSBhbmQgZG9uJ3QgaGF2ZSB0aGUgcm9vbSByZWZlcmVuY2VkLCBzb21ldGhpbmcgd2VudCBob3JyaWJseVxuICAgICAgICAgICAgLy8gd3JvbmcgLSB0aGUgcmVmZXJlbmNlIHNob3VsZCBoYXZlIGJlZW4gdXBkYXRlZCBhYm92ZS5cbiAgICAgICAgICAgIGlmIChoYXNUYWdzICYmICFrbm93blJvb21SZWYgJiYgIWlzU3RpY2t5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3Jvb20ucm9vbUlkfSBpcyBtaXNzaW5nIGZyb20gcm9vbSBhcnJheSBidXQgaXMga25vd24gLSB0cnlpbmcgdG8gZmluZCBkdXBsaWNhdGVgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTGlrZSBhYm92ZSwgdXBkYXRlIHRoZSByZWZlcmVuY2UgdG8gdGhlIHN0aWNreSByb29tIGlmIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIGlmIChoYXNUYWdzICYmIGlzU3RpY2t5KSB7XG4gICAgICAgICAgICAgICAgLy8gR28gZGlyZWN0bHkgaW4gYW5kIHNldCB0aGUgc3RpY2t5IHJvb20ncyBuZXcgcmVmZXJlbmNlLCBiZWluZyBjYXJlZnVsIG5vdFxuICAgICAgICAgICAgICAgIC8vIHRvIHRyaWdnZXIgYSBzdGlja3kgcm9vbSB1cGRhdGUgb3Vyc2VsdmVzLlxuICAgICAgICAgICAgICAgIHRoaXMuX3N0aWNreVJvb20ucm9vbSA9IHJvb207XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGFmdGVyIGFsbCB0aGF0IHdlJ3JlIHN0aWxsIGEgTmV3Um9vbSB1cGRhdGUsIGFkZCB0aGUgcm9vbSBpZiBhcHBsaWNhYmxlLlxuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgZG8gdGhpcyBmb3IgdGhlIHN0aWNreSByb29tIChiZWNhdXNlIGl0IGNhdXNlcyBkdXBsaWNhdGlvbiBpc3N1ZXMpXG4gICAgICAgICAgICAvLyBvciBpZiB3ZSBrbm93IGFib3V0IHRoZSByZWZlcmVuY2UgKGFzIGl0IHNob3VsZCBiZSByZXBsYWNlZCkuXG4gICAgICAgICAgICBpZiAoY2F1c2UgPT09IFJvb21VcGRhdGVDYXVzZS5OZXdSb29tICYmICFpc1N0aWNreSAmJiAha25vd25Sb29tUmVmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb29tcy5wdXNoKHJvb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGRpZFRhZ0NoYW5nZSA9IGZhbHNlO1xuICAgICAgICBpZiAoY2F1c2UgPT09IFJvb21VcGRhdGVDYXVzZS5Qb3NzaWJsZVRhZ0NoYW5nZSkge1xuICAgICAgICAgICAgY29uc3Qgb2xkVGFncyA9IHRoaXMucm9vbUlkc1RvVGFnc1tyb29tLnJvb21JZF0gfHwgW107XG4gICAgICAgICAgICBjb25zdCBuZXdUYWdzID0gdGhpcy5nZXRUYWdzRm9yUm9vbShyb29tKTtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBhcnJheURpZmYob2xkVGFncywgbmV3VGFncyk7XG4gICAgICAgICAgICBpZiAoZGlmZi5yZW1vdmVkLmxlbmd0aCA+IDAgfHwgZGlmZi5hZGRlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBybVRhZyBvZiBkaWZmLnJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxnb3JpdGhtOiBPcmRlcmluZ0FsZ29yaXRobSA9IHRoaXMuYWxnb3JpdGhtc1tybVRhZ107XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWxnb3JpdGhtKSB0aHJvdyBuZXcgRXJyb3IoYE5vIGFsZ29yaXRobSBmb3IgJHtybVRhZ31gKTtcbiAgICAgICAgICAgICAgICAgICAgYWxnb3JpdGhtLmhhbmRsZVJvb21VcGRhdGUocm9vbSwgUm9vbVVwZGF0ZUNhdXNlLlJvb21SZW1vdmVkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkUm9vbXNbcm1UYWddID0gYWxnb3JpdGhtLm9yZGVyZWRSb29tcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZUZpbHRlcmVkUm9vbXNGb3JUYWcocm1UYWcpOyAvLyB1cGRhdGUgZmlsdGVyIHRvIHJlLXNvcnQgdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZVN0aWNreVJvb20ocm1UYWcpOyAvLyB1cGRhdGUgc3RpY2t5IHJvb20gdG8gbWFrZSBzdXJlIGl0IG1vdmVzIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFkZFRhZyBvZiBkaWZmLmFkZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsZ29yaXRobTogT3JkZXJpbmdBbGdvcml0aG0gPSB0aGlzLmFsZ29yaXRobXNbYWRkVGFnXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGdvcml0aG0pIHRocm93IG5ldyBFcnJvcihgTm8gYWxnb3JpdGhtIGZvciAke2FkZFRhZ31gKTtcbiAgICAgICAgICAgICAgICAgICAgYWxnb3JpdGhtLmhhbmRsZVJvb21VcGRhdGUocm9vbSwgUm9vbVVwZGF0ZUNhdXNlLk5ld1Jvb20pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRSb29tc1thZGRUYWddID0gYWxnb3JpdGhtLm9yZGVyZWRSb29tcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHRhZyBtYXAgc28gd2UgZG9uJ3QgcmVnZW4gaXQgaW4gYSBtb21lbnRcbiAgICAgICAgICAgICAgICB0aGlzLnJvb21JZHNUb1RhZ3Nbcm9vbS5yb29tSWRdID0gbmV3VGFncztcblxuICAgICAgICAgICAgICAgIGNhdXNlID0gUm9vbVVwZGF0ZUNhdXNlLlRpbWVsaW5lO1xuICAgICAgICAgICAgICAgIGRpZFRhZ0NoYW5nZSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSB0YWcgY2hhbmdlIHVwZGF0ZSBhbmQgbm8gdGFncyB3ZXJlIGNoYW5nZWQsIG5vdGhpbmcgdG8gZG8hXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGlkVGFnQ2hhbmdlICYmIGlzU3RpY2t5KSB7XG4gICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgdXBkYXRlIHRoZSB0YWcgZm9yIHRoZSBzdGlja3kgcm9vbSB3aXRob3V0IHRyaWdnZXJpbmcgYSBzdGlja3kgcm9vbVxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZS4gVGhlIHVwZGF0ZSB3aWxsIGJlIGhhbmRsZWQgaW1wbGljaXRseSBieSB0aGUgc3RpY2t5IHJvb20gaGFuZGxpbmcgYW5kXG4gICAgICAgICAgICAgICAgLy8gcmVxdWlyZXMgbm8gY2hhbmdlcyBvbiBvdXIgcGFydCwgaWYgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHN0aWNreSByb29tIGNoYW5nZS5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGFzdFN0aWNreVJvb20pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RpY2t5Um9vbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb20sXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6IHRoaXMucm9vbUlkc1RvVGFnc1tyb29tLnJvb21JZF1bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogMCwgLy8gcmlnaHQgYXQgdGhlIHRvcCBhcyBpdCBjaGFuZ2VkIHRhZ3NcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHRvIGNsZWFyIHRoZSBsb2NrIGFzIHRoZSBzdGlja3kgcm9vbSBjaGFuZ2Ugd2lsbCB0cmlnZ2VyIHVwZGF0ZXMuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RpY2t5Um9vbShyb29tKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgdXBkYXRlIGlzIGZvciBhIHJvb20gY2hhbmdlIHdoaWNoIG1pZ2h0IGJlIHRoZSBzdGlja3kgcm9vbSwgcHJldmVudCBpdC4gV2VcbiAgICAgICAgLy8gbmVlZCB0byBtYWtlIHN1cmUgdGhhdCB0aGUgY2F1c2VzIChOZXdSb29tIGFuZCBSb29tUmVtb3ZlZCkgYXJlIHN0aWxsIHRyaWdnZXJlZCB0aG91Z2hcbiAgICAgICAgLy8gYXMgdGhlIHN0aWNreSByb29tIHJlbGllcyBvbiB0aGlzLlxuICAgICAgICBpZiAoY2F1c2UgIT09IFJvb21VcGRhdGVDYXVzZS5OZXdSb29tICYmIGNhdXNlICE9PSBSb29tVXBkYXRlQ2F1c2UuUm9vbVJlbW92ZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0aWNreVJvb20gPT09IHJvb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMucm9vbUlkc1RvVGFnc1tyb29tLnJvb21JZF0pIHtcbiAgICAgICAgICAgIGlmIChDQVVTRVNfUkVRVUlSSU5HX1JPT00uaW5jbHVkZXMoY2F1c2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHRhZ3MgZm9yIHRoZSByb29tIGFuZCBwb3B1bGF0ZSB0aGUgY2FjaGVcbiAgICAgICAgICAgIGNvbnN0IHJvb21UYWdzID0gdGhpcy5nZXRUYWdzRm9yUm9vbShyb29tKS5maWx0ZXIodCA9PiAhaXNOdWxsT3JVbmRlZmluZWQodGhpcy5jYWNoZWRSb29tc1t0XSkpO1xuXG4gICAgICAgICAgICAvLyBcIlRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlblwiIGNvbmRpdGlvbiAtIHdlIHNwZWNpZnkgRGVmYXVsdFRhZ0lELlVudGFnZ2VkIGluIGdldFRhZ3NGb3JSb29tKCksXG4gICAgICAgICAgICAvLyB3aGljaCBtZWFucyB3ZSBzaG91bGQgKmFsd2F5cyogaGF2ZSBhIHRhZyB0byBnbyBvZmYgb2YuXG4gICAgICAgICAgICBpZiAoIXJvb21UYWdzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKGBUYWdzIGNhbm5vdCBiZSBkZXRlcm1pbmVkIGZvciAke3Jvb20ucm9vbUlkfWApO1xuXG4gICAgICAgICAgICB0aGlzLnJvb21JZHNUb1RhZ3Nbcm9vbS5yb29tSWRdID0gcm9vbVRhZ3M7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0YWdzID0gdGhpcy5yb29tSWRzVG9UYWdzW3Jvb20ucm9vbUlkXTtcbiAgICAgICAgaWYgKCF0YWdzKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgTm8gdGFncyBrbm93biBmb3IgXCIke3Jvb20ubmFtZX1cIiAoJHtyb29tLnJvb21JZH0pYCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2hhbmdlZCA9IGRpZFRhZ0NoYW5nZTtcbiAgICAgICAgZm9yIChjb25zdCB0YWcgb2YgdGFncykge1xuICAgICAgICAgICAgY29uc3QgYWxnb3JpdGhtOiBPcmRlcmluZ0FsZ29yaXRobSA9IHRoaXMuYWxnb3JpdGhtc1t0YWddO1xuICAgICAgICAgICAgaWYgKCFhbGdvcml0aG0pIHRocm93IG5ldyBFcnJvcihgTm8gYWxnb3JpdGhtIGZvciAke3RhZ31gKTtcblxuICAgICAgICAgICAgYWxnb3JpdGhtLmhhbmRsZVJvb21VcGRhdGUocm9vbSwgY2F1c2UpO1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVkUm9vbXNbdGFnXSA9IGFsZ29yaXRobS5vcmRlcmVkUm9vbXM7XG5cbiAgICAgICAgICAgIC8vIEZsYWcgdGhhdCB3ZSd2ZSBkb25lIHNvbWV0aGluZ1xuICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZUZpbHRlcmVkUm9vbXNGb3JUYWcodGFnKTsgLy8gdXBkYXRlIGZpbHRlciB0byByZS1zb3J0IHRoZSBsaXN0XG4gICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlU3RpY2t5Um9vbSh0YWcpOyAvLyB1cGRhdGUgc3RpY2t5IHJvb20gdG8gbWFrZSBzdXJlIGl0IGFwcGVhcnMgaWYgbmVlZGVkXG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cbn1cbiJdfQ==