"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MessagePreviewStore = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _AsyncStoreWithClient = require("../AsyncStoreWithClient");

var _dispatcher = _interopRequireDefault(require("../../dispatcher/dispatcher"));

var _MessageEventPreview = require("./previews/MessageEventPreview");

var _utils = require("matrix-js-sdk/src/utils");

var _CallInviteEventPreview = require("./previews/CallInviteEventPreview");

var _CallAnswerEventPreview = require("./previews/CallAnswerEventPreview");

var _CallHangupEvent = require("./previews/CallHangupEvent");

var _StickerEventPreview = require("./previews/StickerEventPreview");

var _ReactionEventPreview = require("./previews/ReactionEventPreview");

var _AsyncStore = require("../AsyncStore");

/*
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// Emitted event for when a room's preview has changed. First argument will the room for which
// the change happened.
const ROOM_PREVIEW_CHANGED = "room_preview_changed";
const PREVIEWS = {
  'm.room.message': {
    isState: false,
    previewer: new _MessageEventPreview.MessageEventPreview()
  },
  'm.call.invite': {
    isState: false,
    previewer: new _CallInviteEventPreview.CallInviteEventPreview()
  },
  'm.call.answer': {
    isState: false,
    previewer: new _CallAnswerEventPreview.CallAnswerEventPreview()
  },
  'm.call.hangup': {
    isState: false,
    previewer: new _CallHangupEvent.CallHangupEvent()
  },
  'm.sticker': {
    isState: false,
    previewer: new _StickerEventPreview.StickerEventPreview()
  },
  'm.reaction': {
    isState: false,
    previewer: new _ReactionEventPreview.ReactionEventPreview()
  }
}; // The maximum number of events we're willing to look back on to get a preview.

const MAX_EVENTS_BACKWARDS = 50; // type merging ftw

// eslint-disable-line @typescript-eslint/naming-convention
const TAG_ANY = "im.vector.any";

class MessagePreviewStore extends _AsyncStoreWithClient.AsyncStoreWithClient {
  // null indicates the preview is empty / irrelevant
  constructor() {
    super(_dispatcher.default, {});
    (0, _defineProperty2.default)(this, "previews", new Map());
  }

  static get instance() {
    return MessagePreviewStore.internalInstance;
  }

  static getPreviewChangedEventName(room) {
    return `${ROOM_PREVIEW_CHANGED}:${room === null || room === void 0 ? void 0 : room.roomId}`;
  }
  /**
   * Gets the pre-translated preview for a given room
   * @param room The room to get the preview for.
   * @param inTagId The tag ID in which the room resides
   * @returns The preview, or null if none present.
   */


  async getPreviewForRoom(room, inTagId) {
    if (!room) return null; // invalid room, just return nothing

    if (!this.previews.has(room.roomId)) await this.generatePreview(room, inTagId);
    const previews = this.previews.get(room.roomId);
    if (!previews) return null;

    if (!previews.has(inTagId)) {
      return previews.get(TAG_ANY);
    }

    return previews.get(inTagId);
  }

  generatePreviewForEvent(event) {
    const previewDef = PREVIEWS[event.getType()]; // TODO: Handle case where we don't have

    if (!previewDef) return '';
    const previewText = previewDef.previewer.getTextFor(event, null, true);
    return previewText ?? '';
  }

  async generatePreview(room, tagId) {
    const events = room.timeline;
    if (!events) return; // should only happen in tests

    let map = this.previews.get(room.roomId);

    if (!map) {
      map = new Map();
      this.previews.set(room.roomId, map);
    } // Set the tags so we know what to generate


    if (!map.has(TAG_ANY)) map.set(TAG_ANY, null);
    if (tagId && !map.has(tagId)) map.set(tagId, null);
    let changed = false;

    for (let i = events.length - 1; i >= 0; i--) {
      if (i === events.length - MAX_EVENTS_BACKWARDS) {
        // limit reached - clear the preview by breaking out of the loop
        break;
      }

      const event = events[i];
      await this.matrixClient.decryptEventIfNeeded(event);
      const previewDef = PREVIEWS[event.getType()];
      if (!previewDef) continue;
      if (previewDef.isState && (0, _utils.isNullOrUndefined)(event.getStateKey())) continue;
      const anyPreview = previewDef.previewer.getTextFor(event, null);
      if (!anyPreview) continue; // not previewable for some reason

      changed = changed || anyPreview !== map.get(TAG_ANY);
      map.set(TAG_ANY, anyPreview);
      const tagsToGenerate = Array.from(map.keys()).filter(t => t !== TAG_ANY); // we did the any tag above

      for (const genTagId of tagsToGenerate) {
        const realTagId = genTagId === TAG_ANY ? null : genTagId;
        const preview = previewDef.previewer.getTextFor(event, realTagId);

        if (preview === anyPreview) {
          changed = changed || anyPreview !== map.get(genTagId);
          map.delete(genTagId);
        } else {
          changed = changed || preview !== map.get(genTagId);
          map.set(genTagId, preview);
        }
      }

      if (changed) {
        // We've muted the underlying Map, so just emit that we've changed.
        this.previews.set(room.roomId, map);
        this.emit(_AsyncStore.UPDATE_EVENT, this);
        this.emit(MessagePreviewStore.getPreviewChangedEventName(room), room);
      }

      return; // we're done
    } // At this point, we didn't generate a preview so clear it


    this.previews.set(room.roomId, new Map());
    this.emit(_AsyncStore.UPDATE_EVENT, this);
    this.emit(MessagePreviewStore.getPreviewChangedEventName(room), room);
  }

  async onAction(payload) {
    if (!this.matrixClient) return;

    if (payload.action === 'MatrixActions.Room.timeline' || payload.action === 'MatrixActions.Event.decrypted') {
      const event = payload.event; // TODO: Type out the dispatcher

      const isHistoricalEvent = payload.hasOwnProperty("isLiveEvent") && !payload.isLiveEvent;
      if (!this.previews.has(event.getRoomId()) || isHistoricalEvent) return; // not important

      await this.generatePreview(this.matrixClient.getRoom(event.getRoomId()), TAG_ANY);
    }
  }

}

exports.MessagePreviewStore = MessagePreviewStore;
(0, _defineProperty2.default)(MessagePreviewStore, "internalInstance", new MessagePreviewStore());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zdG9yZXMvcm9vbS1saXN0L01lc3NhZ2VQcmV2aWV3U3RvcmUudHMiXSwibmFtZXMiOlsiUk9PTV9QUkVWSUVXX0NIQU5HRUQiLCJQUkVWSUVXUyIsImlzU3RhdGUiLCJwcmV2aWV3ZXIiLCJNZXNzYWdlRXZlbnRQcmV2aWV3IiwiQ2FsbEludml0ZUV2ZW50UHJldmlldyIsIkNhbGxBbnN3ZXJFdmVudFByZXZpZXciLCJDYWxsSGFuZ3VwRXZlbnQiLCJTdGlja2VyRXZlbnRQcmV2aWV3IiwiUmVhY3Rpb25FdmVudFByZXZpZXciLCJNQVhfRVZFTlRTX0JBQ0tXQVJEUyIsIlRBR19BTlkiLCJNZXNzYWdlUHJldmlld1N0b3JlIiwiQXN5bmNTdG9yZVdpdGhDbGllbnQiLCJjb25zdHJ1Y3RvciIsImRlZmF1bHREaXNwYXRjaGVyIiwiTWFwIiwiaW5zdGFuY2UiLCJpbnRlcm5hbEluc3RhbmNlIiwiZ2V0UHJldmlld0NoYW5nZWRFdmVudE5hbWUiLCJyb29tIiwicm9vbUlkIiwiZ2V0UHJldmlld0ZvclJvb20iLCJpblRhZ0lkIiwicHJldmlld3MiLCJoYXMiLCJnZW5lcmF0ZVByZXZpZXciLCJnZXQiLCJnZW5lcmF0ZVByZXZpZXdGb3JFdmVudCIsImV2ZW50IiwicHJldmlld0RlZiIsImdldFR5cGUiLCJwcmV2aWV3VGV4dCIsImdldFRleHRGb3IiLCJ0YWdJZCIsImV2ZW50cyIsInRpbWVsaW5lIiwibWFwIiwic2V0IiwiY2hhbmdlZCIsImkiLCJsZW5ndGgiLCJtYXRyaXhDbGllbnQiLCJkZWNyeXB0RXZlbnRJZk5lZWRlZCIsImdldFN0YXRlS2V5IiwiYW55UHJldmlldyIsInRhZ3NUb0dlbmVyYXRlIiwiQXJyYXkiLCJmcm9tIiwia2V5cyIsImZpbHRlciIsInQiLCJnZW5UYWdJZCIsInJlYWxUYWdJZCIsInByZXZpZXciLCJkZWxldGUiLCJlbWl0IiwiVVBEQVRFX0VWRU5UIiwib25BY3Rpb24iLCJwYXlsb2FkIiwiYWN0aW9uIiwiaXNIaXN0b3JpY2FsRXZlbnQiLCJoYXNPd25Qcm9wZXJ0eSIsImlzTGl2ZUV2ZW50IiwiZ2V0Um9vbUlkIiwiZ2V0Um9vbSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFrQkE7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWlCQTtBQUNBO0FBQ0EsTUFBTUEsb0JBQW9CLEdBQUcsc0JBQTdCO0FBRUEsTUFBTUMsUUFBUSxHQUFHO0FBQ2Isb0JBQWtCO0FBQ2RDLElBQUFBLE9BQU8sRUFBRSxLQURLO0FBRWRDLElBQUFBLFNBQVMsRUFBRSxJQUFJQyx3Q0FBSjtBQUZHLEdBREw7QUFLYixtQkFBaUI7QUFDYkYsSUFBQUEsT0FBTyxFQUFFLEtBREk7QUFFYkMsSUFBQUEsU0FBUyxFQUFFLElBQUlFLDhDQUFKO0FBRkUsR0FMSjtBQVNiLG1CQUFpQjtBQUNiSCxJQUFBQSxPQUFPLEVBQUUsS0FESTtBQUViQyxJQUFBQSxTQUFTLEVBQUUsSUFBSUcsOENBQUo7QUFGRSxHQVRKO0FBYWIsbUJBQWlCO0FBQ2JKLElBQUFBLE9BQU8sRUFBRSxLQURJO0FBRWJDLElBQUFBLFNBQVMsRUFBRSxJQUFJSSxnQ0FBSjtBQUZFLEdBYko7QUFpQmIsZUFBYTtBQUNUTCxJQUFBQSxPQUFPLEVBQUUsS0FEQTtBQUVUQyxJQUFBQSxTQUFTLEVBQUUsSUFBSUssd0NBQUo7QUFGRixHQWpCQTtBQXFCYixnQkFBYztBQUNWTixJQUFBQSxPQUFPLEVBQUUsS0FEQztBQUVWQyxJQUFBQSxTQUFTLEVBQUUsSUFBSU0sMENBQUo7QUFGRDtBQXJCRCxDQUFqQixDLENBMkJBOztBQUNBLE1BQU1DLG9CQUFvQixHQUFHLEVBQTdCLEMsQ0FFQTs7QUFDZ0M7QUFDaEMsTUFBTUMsT0FBZ0IsR0FBRyxlQUF6Qjs7QUFNTyxNQUFNQyxtQkFB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QUFSLEtBQW1CLCtCQUEzRSxFQUE0RztBQUN4RyxZQUFNL0IsS0FBSyxHQUFHOEIsT0FBTyxDQUFDOUIsS0FBdEIsQ0FEd0csQ0FDM0U7O0FBQzdCLFlBQU1nQyxpQkFBaUIsR0FBR0YsT0FBTyxDQUFDRyxjQUFSLENBQXVCLGFBQXZCLEtBQXlDLENBQUNILE9BQU8sQ0FBQ0ksV0FBNUU7QUFDQSxVQUFJLENBQUMsS0FBS3ZDLFFBQUwsQ0FBY0MsR0FBZCxDQUFrQkksS0FBSyxDQUFDbUMsU0FBTixFQUFsQixDQUFELElBQXlDSCxpQkFBN0MsRUFBZ0UsT0FId0MsQ0FHaEM7O0FBQ3hFLFlBQU0sS0FBS25DLGVBQUwsQ0FBcUIsS0FBS2dCLFlBQUwsQ0FBa0J1QixPQUFsQixDQUEwQnBDLEtBQUssQ0FBQ21DLFNBQU4sRUFBMUIsQ0FBckIsRUFBbUVyRCxPQUFuRSxDQUFOO0FBQ0g7QUFDSjs7QUF0SGlFOzs7OEJBQXpEQyxtQixzQkFDeUIsSUFBSUEsbUJBQUosRSIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAyMCBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB7IFJvb20gfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvbW9kZWxzL3Jvb21cIjtcbmltcG9ydCB7IEFjdGlvblBheWxvYWQgfSBmcm9tIFwiLi4vLi4vZGlzcGF0Y2hlci9wYXlsb2Fkc1wiO1xuaW1wb3J0IHsgQXN5bmNTdG9yZVdpdGhDbGllbnQgfSBmcm9tIFwiLi4vQXN5bmNTdG9yZVdpdGhDbGllbnRcIjtcbmltcG9ydCBkZWZhdWx0RGlzcGF0Y2hlciBmcm9tIFwiLi4vLi4vZGlzcGF0Y2hlci9kaXNwYXRjaGVyXCI7XG5pbXBvcnQgeyBNZXNzYWdlRXZlbnRQcmV2aWV3IH0gZnJvbSBcIi4vcHJldmlld3MvTWVzc2FnZUV2ZW50UHJldmlld1wiO1xuaW1wb3J0IHsgVGFnSUQgfSBmcm9tIFwiLi9tb2RlbHNcIjtcbmltcG9ydCB7IGlzTnVsbE9yVW5kZWZpbmVkIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL3V0aWxzXCI7XG5pbXBvcnQgeyBDYWxsSW52aXRlRXZlbnRQcmV2aWV3IH0gZnJvbSBcIi4vcHJldmlld3MvQ2FsbEludml0ZUV2ZW50UHJldmlld1wiO1xuaW1wb3J0IHsgQ2FsbEFuc3dlckV2ZW50UHJldmlldyB9IGZyb20gXCIuL3ByZXZpZXdzL0NhbGxBbnN3ZXJFdmVudFByZXZpZXdcIjtcbmltcG9ydCB7IENhbGxIYW5ndXBFdmVudCB9IGZyb20gXCIuL3ByZXZpZXdzL0NhbGxIYW5ndXBFdmVudFwiO1xuaW1wb3J0IHsgU3RpY2tlckV2ZW50UHJldmlldyB9IGZyb20gXCIuL3ByZXZpZXdzL1N0aWNrZXJFdmVudFByZXZpZXdcIjtcbmltcG9ydCB7IFJlYWN0aW9uRXZlbnRQcmV2aWV3IH0gZnJvbSBcIi4vcHJldmlld3MvUmVhY3Rpb25FdmVudFByZXZpZXdcIjtcbmltcG9ydCB7IFVQREFURV9FVkVOVCB9IGZyb20gXCIuLi9Bc3luY1N0b3JlXCI7XG5pbXBvcnQgeyBNYXRyaXhFdmVudCB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9tb2RlbHMvZXZlbnRcIjtcblxuLy8gRW1pdHRlZCBldmVudCBmb3Igd2hlbiBhIHJvb20ncyBwcmV2aWV3IGhhcyBjaGFuZ2VkLiBGaXJzdCBhcmd1bWVudCB3aWxsIHRoZSByb29tIGZvciB3aGljaFxuLy8gdGhlIGNoYW5nZSBoYXBwZW5lZC5cbmNvbnN0IFJPT01fUFJFVklFV19DSEFOR0VEID0gXCJyb29tX3ByZXZpZXdfY2hhbmdlZFwiO1xuXG5jb25zdCBQUkVWSUVXUyA9IHtcbiAgICAnbS5yb29tLm1lc3NhZ2UnOiB7XG4gICAgICAgIGlzU3RhdGU6IGZhbHNlLFxuICAgICAgICBwcmV2aWV3ZXI6IG5ldyBNZXNzYWdlRXZlbnRQcmV2aWV3KCksXG4gICAgfSxcbiAgICAnbS5jYWxsLmludml0ZSc6IHtcbiAgICAgICAgaXNTdGF0ZTogZmFsc2UsXG4gICAgICAgIHByZXZpZXdlcjogbmV3IENhbGxJbnZpdGVFdmVudFByZXZpZXcoKSxcbiAgICB9LFxuICAgICdtLmNhbGwuYW5zd2VyJzoge1xuICAgICAgICBpc1N0YXRlOiBmYWxzZSxcbiAgICAgICAgcHJldmlld2VyOiBuZXcgQ2FsbEFuc3dlckV2ZW50UHJldmlldygpLFxuICAgIH0sXG4gICAgJ20uY2FsbC5oYW5ndXAnOiB7XG4gICAgICAgIGlzU3RhdGU6IGZhbHNlLFxuICAgICAgICBwcmV2aWV3ZXI6IG5ldyBDYWxsSGFuZ3VwRXZlbnQoKSxcbiAgICB9LFxuICAgICdtLnN0aWNrZXInOiB7XG4gICAgICAgIGlzU3RhdGU6IGZhbHNlLFxuICAgICAgICBwcmV2aWV3ZXI6IG5ldyBTdGlja2VyRXZlbnRQcmV2aWV3KCksXG4gICAgfSxcbiAgICAnbS5yZWFjdGlvbic6IHtcbiAgICAgICAgaXNTdGF0ZTogZmFsc2UsXG4gICAgICAgIHByZXZpZXdlcjogbmV3IFJlYWN0aW9uRXZlbnRQcmV2aWV3KCksXG4gICAgfSxcbn07XG5cbi8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBldmVudHMgd2UncmUgd2lsbGluZyB0byBsb29rIGJhY2sgb24gdG8gZ2V0IGEgcHJldmlldy5cbmNvbnN0IE1BWF9FVkVOVFNfQkFDS1dBUkRTID0gNTA7XG5cbi8vIHR5cGUgbWVyZ2luZyBmdHdcbnR5cGUgVEFHX0FOWSA9IFwiaW0udmVjdG9yLmFueVwiOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuY29uc3QgVEFHX0FOWTogVEFHX0FOWSA9IFwiaW0udmVjdG9yLmFueVwiO1xuXG5pbnRlcmZhY2UgSVN0YXRlIHtcbiAgICAvLyBFbXB0eSBiZWNhdXNlIHdlIGRvbid0IGFjdHVhbGx5IHVzZSB0aGUgc3RhdGVcbn1cblxuZXhwb3J0IGNsYXNzIE1lc3NhZ2VQcmV2aWV3U3RvcmUgZXh0ZW5kcyBBc3luY1N0b3JlV2l0aENsaWVudDxJU3RhdGU+IHtcbiAgICBwcml2YXRlIHN0YXRpYyBpbnRlcm5hbEluc3RhbmNlID0gbmV3IE1lc3NhZ2VQcmV2aWV3U3RvcmUoKTtcblxuICAgIC8vIG51bGwgaW5kaWNhdGVzIHRoZSBwcmV2aWV3IGlzIGVtcHR5IC8gaXJyZWxldmFudFxuICAgIHByaXZhdGUgcHJldmlld3MgPSBuZXcgTWFwPHN0cmluZywgTWFwPFRhZ0lEfFRBR19BTlksIHN0cmluZ3xudWxsPj4oKTtcblxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKGRlZmF1bHREaXNwYXRjaGVyLCB7fSk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBnZXQgaW5zdGFuY2UoKTogTWVzc2FnZVByZXZpZXdTdG9yZSB7XG4gICAgICAgIHJldHVybiBNZXNzYWdlUHJldmlld1N0b3JlLmludGVybmFsSW5zdGFuY2U7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBnZXRQcmV2aWV3Q2hhbmdlZEV2ZW50TmFtZShyb29tOiBSb29tKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGAke1JPT01fUFJFVklFV19DSEFOR0VEfToke3Jvb20/LnJvb21JZH1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHByZS10cmFuc2xhdGVkIHByZXZpZXcgZm9yIGEgZ2l2ZW4gcm9vbVxuICAgICAqIEBwYXJhbSByb29tIFRoZSByb29tIHRvIGdldCB0aGUgcHJldmlldyBmb3IuXG4gICAgICogQHBhcmFtIGluVGFnSWQgVGhlIHRhZyBJRCBpbiB3aGljaCB0aGUgcm9vbSByZXNpZGVzXG4gICAgICogQHJldHVybnMgVGhlIHByZXZpZXcsIG9yIG51bGwgaWYgbm9uZSBwcmVzZW50LlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBnZXRQcmV2aWV3Rm9yUm9vbShyb29tOiBSb29tLCBpblRhZ0lkOiBUYWdJRCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGlmICghcm9vbSkgcmV0dXJuIG51bGw7IC8vIGludmFsaWQgcm9vbSwganVzdCByZXR1cm4gbm90aGluZ1xuXG4gICAgICAgIGlmICghdGhpcy5wcmV2aWV3cy5oYXMocm9vbS5yb29tSWQpKSBhd2FpdCB0aGlzLmdlbmVyYXRlUHJldmlldyhyb29tLCBpblRhZ0lkKTtcblxuICAgICAgICBjb25zdCBwcmV2aWV3cyA9IHRoaXMucHJldmlld3MuZ2V0KHJvb20ucm9vbUlkKTtcbiAgICAgICAgaWYgKCFwcmV2aWV3cykgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgaWYgKCFwcmV2aWV3cy5oYXMoaW5UYWdJZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2aWV3cy5nZXQoVEFHX0FOWSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZXZpZXdzLmdldChpblRhZ0lkKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2VuZXJhdGVQcmV2aWV3Rm9yRXZlbnQoZXZlbnQ6IE1hdHJpeEV2ZW50KTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgcHJldmlld0RlZiA9IFBSRVZJRVdTW2V2ZW50LmdldFR5cGUoKV07XG4gICAgICAgIC8vIFRPRE86IEhhbmRsZSBjYXNlIHdoZXJlIHdlIGRvbid0IGhhdmVcbiAgICAgICAgaWYgKCFwcmV2aWV3RGVmKSByZXR1cm4gJyc7XG4gICAgICAgIGNvbnN0IHByZXZpZXdUZXh0ID0gcHJldmlld0RlZi5wcmV2aWV3ZXIuZ2V0VGV4dEZvcihldmVudCwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBwcmV2aWV3VGV4dCA/PyAnJztcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIGdlbmVyYXRlUHJldmlldyhyb29tOiBSb29tLCB0YWdJZD86IFRhZ0lEKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IHJvb20udGltZWxpbmU7XG4gICAgICAgIGlmICghZXZlbnRzKSByZXR1cm47IC8vIHNob3VsZCBvbmx5IGhhcHBlbiBpbiB0ZXN0c1xuXG4gICAgICAgIGxldCBtYXAgPSB0aGlzLnByZXZpZXdzLmdldChyb29tLnJvb21JZCk7XG4gICAgICAgIGlmICghbWFwKSB7XG4gICAgICAgICAgICBtYXAgPSBuZXcgTWFwPFRhZ0lEIHwgVEFHX0FOWSwgc3RyaW5nIHwgbnVsbD4oKTtcbiAgICAgICAgICAgIHRoaXMucHJldmlld3Muc2V0KHJvb20ucm9vbUlkLCBtYXApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHRoZSB0YWdzIHNvIHdlIGtub3cgd2hhdCB0byBnZW5lcmF0ZVxuICAgICAgICBpZiAoIW1hcC5oYXMoVEFHX0FOWSkpIG1hcC5zZXQoVEFHX0FOWSwgbnVsbCk7XG4gICAgICAgIGlmICh0YWdJZCAmJiAhbWFwLmhhcyh0YWdJZCkpIG1hcC5zZXQodGFnSWQsIG51bGwpO1xuXG4gICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSBldmVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChpID09PSBldmVudHMubGVuZ3RoIC0gTUFYX0VWRU5UU19CQUNLV0FSRFMpIHtcbiAgICAgICAgICAgICAgICAvLyBsaW1pdCByZWFjaGVkIC0gY2xlYXIgdGhlIHByZXZpZXcgYnkgYnJlYWtpbmcgb3V0IG9mIHRoZSBsb29wXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gZXZlbnRzW2ldO1xuXG4gICAgICAgICAgICBhd2FpdCB0aGlzLm1hdHJpeENsaWVudC5kZWNyeXB0RXZlbnRJZk5lZWRlZChldmVudCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHByZXZpZXdEZWYgPSBQUkVWSUVXU1tldmVudC5nZXRUeXBlKCldO1xuICAgICAgICAgICAgaWYgKCFwcmV2aWV3RGVmKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChwcmV2aWV3RGVmLmlzU3RhdGUgJiYgaXNOdWxsT3JVbmRlZmluZWQoZXZlbnQuZ2V0U3RhdGVLZXkoKSkpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjb25zdCBhbnlQcmV2aWV3ID0gcHJldmlld0RlZi5wcmV2aWV3ZXIuZ2V0VGV4dEZvcihldmVudCwgbnVsbCk7XG4gICAgICAgICAgICBpZiAoIWFueVByZXZpZXcpIGNvbnRpbnVlOyAvLyBub3QgcHJldmlld2FibGUgZm9yIHNvbWUgcmVhc29uXG5cbiAgICAgICAgICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IGFueVByZXZpZXcgIT09IG1hcC5nZXQoVEFHX0FOWSk7XG4gICAgICAgICAgICBtYXAuc2V0KFRBR19BTlksIGFueVByZXZpZXcpO1xuXG4gICAgICAgICAgICBjb25zdCB0YWdzVG9HZW5lcmF0ZSA9IEFycmF5LmZyb20obWFwLmtleXMoKSkuZmlsdGVyKHQgPT4gdCAhPT0gVEFHX0FOWSk7IC8vIHdlIGRpZCB0aGUgYW55IHRhZyBhYm92ZVxuICAgICAgICAgICAgZm9yIChjb25zdCBnZW5UYWdJZCBvZiB0YWdzVG9HZW5lcmF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlYWxUYWdJZDogVGFnSUQgPSBnZW5UYWdJZCA9PT0gVEFHX0FOWSA/IG51bGwgOiBnZW5UYWdJZDtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2aWV3ID0gcHJldmlld0RlZi5wcmV2aWV3ZXIuZ2V0VGV4dEZvcihldmVudCwgcmVhbFRhZ0lkKTtcbiAgICAgICAgICAgICAgICBpZiAocHJldmlldyA9PT0gYW55UHJldmlldykge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBhbnlQcmV2aWV3ICE9PSBtYXAuZ2V0KGdlblRhZ0lkKTtcbiAgICAgICAgICAgICAgICAgICAgbWFwLmRlbGV0ZShnZW5UYWdJZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IGNoYW5nZWQgfHwgcHJldmlldyAhPT0gbWFwLmdldChnZW5UYWdJZCk7XG4gICAgICAgICAgICAgICAgICAgIG1hcC5zZXQoZ2VuVGFnSWQsIHByZXZpZXcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSd2ZSBtdXRlZCB0aGUgdW5kZXJseWluZyBNYXAsIHNvIGp1c3QgZW1pdCB0aGF0IHdlJ3ZlIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2aWV3cy5zZXQocm9vbS5yb29tSWQsIG1hcCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFVQREFURV9FVkVOVCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KE1lc3NhZ2VQcmV2aWV3U3RvcmUuZ2V0UHJldmlld0NoYW5nZWRFdmVudE5hbWUocm9vbSksIHJvb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuOyAvLyB3ZSdyZSBkb25lXG4gICAgICAgIH1cblxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBkaWRuJ3QgZ2VuZXJhdGUgYSBwcmV2aWV3IHNvIGNsZWFyIGl0XG4gICAgICAgIHRoaXMucHJldmlld3Muc2V0KHJvb20ucm9vbUlkLCBuZXcgTWFwPFRhZ0lEfFRBR19BTlksIHN0cmluZ3xudWxsPigpKTtcbiAgICAgICAgdGhpcy5lbWl0KFVQREFURV9FVkVOVCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZW1pdChNZXNzYWdlUHJldmlld1N0b3JlLmdldFByZXZpZXdDaGFuZ2VkRXZlbnROYW1lKHJvb20pLCByb29tKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgYXN5bmMgb25BY3Rpb24ocGF5bG9hZDogQWN0aW9uUGF5bG9hZCkge1xuICAgICAgICBpZiAoIXRoaXMubWF0cml4Q2xpZW50KSByZXR1cm47XG5cbiAgICAgICAgaWYgKHBheWxvYWQuYWN0aW9uID09PSAnTWF0cml4QWN0aW9ucy5Sb29tLnRpbWVsaW5lJyB8fCBwYXlsb2FkLmFjdGlvbiA9PT0gJ01hdHJpeEFjdGlvbnMuRXZlbnQuZGVjcnlwdGVkJykge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBwYXlsb2FkLmV2ZW50OyAvLyBUT0RPOiBUeXBlIG91dCB0aGUgZGlzcGF0Y2hlclxuICAgICAgICAgICAgY29uc3QgaXNIaXN0b3JpY2FsRXZlbnQgPSBwYXlsb2FkLmhhc093blByb3BlcnR5KFwiaXNMaXZlRXZlbnRcIikgJiYgIXBheWxvYWQuaXNMaXZlRXZlbnQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMucHJldmlld3MuaGFzKGV2ZW50LmdldFJvb21JZCgpKSB8fCBpc0hpc3RvcmljYWxFdmVudCkgcmV0dXJuOyAvLyBub3QgaW1wb3J0YW50XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmdlbmVyYXRlUHJldmlldyh0aGlzLm1hdHJpeENsaWVudC5nZXRSb29tKGV2ZW50LmdldFJvb21JZCgpKSwgVEFHX0FOWSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXX0=