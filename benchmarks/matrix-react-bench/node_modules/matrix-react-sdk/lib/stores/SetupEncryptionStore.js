"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SetupEncryptionStore = exports.Phase = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _events = _interopRequireDefault(require("events"));

var _VerificationRequest = require("matrix-js-sdk/src/crypto/verification/request/VerificationRequest");

var _MatrixClientPeg = require("../MatrixClientPeg");

var _SecurityManager = require("../SecurityManager");

var _Modal = _interopRequireDefault(require("../Modal"));

var _InteractiveAuthDialog = _interopRequireDefault(require("../components/views/dialogs/InteractiveAuthDialog"));

var _languageHandler = require("../languageHandler");

var _logger = require("matrix-js-sdk/src/logger");

/*
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
let Phase;
exports.Phase = Phase;

(function (Phase) {
  Phase[Phase["Loading"] = 0] = "Loading";
  Phase[Phase["Intro"] = 1] = "Intro";
  Phase[Phase["Busy"] = 2] = "Busy";
  Phase[Phase["Done"] = 3] = "Done";
  Phase[Phase["ConfirmSkip"] = 4] = "ConfirmSkip";
  Phase[Phase["Finished"] = 5] = "Finished";
  Phase[Phase["ConfirmReset"] = 6] = "ConfirmReset";
})(Phase || (exports.Phase = Phase = {}));

class SetupEncryptionStore extends _events.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "started", void 0);
    (0, _defineProperty2.default)(this, "phase", void 0);
    (0, _defineProperty2.default)(this, "verificationRequest", void 0);
    (0, _defineProperty2.default)(this, "backupInfo", void 0);
    (0, _defineProperty2.default)(this, "keyId", void 0);
    (0, _defineProperty2.default)(this, "keyInfo", void 0);
    (0, _defineProperty2.default)(this, "hasDevicesToVerifyAgainst", void 0);
    (0, _defineProperty2.default)(this, "onUserTrustStatusChanged", userId => {
      if (userId !== _MatrixClientPeg.MatrixClientPeg.get().getUserId()) return;

      const publicKeysTrusted = _MatrixClientPeg.MatrixClientPeg.get().getCrossSigningId();

      if (publicKeysTrusted) {
        this.phase = Phase.Done;
        this.emit("update");
      }
    });
    (0, _defineProperty2.default)(this, "onVerificationRequest", request => {
      this.setActiveVerificationRequest(request);
    });
    (0, _defineProperty2.default)(this, "onVerificationRequestChange", () => {
      if (this.verificationRequest.cancelled) {
        this.verificationRequest.off("change", this.onVerificationRequestChange);
        this.verificationRequest = null;
        this.emit("update");
      } else if (this.verificationRequest.phase === _VerificationRequest.PHASE_DONE) {
        this.verificationRequest.off("change", this.onVerificationRequestChange);
        this.verificationRequest = null; // At this point, the verification has finished, we just need to wait for
        // cross signing to be ready to use, so wait for the user trust status to
        // change (or change to DONE if it's already ready).

        const publicKeysTrusted = _MatrixClientPeg.MatrixClientPeg.get().getCrossSigningId();

        this.phase = publicKeysTrusted ? Phase.Done : Phase.Busy;
        this.emit("update");
      }
    });
  }

  static sharedInstance() {
    if (!window.mxSetupEncryptionStore) window.mxSetupEncryptionStore = new SetupEncryptionStore();
    return window.mxSetupEncryptionStore;
  }

  start() {
    if (this.started) {
      return;
    }

    this.started = true;
    this.phase = Phase.Loading;
    this.verificationRequest = null;
    this.backupInfo = null; // ID of the key that the secrets we want are encrypted with

    this.keyId = null; // Descriptor of the key that the secrets we want are encrypted with

    this.keyInfo = null;

    const cli = _MatrixClientPeg.MatrixClientPeg.get();

    cli.on("crypto.verification.request", this.onVerificationRequest);
    cli.on('userTrustStatusChanged', this.onUserTrustStatusChanged);
    const requestsInProgress = cli.getVerificationRequestsToDeviceInProgress(cli.getUserId());

    if (requestsInProgress.length) {
      // If there are multiple, we take the most recent. Equally if the user sends another request from
      // another device after this screen has been shown, we'll switch to the new one, so this
      // generally doesn't support multiple requests.
      this.setActiveVerificationRequest(requestsInProgress[requestsInProgress.length - 1]);
    }

    this.fetchKeyInfo();
  }

  stop() {
    if (!this.started) {
      return;
    }

    this.started = false;

    if (this.verificationRequest) {
      this.verificationRequest.off("change", this.onVerificationRequestChange);
    }

    if (_MatrixClientPeg.MatrixClientPeg.get()) {
      _MatrixClientPeg.MatrixClientPeg.get().removeListener("crypto.verification.request", this.onVerificationRequest);

      _MatrixClientPeg.MatrixClientPeg.get().removeListener('userTrustStatusChanged', this.onUserTrustStatusChanged);
    }
  }

  async fetchKeyInfo() {
    const cli = _MatrixClientPeg.MatrixClientPeg.get();

    const keys = await cli.isSecretStored('m.cross_signing.master', false);

    if (keys === null || Object.keys(keys).length === 0) {
      this.keyId = null;
      this.keyInfo = null;
    } else {
      // If the secret is stored under more than one key, we just pick an arbitrary one
      this.keyId = Object.keys(keys)[0];
      this.keyInfo = keys[this.keyId];
    } // do we have any other verified devices which are E2EE which we can verify against?


    const dehydratedDevice = await cli.getDehydratedDevice();
    const ownUserId = cli.getUserId();
    const crossSigningInfo = cli.getStoredCrossSigningForUser(ownUserId);
    this.hasDevicesToVerifyAgainst = cli.getStoredDevicesForUser(ownUserId).some(device => device.getIdentityKey() && (!dehydratedDevice || device.deviceId != dehydratedDevice.device_id) && crossSigningInfo.checkDeviceTrust(crossSigningInfo, device, false, true).isCrossSigningVerified());
    this.phase = Phase.Intro;
    this.emit("update");
  }

  async usePassPhrase() {
    this.phase = Phase.Busy;
    this.emit("update");

    const cli = _MatrixClientPeg.MatrixClientPeg.get();

    try {
      const backupInfo = await cli.getKeyBackupVersion();
      this.backupInfo = backupInfo;
      this.emit("update"); // The control flow is fairly twisted here...
      // For the purposes of completing security, we only wait on getting
      // as far as the trust check and then show a green shield.
      // We also begin the key backup restore as well, which we're
      // awaiting inside `accessSecretStorage` only so that it keeps your
      // passphase cached for that work. This dialog itself will only wait
      // on the first trust check, and the key backup restore will happen
      // in the background.

      await new Promise((resolve, reject) => {
        (0, _SecurityManager.accessSecretStorage)(async () => {
          await cli.checkOwnCrossSigningTrust();
          resolve();

          if (backupInfo) {
            // A complete restore can take many minutes for large
            // accounts / slow servers, so we allow the dialog
            // to advance before this.
            await cli.restoreKeyBackupWithSecretStorage(backupInfo);
          }
        }).catch(reject);
      });

      if (cli.getCrossSigningId()) {
        this.phase = Phase.Done;
        this.emit("update");
      }
    } catch (e) {
      if (!(e instanceof _SecurityManager.AccessCancelledError)) {
        _logger.logger.log(e);
      } // this will throw if the user hits cancel, so ignore


      this.phase = Phase.Intro;
      this.emit("update");
    }
  }

  skip() {
    this.phase = Phase.ConfirmSkip;
    this.emit("update");
  }

  skipConfirm() {
    this.phase = Phase.Finished;
    this.emit("update");
  }

  returnAfterSkip() {
    this.phase = Phase.Intro;
    this.emit("update");
  }

  reset() {
    this.phase = Phase.ConfirmReset;
    this.emit("update");
  }

  async resetConfirm() {
    try {
      // If we've gotten here, the user presumably lost their
      // secret storage key if they had one. Start by resetting
      // secret storage and setting up a new recovery key, then
      // create new cross-signing keys once that succeeds.
      await (0, _SecurityManager.accessSecretStorage)(async () => {
        const cli = _MatrixClientPeg.MatrixClientPeg.get();

        await cli.bootstrapCrossSigning({
          authUploadDeviceSigningKeys: async makeRequest => {
            const {
              finished
            } = _Modal.default.createTrackedDialog('Cross-signing keys dialog', '', _InteractiveAuthDialog.default, {
              title: (0, _languageHandler._t)("Setting up keys"),
              matrixClient: cli,
              makeRequest
            });

            const [confirmed] = await finished;

            if (!confirmed) {
              throw new Error("Cross-signing key upload auth canceled");
            }
          },
          setupNewCrossSigning: true
        });
        this.phase = Phase.Finished;
      }, true);
    } catch (e) {
      _logger.logger.error("Error resetting cross-signing", e);

      this.phase = Phase.Intro;
    }

    this.emit("update");
  }

  returnAfterReset() {
    this.phase = Phase.Intro;
    this.emit("update");
  }

  done() {
    this.phase = Phase.Finished;
    this.emit("update"); // async - ask other clients for keys, if necessary

    _MatrixClientPeg.MatrixClientPeg.get().crypto.cancelAndResendAllOutgoingKeyRequests();
  }

  async setActiveVerificationRequest(request) {
    if (request.otherUserId !== _MatrixClientPeg.MatrixClientPeg.get().getUserId()) return;

    if (this.verificationRequest) {
      this.verificationRequest.off("change", this.onVerificationRequestChange);
    }

    this.verificationRequest = request;
    await request.accept();
    request.on("change", this.onVerificationRequestChange);
    this.emit("update");
  }

  lostKeys() {
    return !this.hasDevicesToVerifyAgainst && !this.keyInfo;
  }

}

exports.SetupEncryptionStore = SetupEncryptionStore;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zdG9yZXMvU2V0dXBFbmNyeXB0aW9uU3RvcmUudHMiXSwibmFtZXMiOlsiUGhhc2UiLCJTZXR1cEVuY3J5cHRpb25TdG9yZSIsIkV2ZW50RW1pdHRlciIsInVzZXJJZCIsIk1hdHJpeENsaWVudFBlZyIsImdldCIsImdldFVzZXJJZCIsInB1YmxpY0tleXNUcnVzdGVkIiwiZ2V0Q3Jvc3NTaWduaW5nSWQiLCJwaGFzZSIsIkRvbmUiLCJlbWl0IiwicmVxdWVzdCIsInNldEFjdGl2ZVZlcmlmaWNhdGlvblJlcXVlc3QiLCJ2ZXJpZmljYXRpb25SZXF1ZXN0IiwiY2FuY2VsbGVkIiwib2ZmIiwib25WZXJpZmljYXRpb25SZXF1ZXN0Q2hhbmdlIiwiVkVSSUZfUEhBU0VfRE9ORSIsIkJ1c3kiLCJzaGFyZWRJbnN0YW5jZSIsIndpbmRvdyIsIm14U2V0dXBFbmNyeXB0aW9uU3RvcmUiLCJzdGFydCIsInN0YXJ0ZWQiLCJMb2FkaW5nIiwiYmFja3VwSW5mbyIsImtleUlkIiwia2V5SW5mbyIsImNsaSIsIm9uIiwib25WZXJpZmljYXRpb25SZXF1ZXN0Iiwib25Vc2VyVHJ1c3RTdGF0dXNDaGFuZ2VkIiwicmVxdWVzdHNJblByb2dyZXNzIiwiZ2V0VmVyaWZpY2F0aW9uUmVxdWVzdHNUb0RldmljZUluUHJvZ3Jlc3MiLCJsZW5ndGgiLCJmZXRjaEtleUluZm8iLCJzdG9wIiwicmVtb3ZlTGlzdGVuZXIiLCJrZXlzIiwiaXNTZWNyZXRTdG9yZWQiLCJPYmplY3QiLCJkZWh5ZHJhdGVkRGV2aWNlIiwiZ2V0RGVoeWRyYXRlZERldmljZSIsIm93blVzZXJJZCIsImNyb3NzU2lnbmluZ0luZm8iLCJnZXRTdG9yZWRDcm9zc1NpZ25pbmdGb3JVc2VyIiwiaGFzRGV2aWNlc1RvVmVyaWZ5QWdhaW5zdCIsImdldFN0b3JlZERldmljZXNGb3JVc2VyIiwic29tZSIsImRldmljZSIsImdldElkZW50aXR5S2V5IiwiZGV2aWNlSWQiLCJkZXZpY2VfaWQiLCJjaGVja0RldmljZVRydXN0IiwiaXNDcm9zc1NpZ25pbmdWZXJpZmllZCIsIkludHJvIiwidXNlUGFzc1BocmFzZSIsImdldEtleUJhY2t1cFZlcnNpb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNoZWNrT3duQ3Jvc3NTaWduaW5nVHJ1c3QiLCJyZXN0b3JlS2V5QmFja3VwV2l0aFNlY3JldFN0b3JhZ2UiLCJjYXRjaCIsImUiLCJBY2Nlc3NDYW5jZWxsZWRFcnJvciIsImxvZ2dlciIsImxvZyIsInNraXAiLCJDb25maXJtU2tpcCIsInNraXBDb25maXJtIiwiRmluaXNoZWQiLCJyZXR1cm5BZnRlclNraXAiLCJyZXNldCIsIkNvbmZpcm1SZXNldCIsInJlc2V0Q29uZmlybSIsImJvb3RzdHJhcENyb3NzU2lnbmluZyIsImF1dGhVcGxvYWREZXZpY2VTaWduaW5nS2V5cyIsIm1ha2VSZXF1ZXN0IiwiZmluaXNoZWQiLCJNb2RhbCIsImNyZWF0ZVRyYWNrZWREaWFsb2ciLCJJbnRlcmFjdGl2ZUF1dGhEaWFsb2ciLCJ0aXRsZSIsIm1hdHJpeENsaWVudCIsImNvbmZpcm1lZCIsIkVycm9yIiwic2V0dXBOZXdDcm9zc1NpZ25pbmciLCJlcnJvciIsInJldHVybkFmdGVyUmVzZXQiLCJkb25lIiwiY3J5cHRvIiwiY2FuY2VsQW5kUmVzZW5kQWxsT3V0Z29pbmdLZXlSZXF1ZXN0cyIsIm90aGVyVXNlcklkIiwiYWNjZXB0IiwibG9zdEtleXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBZ0JBOztBQUlBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQTVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7SUFnQllBLEs7OztXQUFBQSxLO0FBQUFBLEVBQUFBLEssQ0FBQUEsSztBQUFBQSxFQUFBQSxLLENBQUFBLEs7QUFBQUEsRUFBQUEsSyxDQUFBQSxLO0FBQUFBLEVBQUFBLEssQ0FB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R2hCOztBQUNBUCxxQ0FBZ0JDLEdBQWhCLEdBQXNCdUYsTUFBdEIsQ0FBNkJDLHFDQUE3QjtBQUNIOztBQUV5QyxRQUE1QmhGLDRCQUE0QixDQUFDRCxPQUFELEVBQThDO0FBQ3BGLFFBQUlBLE9BQU8sQ0FBQ2tGLFdBQVIsS0FBd0IxRixpQ0FBZ0JDLEdBQWhCLEdBQXNCQyxTQUF0QixFQUE1QixFQUErRDs7QUFFL0QsUUFBSSxLQUFLUSxtQkFBVCxFQUE4QjtBQUMxQixXQUFLQSxtQkFBTCxDQUF5QkUsR0FBekIsQ0FBNkIsUUFBN0IsRUFBdUMsS0FBS0MsMkJBQTVDO0FBQ0g7O0FBQ0QsU0FBS0gsbUJBQUwsR0FBMkJGLE9BQTNCO0FBQ0EsVUFBTUEsT0FBTyxDQUFDbUYsTUFBUixFQUFOO0FBQ0FuRixJQUFBQSxPQUFPLENBQUNrQixFQUFSLENBQVcsUUFBWCxFQUFxQixLQUFLYiwyQkFBMUI7QUFDQSxTQUFLTixJQUFMLENBQVUsUUFBVjtBQUNIOztBQUVNcUYsRUFBQUEsUUFBUSxHQUFZO0FBQ3ZCLFdBQU8sQ0FBQyxLQUFLakQseUJBQU4sSUFBbUMsQ0FBQyxLQUFLbkIsT0FBaEQ7QUFDSDs7QUFsUGtEIiwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDIwIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuaW1wb3J0IHsgVmVyaWZpY2F0aW9uUmVxdWVzdCB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9jcnlwdG8vdmVyaWZpY2F0aW9uL3JlcXVlc3QvVmVyaWZpY2F0aW9uUmVxdWVzdFwiO1xuaW1wb3J0IHsgSUtleUJhY2t1cEluZm8gfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvY3J5cHRvL2tleWJhY2t1cFwiO1xuaW1wb3J0IHsgSVNlY3JldFN0b3JhZ2VLZXlJbmZvIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL2NyeXB0by9hcGlcIjtcbmltcG9ydCB7IFBIQVNFX0RPTkUgYXMgVkVSSUZfUEhBU0VfRE9ORSB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9jcnlwdG8vdmVyaWZpY2F0aW9uL3JlcXVlc3QvVmVyaWZpY2F0aW9uUmVxdWVzdFwiO1xuXG5pbXBvcnQgeyBNYXRyaXhDbGllbnRQZWcgfSBmcm9tICcuLi9NYXRyaXhDbGllbnRQZWcnO1xuaW1wb3J0IHsgYWNjZXNzU2VjcmV0U3RvcmFnZSwgQWNjZXNzQ2FuY2VsbGVkRXJyb3IgfSBmcm9tICcuLi9TZWN1cml0eU1hbmFnZXInO1xuaW1wb3J0IE1vZGFsIGZyb20gJy4uL01vZGFsJztcbmltcG9ydCBJbnRlcmFjdGl2ZUF1dGhEaWFsb2cgZnJvbSAnLi4vY29tcG9uZW50cy92aWV3cy9kaWFsb2dzL0ludGVyYWN0aXZlQXV0aERpYWxvZyc7XG5pbXBvcnQgeyBfdCB9IGZyb20gJy4uL2xhbmd1YWdlSGFuZGxlcic7XG5cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9sb2dnZXJcIjtcblxuZXhwb3J0IGVudW0gUGhhc2Uge1xuICAgIExvYWRpbmcgPSAwLFxuICAgIEludHJvID0gMSxcbiAgICBCdXN5ID0gMixcbiAgICBEb25lID0gMywgLy8gZmluYWwgZG9uZSBzdGFnZSwgYnV0IHN0aWxsIHNob3dpbmcgVVhcbiAgICBDb25maXJtU2tpcCA9IDQsXG4gICAgRmluaXNoZWQgPSA1LCAvLyBVWCBjYW4gYmUgY2xvc2VkXG4gICAgQ29uZmlybVJlc2V0ID0gNixcbn1cblxuZXhwb3J0IGNsYXNzIFNldHVwRW5jcnlwdGlvblN0b3JlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBwcml2YXRlIHN0YXJ0ZWQ6IGJvb2xlYW47XG4gICAgcHVibGljIHBoYXNlOiBQaGFzZTtcbiAgICBwdWJsaWMgdmVyaWZpY2F0aW9uUmVxdWVzdDogVmVyaWZpY2F0aW9uUmVxdWVzdDtcbiAgICBwdWJsaWMgYmFja3VwSW5mbzogSUtleUJhY2t1cEluZm87XG4gICAgcHVibGljIGtleUlkOiBzdHJpbmc7XG4gICAgcHVibGljIGtleUluZm86IElTZWNyZXRTdG9yYWdlS2V5SW5mbztcbiAgICBwdWJsaWMgaGFzRGV2aWNlc1RvVmVyaWZ5QWdhaW5zdDogYm9vbGVhbjtcblxuICAgIHB1YmxpYyBzdGF0aWMgc2hhcmVkSW5zdGFuY2UoKSB7XG4gICAgICAgIGlmICghd2luZG93Lm14U2V0dXBFbmNyeXB0aW9uU3RvcmUpIHdpbmRvdy5teFNldHVwRW5jcnlwdGlvblN0b3JlID0gbmV3IFNldHVwRW5jcnlwdGlvblN0b3JlKCk7XG4gICAgICAgIHJldHVybiB3aW5kb3cubXhTZXR1cEVuY3J5cHRpb25TdG9yZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhcnQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnBoYXNlID0gUGhhc2UuTG9hZGluZztcbiAgICAgICAgdGhpcy52ZXJpZmljYXRpb25SZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYWNrdXBJbmZvID0gbnVsbDtcblxuICAgICAgICAvLyBJRCBvZiB0aGUga2V5IHRoYXQgdGhlIHNlY3JldHMgd2Ugd2FudCBhcmUgZW5jcnlwdGVkIHdpdGhcbiAgICAgICAgdGhpcy5rZXlJZCA9IG51bGw7XG4gICAgICAgIC8vIERlc2NyaXB0b3Igb2YgdGhlIGtleSB0aGF0IHRoZSBzZWNyZXRzIHdlIHdhbnQgYXJlIGVuY3J5cHRlZCB3aXRoXG4gICAgICAgIHRoaXMua2V5SW5mbyA9IG51bGw7XG5cbiAgICAgICAgY29uc3QgY2xpID0gTWF0cml4Q2xpZW50UGVnLmdldCgpO1xuICAgICAgICBjbGkub24oXCJjcnlwdG8udmVyaWZpY2F0aW9uLnJlcXVlc3RcIiwgdGhpcy5vblZlcmlmaWNhdGlvblJlcXVlc3QpO1xuICAgICAgICBjbGkub24oJ3VzZXJUcnVzdFN0YXR1c0NoYW5nZWQnLCB0aGlzLm9uVXNlclRydXN0U3RhdHVzQ2hhbmdlZCk7XG5cbiAgICAgICAgY29uc3QgcmVxdWVzdHNJblByb2dyZXNzID0gY2xpLmdldFZlcmlmaWNhdGlvblJlcXVlc3RzVG9EZXZpY2VJblByb2dyZXNzKGNsaS5nZXRVc2VySWQoKSk7XG4gICAgICAgIGlmIChyZXF1ZXN0c0luUHJvZ3Jlc3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUsIHdlIHRha2UgdGhlIG1vc3QgcmVjZW50LiBFcXVhbGx5IGlmIHRoZSB1c2VyIHNlbmRzIGFub3RoZXIgcmVxdWVzdCBmcm9tXG4gICAgICAgICAgICAvLyBhbm90aGVyIGRldmljZSBhZnRlciB0aGlzIHNjcmVlbiBoYXMgYmVlbiBzaG93biwgd2UnbGwgc3dpdGNoIHRvIHRoZSBuZXcgb25lLCBzbyB0aGlzXG4gICAgICAgICAgICAvLyBnZW5lcmFsbHkgZG9lc24ndCBzdXBwb3J0IG11bHRpcGxlIHJlcXVlc3RzLlxuICAgICAgICAgICAgdGhpcy5zZXRBY3RpdmVWZXJpZmljYXRpb25SZXF1ZXN0KHJlcXVlc3RzSW5Qcm9ncmVzc1tyZXF1ZXN0c0luUHJvZ3Jlc3MubGVuZ3RoIC0gMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mZXRjaEtleUluZm8oKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RvcCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMudmVyaWZpY2F0aW9uUmVxdWVzdCkge1xuICAgICAgICAgICAgdGhpcy52ZXJpZmljYXRpb25SZXF1ZXN0Lm9mZihcImNoYW5nZVwiLCB0aGlzLm9uVmVyaWZpY2F0aW9uUmVxdWVzdENoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE1hdHJpeENsaWVudFBlZy5nZXQoKSkge1xuICAgICAgICAgICAgTWF0cml4Q2xpZW50UGVnLmdldCgpLnJlbW92ZUxpc3RlbmVyKFwiY3J5cHRvLnZlcmlmaWNhdGlvbi5yZXF1ZXN0XCIsIHRoaXMub25WZXJpZmljYXRpb25SZXF1ZXN0KTtcbiAgICAgICAgICAgIE1hdHJpeENsaWVudFBlZy5nZXQoKS5yZW1vdmVMaXN0ZW5lcigndXNlclRydXN0U3RhdHVzQ2hhbmdlZCcsIHRoaXMub25Vc2VyVHJ1c3RTdGF0dXNDaGFuZ2VkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBmZXRjaEtleUluZm8oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGNsaSA9IE1hdHJpeENsaWVudFBlZy5nZXQoKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IGNsaS5pc1NlY3JldFN0b3JlZCgnbS5jcm9zc19zaWduaW5nLm1hc3RlcicsIGZhbHNlKTtcbiAgICAgICAgaWYgKGtleXMgPT09IG51bGwgfHwgT2JqZWN0LmtleXMoa2V5cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmtleUlkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMua2V5SW5mbyA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgc2VjcmV0IGlzIHN0b3JlZCB1bmRlciBtb3JlIHRoYW4gb25lIGtleSwgd2UganVzdCBwaWNrIGFuIGFyYml0cmFyeSBvbmVcbiAgICAgICAgICAgIHRoaXMua2V5SWQgPSBPYmplY3Qua2V5cyhrZXlzKVswXTtcbiAgICAgICAgICAgIHRoaXMua2V5SW5mbyA9IGtleXNbdGhpcy5rZXlJZF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkbyB3ZSBoYXZlIGFueSBvdGhlciB2ZXJpZmllZCBkZXZpY2VzIHdoaWNoIGFyZSBFMkVFIHdoaWNoIHdlIGNhbiB2ZXJpZnkgYWdhaW5zdD9cbiAgICAgICAgY29uc3QgZGVoeWRyYXRlZERldmljZSA9IGF3YWl0IGNsaS5nZXREZWh5ZHJhdGVkRGV2aWNlKCk7XG4gICAgICAgIGNvbnN0IG93blVzZXJJZCA9IGNsaS5nZXRVc2VySWQoKTtcbiAgICAgICAgY29uc3QgY3Jvc3NTaWduaW5nSW5mbyA9IGNsaS5nZXRTdG9yZWRDcm9zc1NpZ25pbmdGb3JVc2VyKG93blVzZXJJZCk7XG4gICAgICAgIHRoaXMuaGFzRGV2aWNlc1RvVmVyaWZ5QWdhaW5zdCA9IGNsaS5nZXRTdG9yZWREZXZpY2VzRm9yVXNlcihvd25Vc2VySWQpLnNvbWUoXG4gICAgICAgICAgICBkZXZpY2UgPT5cbiAgICAgICAgICAgICAgICBkZXZpY2UuZ2V0SWRlbnRpdHlLZXkoKSAmJlxuICAgICAgICAgICAgICAgICghZGVoeWRyYXRlZERldmljZSB8fCAoZGV2aWNlLmRldmljZUlkICE9IGRlaHlkcmF0ZWREZXZpY2UuZGV2aWNlX2lkKSkgJiZcbiAgICAgICAgICAgICAgICBjcm9zc1NpZ25pbmdJbmZvLmNoZWNrRGV2aWNlVHJ1c3QoXG4gICAgICAgICAgICAgICAgICAgIGNyb3NzU2lnbmluZ0luZm8sXG4gICAgICAgICAgICAgICAgICAgIGRldmljZSxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgKS5pc0Nyb3NzU2lnbmluZ1ZlcmlmaWVkKCksXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5waGFzZSA9IFBoYXNlLkludHJvO1xuICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIik7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIHVzZVBhc3NQaHJhc2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRoaXMucGhhc2UgPSBQaGFzZS5CdXN5O1xuICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIik7XG4gICAgICAgIGNvbnN0IGNsaSA9IE1hdHJpeENsaWVudFBlZy5nZXQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGJhY2t1cEluZm8gPSBhd2FpdCBjbGkuZ2V0S2V5QmFja3VwVmVyc2lvbigpO1xuICAgICAgICAgICAgdGhpcy5iYWNrdXBJbmZvID0gYmFja3VwSW5mbztcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiKTtcbiAgICAgICAgICAgIC8vIFRoZSBjb250cm9sIGZsb3cgaXMgZmFpcmx5IHR3aXN0ZWQgaGVyZS4uLlxuICAgICAgICAgICAgLy8gRm9yIHRoZSBwdXJwb3NlcyBvZiBjb21wbGV0aW5nIHNlY3VyaXR5LCB3ZSBvbmx5IHdhaXQgb24gZ2V0dGluZ1xuICAgICAgICAgICAgLy8gYXMgZmFyIGFzIHRoZSB0cnVzdCBjaGVjayBhbmQgdGhlbiBzaG93IGEgZ3JlZW4gc2hpZWxkLlxuICAgICAgICAgICAgLy8gV2UgYWxzbyBiZWdpbiB0aGUga2V5IGJhY2t1cCByZXN0b3JlIGFzIHdlbGwsIHdoaWNoIHdlJ3JlXG4gICAgICAgICAgICAvLyBhd2FpdGluZyBpbnNpZGUgYGFjY2Vzc1NlY3JldFN0b3JhZ2VgIG9ubHkgc28gdGhhdCBpdCBrZWVwcyB5b3VyXG4gICAgICAgICAgICAvLyBwYXNzcGhhc2UgY2FjaGVkIGZvciB0aGF0IHdvcmsuIFRoaXMgZGlhbG9nIGl0c2VsZiB3aWxsIG9ubHkgd2FpdFxuICAgICAgICAgICAgLy8gb24gdGhlIGZpcnN0IHRydXN0IGNoZWNrLCBhbmQgdGhlIGtleSBiYWNrdXAgcmVzdG9yZSB3aWxsIGhhcHBlblxuICAgICAgICAgICAgLy8gaW4gdGhlIGJhY2tncm91bmQuXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZTogKHZhbHVlPzogdW5rbm93bikgPT4gdm9pZCwgcmVqZWN0OiAocmVhc29uPzogYW55KSA9PiB2b2lkKSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjZXNzU2VjcmV0U3RvcmFnZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNsaS5jaGVja093bkNyb3NzU2lnbmluZ1RydXN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhY2t1cEluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgY29tcGxldGUgcmVzdG9yZSBjYW4gdGFrZSBtYW55IG1pbnV0ZXMgZm9yIGxhcmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhY2NvdW50cyAvIHNsb3cgc2VydmVycywgc28gd2UgYWxsb3cgdGhlIGRpYWxvZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gYWR2YW5jZSBiZWZvcmUgdGhpcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGNsaS5yZXN0b3JlS2V5QmFja3VwV2l0aFNlY3JldFN0b3JhZ2UoYmFja3VwSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChjbGkuZ2V0Q3Jvc3NTaWduaW5nSWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGhhc2UgPSBQaGFzZS5Eb25lO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIEFjY2Vzc0NhbmNlbGxlZEVycm9yKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgdGhyb3cgaWYgdGhlIHVzZXIgaGl0cyBjYW5jZWwsIHNvIGlnbm9yZVxuICAgICAgICAgICAgdGhpcy5waGFzZSA9IFBoYXNlLkludHJvO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvblVzZXJUcnVzdFN0YXR1c0NoYW5nZWQgPSAodXNlcklkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKHVzZXJJZCAhPT0gTWF0cml4Q2xpZW50UGVnLmdldCgpLmdldFVzZXJJZCgpKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleXNUcnVzdGVkID0gTWF0cml4Q2xpZW50UGVnLmdldCgpLmdldENyb3NzU2lnbmluZ0lkKCk7XG4gICAgICAgIGlmIChwdWJsaWNLZXlzVHJ1c3RlZCkge1xuICAgICAgICAgICAgdGhpcy5waGFzZSA9IFBoYXNlLkRvbmU7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHVibGljIG9uVmVyaWZpY2F0aW9uUmVxdWVzdCA9IChyZXF1ZXN0OiBWZXJpZmljYXRpb25SZXF1ZXN0KTogdm9pZCA9PiB7XG4gICAgICAgIHRoaXMuc2V0QWN0aXZlVmVyaWZpY2F0aW9uUmVxdWVzdChyZXF1ZXN0KTtcbiAgICB9O1xuXG4gICAgcHVibGljIG9uVmVyaWZpY2F0aW9uUmVxdWVzdENoYW5nZSA9ICgpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKHRoaXMudmVyaWZpY2F0aW9uUmVxdWVzdC5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmVyaWZpY2F0aW9uUmVxdWVzdC5vZmYoXCJjaGFuZ2VcIiwgdGhpcy5vblZlcmlmaWNhdGlvblJlcXVlc3RDaGFuZ2UpO1xuICAgICAgICAgICAgdGhpcy52ZXJpZmljYXRpb25SZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnZlcmlmaWNhdGlvblJlcXVlc3QucGhhc2UgPT09IFZFUklGX1BIQVNFX0RPTkUpIHtcbiAgICAgICAgICAgIHRoaXMudmVyaWZpY2F0aW9uUmVxdWVzdC5vZmYoXCJjaGFuZ2VcIiwgdGhpcy5vblZlcmlmaWNhdGlvblJlcXVlc3RDaGFuZ2UpO1xuICAgICAgICAgICAgdGhpcy52ZXJpZmljYXRpb25SZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSB2ZXJpZmljYXRpb24gaGFzIGZpbmlzaGVkLCB3ZSBqdXN0IG5lZWQgdG8gd2FpdCBmb3JcbiAgICAgICAgICAgIC8vIGNyb3NzIHNpZ25pbmcgdG8gYmUgcmVhZHkgdG8gdXNlLCBzbyB3YWl0IGZvciB0aGUgdXNlciB0cnVzdCBzdGF0dXMgdG9cbiAgICAgICAgICAgIC8vIGNoYW5nZSAob3IgY2hhbmdlIHRvIERPTkUgaWYgaXQncyBhbHJlYWR5IHJlYWR5KS5cbiAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleXNUcnVzdGVkID0gTWF0cml4Q2xpZW50UGVnLmdldCgpLmdldENyb3NzU2lnbmluZ0lkKCk7XG4gICAgICAgICAgICB0aGlzLnBoYXNlID0gcHVibGljS2V5c1RydXN0ZWQgPyBQaGFzZS5Eb25lIDogUGhhc2UuQnVzeTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwdWJsaWMgc2tpcCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5waGFzZSA9IFBoYXNlLkNvbmZpcm1Ta2lwO1xuICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIik7XG4gICAgfVxuXG4gICAgcHVibGljIHNraXBDb25maXJtKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnBoYXNlID0gUGhhc2UuRmluaXNoZWQ7XG4gICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmV0dXJuQWZ0ZXJTa2lwKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnBoYXNlID0gUGhhc2UuSW50cm87XG4gICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucGhhc2UgPSBQaGFzZS5Db25maXJtUmVzZXQ7XG4gICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgcmVzZXRDb25maXJtKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gSWYgd2UndmUgZ290dGVuIGhlcmUsIHRoZSB1c2VyIHByZXN1bWFibHkgbG9zdCB0aGVpclxuICAgICAgICAgICAgLy8gc2VjcmV0IHN0b3JhZ2Uga2V5IGlmIHRoZXkgaGFkIG9uZS4gU3RhcnQgYnkgcmVzZXR0aW5nXG4gICAgICAgICAgICAvLyBzZWNyZXQgc3RvcmFnZSBhbmQgc2V0dGluZyB1cCBhIG5ldyByZWNvdmVyeSBrZXksIHRoZW5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgY3Jvc3Mtc2lnbmluZyBrZXlzIG9uY2UgdGhhdCBzdWNjZWVkcy5cbiAgICAgICAgICAgIGF3YWl0IGFjY2Vzc1NlY3JldFN0b3JhZ2UoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsaSA9IE1hdHJpeENsaWVudFBlZy5nZXQoKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBjbGkuYm9vdHN0cmFwQ3Jvc3NTaWduaW5nKHtcbiAgICAgICAgICAgICAgICAgICAgYXV0aFVwbG9hZERldmljZVNpZ25pbmdLZXlzOiBhc3luYyAobWFrZVJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZmluaXNoZWQgfSA9IE1vZGFsLmNyZWF0ZVRyYWNrZWREaWFsb2coXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Nyb3NzLXNpZ25pbmcga2V5cyBkaWFsb2cnLCAnJywgSW50ZXJhY3RpdmVBdXRoRGlhbG9nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IF90KFwiU2V0dGluZyB1cCBrZXlzXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXhDbGllbnQ6IGNsaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbY29uZmlybWVkXSA9IGF3YWl0IGZpbmlzaGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25maXJtZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDcm9zcy1zaWduaW5nIGtleSB1cGxvYWQgYXV0aCBjYW5jZWxlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBOZXdDcm9zc1NpZ25pbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5waGFzZSA9IFBoYXNlLkZpbmlzaGVkO1xuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkVycm9yIHJlc2V0dGluZyBjcm9zcy1zaWduaW5nXCIsIGUpO1xuICAgICAgICAgICAgdGhpcy5waGFzZSA9IFBoYXNlLkludHJvO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmV0dXJuQWZ0ZXJSZXNldCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5waGFzZSA9IFBoYXNlLkludHJvO1xuICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIik7XG4gICAgfVxuXG4gICAgcHVibGljIGRvbmUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucGhhc2UgPSBQaGFzZS5GaW5pc2hlZDtcbiAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIpO1xuICAgICAgICAvLyBhc3luYyAtIGFzayBvdGhlciBjbGllbnRzIGZvciBrZXlzLCBpZiBuZWNlc3NhcnlcbiAgICAgICAgTWF0cml4Q2xpZW50UGVnLmdldCgpLmNyeXB0by5jYW5jZWxBbmRSZXNlbmRBbGxPdXRnb2luZ0tleVJlcXVlc3RzKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBzZXRBY3RpdmVWZXJpZmljYXRpb25SZXF1ZXN0KHJlcXVlc3Q6IFZlcmlmaWNhdGlvblJlcXVlc3QpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKHJlcXVlc3Qub3RoZXJVc2VySWQgIT09IE1hdHJpeENsaWVudFBlZy5nZXQoKS5nZXRVc2VySWQoKSkgcmV0dXJuO1xuXG4gICAgICAgIGlmICh0aGlzLnZlcmlmaWNhdGlvblJlcXVlc3QpIHtcbiAgICAgICAgICAgIHRoaXMudmVyaWZpY2F0aW9uUmVxdWVzdC5vZmYoXCJjaGFuZ2VcIiwgdGhpcy5vblZlcmlmaWNhdGlvblJlcXVlc3RDaGFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVyaWZpY2F0aW9uUmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIGF3YWl0IHJlcXVlc3QuYWNjZXB0KCk7XG4gICAgICAgIHJlcXVlc3Qub24oXCJjaGFuZ2VcIiwgdGhpcy5vblZlcmlmaWNhdGlvblJlcXVlc3RDaGFuZ2UpO1xuICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIik7XG4gICAgfVxuXG4gICAgcHVibGljIGxvc3RLZXlzKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gIXRoaXMuaGFzRGV2aWNlc1RvVmVyaWZ5QWdhaW5zdCAmJiAhdGhpcy5rZXlJbmZvO1xuICAgIH1cbn1cbiJdfQ==