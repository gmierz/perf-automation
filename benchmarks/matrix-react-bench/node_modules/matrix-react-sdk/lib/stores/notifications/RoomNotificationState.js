"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RoomNotificationState = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _NotificationColor = require("./NotificationColor");

var _MatrixClientPeg = require("../../MatrixClientPeg");

var _membership = require("../../utils/membership");

var _readReceipts = require("../../utils/read-receipts");

var _room = require("matrix-js-sdk/src/models/room");

var RoomNotifs = _interopRequireWildcard(require("../../RoomNotifs"));

var Unread = _interopRequireWildcard(require("../../Unread"));

var _NotificationState = require("./NotificationState");

var _RoomStatusBar = require("../../components/structures/RoomStatusBar");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
class RoomNotificationState extends _NotificationState.NotificationState {
  constructor(room) {
    super();
    this.room = room;
    (0, _defineProperty2.default)(this, "handleLocalEchoUpdated", () => {
      this.updateNotificationState();
    });
    (0, _defineProperty2.default)(this, "handleReadReceipt", (event, room) => {
      if (!(0, _readReceipts.readReceiptChangeIsFor)(event, _MatrixClientPeg.MatrixClientPeg.get())) return; // not our own - ignore

      if (room.roomId !== this.room.roomId) return; // not for us - ignore

      this.updateNotificationState();
    });
    (0, _defineProperty2.default)(this, "handleMembershipUpdate", () => {
      this.updateNotificationState();
    });
    (0, _defineProperty2.default)(this, "handleRoomEventUpdate", event => {
      const roomId = event.getRoomId();
      if (roomId !== this.room.roomId) return; // ignore - not for us

      this.updateNotificationState();
    });
    (0, _defineProperty2.default)(this, "handleAccountDataUpdate", ev => {
      if (ev.getType() === "m.push_rules") {
        this.updateNotificationState();
      }
    });
    this.room.on("Room.receipt", this.handleReadReceipt);
    this.room.on("Room.timeline", this.handleRoomEventUpdate);
    this.room.on("Room.redaction", this.handleRoomEventUpdate);
    this.room.on("Room.myMembership", this.handleMembershipUpdate);
    this.room.on("Room.localEchoUpdated", this.handleLocalEchoUpdated);

    _MatrixClientPeg.MatrixClientPeg.get().on("Event.decrypted", this.handleRoomEventUpdate);

    _MatrixClientPeg.MatrixClientPeg.get().on("accountData", this.handleAccountDataUpdate);

    this.updateNotificationState();
  }

  get roomIsInvite() {
    return (0, _membership.getEffectiveMembership)(this.room.getMyMembership()) === _membership.EffectiveMembership.Invite;
  }

  destroy() {
    super.destroy();
    this.room.removeListener("Room.receipt", this.handleReadReceipt);
    this.room.removeListener("Room.timeline", this.handleRoomEventUpdate);
    this.room.removeListener("Room.redaction", this.handleRoomEventUpdate);
    this.room.removeListener("Room.myMembership", this.handleMembershipUpdate);
    this.room.removeListener("Room.localEchoUpdated", this.handleLocalEchoUpdated);

    if (_MatrixClientPeg.MatrixClientPeg.get()) {
      _MatrixClientPeg.MatrixClientPeg.get().removeListener("Event.decrypted", this.handleRoomEventUpdate);

      _MatrixClientPeg.MatrixClientPeg.get().removeListener("accountData", this.handleAccountDataUpdate);
    }
  }

  updateNotificationState() {
    const snapshot = this.snapshot();

    if ((0, _RoomStatusBar.getUnsentMessages)(this.room).length > 0) {
      // When there are unsent messages we show a red `!`
      this._color = _NotificationColor.NotificationColor.Unsent;
      this._symbol = "!";
      this._count = 1; // not used, technically
    } else if (RoomNotifs.getRoomNotifsState(this.room.roomId) === RoomNotifs.RoomNotifState.Mute) {
      // When muted we suppress all notification states, even if we have context on them.
      this._color = _NotificationColor.NotificationColor.None;
      this._symbol = null;
      this._count = 0;
    } else if (this.roomIsInvite) {
      this._color = _NotificationColor.NotificationColor.Red;
      this._symbol = "!";
      this._count = 1; // not used, technically
    } else {
      const redNotifs = RoomNotifs.getUnreadNotificationCount(this.room, _room.NotificationCountType.Highlight);
      const greyNotifs = RoomNotifs.getUnreadNotificationCount(this.room, _room.NotificationCountType.Total); // For a 'true count' we pick the grey notifications first because they include the
      // red notifications. If we don't have a grey count for some reason we use the red
      // count. If that count is broken for some reason, assume zero. This avoids us showing
      // a badge for 'NaN' (which formats as 'NaNB' for NaN Billion).

      const trueCount = greyNotifs ? greyNotifs : redNotifs ? redNotifs : 0; // Note: we only set the symbol if we have an actual count. We don't want to show
      // zero on badges.

      if (redNotifs > 0) {
        this._color = _NotificationColor.NotificationColor.Red;
        this._count = trueCount;
        this._symbol = null; // symbol calculated by component
      } else if (greyNotifs > 0) {
        this._color = _NotificationColor.NotificationColor.Grey;
        this._count = trueCount;
        this._symbol = null; // symbol calculated by component
      } else {
        // We don't have any notified messages, but we might have unread messages. Let's
        // find out.
        const hasUnread = Unread.doesRoomHaveUnreadMessages(this.room);

        if (hasUnread) {
          this._color = _NotificationColor.NotificationColor.Bold;
        } else {
          this._color = _NotificationColor.NotificationColor.None;
        } // no symbol or count for this state


        this._count = 0;
        this._symbol = null;
      }
    } // finally, publish an update if needed


    this.emitIfUpdated(snapshot);
  }

}

exports.RoomNotificationState = RoomNotificationState;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zdG9yZXMvbm90aWZpY2F0aW9ucy9Sb29tTm90aWZpY2F0aW9uU3RhdGUudHMiXSwibmFtZXMiOlsiUm9vbU5vdGlmaWNhdGlvblN0YXRlIiwiTm90aWZpY2F0aW9uU3RhdGUiLCJjb25zdHJ1Y3RvciIsInJvb20iLCJ1cGRhdGVOb3RpZmljYXRpb25TdGF0ZSIsImV2ZW50IiwiTWF0cml4Q2xpZW50UGVnIiwiZ2V0Iiwicm9vbUlkIiwiZ2V0Um9vbUlkIiwiZXYiLCJnZXRUeXBlIiwib24iLCJoYW5kbGVSZWFkUmVjZWlwdCIsImhhbmRsZVJvb21FdmVudFVwZGF0ZSIsImhhbmRsZU1lbWJlcnNoaXBVcGRhdGUiLCJoYW5kbGVMb2NhbEVjaG9VcGRhdGVkIiwiaGFuZGxlQWNjb3VudERhdGFVcGRhdGUiLCJyb29tSXNJbnZpdGUiLCJnZXRNeU1lbWJlcnNoaXAiLCJFZmZlY3RpdmVNZW1iZXJzaGlwIiwiSW52aXRlIiwiZGVzdHJveSIsInJlbW92ZUxpc3RlbmVyIiwic25hcHNob3QiLCJsZW5ndGgiLCJfY29sb3IiLCJOb3RpZmljYXRpb25Db2xvciIsIlVuc2VudCIsIl9zeW1ib2wiLCJfY291bnQiLCJSb29tTm90aWZzIiwiZ2V0Um9vbU5vdGlmc1N0YXRlIiwiUm9vbU5vdGlmU3RhdGUiLCJNdXRlIiwiTm9uZSIsIlJlZCIsInJlZE5vdGlmcyIsImdldFVucmVhZE5vdGlmaWNhdGlvbkNvdW50IiwiTm90aWZpY2F0aW9uQ291bnRUeXBlIiwiSGlnaGxpZ2h0IiwiZ3JleU5vdGlmcyIsIlRvdGFsIiwidHJ1ZUNvdW50IiwiR3JleSIsImhhc1VucmVhZCIsIlVucmVhZCIsImRvZXNSb29tSGF2ZVVucmVhZE1lc3NhZ2VzIiwiQm9sZCIsImVtaXRJZlVwZGF0ZWQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBZ0JBOztBQUVBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7QUExQkE7QUFD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QUlBLFNBQVMsR0FBRyxDQUFoQixFQUFtQjtBQUNmLGFBQUtYLE1BQUwsR0FBY0MscUNBQWtCUyxHQUFoQztBQUNBLGFBQUtOLE1BQUwsR0FBY2EsU0FBZDtBQUNBLGFBQUtkLE9BQUwsR0FBZSxJQUFmLENBSGUsQ0FHTTtBQUN4QixPQUpELE1BSU8sSUFBSVksVUFBVSxHQUFHLENBQWpCLEVBQW9CO0FBQ3ZCLGFBQUtmLE1BQUwsR0FBY0MscUNBQWtCaUIsSUFBaEM7QUFDQSxhQUFLZCxNQUFMLEdBQWNhLFNBQWQ7QUFDQSxhQUFLZCxPQUFMLEdBQWUsSUFBZixDQUh1QixDQUdGO0FBQ3hCLE9BSk0sTUFJQTtBQUNIO0FBQ0E7QUFDQSxjQUFNZ0IsU0FBUyxHQUFHQyxNQUFNLENBQUNDLDBCQUFQLENBQWtDLEtBQUs1QyxJQUF2QyxDQUFsQjs7QUFDQSxZQUFJMEMsU0FBSixFQUFlO0FBQ1gsZUFBS25CLE1BQUwsR0FBY0MscUNBQWtCcUIsSUFBaEM7QUFDSCxTQUZELE1BRU87QUFDSCxlQUFLdEIsTUFBTCxHQUFjQyxxQ0FBa0JRLElBQWhDO0FBQ0gsU0FSRSxDQVVIOzs7QUFDQSxhQUFLTCxNQUFMLEdBQWMsQ0FBZDtBQUNBLGFBQUtELE9BQUwsR0FBZSxJQUFmO0FBQ0g7QUFDSixLQXBENkIsQ0FzRDlCOzs7QUFDQSxTQUFLb0IsYUFBTCxDQUFtQnpCLFFBQW5CO0FBQ0g7O0FBakhnRiIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAyMCBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB7IE5vdGlmaWNhdGlvbkNvbG9yIH0gZnJvbSBcIi4vTm90aWZpY2F0aW9uQ29sb3JcIjtcbmltcG9ydCB7IElEZXN0cm95YWJsZSB9IGZyb20gXCIuLi8uLi91dGlscy9JRGVzdHJveWFibGVcIjtcbmltcG9ydCB7IE1hdHJpeENsaWVudFBlZyB9IGZyb20gXCIuLi8uLi9NYXRyaXhDbGllbnRQZWdcIjtcbmltcG9ydCB7IEVmZmVjdGl2ZU1lbWJlcnNoaXAsIGdldEVmZmVjdGl2ZU1lbWJlcnNoaXAgfSBmcm9tIFwiLi4vLi4vdXRpbHMvbWVtYmVyc2hpcFwiO1xuaW1wb3J0IHsgcmVhZFJlY2VpcHRDaGFuZ2VJc0ZvciB9IGZyb20gXCIuLi8uLi91dGlscy9yZWFkLXJlY2VpcHRzXCI7XG5pbXBvcnQgeyBNYXRyaXhFdmVudCB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9tb2RlbHMvZXZlbnRcIjtcbmltcG9ydCB7IE5vdGlmaWNhdGlvbkNvdW50VHlwZSwgUm9vbSB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9tb2RlbHMvcm9vbVwiO1xuaW1wb3J0ICogYXMgUm9vbU5vdGlmcyBmcm9tICcuLi8uLi9Sb29tTm90aWZzJztcbmltcG9ydCAqIGFzIFVucmVhZCBmcm9tICcuLi8uLi9VbnJlYWQnO1xuaW1wb3J0IHsgTm90aWZpY2F0aW9uU3RhdGUgfSBmcm9tIFwiLi9Ob3RpZmljYXRpb25TdGF0ZVwiO1xuaW1wb3J0IHsgZ2V0VW5zZW50TWVzc2FnZXMgfSBmcm9tIFwiLi4vLi4vY29tcG9uZW50cy9zdHJ1Y3R1cmVzL1Jvb21TdGF0dXNCYXJcIjtcblxuZXhwb3J0IGNsYXNzIFJvb21Ob3RpZmljYXRpb25TdGF0ZSBleHRlbmRzIE5vdGlmaWNhdGlvblN0YXRlIGltcGxlbWVudHMgSURlc3Ryb3lhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgcm9vbTogUm9vbSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJvb20ub24oXCJSb29tLnJlY2VpcHRcIiwgdGhpcy5oYW5kbGVSZWFkUmVjZWlwdCk7XG4gICAgICAgIHRoaXMucm9vbS5vbihcIlJvb20udGltZWxpbmVcIiwgdGhpcy5oYW5kbGVSb29tRXZlbnRVcGRhdGUpO1xuICAgICAgICB0aGlzLnJvb20ub24oXCJSb29tLnJlZGFjdGlvblwiLCB0aGlzLmhhbmRsZVJvb21FdmVudFVwZGF0ZSk7XG4gICAgICAgIHRoaXMucm9vbS5vbihcIlJvb20ubXlNZW1iZXJzaGlwXCIsIHRoaXMuaGFuZGxlTWVtYmVyc2hpcFVwZGF0ZSk7XG4gICAgICAgIHRoaXMucm9vbS5vbihcIlJvb20ubG9jYWxFY2hvVXBkYXRlZFwiLCB0aGlzLmhhbmRsZUxvY2FsRWNob1VwZGF0ZWQpO1xuICAgICAgICBNYXRyaXhDbGllbnRQZWcuZ2V0KCkub24oXCJFdmVudC5kZWNyeXB0ZWRcIiwgdGhpcy5oYW5kbGVSb29tRXZlbnRVcGRhdGUpO1xuICAgICAgICBNYXRyaXhDbGllbnRQZWcuZ2V0KCkub24oXCJhY2NvdW50RGF0YVwiLCB0aGlzLmhhbmRsZUFjY291bnREYXRhVXBkYXRlKTtcbiAgICAgICAgdGhpcy51cGRhdGVOb3RpZmljYXRpb25TdGF0ZSgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0IHJvb21Jc0ludml0ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGdldEVmZmVjdGl2ZU1lbWJlcnNoaXAodGhpcy5yb29tLmdldE15TWVtYmVyc2hpcCgpKSA9PT0gRWZmZWN0aXZlTWVtYmVyc2hpcC5JbnZpdGU7XG4gICAgfVxuXG4gICAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5yb29tLnJlbW92ZUxpc3RlbmVyKFwiUm9vbS5yZWNlaXB0XCIsIHRoaXMuaGFuZGxlUmVhZFJlY2VpcHQpO1xuICAgICAgICB0aGlzLnJvb20ucmVtb3ZlTGlzdGVuZXIoXCJSb29tLnRpbWVsaW5lXCIsIHRoaXMuaGFuZGxlUm9vbUV2ZW50VXBkYXRlKTtcbiAgICAgICAgdGhpcy5yb29tLnJlbW92ZUxpc3RlbmVyKFwiUm9vbS5yZWRhY3Rpb25cIiwgdGhpcy5oYW5kbGVSb29tRXZlbnRVcGRhdGUpO1xuICAgICAgICB0aGlzLnJvb20ucmVtb3ZlTGlzdGVuZXIoXCJSb29tLm15TWVtYmVyc2hpcFwiLCB0aGlzLmhhbmRsZU1lbWJlcnNoaXBVcGRhdGUpO1xuICAgICAgICB0aGlzLnJvb20ucmVtb3ZlTGlzdGVuZXIoXCJSb29tLmxvY2FsRWNob1VwZGF0ZWRcIiwgdGhpcy5oYW5kbGVMb2NhbEVjaG9VcGRhdGVkKTtcbiAgICAgICAgaWYgKE1hdHJpeENsaWVudFBlZy5nZXQoKSkge1xuICAgICAgICAgICAgTWF0cml4Q2xpZW50UGVnLmdldCgpLnJlbW92ZUxpc3RlbmVyKFwiRXZlbnQuZGVjcnlwdGVkXCIsIHRoaXMuaGFuZGxlUm9vbUV2ZW50VXBkYXRlKTtcbiAgICAgICAgICAgIE1hdHJpeENsaWVudFBlZy5nZXQoKS5yZW1vdmVMaXN0ZW5lcihcImFjY291bnREYXRhXCIsIHRoaXMuaGFuZGxlQWNjb3VudERhdGFVcGRhdGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVMb2NhbEVjaG9VcGRhdGVkID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZU5vdGlmaWNhdGlvblN0YXRlKCk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgaGFuZGxlUmVhZFJlY2VpcHQgPSAoZXZlbnQ6IE1hdHJpeEV2ZW50LCByb29tOiBSb29tKSA9PiB7XG4gICAgICAgIGlmICghcmVhZFJlY2VpcHRDaGFuZ2VJc0ZvcihldmVudCwgTWF0cml4Q2xpZW50UGVnLmdldCgpKSkgcmV0dXJuOyAvLyBub3Qgb3VyIG93biAtIGlnbm9yZVxuICAgICAgICBpZiAocm9vbS5yb29tSWQgIT09IHRoaXMucm9vbS5yb29tSWQpIHJldHVybjsgLy8gbm90IGZvciB1cyAtIGlnbm9yZVxuICAgICAgICB0aGlzLnVwZGF0ZU5vdGlmaWNhdGlvblN0YXRlKCk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgaGFuZGxlTWVtYmVyc2hpcFVwZGF0ZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGVOb3RpZmljYXRpb25TdGF0ZSgpO1xuICAgIH07XG5cbiAgICBwcml2YXRlIGhhbmRsZVJvb21FdmVudFVwZGF0ZSA9IChldmVudDogTWF0cml4RXZlbnQpID0+IHtcbiAgICAgICAgY29uc3Qgcm9vbUlkID0gZXZlbnQuZ2V0Um9vbUlkKCk7XG5cbiAgICAgICAgaWYgKHJvb21JZCAhPT0gdGhpcy5yb29tLnJvb21JZCkgcmV0dXJuOyAvLyBpZ25vcmUgLSBub3QgZm9yIHVzXG4gICAgICAgIHRoaXMudXBkYXRlTm90aWZpY2F0aW9uU3RhdGUoKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBoYW5kbGVBY2NvdW50RGF0YVVwZGF0ZSA9IChldjogTWF0cml4RXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2LmdldFR5cGUoKSA9PT0gXCJtLnB1c2hfcnVsZXNcIikge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVOb3RpZmljYXRpb25TdGF0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByaXZhdGUgdXBkYXRlTm90aWZpY2F0aW9uU3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IHNuYXBzaG90ID0gdGhpcy5zbmFwc2hvdCgpO1xuXG4gICAgICAgIGlmIChnZXRVbnNlbnRNZXNzYWdlcyh0aGlzLnJvb20pLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlcmUgYXJlIHVuc2VudCBtZXNzYWdlcyB3ZSBzaG93IGEgcmVkIGAhYFxuICAgICAgICAgICAgdGhpcy5fY29sb3IgPSBOb3RpZmljYXRpb25Db2xvci5VbnNlbnQ7XG4gICAgICAgICAgICB0aGlzLl9zeW1ib2wgPSBcIiFcIjtcbiAgICAgICAgICAgIHRoaXMuX2NvdW50ID0gMTsgLy8gbm90IHVzZWQsIHRlY2huaWNhbGx5XG4gICAgICAgIH0gZWxzZSBpZiAoUm9vbU5vdGlmcy5nZXRSb29tTm90aWZzU3RhdGUodGhpcy5yb29tLnJvb21JZCkgPT09IFJvb21Ob3RpZnMuUm9vbU5vdGlmU3RhdGUuTXV0ZSkge1xuICAgICAgICAgICAgLy8gV2hlbiBtdXRlZCB3ZSBzdXBwcmVzcyBhbGwgbm90aWZpY2F0aW9uIHN0YXRlcywgZXZlbiBpZiB3ZSBoYXZlIGNvbnRleHQgb24gdGhlbS5cbiAgICAgICAgICAgIHRoaXMuX2NvbG9yID0gTm90aWZpY2F0aW9uQ29sb3IuTm9uZTtcbiAgICAgICAgICAgIHRoaXMuX3N5bWJvbCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9jb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5yb29tSXNJbnZpdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yID0gTm90aWZpY2F0aW9uQ29sb3IuUmVkO1xuICAgICAgICAgICAgdGhpcy5fc3ltYm9sID0gXCIhXCI7XG4gICAgICAgICAgICB0aGlzLl9jb3VudCA9IDE7IC8vIG5vdCB1c2VkLCB0ZWNobmljYWxseVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVkTm90aWZzID0gUm9vbU5vdGlmcy5nZXRVbnJlYWROb3RpZmljYXRpb25Db3VudCh0aGlzLnJvb20sIE5vdGlmaWNhdGlvbkNvdW50VHlwZS5IaWdobGlnaHQpO1xuICAgICAgICAgICAgY29uc3QgZ3JleU5vdGlmcyA9IFJvb21Ob3RpZnMuZ2V0VW5yZWFkTm90aWZpY2F0aW9uQ291bnQodGhpcy5yb29tLCBOb3RpZmljYXRpb25Db3VudFR5cGUuVG90YWwpO1xuXG4gICAgICAgICAgICAvLyBGb3IgYSAndHJ1ZSBjb3VudCcgd2UgcGljayB0aGUgZ3JleSBub3RpZmljYXRpb25zIGZpcnN0IGJlY2F1c2UgdGhleSBpbmNsdWRlIHRoZVxuICAgICAgICAgICAgLy8gcmVkIG5vdGlmaWNhdGlvbnMuIElmIHdlIGRvbid0IGhhdmUgYSBncmV5IGNvdW50IGZvciBzb21lIHJlYXNvbiB3ZSB1c2UgdGhlIHJlZFxuICAgICAgICAgICAgLy8gY291bnQuIElmIHRoYXQgY291bnQgaXMgYnJva2VuIGZvciBzb21lIHJlYXNvbiwgYXNzdW1lIHplcm8uIFRoaXMgYXZvaWRzIHVzIHNob3dpbmdcbiAgICAgICAgICAgIC8vIGEgYmFkZ2UgZm9yICdOYU4nICh3aGljaCBmb3JtYXRzIGFzICdOYU5CJyBmb3IgTmFOIEJpbGxpb24pLlxuICAgICAgICAgICAgY29uc3QgdHJ1ZUNvdW50ID0gZ3JleU5vdGlmcyA/IGdyZXlOb3RpZnMgOiAocmVkTm90aWZzID8gcmVkTm90aWZzIDogMCk7XG5cbiAgICAgICAgICAgIC8vIE5vdGU6IHdlIG9ubHkgc2V0IHRoZSBzeW1ib2wgaWYgd2UgaGF2ZSBhbiBhY3R1YWwgY291bnQuIFdlIGRvbid0IHdhbnQgdG8gc2hvd1xuICAgICAgICAgICAgLy8gemVybyBvbiBiYWRnZXMuXG5cbiAgICAgICAgICAgIGlmIChyZWROb3RpZnMgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sb3IgPSBOb3RpZmljYXRpb25Db2xvci5SZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fY291bnQgPSB0cnVlQ291bnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3ltYm9sID0gbnVsbDsgLy8gc3ltYm9sIGNhbGN1bGF0ZWQgYnkgY29tcG9uZW50XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGdyZXlOb3RpZnMgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sb3IgPSBOb3RpZmljYXRpb25Db2xvci5HcmV5O1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvdW50ID0gdHJ1ZUNvdW50O1xuICAgICAgICAgICAgICAgIHRoaXMuX3N5bWJvbCA9IG51bGw7IC8vIHN5bWJvbCBjYWxjdWxhdGVkIGJ5IGNvbXBvbmVudFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBoYXZlIGFueSBub3RpZmllZCBtZXNzYWdlcywgYnV0IHdlIG1pZ2h0IGhhdmUgdW5yZWFkIG1lc3NhZ2VzLiBMZXQnc1xuICAgICAgICAgICAgICAgIC8vIGZpbmQgb3V0LlxuICAgICAgICAgICAgICAgIGNvbnN0IGhhc1VucmVhZCA9IFVucmVhZC5kb2VzUm9vbUhhdmVVbnJlYWRNZXNzYWdlcyh0aGlzLnJvb20pO1xuICAgICAgICAgICAgICAgIGlmIChoYXNVbnJlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29sb3IgPSBOb3RpZmljYXRpb25Db2xvci5Cb2xkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbG9yID0gTm90aWZpY2F0aW9uQ29sb3IuTm9uZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBubyBzeW1ib2wgb3IgY291bnQgZm9yIHRoaXMgc3RhdGVcbiAgICAgICAgICAgICAgICB0aGlzLl9jb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3ltYm9sID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmFsbHksIHB1Ymxpc2ggYW4gdXBkYXRlIGlmIG5lZWRlZFxuICAgICAgICB0aGlzLmVtaXRJZlVwZGF0ZWQoc25hcHNob3QpO1xuICAgIH1cbn1cbiJdfQ==