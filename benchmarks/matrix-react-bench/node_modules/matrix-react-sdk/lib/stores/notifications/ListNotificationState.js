"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ListNotificationState = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _NotificationColor = require("./NotificationColor");

var _arrays = require("../../utils/arrays");

var _NotificationState = require("./NotificationState");

/*
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
class ListNotificationState extends _NotificationState.NotificationState {
  constructor(byTileCount = false, tagId, getRoomFn) {
    super();
    this.byTileCount = byTileCount;
    this.tagId = tagId;
    this.getRoomFn = getRoomFn;
    (0, _defineProperty2.default)(this, "rooms", []);
    (0, _defineProperty2.default)(this, "states", {});
    (0, _defineProperty2.default)(this, "onRoomNotificationStateUpdate", () => {
      this.calculateTotalState();
    });
  }

  get symbol() {
    return this._color === _NotificationColor.NotificationColor.Unsent ? "!" : null;
  }

  setRooms(rooms) {
    // If we're only concerned about the tile count, don't bother setting up listeners.
    if (this.byTileCount) {
      this.rooms = rooms;
      this.calculateTotalState();
      return;
    }

    const oldRooms = this.rooms;
    const diff = (0, _arrays.arrayDiff)(oldRooms, rooms);
    this.rooms = rooms;

    for (const oldRoom of diff.removed) {
      const state = this.states[oldRoom.roomId];
      if (!state) continue; // We likely just didn't have a badge (race condition)

      delete this.states[oldRoom.roomId];
      state.off(_NotificationState.NOTIFICATION_STATE_UPDATE, this.onRoomNotificationStateUpdate);
    }

    for (const newRoom of diff.added) {
      const state = this.getRoomFn(newRoom);
      state.on(_NotificationState.NOTIFICATION_STATE_UPDATE, this.onRoomNotificationStateUpdate);
      this.states[newRoom.roomId] = state;
    }

    this.calculateTotalState();
  }

  getForRoom(room) {
    const state = this.states[room.roomId];
    if (!state) throw new Error("Unknown room for notification state");
    return state;
  }

  destroy() {
    super.destroy();

    for (const state of Object.values(this.states)) {
      state.off(_NotificationState.NOTIFICATION_STATE_UPDATE, this.onRoomNotificationStateUpdate);
    }

    this.states = {};
  }

  calculateTotalState() {
    const snapshot = this.snapshot();

    if (this.byTileCount) {
      this._color = _NotificationColor.NotificationColor.Red;
      this._count = this.rooms.length;
    } else {
      this._count = 0;
      this._color = _NotificationColor.NotificationColor.None;

      for (const state of Object.values(this.states)) {
        this._count += state.count;
        this._color = Math.max(this.color, state.color);
      }
    } // finally, publish an update if needed


    this.emitIfUpdated(snapshot);
  }

}

exports.ListNotificationState = ListNotificationState;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zdG9yZXMvbm90aWZpY2F0aW9ucy9MaXN0Tm90aWZpY2F0aW9uU3RhdGUudHMiXSwibmFtZXMiOlsiTGlzdE5vdGlmaWNhdGlvblN0YXRlIiwiTm90aWZpY2F0aW9uU3RhdGUiLCJjb25zdHJ1Y3RvciIsImJ5VGlsZUNvdW50IiwidGFnSWQiLCJnZXRSb29tRm4iLCJjYWxjdWxhdGVUb3RhbFN0YXRlIiwic3ltYm9sIiwiX2NvbG9yIiwiTm90aWZpY2F0aW9uQ29sb3IiLCJVbnNlbnQiLCJzZXRSb29tcyIsInJvb21zIiwib2xkUm9vbXMiLCJkaWZmIiwib2xkUm9vbSIsInJlbW92ZWQiLCJzdGF0ZSIsInN0YXRlcyIsInJvb21JZCIsIm9mZiIsIk5PVElGSUNBVElPTl9TVEFURV9VUERBVEUiLCJvblJvb21Ob3RpZmljYXRpb25TdGF0ZVVwZGF0ZSIsIm5ld1Jvb20iLCJhZGRlZCIsIm9uIiwiZ2V0Rm9yUm9vbSIsInJvb20iLCJFcnJvciIsImRlc3Ryb3kiLCJPYmplY3QiLCJ2YWx1ZXMiLCJzbmFwc2hvdCIsIlJlZCIsIl9jb3VudCIsImxlbmd0aCIsIk5vbmUiLCJjb3VudCIsIk1hdGgiLCJtYXgiLCJjb2xvciIsImVtaXRJZlVwZGF0ZWQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBZ0JBOztBQUdBOztBQUVBOztBQXJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFXTyxNQUFNQSxxQkFBTixTQUFvQ0Msb0NBQXBDLENBQXNEO0FBSXpEQyxFQUFBQSxXQUFXLENBQVNDLFdBQVcsR0FBRyxLQUF2QixFQUFzQ0MsS0FBdEMsRUFBNERDLFNBQTVELEVBQW9GO0FBQzNGO0FBRDJGLFNBQTNFRixXQUEyRSxHQUEzRUEsV0FBMkU7QUFBQSxTQUE5Q0MsS0FBOEMsR0FBOUNBLEtBQThDO0FBQUEsU0FBeEJDLFNBQXdCLEdBQXhCQSxTQUF3QjtB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LFNBQUtDLGFBQUwsQ0FBbUJULFFBQW5CO0FBQ0g7O0FBekV3RCIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAyMCBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB7IE5vdGlmaWNhdGlvbkNvbG9yIH0gZnJvbSBcIi4vTm90aWZpY2F0aW9uQ29sb3JcIjtcbmltcG9ydCB7IFRhZ0lEIH0gZnJvbSBcIi4uL3Jvb20tbGlzdC9tb2RlbHNcIjtcbmltcG9ydCB7IFJvb20gfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvbW9kZWxzL3Jvb21cIjtcbmltcG9ydCB7IGFycmF5RGlmZiB9IGZyb20gXCIuLi8uLi91dGlscy9hcnJheXNcIjtcbmltcG9ydCB7IFJvb21Ob3RpZmljYXRpb25TdGF0ZSB9IGZyb20gXCIuL1Jvb21Ob3RpZmljYXRpb25TdGF0ZVwiO1xuaW1wb3J0IHsgTk9USUZJQ0FUSU9OX1NUQVRFX1VQREFURSwgTm90aWZpY2F0aW9uU3RhdGUgfSBmcm9tIFwiLi9Ob3RpZmljYXRpb25TdGF0ZVwiO1xuXG5leHBvcnQgdHlwZSBGZXRjaFJvb21GbiA9IChyb29tOiBSb29tKSA9PiBSb29tTm90aWZpY2F0aW9uU3RhdGU7XG5cbmV4cG9ydCBjbGFzcyBMaXN0Tm90aWZpY2F0aW9uU3RhdGUgZXh0ZW5kcyBOb3RpZmljYXRpb25TdGF0ZSB7XG4gICAgcHJpdmF0ZSByb29tczogUm9vbVtdID0gW107XG4gICAgcHJpdmF0ZSBzdGF0ZXM6IHsgW3Jvb21JZDogc3RyaW5nXTogUm9vbU5vdGlmaWNhdGlvblN0YXRlIH0gPSB7fTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgYnlUaWxlQ291bnQgPSBmYWxzZSwgcHJpdmF0ZSB0YWdJZDogVGFnSUQsIHByaXZhdGUgZ2V0Um9vbUZuOiBGZXRjaFJvb21Gbikge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgc3ltYm9sKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvciA9PT0gTm90aWZpY2F0aW9uQ29sb3IuVW5zZW50ID8gXCIhXCIgOiBudWxsO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXRSb29tcyhyb29tczogUm9vbVtdKSB7XG4gICAgICAgIC8vIElmIHdlJ3JlIG9ubHkgY29uY2VybmVkIGFib3V0IHRoZSB0aWxlIGNvdW50LCBkb24ndCBib3RoZXIgc2V0dGluZyB1cCBsaXN0ZW5lcnMuXG4gICAgICAgIGlmICh0aGlzLmJ5VGlsZUNvdW50KSB7XG4gICAgICAgICAgICB0aGlzLnJvb21zID0gcm9vbXM7XG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZVRvdGFsU3RhdGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9sZFJvb21zID0gdGhpcy5yb29tcztcbiAgICAgICAgY29uc3QgZGlmZiA9IGFycmF5RGlmZihvbGRSb29tcywgcm9vbXMpO1xuICAgICAgICB0aGlzLnJvb21zID0gcm9vbXM7XG4gICAgICAgIGZvciAoY29uc3Qgb2xkUm9vbSBvZiBkaWZmLnJlbW92ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZXNbb2xkUm9vbS5yb29tSWRdO1xuICAgICAgICAgICAgaWYgKCFzdGF0ZSkgY29udGludWU7IC8vIFdlIGxpa2VseSBqdXN0IGRpZG4ndCBoYXZlIGEgYmFkZ2UgKHJhY2UgY29uZGl0aW9uKVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3RhdGVzW29sZFJvb20ucm9vbUlkXTtcbiAgICAgICAgICAgIHN0YXRlLm9mZihOT1RJRklDQVRJT05fU1RBVEVfVVBEQVRFLCB0aGlzLm9uUm9vbU5vdGlmaWNhdGlvblN0YXRlVXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG5ld1Jvb20gb2YgZGlmZi5hZGRlZCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFJvb21GbihuZXdSb29tKTtcbiAgICAgICAgICAgIHN0YXRlLm9uKE5PVElGSUNBVElPTl9TVEFURV9VUERBVEUsIHRoaXMub25Sb29tTm90aWZpY2F0aW9uU3RhdGVVcGRhdGUpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZXNbbmV3Um9vbS5yb29tSWRdID0gc3RhdGU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGN1bGF0ZVRvdGFsU3RhdGUoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0Rm9yUm9vbShyb29tOiBSb29tKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZXNbcm9vbS5yb29tSWRdO1xuICAgICAgICBpZiAoIXN0YXRlKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHJvb20gZm9yIG5vdGlmaWNhdGlvbiBzdGF0ZVwiKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIHB1YmxpYyBkZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgICAgIGZvciAoY29uc3Qgc3RhdGUgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLnN0YXRlcykpIHtcbiAgICAgICAgICAgIHN0YXRlLm9mZihOT1RJRklDQVRJT05fU1RBVEVfVVBEQVRFLCB0aGlzLm9uUm9vbU5vdGlmaWNhdGlvblN0YXRlVXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlcyA9IHt9O1xuICAgIH1cblxuICAgIHByaXZhdGUgb25Sb29tTm90aWZpY2F0aW9uU3RhdGVVcGRhdGUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlVG90YWxTdGF0ZSgpO1xuICAgIH07XG5cbiAgICBwcml2YXRlIGNhbGN1bGF0ZVRvdGFsU3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IHNuYXBzaG90ID0gdGhpcy5zbmFwc2hvdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmJ5VGlsZUNvdW50KSB7XG4gICAgICAgICAgICB0aGlzLl9jb2xvciA9IE5vdGlmaWNhdGlvbkNvbG9yLlJlZDtcbiAgICAgICAgICAgIHRoaXMuX2NvdW50ID0gdGhpcy5yb29tcy5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jb3VudCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9jb2xvciA9IE5vdGlmaWNhdGlvbkNvbG9yLk5vbmU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN0YXRlIG9mIE9iamVjdC52YWx1ZXModGhpcy5zdGF0ZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY291bnQgKz0gc3RhdGUuY291bnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sb3IgPSBNYXRoLm1heCh0aGlzLmNvbG9yLCBzdGF0ZS5jb2xvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5hbGx5LCBwdWJsaXNoIGFuIHVwZGF0ZSBpZiBuZWVkZWRcbiAgICAgICAgdGhpcy5lbWl0SWZVcGRhdGVkKHNuYXBzaG90KTtcbiAgICB9XG59XG5cbiJdfQ==