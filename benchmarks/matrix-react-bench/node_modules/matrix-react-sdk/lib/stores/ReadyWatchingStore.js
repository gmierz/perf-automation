"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReadyWatchingStore = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _MatrixClientPeg = require("../MatrixClientPeg");

var _events = require("events");

/*
 * Copyright 2021 The Matrix.org Foundation C.I.C.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ReadyWatchingStore extends _events.EventEmitter {
  constructor(dispatcher) {
    super();
    this.dispatcher = dispatcher;
    (0, _defineProperty2.default)(this, "matrixClient", void 0);
    (0, _defineProperty2.default)(this, "dispatcherRef", void 0);
    (0, _defineProperty2.default)(this, "onAction", async payload => {
      if (payload.action === 'MatrixActions.sync') {
        // Only set the client on the transition into the PREPARED state.
        // Everything after this is unnecessary (we only need to know once we have a client)
        // and we intentionally don't set the client before this point to avoid stores
        // updating for every event emitted during the cached sync.
        if (!(payload.prevState === 'PREPARED' && payload.state !== 'PREPARED')) {
          return;
        }

        if (this.matrixClient !== payload.matrixClient) {
          if (this.matrixClient) {
            await this.onNotReady();
          }

          this.matrixClient = payload.matrixClient;
          await this.onReady();
        }
      } else if (payload.action === 'on_client_not_viable' || payload.action === 'on_logged_out') {
        if (this.matrixClient) {
          await this.onNotReady();
          this.matrixClient = null;
        }
      }
    });
    this.dispatcherRef = this.dispatcher.register(this.onAction);

    if (_MatrixClientPeg.MatrixClientPeg.get()) {
      this.matrixClient = _MatrixClientPeg.MatrixClientPeg.get(); // noinspection JSIgnoredPromiseFromCall

      this.onReady();
    }
  }

  get mxClient() {
    return this.matrixClient; // for external readonly access
  }

  useUnitTestClient(cli) {
    this.matrixClient = cli;
  }

  destroy() {
    this.dispatcher.unregister(this.dispatcherRef);
  }

  async onReady() {// Default implementation is to do nothing.
  }

  async onNotReady() {// Default implementation is to do nothing.
  }

}

exports.ReadyWatchingStore = ReadyWatchingStore;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zdG9yZXMvUmVhZHlXYXRjaGluZ1N0b3JlLnRzIl0sIm5hbWVzIjpbIlJlYWR5V2F0Y2hpbmdTdG9yZSIsIkV2ZW50RW1pdHRlciIsImNvbnN0cnVjdG9yIiwiZGlzcGF0Y2hlciIsInBheWxvYWQiLCJhY3Rpb24iLCJwcmV2U3RhdGUiLCJzdGF0ZSIsIm1hdHJpeENsaWVudCIsIm9uTm90UmVhZHkiLCJvblJlYWR5IiwiZGlzcGF0Y2hlclJlZiIsInJlZ2lzdGVyIiwib25BY3Rpb24iLCJNYXRyaXhDbGllbnRQZWciLCJnZXQiLCJteENsaWVudCIsInVzZVVuaXRUZXN0Q2xpZW50IiwiY2xpIiwiZGVzdHJveSIsInVucmVnaXN0ZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBaUJBOztBQUlBOztBQXJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTTyxNQUFlQSxrQkFBZixTQUEwQ0Msb0JBQTFDLENBQStFO0FBSWxGQyxFQUFBQSxXQUFXLENBQW9CQyxVQUFwQixFQUEyRDtBQUNsRTtBQURrRSxTQUF2Q0EsVUFBdUMsR0FBdkNBLFVBQXVDO0FBQUE7QUFBQTtBQUFBLG9EQWlDbkQsTUFBT0MsT0FBUCxJQUFrQztBQUNqRCxVQUFJQSxPQUFPLENBQUNDLE1BQVIsS0FBbUIsb0JBQXZCLEVBQTZDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSSxFQUFFRCxPQUFPLENBQUNFLFNBQVIsS0FBc0IsVUFBdEIsSUFBb0NGLE9BQU8sQ0FBQ0csS0FBUixLQUFrQixVQUF4RCxDQUFKLEVBQXlFO0FBQ3JFO0FBQ0g7O0FBRUQsWUFBSSxLQUFLQyxZQUFMLEtBQXNCSixPQUFPLENBQUNJLFlBQWxDLEVBQWdEO0FBQzVDLGNBQUksS0FBS0EsWUFBVCxFQUF1QjtBQUNuQixrQkFBTSxLQUFLQyxVQUFMLEVBQU47QUFDSDs7QUFDRCxlQUFLRCxZQUFMLEdBQW9CSixPQUFPLENBQUNJLFlBQTVCO0FBQ0EsZ0JBQU0sS0FBS0UsT0FBTCxFQUFOO0FBQ0g7QUFDSixPQWhCRCxNQWdCTyxJQUFJTixPQUFPLENBQUNDLE1BQVIsS0FBbUIsc0JBQW5CLElBQTZDRCxPQUFPLENBQUNDLE1BQVIsS0FBbUIsZUFBcEUsRUFBcUY7QUFDeEYsWUFBSSxLQUFLRyxZQUFULEVBQXVCO0FBQ25CLGdCQUFNLEtBQUtDLFVBQUwsRUFBTjtBQUNBLGVBQUtELFlBQUwsR0FBb0IsSUFBcEI7QUFDSDtBQUNKO0FBQ0osS0F4RHFFO0FBR2xFLFNBQUtHLGFBQUwsR0FBcUIsS0FBS1IsVUFBTCxDQUFnQlMsUUFBaEIsQ0FBeUIsS0FBS0MsUUFBOUIsQ0FBckI7O0FBRUEsUUFBSUMsaUNBQWdCQyxHQUFoQixFQUFKLEVBQTJCO0FBQ3ZCLFdBQUtQLFlBQUwsR0FBb0JNLGlDQUFnQkMsR0FBaEIsRUFBcEIsQ0FEdUIsQ0FHdkI7O0FBQ0EsV0FBS0wsT0FBTDtBQUNIO0FBQ0o7O0FBRWtCLE1BQVJNLFFBQVEsR0FBaUI7QUFDaEMsV0FBTyxLQUFLUixZQUFaLENBRGdDLENBQ047QUFDN0I7O0FBRU1TLEVBQUFBLGlCQUFpQixDQUFDQyxHQUFELEVBQW9CO0FBQ3hDLFNBQUtWLFlBQUwsR0FBb0JVLEdBQXBCO0FBQ0g7O0FBRU1DLEVBQUFBLE9BQU8sR0FBRztBQUNiLFNBQUtoQixVQUFMLENBQWdCaUIsVUFBaEIsQ0FBMkIsS0FBS1QsYUFBaEM7QUFDSDs7QUFFc0IsUUFBUEQsT0FBTyxHQUFHLENBQ3RCO0FBQ0g7O0FBRXlCLFFBQVZELFVBQVUsR0FBRyxDQUN6QjtBQUNIOztBQW5DaUYiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IDIwMjEgVGhlIE1hdHJpeC5vcmcgRm91bmRhdGlvbiBDLkkuQy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IE1hdHJpeENsaWVudCB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9jbGllbnRcIjtcbmltcG9ydCB7IE1hdHJpeENsaWVudFBlZyB9IGZyb20gXCIuLi9NYXRyaXhDbGllbnRQZWdcIjtcbmltcG9ydCB7IEFjdGlvblBheWxvYWQgfSBmcm9tIFwiLi4vZGlzcGF0Y2hlci9wYXlsb2Fkc1wiO1xuaW1wb3J0IHsgRGlzcGF0Y2hlciB9IGZyb20gXCJmbHV4XCI7XG5pbXBvcnQgeyBJRGVzdHJveWFibGUgfSBmcm9tIFwiLi4vdXRpbHMvSURlc3Ryb3lhYmxlXCI7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tIFwiZXZlbnRzXCI7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSZWFkeVdhdGNoaW5nU3RvcmUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIgaW1wbGVtZW50cyBJRGVzdHJveWFibGUge1xuICAgIHByb3RlY3RlZCBtYXRyaXhDbGllbnQ6IE1hdHJpeENsaWVudDtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGRpc3BhdGNoZXJSZWY6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBkaXNwYXRjaGVyOiBEaXNwYXRjaGVyPEFjdGlvblBheWxvYWQ+KSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyUmVmID0gdGhpcy5kaXNwYXRjaGVyLnJlZ2lzdGVyKHRoaXMub25BY3Rpb24pO1xuXG4gICAgICAgIGlmIChNYXRyaXhDbGllbnRQZWcuZ2V0KCkpIHtcbiAgICAgICAgICAgIHRoaXMubWF0cml4Q2xpZW50ID0gTWF0cml4Q2xpZW50UGVnLmdldCgpO1xuXG4gICAgICAgICAgICAvLyBub2luc3BlY3Rpb24gSlNJZ25vcmVkUHJvbWlzZUZyb21DYWxsXG4gICAgICAgICAgICB0aGlzLm9uUmVhZHkoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgbXhDbGllbnQoKTogTWF0cml4Q2xpZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4Q2xpZW50OyAvLyBmb3IgZXh0ZXJuYWwgcmVhZG9ubHkgYWNjZXNzXG4gICAgfVxuXG4gICAgcHVibGljIHVzZVVuaXRUZXN0Q2xpZW50KGNsaTogTWF0cml4Q2xpZW50KSB7XG4gICAgICAgIHRoaXMubWF0cml4Q2xpZW50ID0gY2xpO1xuICAgIH1cblxuICAgIHB1YmxpYyBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoZXIudW5yZWdpc3Rlcih0aGlzLmRpc3BhdGNoZXJSZWYpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBhc3luYyBvblJlYWR5KCkge1xuICAgICAgICAvLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uIGlzIHRvIGRvIG5vdGhpbmcuXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGFzeW5jIG9uTm90UmVhZHkoKSB7XG4gICAgICAgIC8vIERlZmF1bHQgaW1wbGVtZW50YXRpb24gaXMgdG8gZG8gbm90aGluZy5cbiAgICB9XG5cbiAgICBwcml2YXRlIG9uQWN0aW9uID0gYXN5bmMgKHBheWxvYWQ6IEFjdGlvblBheWxvYWQpID0+IHtcbiAgICAgICAgaWYgKHBheWxvYWQuYWN0aW9uID09PSAnTWF0cml4QWN0aW9ucy5zeW5jJykge1xuICAgICAgICAgICAgLy8gT25seSBzZXQgdGhlIGNsaWVudCBvbiB0aGUgdHJhbnNpdGlvbiBpbnRvIHRoZSBQUkVQQVJFRCBzdGF0ZS5cbiAgICAgICAgICAgIC8vIEV2ZXJ5dGhpbmcgYWZ0ZXIgdGhpcyBpcyB1bm5lY2Vzc2FyeSAod2Ugb25seSBuZWVkIHRvIGtub3cgb25jZSB3ZSBoYXZlIGEgY2xpZW50KVxuICAgICAgICAgICAgLy8gYW5kIHdlIGludGVudGlvbmFsbHkgZG9uJ3Qgc2V0IHRoZSBjbGllbnQgYmVmb3JlIHRoaXMgcG9pbnQgdG8gYXZvaWQgc3RvcmVzXG4gICAgICAgICAgICAvLyB1cGRhdGluZyBmb3IgZXZlcnkgZXZlbnQgZW1pdHRlZCBkdXJpbmcgdGhlIGNhY2hlZCBzeW5jLlxuICAgICAgICAgICAgaWYgKCEocGF5bG9hZC5wcmV2U3RhdGUgPT09ICdQUkVQQVJFRCcgJiYgcGF5bG9hZC5zdGF0ZSAhPT0gJ1BSRVBBUkVEJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm1hdHJpeENsaWVudCAhPT0gcGF5bG9hZC5tYXRyaXhDbGllbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRyaXhDbGllbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5vbk5vdFJlYWR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubWF0cml4Q2xpZW50ID0gcGF5bG9hZC5tYXRyaXhDbGllbnQ7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5vblJlYWR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocGF5bG9hZC5hY3Rpb24gPT09ICdvbl9jbGllbnRfbm90X3ZpYWJsZScgfHwgcGF5bG9hZC5hY3Rpb24gPT09ICdvbl9sb2dnZWRfb3V0Jykge1xuICAgICAgICAgICAgaWYgKHRoaXMubWF0cml4Q2xpZW50KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5vbk5vdFJlYWR5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRyaXhDbGllbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbiJdfQ==