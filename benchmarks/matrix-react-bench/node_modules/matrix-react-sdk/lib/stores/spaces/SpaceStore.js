"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getChildOrder = exports.default = exports.SpaceStoreClass = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

var _event = require("matrix-js-sdk/src/@types/event");

var _logger = require("matrix-js-sdk/src/logger");

var _AsyncStoreWithClient = require("../AsyncStoreWithClient");

var _dispatcher = _interopRequireDefault(require("../../dispatcher/dispatcher"));

var _RoomListStore = _interopRequireDefault(require("../room-list/RoomListStore"));

var _SettingsStore = _interopRequireDefault(require("../../settings/SettingsStore"));

var _DMRoomMap = _interopRequireDefault(require("../../utils/DMRoomMap"));

var _SpaceNotificationState = require("../notifications/SpaceNotificationState");

var _RoomNotificationStateStore = require("../notifications/RoomNotificationStateStore");

var _models = require("../room-list/models");

var _maps = require("../../utils/maps");

var _sets = require("../../utils/sets");

var _RoomViewStore = _interopRequireDefault(require("../RoomViewStore"));

var _actions = require("../../dispatcher/actions");

var _arrays = require("../../utils/arrays");

var _objects = require("../../utils/objects");

var _stringOrderField = require("../../utils/stringOrderField");

var _RoomList = require("../../components/views/rooms/RoomList");

var _ = require(".");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const ACTIVE_SPACE_LS_KEY = "mx_active_space";
const metaSpaceOrder = [_.MetaSpace.Home, _.MetaSpace.Favourites, _.MetaSpace.People, _.MetaSpace.Orphans];
const MAX_SUGGESTED_ROOMS = 20; // This setting causes the page to reload and can be costly if read frequently, so read it here only

const spacesEnabled = !_SettingsStore.default.getValue("showCommunitiesInsteadOfSpaces");

const getSpaceContextKey = space => `mx_space_context_${space}`;

const partitionSpacesAndRooms = arr => {
  // [spaces, rooms]
  return arr.reduce((result, room) => {
    result[room.isSpaceRoom() ? 0 : 1].push(room);
    return result;
  }, [[], []]);
};

const validOrder = order => {
  if (typeof order === "string" && order.length <= 50 && Array.from(order).every(c => {
    const charCode = c.charCodeAt(0);
    return charCode >= 0x20 && charCode <= 0x7E;
  })) {
    return order;
  }
}; // For sorting space children using a validated `order`, `m.room.create`'s `origin_server_ts`, `room_id`


const getChildOrder = (order, creationTs, roomId) => {
  return [validOrder(order) ?? NaN, creationTs, roomId]; // NaN has lodash sort it at the end in asc
};

exports.getChildOrder = getChildOrder;

const getRoomFn = room => {
  return _RoomNotificationStateStore.RoomNotificationStateStore.instance.getRoomState(room);
};

class SpaceStoreClass extends _AsyncStoreWithClient.AsyncStoreWithClient {
  // The spaces representing the roots of the various tree-like hierarchies
  // The list of rooms not present in any currently joined spaces
  // Map from room ID to set of spaces which list it as a child
  // Map from SpaceKey to SpaceNotificationState instance representing that space
  // Map from space key to Set of room IDs that should be shown as part of that space's filter
  // The space currently selected in the Space Panel
  // set properly by onReady
  // set by onReady
  constructor() {
    super(_dispatcher.default, {});
    (0, _defineProperty2.default)(this, "rootSpaces", []);
    (0, _defineProperty2.default)(this, "orphanedRooms", new Set());
    (0, _defineProperty2.default)(this, "parentMap", new _maps.EnhancedMap());
    (0, _defineProperty2.default)(this, "notificationStateMap", new Map());
    (0, _defineProperty2.default)(this, "spaceFilteredRooms", new Map());
    (0, _defineProperty2.default)(this, "_activeSpace", _.MetaSpace.Home);
    (0, _defineProperty2.default)(this, "_suggestedRooms", []);
    (0, _defineProperty2.default)(this, "_invitedSpaces", new Set());
    (0, _defineProperty2.default)(this, "spaceOrderLocalEchoMap", new Map());
    (0, _defineProperty2.default)(this, "_restrictedJoinRuleSupport", void 0);
    (0, _defineProperty2.default)(this, "_allRoomsInHome", _SettingsStore.default.getValue("Spaces.allRoomsInHome"));
    (0, _defineProperty2.default)(this, "_enabledMetaSpaces", []);
    (0, _defineProperty2.default)(this, "fetchSuggestedRooms", async (space, limit = MAX_SUGGESTED_ROOMS) => {
      try {
        const {
          rooms
        } = await this.matrixClient.getRoomHierarchy(space.roomId, limit, 1, true);
        const viaMap = new _maps.EnhancedMap();
        rooms.forEach(room => {
          room.children_state.forEach(ev => {
            var _ev$content$via;

            if (ev.type === _event.EventType.SpaceChild && (_ev$content$via = ev.content.via) !== null && _ev$content$via !== void 0 && _ev$content$via.length) {
              ev.content.via.forEach(via => {
                viaMap.getOrCreate(ev.state_key, new Set()).add(via);
              });
            }
          });
        });
        return rooms.filter(roomInfo => {
          var _this$matrixClient$ge;

          return roomInfo.room_type !== _event.RoomType.Space && ((_this$matrixClient$ge = this.matrixClient.getRoom(roomInfo.room_id)) === null || _this$matrixClient$ge === void 0 ? void 0 : _this$matrixClient$ge.getMyMembership()) !== "join";
        }).map(roomInfo => _objectSpread(_objectSpread({}, roomInfo), {}, {
          viaServers: Array.from(viaMap.get(roomInfo.room_id) || [])
        }));
      } catch (e) {
        _logger.logger.error(e);
      }

      return [];
    });
    (0, _defineProperty2.default)(this, "getSpaceFilteredRoomIds", space => {
      if (space === _.MetaSpace.Home && this.allRoomsInHome) {
        return new Set(this.matrixClient.getVisibleRooms().map(r => r.roomId));
      }

      return this.spaceFilteredRooms.get(space) || new Set();
    });
    (0, _defineProperty2.default)(this, "rebuild", (0, _lodash.throttle)(() => {
      if (!this.matrixClient) return;
      const [visibleSpaces, visibleRooms] = partitionSpacesAndRooms(this.matrixClient.getVisibleRooms());
      const [joinedSpaces, invitedSpaces] = visibleSpaces.reduce((arr, s) => {
        if (s.getMyMembership() === "join") {
          arr[0].push(s);
        } else if (s.getMyMembership() === "invite") {
          arr[1].push(s);
        }

        return arr;
      }, [[], []]); // exclude invited spaces from unseenChildren as they will be forcibly shown at the top level of the treeview

      const unseenChildren = new Set([...visibleRooms, ...joinedSpaces]);
      const backrefs = new _maps.EnhancedMap(); // Sort spaces by room ID to force the cycle breaking to be deterministic

      const spaces = (0, _lodash.sortBy)(joinedSpaces, space => space.roomId); // TODO handle cleaning up links when a Space is removed

      spaces.forEach(space => {
        const children = this.getChildren(space.roomId);
        children.forEach(child => {
          unseenChildren.delete(child);
          backrefs.getOrCreate(child.roomId, new Set()).add(space.roomId);
        });
      });
      const [rootSpaces, orphanedRooms] = partitionSpacesAndRooms(Array.from(unseenChildren)); // somewhat algorithm to handle full-cycles

      const detachedNodes = new Set(spaces);

      const markTreeChildren = (rootSpace, unseen) => {
        const stack = [rootSpace];

        while (stack.length) {
          const op = stack.pop();
          unseen.delete(op);
          this.getChildSpaces(op.roomId).forEach(space => {
            if (unseen.has(space)) {
              stack.push(space);
            }
          });
        }
      };

      rootSpaces.forEach(rootSpace => {
        markTreeChildren(rootSpace, detachedNodes);
      }); // Handle spaces forming fully cyclical relationships.
      // In order, assume each detachedNode is a root unless it has already
      // been claimed as the child of prior detached node.
      // Work from a copy of the detachedNodes set as it will be mutated as part of this operation.

      Array.from(detachedNodes).forEach(detachedNode => {
        if (!detachedNodes.has(detachedNode)) return; // declare this detached node a new root, find its children, without ever looping back to it

        detachedNodes.delete(detachedNode);
        rootSpaces.push(detachedNode);
        markTreeChildren(detachedNode, detachedNodes); // TODO only consider a detached node a root space if it has no *parents other than the ones forming cycles
      }); // TODO neither of these handle an A->B->C->A with an additional C->D
      // detachedNodes.forEach(space => {
      //     rootSpaces.push(space);
      // });

      this.orphanedRooms = new Set(orphanedRooms.map(r => r.roomId));
      this.rootSpaces = this.sortRootSpaces(rootSpaces);
      this.parentMap = backrefs; // if the currently selected space no longer exists, remove its selection

      if (this._activeSpace[0] === "!" && detachedNodes.has(this.matrixClient.getRoom(this._activeSpace))) {
        this.goToFirstSpace();
      }

      this.onRoomsUpdate(); // TODO only do this if a change has happened

      this.emit(_.UPDATE_TOP_LEVEL_SPACES, this.spacePanelSpaces, this.enabledMetaSpaces); // build initial state of invited spaces as we would have missed the emitted events about the room at launch

      this._invitedSpaces = new Set(this.sortRootSpaces(invitedSpaces));
      this.emit(_.UPDATE_INVITED_SPACES, this.invitedSpaces);
    }, 100, {
      trailing: true,
      leading: true
    }));
    (0, _defineProperty2.default)(this, "onSpaceUpdate", () => {
      this.rebuild();
    });
    (0, _defineProperty2.default)(this, "showInHomeSpace", room => {
      var _this$parentMap$get;

      if (this.allRoomsInHome) return true;
      if (room.isSpaceRoom()) return false;
      return !((_this$parentMap$get = this.parentMap.get(room.roomId)) !== null && _this$parentMap$get !== void 0 && _this$parentMap$get.size) // put all orphaned rooms in the Home Space
      || _DMRoomMap.default.shared().getUserIdForRoomId(room.roomId); // put all DMs in the Home Space
    });
    (0, _defineProperty2.default)(this, "onRoomUpdate", room => {
      const enabledMetaSpaces = new Set(this.enabledMetaSpaces); // TODO more metaspace stuffs

      if (enabledMetaSpaces.has(_.MetaSpace.Home)) {
        if (this.showInHomeSpace(room)) {
          var _this$spaceFilteredRo;

          (_this$spaceFilteredRo = this.spaceFilteredRooms.get(_.MetaSpace.Home)) === null || _this$spaceFilteredRo === void 0 ? void 0 : _this$spaceFilteredRo.add(room.roomId);
          this.emit(_.MetaSpace.Home);
        } else if (!this.orphanedRooms.has(room.roomId)) {
          var _this$spaceFilteredRo2;

          (_this$spaceFilteredRo2 = this.spaceFilteredRooms.get(_.MetaSpace.Home)) === null || _this$spaceFilteredRo2 === void 0 ? void 0 : _this$spaceFilteredRo2.delete(room.roomId);
          this.emit(_.MetaSpace.Home);
        }
      }
    });
    (0, _defineProperty2.default)(this, "onSpaceMembersChange", ev => {
      // skip this update if we do not have a DM with this user
      if (_DMRoomMap.default.shared().getDMRoomsForUserId(ev.getStateKey()).length < 1) return;
      this.onRoomsUpdate();
    });
    (0, _defineProperty2.default)(this, "onRoomsUpdate", (0, _lodash.throttle)(() => {
      // TODO resolve some updates as deltas
      const visibleRooms = this.matrixClient.getVisibleRooms();
      const oldFilteredRooms = this.spaceFilteredRooms;
      this.spaceFilteredRooms = new Map();
      const enabledMetaSpaces = new Set(this.enabledMetaSpaces); // populate the Home metaspace if it is enabled and is not set to all rooms

      if (enabledMetaSpaces.has(_.MetaSpace.Home) && !this.allRoomsInHome) {
        // put all room invites in the Home Space
        const invites = visibleRooms.filter(r => !r.isSpaceRoom() && r.getMyMembership() === "invite");
        this.spaceFilteredRooms.set(_.MetaSpace.Home, new Set(invites.map(r => r.roomId)));
        visibleRooms.forEach(room => {
          if (this.showInHomeSpace(room)) {
            this.spaceFilteredRooms.get(_.MetaSpace.Home).add(room.roomId);
          }
        });
      } // populate the Favourites metaspace if it is enabled


      if (enabledMetaSpaces.has(_.MetaSpace.Favourites)) {
        const favourites = visibleRooms.filter(r => r.tags[_models.DefaultTagID.Favourite]);
        this.spaceFilteredRooms.set(_.MetaSpace.Favourites, new Set(favourites.map(r => r.roomId)));
      } // populate the People metaspace if it is enabled


      if (enabledMetaSpaces.has(_.MetaSpace.People)) {
        const people = visibleRooms.filter(r => _DMRoomMap.default.shared().getUserIdForRoomId(r.roomId));
        this.spaceFilteredRooms.set(_.MetaSpace.People, new Set(people.map(r => r.roomId)));
      } // populate the Orphans metaspace if it is enabled


      if (enabledMetaSpaces.has(_.MetaSpace.Orphans)) {
        const orphans = visibleRooms.filter(r => {
          var _this$parentMap$get2;

          // filter out DMs and rooms with >0 parents
          return !((_this$parentMap$get2 = this.parentMap.get(r.roomId)) !== null && _this$parentMap$get2 !== void 0 && _this$parentMap$get2.size) && !_DMRoomMap.default.shared().getUserIdForRoomId(r.roomId);
        });
        this.spaceFilteredRooms.set(_.MetaSpace.Orphans, new Set(orphans.map(r => r.roomId)));
      }

      const hiddenChildren = new _maps.EnhancedMap();
      visibleRooms.forEach(room => {
        if (room.getMyMembership() !== "join") return;
        this.getParents(room.roomId).forEach(parent => {
          hiddenChildren.getOrCreate(parent.roomId, new Set()).add(room.roomId);
        });
      });
      this.rootSpaces.forEach(s => {
        // traverse each space tree in DFS to build up the supersets as you go up,
        // reusing results from like subtrees.
        const fn = (spaceId, parentPath) => {
          var _this$matrixClient, _hiddenChildren$get;

          if (parentPath.has(spaceId)) return; // prevent cycles
          // reuse existing results if multiple similar branches exist

          if (this.spaceFilteredRooms.has(spaceId)) {
            return this.spaceFilteredRooms.get(spaceId);
          }

          const [childSpaces, childRooms] = partitionSpacesAndRooms(this.getChildren(spaceId));
          const roomIds = new Set(childRooms.map(r => r.roomId));
          const space = (_this$matrixClient = this.matrixClient) === null || _this$matrixClient === void 0 ? void 0 : _this$matrixClient.getRoom(spaceId); // Add relevant DMs

          space === null || space === void 0 ? void 0 : space.getMembers().forEach(member => {
            if (member.membership !== "join" && member.membership !== "invite") return;

            _DMRoomMap.default.shared().getDMRoomsForUserId(member.userId).forEach(roomId => {
              roomIds.add(roomId);
            });
          });
          const newPath = new Set(parentPath).add(spaceId);
          childSpaces.forEach(childSpace => {
            var _fn;

            (_fn = fn(childSpace.roomId, newPath)) === null || _fn === void 0 ? void 0 : _fn.forEach(roomId => {
              roomIds.add(roomId);
            });
          });
          (_hiddenChildren$get = hiddenChildren.get(spaceId)) === null || _hiddenChildren$get === void 0 ? void 0 : _hiddenChildren$get.forEach(roomId => {
            roomIds.add(roomId);
          }); // Expand room IDs to all known versions of the given rooms

          const expandedRoomIds = new Set(Array.from(roomIds).flatMap(roomId => {
            return this.matrixClient.getRoomUpgradeHistory(roomId, true).map(r => r.roomId);
          }));
          this.spaceFilteredRooms.set(spaceId, expandedRoomIds);
          return expandedRoomIds;
        };

        fn(s.roomId, new Set());
      });
      const diff = (0, _maps.mapDiff)(oldFilteredRooms, this.spaceFilteredRooms); // filter out keys which changed by reference only by checking whether the sets differ

      const changed = diff.changed.filter(k => (0, _sets.setHasDiff)(oldFilteredRooms.get(k), this.spaceFilteredRooms.get(k)));
      [...diff.added, ...diff.removed, ...changed].forEach(k => {
        this.emit(k);
      });
      let dmBadgeSpace; // only show badges on dms on the most relevant space if such exists

      if (enabledMetaSpaces.has(_.MetaSpace.People)) {
        dmBadgeSpace = _.MetaSpace.People;
      } else if (enabledMetaSpaces.has(_.MetaSpace.Home)) {
        dmBadgeSpace = _.MetaSpace.Home;
      }

      this.spaceFilteredRooms.forEach((roomIds, s) => {
        if (this.allRoomsInHome && s === _.MetaSpace.Home) return; // we'll be using the global notification state, skip
        // Update NotificationStates

        this.getNotificationState(s).setRooms(visibleRooms.filter(room => {
          if (!roomIds.has(room.roomId) || room.isSpaceRoom()) return false;

          if (dmBadgeSpace && _DMRoomMap.default.shared().getUserIdForRoomId(room.roomId)) {
            return s === dmBadgeSpace;
          }

          return true;
        }));
      });
    }, 100, {
      trailing: true,
      leading: true
    }));
    (0, _defineProperty2.default)(this, "switchToRelatedSpace", roomId => {
      var _parent;

      if (this.suggestedRooms.find(r => r.room_id === roomId)) return;
      let parent = this.getCanonicalParent(roomId);

      if (!parent) {
        parent = this.rootSpaces.find(s => {
          var _this$spaceFilteredRo3;

          return (_this$spaceFilteredRo3 = this.spaceFilteredRooms.get(s.roomId)) === null || _this$spaceFilteredRo3 === void 0 ? void 0 : _this$spaceFilteredRo3.has(roomId);
        });
      }

      if (!parent) {
        const parentIds = Array.from(this.parentMap.get(roomId) || []);

        for (const parentId of parentIds) {
          const room = this.matrixClient.getRoom(parentId);

          if (room) {
            parent = room;
            break;
          }
        }
      } // don't trigger a context switch when we are switching a space to match the chosen room


      this.setActiveSpace(((_parent = parent) === null || _parent === void 0 ? void 0 : _parent.roomId) ?? _.MetaSpace.Home, false); // TODO
    });
    (0, _defineProperty2.default)(this, "onRoom", (room, newMembership, oldMembership) => {
      const roomMembership = room.getMyMembership();

      if (!roomMembership) {
        // room is still being baked in the js-sdk, we'll process it at Room.myMembership instead
        return;
      }

      const membership = newMembership || roomMembership;

      if (!room.isSpaceRoom()) {
        // this.onRoomUpdate(room);
        // this.onRoomsUpdate();
        // ideally we only need onRoomsUpdate here but it doesn't rebuild parentMap so always adds new rooms to Home
        this.rebuild();

        if (membership === "join") {
          // the user just joined a room, remove it from the suggested list if it was there
          const numSuggestedRooms = this._suggestedRooms.length;
          this._suggestedRooms = this._suggestedRooms.filter(r => r.room_id !== room.roomId);

          if (numSuggestedRooms !== this._suggestedRooms.length) {
            this.emit(_.UPDATE_SUGGESTED_ROOMS, this._suggestedRooms);
          } // if the room currently being viewed was just joined then switch to its related space


          if (newMembership === "join" && room.roomId === _RoomViewStore.default.getRoomId()) {
            this.switchToRelatedSpace(room.roomId);
          }
        }

        return;
      } // Space


      if (membership === "invite") {
        this._invitedSpaces.add(room);

        this.emit(_.UPDATE_INVITED_SPACES, this.invitedSpaces);
      } else if (oldMembership === "invite" && membership !== "join") {
        this._invitedSpaces.delete(room);

        this.emit(_.UPDATE_INVITED_SPACES, this.invitedSpaces);
      } else {
        this.onSpaceUpdate();
        this.emit(room.roomId);
      }

      if (membership === "join" && room.roomId === _RoomViewStore.default.getRoomId()) {
        // if the user was looking at the space and then joined: select that space
        this.setActiveSpace(room.roomId, false);
      } else if (membership === "leave" && room.roomId === this.activeSpace) {
        // user's active space has gone away, go back to home
        this.goToFirstSpace(true);
      }
    });
    (0, _defineProperty2.default)(this, "onRoomState", ev => {
      var _this$matrixClient$ge2;

      const room = this.matrixClient.getRoom(ev.getRoomId());
      if (!room) return;

      switch (ev.getType()) {
        case _event.EventType.SpaceChild:
          if (room.isSpaceRoom()) {
            this.onSpaceUpdate();
            this.emit(room.roomId);
          }

          if (room.roomId === this.activeSpace && // current space
          ((_this$matrixClient$ge2 = this.matrixClient.getRoom(ev.getStateKey())) === null || _this$matrixClient$ge2 === void 0 ? void 0 : _this$matrixClient$ge2.getMyMembership()) !== "join" && // target not joined
          ev.getPrevContent().suggested !== ev.getContent().suggested // suggested flag changed
          ) {
            this.loadSuggestedRooms(room);
          }

          break;

        case _event.EventType.SpaceParent:
          // TODO rebuild the space parent and not the room - check permissions?
          // TODO confirm this after implementing parenting behaviour
          if (room.isSpaceRoom()) {
            this.onSpaceUpdate();
          } else if (!this.allRoomsInHome) {
            this.onRoomUpdate(room);
          }

          this.emit(room.roomId);
          break;

        case _event.EventType.RoomPowerLevels:
          if (room.isSpaceRoom()) {
            this.onRoomsUpdate();
          }

          break;
      }
    });
    (0, _defineProperty2.default)(this, "onRoomStateMembers", ev => {
      const room = this.matrixClient.getRoom(ev.getRoomId());

      if (room !== null && room !== void 0 && room.isSpaceRoom()) {
        this.onSpaceMembersChange(ev);
      }
    });
    (0, _defineProperty2.default)(this, "onRoomAccountData", (ev, room, lastEv) => {
      if (!room.isSpaceRoom()) return;

      if (ev.getType() === _event.EventType.SpaceOrder) {
        var _ev$getContent, _lastEv$getContent;

        this.spaceOrderLocalEchoMap.delete(room.roomId); // clear any local echo

        const order = (_ev$getContent = ev.getContent()) === null || _ev$getContent === void 0 ? void 0 : _ev$getContent.order;
        const lastOrder = lastEv === null || lastEv === void 0 ? void 0 : (_lastEv$getContent = lastEv.getContent()) === null || _lastEv$getContent === void 0 ? void 0 : _lastEv$getContent.order;

        if (order !== lastOrder) {
          this.notifyIfOrderChanged();
        }
      } else if (ev.getType() === _event.EventType.Tag) {
        var _lastEv$getContent2, _ev$getContent2;

        // If the room was in favourites and now isn't or the opposite then update its position in the trees
        const oldTags = (lastEv === null || lastEv === void 0 ? void 0 : (_lastEv$getContent2 = lastEv.getContent()) === null || _lastEv$getContent2 === void 0 ? void 0 : _lastEv$getContent2.tags) || {};
        const newTags = ((_ev$getContent2 = ev.getContent()) === null || _ev$getContent2 === void 0 ? void 0 : _ev$getContent2.tags) || {};

        if (!!oldTags[_models.DefaultTagID.Favourite] !== !!newTags[_models.DefaultTagID.Favourite]) {
          this.onRoomUpdate(room);
        }
      }
    });
    (0, _defineProperty2.default)(this, "onAccountData", (ev, prevEvent) => {
      if (!this.allRoomsInHome && ev.getType() === _event.EventType.Direct) {
        const lastContent = (prevEvent === null || prevEvent === void 0 ? void 0 : prevEvent.getContent()) ?? {};
        const content = ev.getContent();
        const diff = (0, _objects.objectDiff)(lastContent, content); // filter out keys which changed by reference only by checking whether the sets differ

        const changed = diff.changed.filter(k => (0, _arrays.arrayHasDiff)(lastContent[k], content[k])); // DM tag changes, refresh relevant rooms

        new Set([...diff.added, ...diff.removed, ...changed]).forEach(roomId => {
          var _this$matrixClient2;

          const room = (_this$matrixClient2 = this.matrixClient) === null || _this$matrixClient2 === void 0 ? void 0 : _this$matrixClient2.getRoom(roomId);

          if (room) {
            this.onRoomUpdate(room);
          }
        });
      }
    });
    (0, _defineProperty2.default)(this, "getSpaceTagOrdering", space => {
      var _space$getAccountData, _space$getAccountData2;

      if (this.spaceOrderLocalEchoMap.has(space.roomId)) return this.spaceOrderLocalEchoMap.get(space.roomId);
      return validOrder((_space$getAccountData = space.getAccountData(_event.EventType.SpaceOrder)) === null || _space$getAccountData === void 0 ? void 0 : (_space$getAccountData2 = _space$getAccountData.getContent()) === null || _space$getAccountData2 === void 0 ? void 0 : _space$getAccountData2.order);
    });

    _SettingsStore.default.monitorSetting("Spaces.allRoomsInHome", null);

    _SettingsStore.default.monitorSetting("Spaces.enabledMetaSpaces", null);
  }

  get invitedSpaces() {
    return Array.from(this._invitedSpaces);
  }

  get enabledMetaSpaces() {
    return this._enabledMetaSpaces;
  }

  get spacePanelSpaces() {
    return this.rootSpaces;
  }

  get activeSpace() {
    return this._activeSpace;
  }

  get activeSpaceRoom() {
    var _this$matrixClient3;

    if (this._activeSpace[0] !== "!") return null;
    return (_this$matrixClient3 = this.matrixClient) === null || _this$matrixClient3 === void 0 ? void 0 : _this$matrixClient3.getRoom(this._activeSpace);
  }

  get suggestedRooms() {
    return this._suggestedRooms;
  }

  get allRoomsInHome() {
    return this._allRoomsInHome;
  }

  setActiveRoomInSpace(space) {
    var _this$matrixClient4, _this$matrixClient4$g;

    if (space[0] === "!" && !((_this$matrixClient4 = this.matrixClient) !== null && _this$matrixClient4 !== void 0 && (_this$matrixClient4$g = _this$matrixClient4.getRoom(space)) !== null && _this$matrixClient4$g !== void 0 && _this$matrixClient4$g.isSpaceRoom())) return;
    if (space !== this.activeSpace) this.setActiveSpace(space);

    if (space) {
      const roomId = this.getNotificationState(space).getFirstRoomWithNotifications();

      _dispatcher.default.dispatch({
        action: "view_room",
        room_id: roomId,
        context_switch: true
      });
    } else {
      const lists = _RoomListStore.default.instance.unfilteredLists;

      for (let i = 0; i < _RoomList.TAG_ORDER.length; i++) {
        const t = _RoomList.TAG_ORDER[i];
        const listRooms = lists[t];
        const unreadRoom = listRooms.find(r => {
          if (this.showInHomeSpace(r)) {
            const state = _RoomNotificationStateStore.RoomNotificationStateStore.instance.getRoomState(r);

            return state.isUnread;
          }
        });

        if (unreadRoom) {
          _dispatcher.default.dispatch({
            action: "view_room",
            room_id: unreadRoom.roomId,
            context_switch: true
          });

          break;
        }
      }
    }
  }

  get restrictedJoinRuleSupport() {
    return this._restrictedJoinRuleSupport;
  }
  /**
   * Sets the active space, updates room list filters,
   * optionally switches the user's room back to where they were when they last viewed that space.
   * @param space which space to switch to.
   * @param contextSwitch whether to switch the user's context,
   * should not be done when the space switch is done implicitly due to another event like switching room.
   */


  setActiveSpace(space, contextSwitch = true) {
    if (!space || !this.matrixClient || space === this.activeSpace) return;
    let cliSpace;

    if (space[0] === "!") {
      var _cliSpace;

      cliSpace = this.matrixClient.getRoom(space);
      if (!((_cliSpace = cliSpace) !== null && _cliSpace !== void 0 && _cliSpace.isSpaceRoom())) return;
    } else if (!this.enabledMetaSpaces.includes(space)) {
      return;
    }

    this._activeSpace = space;
    this.emit(_.UPDATE_SELECTED_SPACE, this.activeSpace);
    this.emit(_.UPDATE_SUGGESTED_ROOMS, this._suggestedRooms = []);

    if (contextSwitch) {
      var _cliSpace2, _this$matrixClient$ge3;

      // view last selected room from space
      const roomId = window.localStorage.getItem(getSpaceContextKey(this.activeSpace)); // if the space being selected is an invite then always view that invite
      // else if the last viewed room in this space is joined then view that
      // else view space home or home depending on what is being clicked on

      if (((_cliSpace2 = cliSpace) === null || _cliSpace2 === void 0 ? void 0 : _cliSpace2.getMyMembership()) !== "invite" && ((_this$matrixClient$ge3 = this.matrixClient.getRoom(roomId)) === null || _this$matrixClient$ge3 === void 0 ? void 0 : _this$matrixClient$ge3.getMyMembership()) === "join" && this.getSpaceFilteredRoomIds(space).has(roomId)) {
        _dispatcher.default.dispatch({
          action: "view_room",
          room_id: roomId,
          context_switch: true
        });
      } else if (cliSpace) {
        _dispatcher.default.dispatch({
          action: "view_room",
          room_id: space,
          context_switch: true
        });
      } else {
        _dispatcher.default.dispatch({
          action: "view_home_page",
          context_switch: true
        });
      }
    } // persist space selected


    window.localStorage.setItem(ACTIVE_SPACE_LS_KEY, space);

    if (cliSpace) {
      this.loadSuggestedRooms(cliSpace);
    }
  }

  async loadSuggestedRooms(space) {
    const suggestedRooms = await this.fetchSuggestedRooms(space);

    if (this._activeSpace === space.roomId) {
      this._suggestedRooms = suggestedRooms;
      this.emit(_.UPDATE_SUGGESTED_ROOMS, this._suggestedRooms);
    }
  }

  addRoomToSpace(space, roomId, via, suggested = false, autoJoin = false) {
    return this.matrixClient.sendStateEvent(space.roomId, _event.EventType.SpaceChild, {
      via,
      suggested,
      auto_join: autoJoin
    }, roomId);
  }

  getChildren(spaceId) {
    var _this$matrixClient5;

    const room = (_this$matrixClient5 = this.matrixClient) === null || _this$matrixClient5 === void 0 ? void 0 : _this$matrixClient5.getRoom(spaceId);
    const childEvents = room === null || room === void 0 ? void 0 : room.currentState.getStateEvents(_event.EventType.SpaceChild).filter(ev => {
      var _ev$getContent3;

      return (_ev$getContent3 = ev.getContent()) === null || _ev$getContent3 === void 0 ? void 0 : _ev$getContent3.via;
    });
    return (0, _lodash.sortBy)(childEvents, ev => {
      var _this$matrixClient6, _childRoom$currentSta;

      const roomId = ev.getStateKey();
      const childRoom = (_this$matrixClient6 = this.matrixClient) === null || _this$matrixClient6 === void 0 ? void 0 : _this$matrixClient6.getRoom(roomId);
      const createTs = childRoom === null || childRoom === void 0 ? void 0 : (_childRoom$currentSta = childRoom.currentState.getStateEvents(_event.EventType.RoomCreate, "")) === null || _childRoom$currentSta === void 0 ? void 0 : _childRoom$currentSta.getTs();
      return getChildOrder(ev.getContent().order, createTs, roomId);
    }).map(ev => {
      const history = this.matrixClient.getRoomUpgradeHistory(ev.getStateKey(), true);
      return history[history.length - 1];
    }).filter(room => {
      return (room === null || room === void 0 ? void 0 : room.getMyMembership()) === "join" || (room === null || room === void 0 ? void 0 : room.getMyMembership()) === "invite";
    }) || [];
  }

  getChildRooms(spaceId) {
    return this.getChildren(spaceId).filter(r => !r.isSpaceRoom());
  }

  getChildSpaces(spaceId) {
    // don't show invited subspaces as they surface at the top level for better visibility
    return this.getChildren(spaceId).filter(r => r.isSpaceRoom() && r.getMyMembership() === "join");
  }

  getParents(roomId, canonicalOnly = false) {
    var _this$matrixClient7, _this$matrixClient8;

    const userId = (_this$matrixClient7 = this.matrixClient) === null || _this$matrixClient7 === void 0 ? void 0 : _this$matrixClient7.getUserId();
    const room = (_this$matrixClient8 = this.matrixClient) === null || _this$matrixClient8 === void 0 ? void 0 : _this$matrixClient8.getRoom(roomId);
    return (room === null || room === void 0 ? void 0 : room.currentState.getStateEvents(_event.EventType.SpaceParent).map(ev => {
      const content = ev.getContent();

      if (!Array.isArray(content.via) || canonicalOnly && !content.canonical) {
        return; // skip
      } // only respect the relationship if the sender has sufficient permissions in the parent to set
      // child relations, as per MSC1772.
      // https://github.com/matrix-org/matrix-doc/blob/main/proposals/1772-groups-as-rooms.md#relationship-between-rooms-and-spaces


      const parent = this.matrixClient.getRoom(ev.getStateKey());
      const relation = parent === null || parent === void 0 ? void 0 : parent.currentState.getStateEvents(_event.EventType.SpaceChild, roomId);

      if (!(parent !== null && parent !== void 0 && parent.currentState.maySendStateEvent(_event.EventType.SpaceChild, userId)) || // also skip this relation if the parent had this child added but then since removed it
      relation && !Array.isArray(relation.getContent().via)) {
        return; // skip
      }

      return parent;
    }).filter(Boolean)) || [];
  }

  getCanonicalParent(roomId) {
    var _sortBy;

    const parents = this.getParents(roomId, true);
    return ((_sortBy = (0, _lodash.sortBy)(parents, r => r.roomId)) === null || _sortBy === void 0 ? void 0 : _sortBy[0]) || null;
  }

  getKnownParents(roomId) {
    return this.parentMap.get(roomId) || new Set();
  }

  notifyIfOrderChanged() {
    const rootSpaces = this.sortRootSpaces(this.rootSpaces);

    if ((0, _arrays.arrayHasOrderChange)(this.rootSpaces, rootSpaces)) {
      this.rootSpaces = rootSpaces;
      this.emit(_.UPDATE_TOP_LEVEL_SPACES, this.spacePanelSpaces, this.enabledMetaSpaces);
    }
  }

  async reset() {
    this.rootSpaces = [];
    this.orphanedRooms = new Set();
    this.parentMap = new _maps.EnhancedMap();
    this.notificationStateMap = new Map();
    this.spaceFilteredRooms = new Map();
    this._activeSpace = _.MetaSpace.Home; // set properly by onReady

    this._suggestedRooms = [];
    this._invitedSpaces = new Set();
    this._enabledMetaSpaces = [];
  }

  async onNotReady() {
    if (!SpaceStore.spacesEnabled) return;

    if (this.matrixClient) {
      this.matrixClient.removeListener("Room", this.onRoom);
      this.matrixClient.removeListener("Room.myMembership", this.onRoom);
      this.matrixClient.removeListener("Room.accountData", this.onRoomAccountData);
      this.matrixClient.removeListener("RoomState.events", this.onRoomState);
      this.matrixClient.removeListener("RoomState.members", this.onRoomStateMembers);
      this.matrixClient.removeListener("accountData", this.onAccountData);
    }

    await this.reset();
  }

  async onReady() {
    if (!spacesEnabled) return;
    this.matrixClient.on("Room", this.onRoom);
    this.matrixClient.on("Room.myMembership", this.onRoom);
    this.matrixClient.on("Room.accountData", this.onRoomAccountData);
    this.matrixClient.on("RoomState.events", this.onRoomState);
    this.matrixClient.on("RoomState.members", this.onRoomStateMembers);
    this.matrixClient.on("accountData", this.onAccountData);
    this.matrixClient.getCapabilities().then(capabilities => {
      var _capabilities$mRoom_, _capabilities$mRoom_$;

      this._restrictedJoinRuleSupport = capabilities === null || capabilities === void 0 ? void 0 : (_capabilities$mRoom_ = capabilities["m.room_versions"]) === null || _capabilities$mRoom_ === void 0 ? void 0 : (_capabilities$mRoom_$ = _capabilities$mRoom_["org.matrix.msc3244.room_capabilities"]) === null || _capabilities$mRoom_$ === void 0 ? void 0 : _capabilities$mRoom_$["restricted"];
    });

    const enabledMetaSpaces = _SettingsStore.default.getValue("Spaces.enabledMetaSpaces");

    this._enabledMetaSpaces = metaSpaceOrder.filter(k => enabledMetaSpaces[k]);
    await this.onSpaceUpdate(); // trigger an initial update
    // restore selected state from last session if any and still valid

    const lastSpaceId = window.localStorage.getItem(ACTIVE_SPACE_LS_KEY);

    if (lastSpaceId && (lastSpaceId[0] === "!" ? this.matrixClient.getRoom(lastSpaceId) : enabledMetaSpaces[lastSpaceId])) {
      // don't context switch here as it may break permalinks
      this.setActiveSpace(lastSpaceId, false);
    } else {
      this.goToFirstSpace();
    }
  }

  goToFirstSpace(contextSwitch = false) {
    var _this$spacePanelSpace;

    this.setActiveSpace(this.enabledMetaSpaces[0] ?? ((_this$spacePanelSpace = this.spacePanelSpaces[0]) === null || _this$spacePanelSpace === void 0 ? void 0 : _this$spacePanelSpace.roomId), contextSwitch);
  }

  async onAction(payload) {
    if (!spacesEnabled) return;

    switch (payload.action) {
      case "view_room":
        {
          var _this$matrixClient9;

          // Don't auto-switch rooms when reacting to a context-switch
          // as this is not helpful and can create loops of rooms/space switching
          if (payload.context_switch) break;
          const roomId = payload.room_id;
          const room = (_this$matrixClient9 = this.matrixClient) === null || _this$matrixClient9 === void 0 ? void 0 : _this$matrixClient9.getRoom(roomId);

          if (room !== null && room !== void 0 && room.isSpaceRoom()) {
            // Don't context switch when navigating to the space room
            // as it will cause you to end up in the wrong room
            this.setActiveSpace(room.roomId, false);
          } else if ((!this.allRoomsInHome || this.activeSpace[0] === "!") && !this.getSpaceFilteredRoomIds(this.activeSpace).has(roomId)) {
            this.switchToRelatedSpace(roomId);
          } // Persist last viewed room from a space
          // we don't await setActiveSpace above as we only care about this.activeSpace being up to date
          // synchronously for the below code - everything else can and should be async.


          window.localStorage.setItem(getSpaceContextKey(this.activeSpace), payload.room_id);
          break;
        }

      case "view_home_page":
        if (!payload.context_switch && this.enabledMetaSpaces.includes(_.MetaSpace.Home)) {
          this.setActiveSpace(_.MetaSpace.Home, false);
          window.localStorage.setItem(getSpaceContextKey(this.activeSpace), "");
        }

        break;

      case "after_leave_room":
        if (this._activeSpace[0] === "!" && payload.room_id === this._activeSpace) {
          // User has left the current space, go to first space
          this.goToFirstSpace();
        }

        break;

      case _actions.Action.SwitchSpace:
        {
          // Metaspaces start at 1, Spaces follow
          if (payload.num < 1 || payload.num > 9) break;
          const numMetaSpaces = this.enabledMetaSpaces.length;

          if (payload.num <= numMetaSpaces) {
            this.setActiveSpace(this.enabledMetaSpaces[payload.num - 1]);
          } else if (this.spacePanelSpaces.length > payload.num - numMetaSpaces - 1) {
            this.setActiveSpace(this.spacePanelSpaces[payload.num - numMetaSpaces - 1].roomId);
          }

          break;
        }

      case _actions.Action.SettingUpdated:
        {
          const settingUpdatedPayload = payload;

          switch (settingUpdatedPayload.settingName) {
            case "Spaces.allRoomsInHome":
              {
                const newValue = _SettingsStore.default.getValue("Spaces.allRoomsInHome");

                if (this.allRoomsInHome !== newValue) {
                  this._allRoomsInHome = newValue;
                  this.emit(_.UPDATE_HOME_BEHAVIOUR, this.allRoomsInHome);
                  this.rebuild(); // rebuild everything
                }

                break;
              }

            case "Spaces.enabledMetaSpaces":
              {
                const newValue = _SettingsStore.default.getValue("Spaces.enabledMetaSpaces");

                const enabledMetaSpaces = metaSpaceOrder.filter(k => newValue[k]);

                if ((0, _arrays.arrayHasDiff)(this._enabledMetaSpaces, enabledMetaSpaces)) {
                  this._enabledMetaSpaces = enabledMetaSpaces; // if a metaspace currently being viewed was remove, go to another one

                  if (this.activeSpace[0] !== "!" && !enabledMetaSpaces.includes(this.activeSpace)) {
                    this.goToFirstSpace();
                  }

                  this.emit(_.UPDATE_TOP_LEVEL_SPACES, this.spacePanelSpaces, this.enabledMetaSpaces);
                  this.rebuild(); // rebuild everything
                }

                break;
              }
          }
        }
    }
  }

  getNotificationState(key) {
    if (this.notificationStateMap.has(key)) {
      return this.notificationStateMap.get(key);
    }

    const state = new _SpaceNotificationState.SpaceNotificationState(key, getRoomFn);
    this.notificationStateMap.set(key, state);
    return state;
  } // traverse space tree with DFS calling fn on each space including the given root one,
  // if includeRooms is true then fn will be called on each leaf room, if it is present in multiple sub-spaces
  // then fn will be called with it multiple times.


  traverseSpace(spaceId, fn, includeRooms = false, parentPath) {
    if (parentPath && parentPath.has(spaceId)) return; // prevent cycles

    fn(spaceId);
    const newPath = new Set(parentPath).add(spaceId);
    const [childSpaces, childRooms] = partitionSpacesAndRooms(this.getChildren(spaceId));

    if (includeRooms) {
      childRooms.forEach(r => fn(r.roomId));
    }

    childSpaces.forEach(s => this.traverseSpace(s.roomId, fn, includeRooms, newPath));
  }

  sortRootSpaces(spaces) {
    return (0, _lodash.sortBy)(spaces, [this.getSpaceTagOrdering, "roomId"]);
  }

  async setRootSpaceOrder(space, order) {
    this.spaceOrderLocalEchoMap.set(space.roomId, order);

    try {
      await this.matrixClient.setRoomAccountData(space.roomId, _event.EventType.SpaceOrder, {
        order
      });
    } catch (e) {
      _logger.logger.warn("Failed to set root space order", e);

      if (this.spaceOrderLocalEchoMap.get(space.roomId) === order) {
        this.spaceOrderLocalEchoMap.delete(space.roomId);
      }
    }
  }

  moveRootSpace(fromIndex, toIndex) {
    const currentOrders = this.rootSpaces.map(this.getSpaceTagOrdering);
    const changes = (0, _stringOrderField.reorderLexicographically)(currentOrders, fromIndex, toIndex);
    changes.forEach(({
      index,
      order
    }) => {
      this.setRootSpaceOrder(this.rootSpaces[index], order);
    });
    this.notifyIfOrderChanged();
  }

}

exports.SpaceStoreClass = SpaceStoreClass;

class SpaceStore {
  static get instance() {
    return SpaceStore.internalInstance;
  }

}

exports.default = SpaceStore;
(0, _defineProperty2.default)(SpaceStore, "spacesEnabled", spacesEnabled);
(0, _defineProperty2.default)(SpaceStore, "internalInstance", new SpaceStoreClass());
window.mxSpaceStore = SpaceStore.instance;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zdG9yZXMvc3BhY2VzL1NwYWNlU3RvcmUudHMiXSwibmFtZXMiOlsiQUNUSVZFX1NQQUNFX0xTX0tFWSIsIm1ldGFTcGFjZU9yZGVyIiwiTWV0YVNwYWNlIiwiSG9tZSIsIkZhdm91cml0ZXMiLCJQZW9wbGUiLCJPcnBoYW5zIiwiTUFYX1NVR0dFU1RFRF9ST09NUyIsInNwYWNlc0VuYWJsZWQiLCJTZXR0aW5nc1N0b3JlIiwiZ2V0VmFsdWUiLCJnZXRTcGFjZUNvbnRleHRLZXkiLCJzcGFjZSIsInBhcnRpdGlvblNwYWNlc0FuZFJvb21zIiwiYXJyIiwicmVkdWNlIiwicmVzdWx0Iiwicm9vbSIsImlzU3BhY2VSb29tIiwicHVzaCIsInZhbGlkT3JkZXIiLCJvcmRlciIsImxlbmd0aCIsIkFycmF5IiwiZnJvbSIsImV2ZXJ5IiwiYyIsImNoYXJDb2RlIiwiY2hhckNvZGVBdCIsImdldENoaWxkT3JkZXIiLCJjcmVhdGlvblRzIiwicm9vbUlkIiwiTmFOIiwiZ2V0Um9vbUZuIiwiUm9vbU5vdGlmaWNhdGlvblN0YXRlU3RvcmUiLCJpbnN0YW5jZSIsImdldFJvb21TdGF0ZSIsIlNwYWNlU3RvcmVDbGFzcyIsIkFzeW5jU3RvcmVXaXRoQ2xpZW50IiwiY29uc3RydWN0b3IiLCJkZWZhdWx0RGlzcGF0Y2hlciIsIlNldCIsIkVuaGFuY2VkTWFwIiwiTWFwIiwibGltaXQiLCJyb29tcyIsIm1hdHJpeENsaWVudCIsImdldFJvb21IaWVyYXJjaHkiLCJ2aWFNYXAiLCJmb3JFYWNoIiwiY2hpbGRyZW5fc3RhdGUiLCJldiIsInR5cGUiLCJFdmVudFR5cGUiLCJTcGFjZUNoaWxkIiwiY29udGVudCIsInZpYSIsImdldE9yQ3JlYXRlIiwic3RhdGVfa2V5IiwiYWRkIiwiZmlsdGVyIiwicm9vbUluZm8iLCJyb29tX3R5cGUiLCJSb29tVHlwZSIsIlNwYWNlIiwiZ2V0Um9vbSIsInJvb21faWQiLCJnZXRNeU1lbWJlcnNoaXAiLCJtYXAiLCJ2aWFTZXJ2ZXJzIiwiZ2V0IiwiZSIsImxvZ2dlciIsImVycm9yIiwiYWxsUm9vbXNJbkhvbWUiLCJnZXRWaXNpYmxlUm9vbXMiLCJyIiwic3BhY2VGaWx0ZXJlZFJvb21zIiwidmlzaWJsZVNwYWNlcyIsInZpc2libGVSb29tcyIsImpvaW5lZFNwYWNlcyIsImludml0ZWRTcGFjZXMiLCJzIiwidW5zZWVuQ2hpbGRyZW4iLCJiYWNrcmVmcyIsInNwYWNlcyIsImNoaWxkcmVuIiwiZ2V0Q2hpbGRyZW4iLCJjaGlsZCIsImRlbGV0ZSIsInJvb3RTcGFjZXMiLCJvcnBoYW5lZFJvb21zIiwiZGV0YWNoZWROb2RlcyIsIm1hcmtUcmVlQ2hpbGRyZW4iLCJyb290U3BhY2UiLCJ1bnNlZW4iLCJzdGFjayIsIm9wIiwicG9wIiwiZ2V0Q2hpbGRTcGFjZXMiLCJoYXMiLCJkZXRhY2hlZE5vZGUiLCJzb3J0Um9vdFNwYWNlcyIsInBhcmVudE1hcCIsIl9hY3RpdmVTcGFjZSIsImdvVG9GaXJzdFNwYWNlIiwib25Sb29tc1VwZGF0ZSIsImVtaXQiLCJVUERBVEVfVE9QX0xFVkVMX1NQQUNFUyIsInNwYWNlUGFuZWxTcGFjZXMiLCJlbmFibGVkTWV0YVNwYWNlcyIsIl9pbnZpdGVkU3BhY2VzIiwiVVBEQVRFX0lOVklURURfU1BBQ0VTIiwidHJhaWxpbmciLCJsZWFkaW5nIiwicmVidWlsZCIsInNpemUiLCJETVJvb21NYXAiLCJzaGFyZWQiLCJnZXRVc2VySWRGb3JSb29tSWQiLCJzaG93SW5Ib21lU3BhY2UiLCJnZXRETVJvb21zRm9yVXNlcklkIiwiZ2V0U3RhdGVLZXkiLCJvbGRGaWx0ZXJlZFJvb21zIiwiaW52aXRlcyIsInNldCIsImZhdm91cml0ZXMiLCJ0YWdzIiwiRGVmYXVsdFRhZ0lEIiwiRmF2b3VyaXRlIiwicGVvcGxlIiwib3JwaGFucyIsImhpZGRlbkNoaWxkcmVuIiwiZ2V0UGFyZW50cyIsInBhcmVudCIsImZuIiwic3BhY2VJZCIsInBhcmVudFBhdGgiLCJjaGlsZFNwYWNlcyIsImNoaWxkUm9vbXMiLCJyb29tSWRzIiwiZ2V0TWVtYmVycyIsIm1lbWJlciIsIm1lbWJlcnNoaXAiLCJ1c2VySWQiLCJuZXdQYXRoIiwiY2hpbGRTcGFjZSIsImV4cGFuZGVkUm9vbUlkcyIsImZsYXRNYXAiLCJnZXRSb29tVXBncmFkZUhpc3RvcnkiLCJkaWZmIiwiY2hhbmdlZCIsImsiLCJhZGRlZCIsInJlbW92ZWQiLCJkbUJhZGdlU3BhY2UiLCJnZXROb3RpZmljYXRpb25TdGF0ZSIsInNldFJvb21zIiwic3VnZ2VzdGVkUm9vbXMiLCJmaW5kIiwiZ2V0Q2Fub25pY2FsUGFyZW50IiwicGFyZW50SWRzIiwicGFyZW50SWQiLCJzZXRBY3RpdmVTcGFjZSIsIm5ld01lbWJlcnNoaXAiLCJvbGRNZW1iZXJzaGlwIiwicm9vbU1lbWJlcnNoaXAiLCJudW1TdWdnZXN0ZWRSb29tcyIsIl9zdWdnZXN0ZWRSb29tcyIsIlVQREFURV9TVUdHRVNURURfUk9PTVMiLCJSb29tVmlld1N0b3JlIiwiZ2V0Um9vbUlkIiwic3dpdGNoVG9SZWxhdGVkU3BhY2UiLCJvblNwYWNlVXBkYXRlIiwiYWN0aXZlU3BhY2UiLCJnZXRUeXBlIiwiZ2V0UHJldkNvbnRlbnQiLCJzdWdnZXN0ZWQiLCJnZXRDb250ZW50IiwibG9hZFN1Z2dlc3RlZFJvb21zIiwiU3BhY2VQYXJlbnQiLCJvblJvb21VcGRhdGUiLCJSb29tUG93ZXJMZXZlbHMiLCJvblNwYWNlTWVtYmVyc0NoYW5nZSIsImxhc3RFdiIsIlNwYWNlT3JkZXIiLCJzcGFjZU9yZGVyTG9jYWxFY2hvTWFwIiwibGFzdE9yZGVyIiwibm90aWZ5SWZPcmRlckNoYW5nZWQiLCJUYWciLCJvbGRUYWdzIiwibmV3VGFncyIsInByZXZFdmVudCIsIkRpcmVjdCIsImxhc3RDb250ZW50IiwiZ2V0QWNjb3VudERhdGEiLCJtb25pdG9yU2V0dGluZyIsIl9lbmFibGVkTWV0YVNwYWNlcyIsImFjdGl2ZVNwYWNlUm9vbSIsIl9hbGxSb29tc0luSG9tZSIsInNldEFjdGl2ZVJvb21JblNwYWNlIiwiZ2V0Rmlyc3RSb29tV2l0aE5vdGlmaWNhdGlvbnMiLCJkaXNwYXRjaCIsImFjdGlvbiIsImNvbnRleHRfc3dpdGNoIiwibGlzdHMiLCJSb29tTGlzdFN0b3JlIiwidW5maWx0ZXJlZExpc3RzIiwiaSIsIlRBR19PUkRFUiIsInQiLCJsaXN0Um9vbXMiLCJ1bnJlYWRSb29tIiwic3RhdGUiLCJpc1VucmVhZCIsInJlc3RyaWN0ZWRKb2luUnVsZVN1cHBvcnQiLCJfcmVzdHJpY3RlZEpvaW5SdWxlU3VwcG9ydCIsImNvbnRleHRTd2l0Y2giLCJjbGlTcGFjZSIsImluY2x1ZGVzIiwiVVBEQVRFX1NFTEVDVEVEX1NQQUNFIiwid2luZG93IiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImdldFNwYWNlRmlsdGVyZWRSb29tSWRzIiwic2V0SXRlbSIsImZldGNoU3VnZ2VzdGVkUm9vbXMiLCJhZGRSb29tVG9TcGFjZSIsImF1dG9Kb2luIiwic2VuZFN0YXRlRXZlbnQiLCJhdXRvX2pvaW4iLCJjaGlsZEV2ZW50cyIsImN1cnJlbnRTdGF0ZSIsImdldFN0YXRlRXZlbnRzIiwiY2hpbGRSb29tIiwiY3JlYXRlVHMiLCJSb29tQ3JlYXRlIiwiZ2V0VHMiLCJoaXN0b3J5IiwiZ2V0Q2hpbGRSb29tcyIsImNhbm9uaWNhbE9ubHkiLCJnZXRVc2VySWQiLCJpc0FycmF5IiwiY2Fub25pY2FsIiwicmVsYXRpb24iLCJtYXlTZW5kU3RhdGVFdmVudCIsIkJvb2xlYW4iLCJwYXJlbnRzIiwiZ2V0S25vd25QYXJlbnRzIiwicmVzZXQiLCJub3RpZmljYXRpb25TdGF0ZU1hcCIsIm9uTm90UmVhZHkiLCJTcGFjZVN0b3JlIiwicmVtb3ZlTGlzdGVuZXIiLCJvblJvb20iLCJvblJvb21BY2NvdW50RGF0YSIsIm9uUm9vbVN0YXRlIiwib25Sb29tU3RhdGVNZW1iZXJzIiwib25BY2NvdW50RGF0YSIsIm9uUmVhZHkiLCJvbiIsImdldENhcGFiaWxpdGllcyIsInRoZW4iLCJjYXBhYmlsaXRpZXMiLCJsYXN0U3BhY2VJZCIsIm9uQWN0aW9uIiwicGF5bG9hZCIsIkFjdGlvbiIsIlN3aXRjaFNwYWNlIiwibnVtIiwibnVtTWV0YVNwYWNlcyIsIlNldHRpbmdVcGRhdGVkIiwic2V0dGluZ1VwZGF0ZWRQYXlsb2FkIiwic2V0dGluZ05hbWUiLCJuZXdWYWx1ZSIsIlVQREFURV9IT01FX0JFSEFWSU9VUiIsImtleSIsIlNwYWNlTm90aWZpY2F0aW9uU3RhdGUiLCJ0cmF2ZXJzZVNwYWNlIiwiaW5jbHVkZVJvb21zIiwiZ2V0U3BhY2VUYWdPcmRlcmluZyIsInNldFJvb3RTcGFjZU9yZGVyIiwic2V0Um9vbUFjY291bnREYXRhIiwid2FybiIsIm1vdmVSb290U3BhY2UiLCJmcm9tSW5kZXgiLCJ0b0luZGV4IiwiY3VycmVudE9yZGVycyIsImNoYW5nZXMiLCJpbmRleCIsImludGVybmFsSW5zdGFuY2UiLCJteFNwYWNlU3RvcmUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBZ0JBOztBQUNBOztBQUlBOztBQUVBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOzs7Ozs7QUFhQSxNQUFNQSxtQkFBbUIsR0FBRyxpQkFBNUI7QUFFQSxNQUFNQyxjQUEyQixHQUFHLENBQUNDLFlBQVVDLElBQVgsRUFBaUJELFlBQVVFLFVBQTNCLEVBQXVDRixZQUFVRyxNQUFqRCxFQUF5REgsWUFBVUksT0FBbkUsQ0FBcEM7QUFFQSxNQUFNQyxtQkFBbUIsR0FBRyxFQUE1QixDLENBRUE7O0FBQ0EsTUFBTUMsYUFBYSxHQUFHLENBQUNDLHVCQUFjQyxRQUFkLENBQXVCLGdDQUF2QixDQUF2Qjs7QUFFQSxNQUFNQyxrQkFBa0IsR0FBSUMsS0FBRCxJQUFzQixvQkFBbUJBLEtBQU0sRUFBMUU7O0FBRUEsTUFBTUMsdUJBQXVCLEdBQUlDLEdBQUQsSUFBbUM7QUFBRTtBQUNqRSxTQUFPQSxHQUFHLENBQUNDLE1BQUosQ0FBVyxD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QUFLb04sbUJBQXpCLENBQXRCO0FBQ0EsVUFBTVEsT0FBTyxHQUFHLGdEQUF5QkQsYUFBekIsRUFBd0NGLFNBQXhDLEVBQW1EQyxPQUFuRCxDQUFoQjtBQUVBRSxJQUFBQSxPQUFPLENBQUMvTyxPQUFSLENBQWdCLENBQUM7QUFBRWdQLE1BQUFBLEtBQUY7QUFBUzVRLE1BQUFBO0FBQVQsS0FBRCxLQUFzQjtBQUNsQyxXQUFLb1EsaUJBQUwsQ0FBdUIsS0FBSy9MLFVBQUwsQ0FBZ0J1TSxLQUFoQixDQUF2QixFQUErQzVRLEtBQS9DO0FBQ0gsS0FGRDtBQUlBLFNBQUt1SyxvQkFBTDtBQUNIOztBQXgzQjZEOzs7O0FBMjNCbkQsTUFBTWdFLFVBQU4sQ0FBaUI7QUFLRixhQUFSek4sUUFBUSxHQUFvQjtBQUMxQyxXQUFPeU4sVUFBVSxDQUFDc0MsZ0JBQWxCO0FBQ0g7O0FBUDJCOzs7OEJBQVh0QyxVLG1CQUNhcFAsYTs4QkFEYm9QLFUsc0JBR2lCLElBQUl2TixlQUFKLEU7QUFPdEN3TCxNQUFNLENBQUNzRSxZQUFQLEdBQXNCdkMsVUFBVSxDQUFDek4sUUFBakMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMjEgVGhlIE1hdHJpeC5vcmcgRm91bmRhdGlvbiBDLkkuQy5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgeyBMaXN0SXRlcmF0ZWUsIE1hbnksIHNvcnRCeSwgdGhyb3R0bGUgfSBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgeyBFdmVudFR5cGUsIFJvb21UeXBlIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL0B0eXBlcy9ldmVudFwiO1xuaW1wb3J0IHsgUm9vbSB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9tb2RlbHMvcm9vbVwiO1xuaW1wb3J0IHsgTWF0cml4RXZlbnQgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvbW9kZWxzL2V2ZW50XCI7XG5pbXBvcnQgeyBJUm9vbUNhcGFiaWxpdHkgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvY2xpZW50XCI7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvbG9nZ2VyXCI7XG5cbmltcG9ydCB7IEFzeW5jU3RvcmVXaXRoQ2xpZW50IH0gZnJvbSBcIi4uL0FzeW5jU3RvcmVXaXRoQ2xpZW50XCI7XG5pbXBvcnQgZGVmYXVsdERpc3BhdGNoZXIgZnJvbSBcIi4uLy4uL2Rpc3BhdGNoZXIvZGlzcGF0Y2hlclwiO1xuaW1wb3J0IHsgQWN0aW9uUGF5bG9hZCB9IGZyb20gXCIuLi8uLi9kaXNwYXRjaGVyL3BheWxvYWRzXCI7XG5pbXBvcnQgUm9vbUxpc3RTdG9yZSBmcm9tIFwiLi4vcm9vbS1saXN0L1Jvb21MaXN0U3RvcmVcIjtcbmltcG9ydCBTZXR0aW5nc1N0b3JlIGZyb20gXCIuLi8uLi9zZXR0aW5ncy9TZXR0aW5nc1N0b3JlXCI7XG5pbXBvcnQgRE1Sb29tTWFwIGZyb20gXCIuLi8uLi91dGlscy9ETVJvb21NYXBcIjtcbmltcG9ydCB7IEZldGNoUm9vbUZuIH0gZnJvbSBcIi4uL25vdGlmaWNhdGlvbnMvTGlzdE5vdGlmaWNhdGlvblN0YXRlXCI7XG5pbXBvcnQgeyBTcGFjZU5vdGlmaWNhdGlvblN0YXRlIH0gZnJvbSBcIi4uL25vdGlmaWNhdGlvbnMvU3BhY2VOb3RpZmljYXRpb25TdGF0ZVwiO1xuaW1wb3J0IHsgUm9vbU5vdGlmaWNhdGlvblN0YXRlU3RvcmUgfSBmcm9tIFwiLi4vbm90aWZpY2F0aW9ucy9Sb29tTm90aWZpY2F0aW9uU3RhdGVTdG9yZVwiO1xuaW1wb3J0IHsgRGVmYXVsdFRhZ0lEIH0gZnJvbSBcIi4uL3Jvb20tbGlzdC9tb2RlbHNcIjtcbmltcG9ydCB7IEVuaGFuY2VkTWFwLCBtYXBEaWZmIH0gZnJvbSBcIi4uLy4uL3V0aWxzL21hcHNcIjtcbmltcG9ydCB7IHNldEhhc0RpZmYgfSBmcm9tIFwiLi4vLi4vdXRpbHMvc2V0c1wiO1xuaW1wb3J0IFJvb21WaWV3U3RvcmUgZnJvbSBcIi4uL1Jvb21WaWV3U3RvcmVcIjtcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gXCIuLi8uLi9kaXNwYXRjaGVyL2FjdGlvbnNcIjtcbmltcG9ydCB7IGFycmF5SGFzRGlmZiwgYXJyYXlIYXNPcmRlckNoYW5nZSB9IGZyb20gXCIuLi8uLi91dGlscy9hcnJheXNcIjtcbmltcG9ydCB7IG9iamVjdERpZmYgfSBmcm9tIFwiLi4vLi4vdXRpbHMvb2JqZWN0c1wiO1xuaW1wb3J0IHsgcmVvcmRlckxleGljb2dyYXBoaWNhbGx5IH0gZnJvbSBcIi4uLy4uL3V0aWxzL3N0cmluZ09yZGVyRmllbGRcIjtcbmltcG9ydCB7IFRBR19PUkRFUiB9IGZyb20gXCIuLi8uLi9jb21wb25lbnRzL3ZpZXdzL3Jvb21zL1Jvb21MaXN0XCI7XG5pbXBvcnQgeyBTZXR0aW5nVXBkYXRlZFBheWxvYWQgfSBmcm9tIFwiLi4vLi4vZGlzcGF0Y2hlci9wYXlsb2Fkcy9TZXR0aW5nVXBkYXRlZFBheWxvYWRcIjtcbmltcG9ydCB7XG4gICAgSVN1Z2dlc3RlZFJvb20sXG4gICAgTWV0YVNwYWNlLFxuICAgIFNwYWNlS2V5LFxuICAgIFVQREFURV9IT01FX0JFSEFWSU9VUixcbiAgICBVUERBVEVfSU5WSVRFRF9TUEFDRVMsXG4gICAgVVBEQVRFX1NFTEVDVEVEX1NQQUNFLFxuICAgIFVQREFURV9TVUdHRVNURURfUk9PTVMsXG4gICAgVVBEQVRFX1RPUF9MRVZFTF9TUEFDRVMsXG59IGZyb20gXCIuXCI7XG5cbmludGVyZmFjZSBJU3RhdGUge31cblxuY29uc3QgQUNUSVZFX1NQQUNFX0xTX0tFWSA9IFwibXhfYWN0aXZlX3NwYWNlXCI7XG5cbmNvbnN0IG1ldGFTcGFjZU9yZGVyOiBNZXRhU3BhY2VbXSA9IFtNZXRhU3BhY2UuSG9tZSwgTWV0YVNwYWNlLkZhdm91cml0ZXMsIE1ldGFTcGFjZS5QZW9wbGUsIE1ldGFTcGFjZS5PcnBoYW5zXTtcblxuY29uc3QgTUFYX1NVR0dFU1RFRF9ST09NUyA9IDIwO1xuXG4vLyBUaGlzIHNldHRpbmcgY2F1c2VzIHRoZSBwYWdlIHRvIHJlbG9hZCBhbmQgY2FuIGJlIGNvc3RseSBpZiByZWFkIGZyZXF1ZW50bHksIHNvIHJlYWQgaXQgaGVyZSBvbmx5XG5jb25zdCBzcGFjZXNFbmFibGVkID0gIVNldHRpbmdzU3RvcmUuZ2V0VmFsdWUoXCJzaG93Q29tbXVuaXRpZXNJbnN0ZWFkT2ZTcGFjZXNcIik7XG5cbmNvbnN0IGdldFNwYWNlQ29udGV4dEtleSA9IChzcGFjZTogU3BhY2VLZXkpID0+IGBteF9zcGFjZV9jb250ZXh0XyR7c3BhY2V9YDtcblxuY29uc3QgcGFydGl0aW9uU3BhY2VzQW5kUm9vbXMgPSAoYXJyOiBSb29tW10pOiBbUm9vbVtdLCBSb29tW11dID0+IHsgLy8gW3NwYWNlcywgcm9vbXNdXG4gICAgcmV0dXJuIGFyci5yZWR1Y2UoKHJlc3VsdCwgcm9vbTogUm9vbSkgPT4ge1xuICAgICAgICByZXN1bHRbcm9vbS5pc1NwYWNlUm9vbSgpID8gMCA6IDFdLnB1c2gocm9vbSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW1tdLCBbXV0pO1xufTtcblxuY29uc3QgdmFsaWRPcmRlciA9IChvcmRlcjogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAodHlwZW9mIG9yZGVyID09PSBcInN0cmluZ1wiICYmIG9yZGVyLmxlbmd0aCA8PSA1MCAmJiBBcnJheS5mcm9tKG9yZGVyKS5ldmVyeSgoYzogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoYXJDb2RlID0gYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICByZXR1cm4gY2hhckNvZGUgPj0gMHgyMCAmJiBjaGFyQ29kZSA8PSAweDdFO1xuICAgIH0pKSB7XG4gICAgICAgIHJldHVybiBvcmRlcjtcbiAgICB9XG59O1xuXG4vLyBGb3Igc29ydGluZyBzcGFjZSBjaGlsZHJlbiB1c2luZyBhIHZhbGlkYXRlZCBgb3JkZXJgLCBgbS5yb29tLmNyZWF0ZWAncyBgb3JpZ2luX3NlcnZlcl90c2AsIGByb29tX2lkYFxuZXhwb3J0IGNvbnN0IGdldENoaWxkT3JkZXIgPSAob3JkZXI6IHN0cmluZywgY3JlYXRpb25UczogbnVtYmVyLCByb29tSWQ6IHN0cmluZyk6IEFycmF5PE1hbnk8TGlzdEl0ZXJhdGVlPGFueT4+PiA9PiB7XG4gICAgcmV0dXJuIFt2YWxpZE9yZGVyKG9yZGVyKSA/PyBOYU4sIGNyZWF0aW9uVHMsIHJvb21JZF07IC8vIE5hTiBoYXMgbG9kYXNoIHNvcnQgaXQgYXQgdGhlIGVuZCBpbiBhc2Ncbn07XG5cbmNvbnN0IGdldFJvb21GbjogRmV0Y2hSb29tRm4gPSAocm9vbTogUm9vbSkgPT4ge1xuICAgIHJldHVybiBSb29tTm90aWZpY2F0aW9uU3RhdGVTdG9yZS5pbnN0YW5jZS5nZXRSb29tU3RhdGUocm9vbSk7XG59O1xuXG5leHBvcnQgY2xhc3MgU3BhY2VTdG9yZUNsYXNzIGV4dGVuZHMgQXN5bmNTdG9yZVdpdGhDbGllbnQ8SVN0YXRlPiB7XG4gICAgLy8gVGhlIHNwYWNlcyByZXByZXNlbnRpbmcgdGhlIHJvb3RzIG9mIHRoZSB2YXJpb3VzIHRyZWUtbGlrZSBoaWVyYXJjaGllc1xuICAgIHByaXZhdGUgcm9vdFNwYWNlczogUm9vbVtdID0gW107XG4gICAgLy8gVGhlIGxpc3Qgb2Ygcm9vbXMgbm90IHByZXNlbnQgaW4gYW55IGN1cnJlbnRseSBqb2luZWQgc3BhY2VzXG4gICAgcHJpdmF0ZSBvcnBoYW5lZFJvb21zID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgLy8gTWFwIGZyb20gcm9vbSBJRCB0byBzZXQgb2Ygc3BhY2VzIHdoaWNoIGxpc3QgaXQgYXMgYSBjaGlsZFxuICAgIHByaXZhdGUgcGFyZW50TWFwID0gbmV3IEVuaGFuY2VkTWFwPHN0cmluZywgU2V0PHN0cmluZz4+KCk7XG4gICAgLy8gTWFwIGZyb20gU3BhY2VLZXkgdG8gU3BhY2VOb3RpZmljYXRpb25TdGF0ZSBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhhdCBzcGFjZVxuICAgIHByaXZhdGUgbm90aWZpY2F0aW9uU3RhdGVNYXAgPSBuZXcgTWFwPFNwYWNlS2V5LCBTcGFjZU5vdGlmaWNhdGlvblN0YXRlPigpO1xuICAgIC8vIE1hcCBmcm9tIHNwYWNlIGtleSB0byBTZXQgb2Ygcm9vbSBJRHMgdGhhdCBzaG91bGQgYmUgc2hvd24gYXMgcGFydCBvZiB0aGF0IHNwYWNlJ3MgZmlsdGVyXG4gICAgcHJpdmF0ZSBzcGFjZUZpbHRlcmVkUm9vbXMgPSBuZXcgTWFwPFNwYWNlS2V5LCBTZXQ8c3RyaW5nPj4oKTtcbiAgICAvLyBUaGUgc3BhY2UgY3VycmVudGx5IHNlbGVjdGVkIGluIHRoZSBTcGFjZSBQYW5lbFxuICAgIHByaXZhdGUgX2FjdGl2ZVNwYWNlPzogU3BhY2VLZXkgPSBNZXRhU3BhY2UuSG9tZTsgLy8gc2V0IHByb3Blcmx5IGJ5IG9uUmVhZHlcbiAgICBwcml2YXRlIF9zdWdnZXN0ZWRSb29tczogSVN1Z2dlc3RlZFJvb21bXSA9IFtdO1xuICAgIHByaXZhdGUgX2ludml0ZWRTcGFjZXMgPSBuZXcgU2V0PFJvb20+KCk7XG4gICAgcHJpdmF0ZSBzcGFjZU9yZGVyTG9jYWxFY2hvTWFwID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcbiAgICBwcml2YXRlIF9yZXN0cmljdGVkSm9pblJ1bGVTdXBwb3J0PzogSVJvb21DYXBhYmlsaXR5O1xuICAgIHByaXZhdGUgX2FsbFJvb21zSW5Ib21lOiBib29sZWFuID0gU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZShcIlNwYWNlcy5hbGxSb29tc0luSG9tZVwiKTtcbiAgICBwcml2YXRlIF9lbmFibGVkTWV0YVNwYWNlczogTWV0YVNwYWNlW10gPSBbXTsgLy8gc2V0IGJ5IG9uUmVhZHlcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihkZWZhdWx0RGlzcGF0Y2hlciwge30pO1xuXG4gICAgICAgIFNldHRpbmdzU3RvcmUubW9uaXRvclNldHRpbmcoXCJTcGFjZXMuYWxsUm9vbXNJbkhvbWVcIiwgbnVsbCk7XG4gICAgICAgIFNldHRpbmdzU3RvcmUubW9uaXRvclNldHRpbmcoXCJTcGFjZXMuZW5hYmxlZE1ldGFTcGFjZXNcIiwgbnVsbCk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBpbnZpdGVkU3BhY2VzKCk6IFJvb21bXSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX2ludml0ZWRTcGFjZXMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgZW5hYmxlZE1ldGFTcGFjZXMoKTogTWV0YVNwYWNlW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZE1ldGFTcGFjZXM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBzcGFjZVBhbmVsU3BhY2VzKCk6IFJvb21bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RTcGFjZXM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBhY3RpdmVTcGFjZSgpOiBTcGFjZUtleSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVTcGFjZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGFjdGl2ZVNwYWNlUm9vbSgpOiBSb29tIHwgbnVsbCB7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVTcGFjZVswXSAhPT0gXCIhXCIpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXhDbGllbnQ/LmdldFJvb20odGhpcy5fYWN0aXZlU3BhY2UpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgc3VnZ2VzdGVkUm9vbXMoKTogSVN1Z2dlc3RlZFJvb21bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdWdnZXN0ZWRSb29tcztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGFsbFJvb21zSW5Ib21lKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWxsUm9vbXNJbkhvbWU7XG4gICAgfVxuXG4gICAgcHVibGljIHNldEFjdGl2ZVJvb21JblNwYWNlKHNwYWNlOiBTcGFjZUtleSk6IHZvaWQge1xuICAgICAgICBpZiAoc3BhY2VbMF0gPT09IFwiIVwiICYmICF0aGlzLm1hdHJpeENsaWVudD8uZ2V0Um9vbShzcGFjZSk/LmlzU3BhY2VSb29tKCkpIHJldHVybjtcbiAgICAgICAgaWYgKHNwYWNlICE9PSB0aGlzLmFjdGl2ZVNwYWNlKSB0aGlzLnNldEFjdGl2ZVNwYWNlKHNwYWNlKTtcblxuICAgICAgICBpZiAoc3BhY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb21JZCA9IHRoaXMuZ2V0Tm90aWZpY2F0aW9uU3RhdGUoc3BhY2UpLmdldEZpcnN0Um9vbVdpdGhOb3RpZmljYXRpb25zKCk7XG4gICAgICAgICAgICBkZWZhdWx0RGlzcGF0Y2hlci5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcInZpZXdfcm9vbVwiLFxuICAgICAgICAgICAgICAgIHJvb21faWQ6IHJvb21JZCxcbiAgICAgICAgICAgICAgICBjb250ZXh0X3N3aXRjaDogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbGlzdHMgPSBSb29tTGlzdFN0b3JlLmluc3RhbmNlLnVuZmlsdGVyZWRMaXN0cztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgVEFHX09SREVSLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IFRBR19PUkRFUltpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaXN0Um9vbXMgPSBsaXN0c1t0XTtcbiAgICAgICAgICAgICAgICBjb25zdCB1bnJlYWRSb29tID0gbGlzdFJvb21zLmZpbmQoKHI6IFJvb20pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvd0luSG9tZVNwYWNlKHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IFJvb21Ob3RpZmljYXRpb25TdGF0ZVN0b3JlLmluc3RhbmNlLmdldFJvb21TdGF0ZShyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS5pc1VucmVhZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh1bnJlYWRSb29tKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHREaXNwYXRjaGVyLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJ2aWV3X3Jvb21cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb21faWQ6IHVucmVhZFJvb20ucm9vbUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dF9zd2l0Y2g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHJlc3RyaWN0ZWRKb2luUnVsZVN1cHBvcnQoKTogSVJvb21DYXBhYmlsaXR5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3RyaWN0ZWRKb2luUnVsZVN1cHBvcnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYWN0aXZlIHNwYWNlLCB1cGRhdGVzIHJvb20gbGlzdCBmaWx0ZXJzLFxuICAgICAqIG9wdGlvbmFsbHkgc3dpdGNoZXMgdGhlIHVzZXIncyByb29tIGJhY2sgdG8gd2hlcmUgdGhleSB3ZXJlIHdoZW4gdGhleSBsYXN0IHZpZXdlZCB0aGF0IHNwYWNlLlxuICAgICAqIEBwYXJhbSBzcGFjZSB3aGljaCBzcGFjZSB0byBzd2l0Y2ggdG8uXG4gICAgICogQHBhcmFtIGNvbnRleHRTd2l0Y2ggd2hldGhlciB0byBzd2l0Y2ggdGhlIHVzZXIncyBjb250ZXh0LFxuICAgICAqIHNob3VsZCBub3QgYmUgZG9uZSB3aGVuIHRoZSBzcGFjZSBzd2l0Y2ggaXMgZG9uZSBpbXBsaWNpdGx5IGR1ZSB0byBhbm90aGVyIGV2ZW50IGxpa2Ugc3dpdGNoaW5nIHJvb20uXG4gICAgICovXG4gICAgcHVibGljIHNldEFjdGl2ZVNwYWNlKHNwYWNlOiBTcGFjZUtleSwgY29udGV4dFN3aXRjaCA9IHRydWUpIHtcbiAgICAgICAgaWYgKCFzcGFjZSB8fCAhdGhpcy5tYXRyaXhDbGllbnQgfHwgc3BhY2UgPT09IHRoaXMuYWN0aXZlU3BhY2UpIHJldHVybjtcblxuICAgICAgICBsZXQgY2xpU3BhY2U6IFJvb207XG4gICAgICAgIGlmIChzcGFjZVswXSA9PT0gXCIhXCIpIHtcbiAgICAgICAgICAgIGNsaVNwYWNlID0gdGhpcy5tYXRyaXhDbGllbnQuZ2V0Um9vbShzcGFjZSk7XG4gICAgICAgICAgICBpZiAoIWNsaVNwYWNlPy5pc1NwYWNlUm9vbSgpKSByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuZW5hYmxlZE1ldGFTcGFjZXMuaW5jbHVkZXMoc3BhY2UgYXMgTWV0YVNwYWNlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYWN0aXZlU3BhY2UgPSBzcGFjZTtcbiAgICAgICAgdGhpcy5lbWl0KFVQREFURV9TRUxFQ1RFRF9TUEFDRSwgdGhpcy5hY3RpdmVTcGFjZSk7XG4gICAgICAgIHRoaXMuZW1pdChVUERBVEVfU1VHR0VTVEVEX1JPT01TLCB0aGlzLl9zdWdnZXN0ZWRSb29tcyA9IFtdKTtcblxuICAgICAgICBpZiAoY29udGV4dFN3aXRjaCkge1xuICAgICAgICAgICAgLy8gdmlldyBsYXN0IHNlbGVjdGVkIHJvb20gZnJvbSBzcGFjZVxuICAgICAgICAgICAgY29uc3Qgcm9vbUlkID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldFNwYWNlQ29udGV4dEtleSh0aGlzLmFjdGl2ZVNwYWNlKSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBzcGFjZSBiZWluZyBzZWxlY3RlZCBpcyBhbiBpbnZpdGUgdGhlbiBhbHdheXMgdmlldyB0aGF0IGludml0ZVxuICAgICAgICAgICAgLy8gZWxzZSBpZiB0aGUgbGFzdCB2aWV3ZWQgcm9vbSBpbiB0aGlzIHNwYWNlIGlzIGpvaW5lZCB0aGVuIHZpZXcgdGhhdFxuICAgICAgICAgICAgLy8gZWxzZSB2aWV3IHNwYWNlIGhvbWUgb3IgaG9tZSBkZXBlbmRpbmcgb24gd2hhdCBpcyBiZWluZyBjbGlja2VkIG9uXG4gICAgICAgICAgICBpZiAoY2xpU3BhY2U/LmdldE15TWVtYmVyc2hpcCgpICE9PSBcImludml0ZVwiICYmXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRyaXhDbGllbnQuZ2V0Um9vbShyb29tSWQpPy5nZXRNeU1lbWJlcnNoaXAoKSA9PT0gXCJqb2luXCIgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmdldFNwYWNlRmlsdGVyZWRSb29tSWRzKHNwYWNlKS5oYXMocm9vbUlkKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwidmlld19yb29tXCIsXG4gICAgICAgICAgICAgICAgICAgIHJvb21faWQ6IHJvb21JZCxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dF9zd2l0Y2g6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsaVNwYWNlKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwidmlld19yb29tXCIsXG4gICAgICAgICAgICAgICAgICAgIHJvb21faWQ6IHNwYWNlLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0X3N3aXRjaDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwidmlld19ob21lX3BhZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dF9zd2l0Y2g6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwZXJzaXN0IHNwYWNlIHNlbGVjdGVkXG4gICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShBQ1RJVkVfU1BBQ0VfTFNfS0VZLCBzcGFjZSk7XG5cbiAgICAgICAgaWYgKGNsaVNwYWNlKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRTdWdnZXN0ZWRSb29tcyhjbGlTcGFjZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIGxvYWRTdWdnZXN0ZWRSb29tcyhzcGFjZTogUm9vbSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBzdWdnZXN0ZWRSb29tcyA9IGF3YWl0IHRoaXMuZmV0Y2hTdWdnZXN0ZWRSb29tcyhzcGFjZSk7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVTcGFjZSA9PT0gc3BhY2Uucm9vbUlkKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWdnZXN0ZWRSb29tcyA9IHN1Z2dlc3RlZFJvb21zO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFVQREFURV9TVUdHRVNURURfUk9PTVMsIHRoaXMuX3N1Z2dlc3RlZFJvb21zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBmZXRjaFN1Z2dlc3RlZFJvb21zID0gYXN5bmMgKHNwYWNlOiBSb29tLCBsaW1pdCA9IE1BWF9TVUdHRVNURURfUk9PTVMpOiBQcm9taXNlPElTdWdnZXN0ZWRSb29tW10+ID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcm9vbXMgfSA9IGF3YWl0IHRoaXMubWF0cml4Q2xpZW50LmdldFJvb21IaWVyYXJjaHkoc3BhY2Uucm9vbUlkLCBsaW1pdCwgMSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHZpYU1hcCA9IG5ldyBFbmhhbmNlZE1hcDxzdHJpbmcsIFNldDxzdHJpbmc+PigpO1xuICAgICAgICAgICAgcm9vbXMuZm9yRWFjaChyb29tID0+IHtcbiAgICAgICAgICAgICAgICByb29tLmNoaWxkcmVuX3N0YXRlLmZvckVhY2goZXYgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXYudHlwZSA9PT0gRXZlbnRUeXBlLlNwYWNlQ2hpbGQgJiYgZXYuY29udGVudC52aWE/Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXYuY29udGVudC52aWEuZm9yRWFjaCh2aWEgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpYU1hcC5nZXRPckNyZWF0ZShldi5zdGF0ZV9rZXksIG5ldyBTZXQoKSkuYWRkKHZpYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiByb29tcy5maWx0ZXIocm9vbUluZm8gPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByb29tSW5mby5yb29tX3R5cGUgIT09IFJvb21UeXBlLlNwYWNlXG4gICAgICAgICAgICAgICAgICAgICYmIHRoaXMubWF0cml4Q2xpZW50LmdldFJvb20ocm9vbUluZm8ucm9vbV9pZCk/LmdldE15TWVtYmVyc2hpcCgpICE9PSBcImpvaW5cIjtcbiAgICAgICAgICAgIH0pLm1hcChyb29tSW5mbyA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLnJvb21JbmZvLFxuICAgICAgICAgICAgICAgIHZpYVNlcnZlcnM6IEFycmF5LmZyb20odmlhTWFwLmdldChyb29tSW5mby5yb29tX2lkKSB8fCBbXSksXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcblxuICAgIHB1YmxpYyBhZGRSb29tVG9TcGFjZShzcGFjZTogUm9vbSwgcm9vbUlkOiBzdHJpbmcsIHZpYTogc3RyaW5nW10sIHN1Z2dlc3RlZCA9IGZhbHNlLCBhdXRvSm9pbiA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdHJpeENsaWVudC5zZW5kU3RhdGVFdmVudChzcGFjZS5yb29tSWQsIEV2ZW50VHlwZS5TcGFjZUNoaWxkLCB7XG4gICAgICAgICAgICB2aWEsXG4gICAgICAgICAgICBzdWdnZXN0ZWQsXG4gICAgICAgICAgICBhdXRvX2pvaW46IGF1dG9Kb2luLFxuICAgICAgICB9LCByb29tSWQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRDaGlsZHJlbihzcGFjZUlkOiBzdHJpbmcpOiBSb29tW10ge1xuICAgICAgICBjb25zdCByb29tID0gdGhpcy5tYXRyaXhDbGllbnQ/LmdldFJvb20oc3BhY2VJZCk7XG4gICAgICAgIGNvbnN0IGNoaWxkRXZlbnRzID0gcm9vbT8uY3VycmVudFN0YXRlLmdldFN0YXRlRXZlbnRzKEV2ZW50VHlwZS5TcGFjZUNoaWxkKS5maWx0ZXIoZXYgPT4gZXYuZ2V0Q29udGVudCgpPy52aWEpO1xuICAgICAgICByZXR1cm4gc29ydEJ5KGNoaWxkRXZlbnRzLCBldiA9PiB7XG4gICAgICAgICAgICBjb25zdCByb29tSWQgPSBldi5nZXRTdGF0ZUtleSgpO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRSb29tID0gdGhpcy5tYXRyaXhDbGllbnQ/LmdldFJvb20ocm9vbUlkKTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZVRzID0gY2hpbGRSb29tPy5jdXJyZW50U3RhdGUuZ2V0U3RhdGVFdmVudHMoRXZlbnRUeXBlLlJvb21DcmVhdGUsIFwiXCIpPy5nZXRUcygpO1xuICAgICAgICAgICAgcmV0dXJuIGdldENoaWxkT3JkZXIoZXYuZ2V0Q29udGVudCgpLm9yZGVyLCBjcmVhdGVUcywgcm9vbUlkKTtcbiAgICAgICAgfSkubWFwKGV2ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhpc3RvcnkgPSB0aGlzLm1hdHJpeENsaWVudC5nZXRSb29tVXBncmFkZUhpc3RvcnkoZXYuZ2V0U3RhdGVLZXkoKSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gaGlzdG9yeVtoaXN0b3J5Lmxlbmd0aCAtIDFdO1xuICAgICAgICB9KS5maWx0ZXIocm9vbSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcm9vbT8uZ2V0TXlNZW1iZXJzaGlwKCkgPT09IFwiam9pblwiIHx8IHJvb20/LmdldE15TWVtYmVyc2hpcCgpID09PSBcImludml0ZVwiO1xuICAgICAgICB9KSB8fCBbXTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0Q2hpbGRSb29tcyhzcGFjZUlkOiBzdHJpbmcpOiBSb29tW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDaGlsZHJlbihzcGFjZUlkKS5maWx0ZXIociA9PiAhci5pc1NwYWNlUm9vbSgpKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0Q2hpbGRTcGFjZXMoc3BhY2VJZDogc3RyaW5nKTogUm9vbVtdIHtcbiAgICAgICAgLy8gZG9uJ3Qgc2hvdyBpbnZpdGVkIHN1YnNwYWNlcyBhcyB0aGV5IHN1cmZhY2UgYXQgdGhlIHRvcCBsZXZlbCBmb3IgYmV0dGVyIHZpc2liaWxpdHlcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2hpbGRyZW4oc3BhY2VJZCkuZmlsdGVyKHIgPT4gci5pc1NwYWNlUm9vbSgpICYmIHIuZ2V0TXlNZW1iZXJzaGlwKCkgPT09IFwiam9pblwiKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0UGFyZW50cyhyb29tSWQ6IHN0cmluZywgY2Fub25pY2FsT25seSA9IGZhbHNlKTogUm9vbVtdIHtcbiAgICAgICAgY29uc3QgdXNlcklkID0gdGhpcy5tYXRyaXhDbGllbnQ/LmdldFVzZXJJZCgpO1xuICAgICAgICBjb25zdCByb29tID0gdGhpcy5tYXRyaXhDbGllbnQ/LmdldFJvb20ocm9vbUlkKTtcbiAgICAgICAgcmV0dXJuIHJvb20/LmN1cnJlbnRTdGF0ZS5nZXRTdGF0ZUV2ZW50cyhFdmVudFR5cGUuU3BhY2VQYXJlbnQpXG4gICAgICAgICAgICAubWFwKGV2ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gZXYuZ2V0Q29udGVudCgpO1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjb250ZW50LnZpYSkgfHwgKGNhbm9uaWNhbE9ubHkgJiYgIWNvbnRlbnQuY2Fub25pY2FsKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIHNraXBcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBvbmx5IHJlc3BlY3QgdGhlIHJlbGF0aW9uc2hpcCBpZiB0aGUgc2VuZGVyIGhhcyBzdWZmaWNpZW50IHBlcm1pc3Npb25zIGluIHRoZSBwYXJlbnQgdG8gc2V0XG4gICAgICAgICAgICAgICAgLy8gY2hpbGQgcmVsYXRpb25zLCBhcyBwZXIgTVNDMTc3Mi5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF0cml4LW9yZy9tYXRyaXgtZG9jL2Jsb2IvbWFpbi9wcm9wb3NhbHMvMTc3Mi1ncm91cHMtYXMtcm9vbXMubWQjcmVsYXRpb25zaGlwLWJldHdlZW4tcm9vbXMtYW5kLXNwYWNlc1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMubWF0cml4Q2xpZW50LmdldFJvb20oZXYuZ2V0U3RhdGVLZXkoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVsYXRpb24gPSBwYXJlbnQ/LmN1cnJlbnRTdGF0ZS5nZXRTdGF0ZUV2ZW50cyhFdmVudFR5cGUuU3BhY2VDaGlsZCwgcm9vbUlkKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudD8uY3VycmVudFN0YXRlLm1heVNlbmRTdGF0ZUV2ZW50KEV2ZW50VHlwZS5TcGFjZUNoaWxkLCB1c2VySWQpIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIGFsc28gc2tpcCB0aGlzIHJlbGF0aW9uIGlmIHRoZSBwYXJlbnQgaGFkIHRoaXMgY2hpbGQgYWRkZWQgYnV0IHRoZW4gc2luY2UgcmVtb3ZlZCBpdFxuICAgICAgICAgICAgICAgICAgICAocmVsYXRpb24gJiYgIUFycmF5LmlzQXJyYXkocmVsYXRpb24uZ2V0Q29udGVudCgpLnZpYSkpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gc2tpcFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKSB8fCBbXTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0Q2Fub25pY2FsUGFyZW50KHJvb21JZDogc3RyaW5nKTogUm9vbSB8IG51bGwge1xuICAgICAgICBjb25zdCBwYXJlbnRzID0gdGhpcy5nZXRQYXJlbnRzKHJvb21JZCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBzb3J0QnkocGFyZW50cywgciA9PiByLnJvb21JZCk/LlswXSB8fCBudWxsO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRLbm93blBhcmVudHMocm9vbUlkOiBzdHJpbmcpOiBTZXQ8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudE1hcC5nZXQocm9vbUlkKSB8fCBuZXcgU2V0KCk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFNwYWNlRmlsdGVyZWRSb29tSWRzID0gKHNwYWNlOiBTcGFjZUtleSk6IFNldDxzdHJpbmc+ID0+IHtcbiAgICAgICAgaWYgKHNwYWNlID09PSBNZXRhU3BhY2UuSG9tZSAmJiB0aGlzLmFsbFJvb21zSW5Ib21lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNldCh0aGlzLm1hdHJpeENsaWVudC5nZXRWaXNpYmxlUm9vbXMoKS5tYXAociA9PiByLnJvb21JZCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNwYWNlRmlsdGVyZWRSb29tcy5nZXQoc3BhY2UpIHx8IG5ldyBTZXQoKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSByZWJ1aWxkID0gdGhyb3R0bGUoKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMubWF0cml4Q2xpZW50KSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgW3Zpc2libGVTcGFjZXMsIHZpc2libGVSb29tc10gPSBwYXJ0aXRpb25TcGFjZXNBbmRSb29tcyh0aGlzLm1hdHJpeENsaWVudC5nZXRWaXNpYmxlUm9vbXMoKSk7XG4gICAgICAgIGNvbnN0IFtqb2luZWRTcGFjZXMsIGludml0ZWRTcGFjZXNdID0gdmlzaWJsZVNwYWNlcy5yZWR1Y2UoKGFyciwgcykgPT4ge1xuICAgICAgICAgICAgaWYgKHMuZ2V0TXlNZW1iZXJzaGlwKCkgPT09IFwiam9pblwiKSB7XG4gICAgICAgICAgICAgICAgYXJyWzBdLnB1c2gocyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHMuZ2V0TXlNZW1iZXJzaGlwKCkgPT09IFwiaW52aXRlXCIpIHtcbiAgICAgICAgICAgICAgICBhcnJbMV0ucHVzaChzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIH0sIFtbXSwgW11dKTtcblxuICAgICAgICAvLyBleGNsdWRlIGludml0ZWQgc3BhY2VzIGZyb20gdW5zZWVuQ2hpbGRyZW4gYXMgdGhleSB3aWxsIGJlIGZvcmNpYmx5IHNob3duIGF0IHRoZSB0b3AgbGV2ZWwgb2YgdGhlIHRyZWV2aWV3XG4gICAgICAgIGNvbnN0IHVuc2VlbkNoaWxkcmVuID0gbmV3IFNldDxSb29tPihbLi4udmlzaWJsZVJvb21zLCAuLi5qb2luZWRTcGFjZXNdKTtcbiAgICAgICAgY29uc3QgYmFja3JlZnMgPSBuZXcgRW5oYW5jZWRNYXA8c3RyaW5nLCBTZXQ8c3RyaW5nPj4oKTtcblxuICAgICAgICAvLyBTb3J0IHNwYWNlcyBieSByb29tIElEIHRvIGZvcmNlIHRoZSBjeWNsZSBicmVha2luZyB0byBiZSBkZXRlcm1pbmlzdGljXG4gICAgICAgIGNvbnN0IHNwYWNlcyA9IHNvcnRCeShqb2luZWRTcGFjZXMsIHNwYWNlID0+IHNwYWNlLnJvb21JZCk7XG5cbiAgICAgICAgLy8gVE9ETyBoYW5kbGUgY2xlYW5pbmcgdXAgbGlua3Mgd2hlbiBhIFNwYWNlIGlzIHJlbW92ZWRcbiAgICAgICAgc3BhY2VzLmZvckVhY2goc3BhY2UgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKHNwYWNlLnJvb21JZCk7XG4gICAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICB1bnNlZW5DaGlsZHJlbi5kZWxldGUoY2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgYmFja3JlZnMuZ2V0T3JDcmVhdGUoY2hpbGQucm9vbUlkLCBuZXcgU2V0KCkpLmFkZChzcGFjZS5yb29tSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IFtyb290U3BhY2VzLCBvcnBoYW5lZFJvb21zXSA9IHBhcnRpdGlvblNwYWNlc0FuZFJvb21zKEFycmF5LmZyb20odW5zZWVuQ2hpbGRyZW4pKTtcblxuICAgICAgICAvLyBzb21ld2hhdCBhbGdvcml0aG0gdG8gaGFuZGxlIGZ1bGwtY3ljbGVzXG4gICAgICAgIGNvbnN0IGRldGFjaGVkTm9kZXMgPSBuZXcgU2V0PFJvb20+KHNwYWNlcyk7XG5cbiAgICAgICAgY29uc3QgbWFya1RyZWVDaGlsZHJlbiA9IChyb290U3BhY2U6IFJvb20sIHVuc2VlbjogU2V0PFJvb20+KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IFtyb290U3BhY2VdO1xuICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgdW5zZWVuLmRlbGV0ZShvcCk7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRDaGlsZFNwYWNlcyhvcC5yb29tSWQpLmZvckVhY2goc3BhY2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodW5zZWVuLmhhcyhzcGFjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcm9vdFNwYWNlcy5mb3JFYWNoKHJvb3RTcGFjZSA9PiB7XG4gICAgICAgICAgICBtYXJrVHJlZUNoaWxkcmVuKHJvb3RTcGFjZSwgZGV0YWNoZWROb2Rlcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEhhbmRsZSBzcGFjZXMgZm9ybWluZyBmdWxseSBjeWNsaWNhbCByZWxhdGlvbnNoaXBzLlxuICAgICAgICAvLyBJbiBvcmRlciwgYXNzdW1lIGVhY2ggZGV0YWNoZWROb2RlIGlzIGEgcm9vdCB1bmxlc3MgaXQgaGFzIGFscmVhZHlcbiAgICAgICAgLy8gYmVlbiBjbGFpbWVkIGFzIHRoZSBjaGlsZCBvZiBwcmlvciBkZXRhY2hlZCBub2RlLlxuICAgICAgICAvLyBXb3JrIGZyb20gYSBjb3B5IG9mIHRoZSBkZXRhY2hlZE5vZGVzIHNldCBhcyBpdCB3aWxsIGJlIG11dGF0ZWQgYXMgcGFydCBvZiB0aGlzIG9wZXJhdGlvbi5cbiAgICAgICAgQXJyYXkuZnJvbShkZXRhY2hlZE5vZGVzKS5mb3JFYWNoKGRldGFjaGVkTm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoIWRldGFjaGVkTm9kZXMuaGFzKGRldGFjaGVkTm9kZSkpIHJldHVybjtcbiAgICAgICAgICAgIC8vIGRlY2xhcmUgdGhpcyBkZXRhY2hlZCBub2RlIGEgbmV3IHJvb3QsIGZpbmQgaXRzIGNoaWxkcmVuLCB3aXRob3V0IGV2ZXIgbG9vcGluZyBiYWNrIHRvIGl0XG4gICAgICAgICAgICBkZXRhY2hlZE5vZGVzLmRlbGV0ZShkZXRhY2hlZE5vZGUpO1xuICAgICAgICAgICAgcm9vdFNwYWNlcy5wdXNoKGRldGFjaGVkTm9kZSk7XG4gICAgICAgICAgICBtYXJrVHJlZUNoaWxkcmVuKGRldGFjaGVkTm9kZSwgZGV0YWNoZWROb2Rlcyk7XG5cbiAgICAgICAgICAgIC8vIFRPRE8gb25seSBjb25zaWRlciBhIGRldGFjaGVkIG5vZGUgYSByb290IHNwYWNlIGlmIGl0IGhhcyBubyAqcGFyZW50cyBvdGhlciB0aGFuIHRoZSBvbmVzIGZvcm1pbmcgY3ljbGVzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRPRE8gbmVpdGhlciBvZiB0aGVzZSBoYW5kbGUgYW4gQS0+Qi0+Qy0+QSB3aXRoIGFuIGFkZGl0aW9uYWwgQy0+RFxuICAgICAgICAvLyBkZXRhY2hlZE5vZGVzLmZvckVhY2goc3BhY2UgPT4ge1xuICAgICAgICAvLyAgICAgcm9vdFNwYWNlcy5wdXNoKHNwYWNlKTtcbiAgICAgICAgLy8gfSk7XG5cbiAgICAgICAgdGhpcy5vcnBoYW5lZFJvb21zID0gbmV3IFNldChvcnBoYW5lZFJvb21zLm1hcChyID0+IHIucm9vbUlkKSk7XG4gICAgICAgIHRoaXMucm9vdFNwYWNlcyA9IHRoaXMuc29ydFJvb3RTcGFjZXMocm9vdFNwYWNlcyk7XG4gICAgICAgIHRoaXMucGFyZW50TWFwID0gYmFja3JlZnM7XG5cbiAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBzcGFjZSBubyBsb25nZXIgZXhpc3RzLCByZW1vdmUgaXRzIHNlbGVjdGlvblxuICAgICAgICBpZiAodGhpcy5fYWN0aXZlU3BhY2VbMF0gPT09IFwiIVwiICYmIGRldGFjaGVkTm9kZXMuaGFzKHRoaXMubWF0cml4Q2xpZW50LmdldFJvb20odGhpcy5fYWN0aXZlU3BhY2UpKSkge1xuICAgICAgICAgICAgdGhpcy5nb1RvRmlyc3RTcGFjZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vblJvb21zVXBkYXRlKCk7IC8vIFRPRE8gb25seSBkbyB0aGlzIGlmIGEgY2hhbmdlIGhhcyBoYXBwZW5lZFxuICAgICAgICB0aGlzLmVtaXQoVVBEQVRFX1RPUF9MRVZFTF9TUEFDRVMsIHRoaXMuc3BhY2VQYW5lbFNwYWNlcywgdGhpcy5lbmFibGVkTWV0YVNwYWNlcyk7XG5cbiAgICAgICAgLy8gYnVpbGQgaW5pdGlhbCBzdGF0ZSBvZiBpbnZpdGVkIHNwYWNlcyBhcyB3ZSB3b3VsZCBoYXZlIG1pc3NlZCB0aGUgZW1pdHRlZCBldmVudHMgYWJvdXQgdGhlIHJvb20gYXQgbGF1bmNoXG4gICAgICAgIHRoaXMuX2ludml0ZWRTcGFjZXMgPSBuZXcgU2V0KHRoaXMuc29ydFJvb3RTcGFjZXMoaW52aXRlZFNwYWNlcykpO1xuICAgICAgICB0aGlzLmVtaXQoVVBEQVRFX0lOVklURURfU1BBQ0VTLCB0aGlzLmludml0ZWRTcGFjZXMpO1xuICAgIH0sIDEwMCwgeyB0cmFpbGluZzogdHJ1ZSwgbGVhZGluZzogdHJ1ZSB9KTtcblxuICAgIHByaXZhdGUgb25TcGFjZVVwZGF0ZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5yZWJ1aWxkKCk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgc2hvd0luSG9tZVNwYWNlID0gKHJvb206IFJvb20pID0+IHtcbiAgICAgICAgaWYgKHRoaXMuYWxsUm9vbXNJbkhvbWUpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAocm9vbS5pc1NwYWNlUm9vbSgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiAhdGhpcy5wYXJlbnRNYXAuZ2V0KHJvb20ucm9vbUlkKT8uc2l6ZSAvLyBwdXQgYWxsIG9ycGhhbmVkIHJvb21zIGluIHRoZSBIb21lIFNwYWNlXG4gICAgICAgICAgICB8fCBETVJvb21NYXAuc2hhcmVkKCkuZ2V0VXNlcklkRm9yUm9vbUlkKHJvb20ucm9vbUlkKTsgLy8gcHV0IGFsbCBETXMgaW4gdGhlIEhvbWUgU3BhY2VcbiAgICB9O1xuXG4gICAgLy8gVXBkYXRlIGEgZ2l2ZW4gcm9vbSBkdWUgdG8gaXRzIHRhZyBjaGFuZ2luZyAoZS5nIERNLW5lc3Mgb3IgRmF2LW5lc3MpXG4gICAgLy8gVGhpcyBjYW4gb25seSBjaGFuZ2Ugd2hldGhlciBpdCBzaG93cyB1cCBpbiB0aGUgSE9NRV9TUEFDRSBvciBub3RcbiAgICBwcml2YXRlIG9uUm9vbVVwZGF0ZSA9IChyb29tOiBSb29tKSA9PiB7XG4gICAgICAgIGNvbnN0IGVuYWJsZWRNZXRhU3BhY2VzID0gbmV3IFNldCh0aGlzLmVuYWJsZWRNZXRhU3BhY2VzKTtcbiAgICAgICAgLy8gVE9ETyBtb3JlIG1ldGFzcGFjZSBzdHVmZnNcbiAgICAgICAgaWYgKGVuYWJsZWRNZXRhU3BhY2VzLmhhcyhNZXRhU3BhY2UuSG9tZSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3dJbkhvbWVTcGFjZShyb29tKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3BhY2VGaWx0ZXJlZFJvb21zLmdldChNZXRhU3BhY2UuSG9tZSk/LmFkZChyb29tLnJvb21JZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KE1ldGFTcGFjZS5Ib21lKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMub3JwaGFuZWRSb29tcy5oYXMocm9vbS5yb29tSWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGFjZUZpbHRlcmVkUm9vbXMuZ2V0KE1ldGFTcGFjZS5Ib21lKT8uZGVsZXRlKHJvb20ucm9vbUlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoTWV0YVNwYWNlLkhvbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25TcGFjZU1lbWJlcnNDaGFuZ2UgPSAoZXY6IE1hdHJpeEV2ZW50KSA9PiB7XG4gICAgICAgIC8vIHNraXAgdGhpcyB1cGRhdGUgaWYgd2UgZG8gbm90IGhhdmUgYSBETSB3aXRoIHRoaXMgdXNlclxuICAgICAgICBpZiAoRE1Sb29tTWFwLnNoYXJlZCgpLmdldERNUm9vbXNGb3JVc2VySWQoZXYuZ2V0U3RhdGVLZXkoKSkubGVuZ3RoIDwgMSkgcmV0dXJuO1xuICAgICAgICB0aGlzLm9uUm9vbXNVcGRhdGUoKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvblJvb21zVXBkYXRlID0gdGhyb3R0bGUoKCkgPT4ge1xuICAgICAgICAvLyBUT0RPIHJlc29sdmUgc29tZSB1cGRhdGVzIGFzIGRlbHRhc1xuICAgICAgICBjb25zdCB2aXNpYmxlUm9vbXMgPSB0aGlzLm1hdHJpeENsaWVudC5nZXRWaXNpYmxlUm9vbXMoKTtcblxuICAgICAgICBjb25zdCBvbGRGaWx0ZXJlZFJvb21zID0gdGhpcy5zcGFjZUZpbHRlcmVkUm9vbXM7XG4gICAgICAgIHRoaXMuc3BhY2VGaWx0ZXJlZFJvb21zID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIGNvbnN0IGVuYWJsZWRNZXRhU3BhY2VzID0gbmV3IFNldCh0aGlzLmVuYWJsZWRNZXRhU3BhY2VzKTtcbiAgICAgICAgLy8gcG9wdWxhdGUgdGhlIEhvbWUgbWV0YXNwYWNlIGlmIGl0IGlzIGVuYWJsZWQgYW5kIGlzIG5vdCBzZXQgdG8gYWxsIHJvb21zXG4gICAgICAgIGlmIChlbmFibGVkTWV0YVNwYWNlcy5oYXMoTWV0YVNwYWNlLkhvbWUpICYmICF0aGlzLmFsbFJvb21zSW5Ib21lKSB7XG4gICAgICAgICAgICAvLyBwdXQgYWxsIHJvb20gaW52aXRlcyBpbiB0aGUgSG9tZSBTcGFjZVxuICAgICAgICAgICAgY29uc3QgaW52aXRlcyA9IHZpc2libGVSb29tcy5maWx0ZXIociA9PiAhci5pc1NwYWNlUm9vbSgpICYmIHIuZ2V0TXlNZW1iZXJzaGlwKCkgPT09IFwiaW52aXRlXCIpO1xuICAgICAgICAgICAgdGhpcy5zcGFjZUZpbHRlcmVkUm9vbXMuc2V0KE1ldGFTcGFjZS5Ib21lLCBuZXcgU2V0KGludml0ZXMubWFwKHIgPT4gci5yb29tSWQpKSk7XG5cbiAgICAgICAgICAgIHZpc2libGVSb29tcy5mb3JFYWNoKHJvb20gPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3dJbkhvbWVTcGFjZShyb29tKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwYWNlRmlsdGVyZWRSb29tcy5nZXQoTWV0YVNwYWNlLkhvbWUpLmFkZChyb29tLnJvb21JZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwb3B1bGF0ZSB0aGUgRmF2b3VyaXRlcyBtZXRhc3BhY2UgaWYgaXQgaXMgZW5hYmxlZFxuICAgICAgICBpZiAoZW5hYmxlZE1ldGFTcGFjZXMuaGFzKE1ldGFTcGFjZS5GYXZvdXJpdGVzKSkge1xuICAgICAgICAgICAgY29uc3QgZmF2b3VyaXRlcyA9IHZpc2libGVSb29tcy5maWx0ZXIociA9PiByLnRhZ3NbRGVmYXVsdFRhZ0lELkZhdm91cml0ZV0pO1xuICAgICAgICAgICAgdGhpcy5zcGFjZUZpbHRlcmVkUm9vbXMuc2V0KE1ldGFTcGFjZS5GYXZvdXJpdGVzLCBuZXcgU2V0KGZhdm91cml0ZXMubWFwKHIgPT4gci5yb29tSWQpKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwb3B1bGF0ZSB0aGUgUGVvcGxlIG1ldGFzcGFjZSBpZiBpdCBpcyBlbmFibGVkXG4gICAgICAgIGlmIChlbmFibGVkTWV0YVNwYWNlcy5oYXMoTWV0YVNwYWNlLlBlb3BsZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBlb3BsZSA9IHZpc2libGVSb29tcy5maWx0ZXIociA9PiBETVJvb21NYXAuc2hhcmVkKCkuZ2V0VXNlcklkRm9yUm9vbUlkKHIucm9vbUlkKSk7XG4gICAgICAgICAgICB0aGlzLnNwYWNlRmlsdGVyZWRSb29tcy5zZXQoTWV0YVNwYWNlLlBlb3BsZSwgbmV3IFNldChwZW9wbGUubWFwKHIgPT4gci5yb29tSWQpKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwb3B1bGF0ZSB0aGUgT3JwaGFucyBtZXRhc3BhY2UgaWYgaXQgaXMgZW5hYmxlZFxuICAgICAgICBpZiAoZW5hYmxlZE1ldGFTcGFjZXMuaGFzKE1ldGFTcGFjZS5PcnBoYW5zKSkge1xuICAgICAgICAgICAgY29uc3Qgb3JwaGFucyA9IHZpc2libGVSb29tcy5maWx0ZXIociA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIG91dCBETXMgYW5kIHJvb21zIHdpdGggPjAgcGFyZW50c1xuICAgICAgICAgICAgICAgIHJldHVybiAhdGhpcy5wYXJlbnRNYXAuZ2V0KHIucm9vbUlkKT8uc2l6ZSAmJiAhRE1Sb29tTWFwLnNoYXJlZCgpLmdldFVzZXJJZEZvclJvb21JZChyLnJvb21JZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc3BhY2VGaWx0ZXJlZFJvb21zLnNldChNZXRhU3BhY2UuT3JwaGFucywgbmV3IFNldChvcnBoYW5zLm1hcChyID0+IHIucm9vbUlkKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaGlkZGVuQ2hpbGRyZW4gPSBuZXcgRW5oYW5jZWRNYXA8c3RyaW5nLCBTZXQ8c3RyaW5nPj4oKTtcbiAgICAgICAgdmlzaWJsZVJvb21zLmZvckVhY2gocm9vbSA9PiB7XG4gICAgICAgICAgICBpZiAocm9vbS5nZXRNeU1lbWJlcnNoaXAoKSAhPT0gXCJqb2luXCIpIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuZ2V0UGFyZW50cyhyb29tLnJvb21JZCkuZm9yRWFjaChwYXJlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGhpZGRlbkNoaWxkcmVuLmdldE9yQ3JlYXRlKHBhcmVudC5yb29tSWQsIG5ldyBTZXQoKSkuYWRkKHJvb20ucm9vbUlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnJvb3RTcGFjZXMuZm9yRWFjaChzID0+IHtcbiAgICAgICAgICAgIC8vIHRyYXZlcnNlIGVhY2ggc3BhY2UgdHJlZSBpbiBERlMgdG8gYnVpbGQgdXAgdGhlIHN1cGVyc2V0cyBhcyB5b3UgZ28gdXAsXG4gICAgICAgICAgICAvLyByZXVzaW5nIHJlc3VsdHMgZnJvbSBsaWtlIHN1YnRyZWVzLlxuICAgICAgICAgICAgY29uc3QgZm4gPSAoc3BhY2VJZDogc3RyaW5nLCBwYXJlbnRQYXRoOiBTZXQ8c3RyaW5nPik6IFNldDxzdHJpbmc+ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50UGF0aC5oYXMoc3BhY2VJZCkpIHJldHVybjsgLy8gcHJldmVudCBjeWNsZXNcblxuICAgICAgICAgICAgICAgIC8vIHJldXNlIGV4aXN0aW5nIHJlc3VsdHMgaWYgbXVsdGlwbGUgc2ltaWxhciBicmFuY2hlcyBleGlzdFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNwYWNlRmlsdGVyZWRSb29tcy5oYXMoc3BhY2VJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BhY2VGaWx0ZXJlZFJvb21zLmdldChzcGFjZUlkKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBbY2hpbGRTcGFjZXMsIGNoaWxkUm9vbXNdID0gcGFydGl0aW9uU3BhY2VzQW5kUm9vbXModGhpcy5nZXRDaGlsZHJlbihzcGFjZUlkKSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm9vbUlkcyA9IG5ldyBTZXQoY2hpbGRSb29tcy5tYXAociA9PiByLnJvb21JZCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwYWNlID0gdGhpcy5tYXRyaXhDbGllbnQ/LmdldFJvb20oc3BhY2VJZCk7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgcmVsZXZhbnQgRE1zXG4gICAgICAgICAgICAgICAgc3BhY2U/LmdldE1lbWJlcnMoKS5mb3JFYWNoKG1lbWJlciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZW1iZXIubWVtYmVyc2hpcCAhPT0gXCJqb2luXCIgJiYgbWVtYmVyLm1lbWJlcnNoaXAgIT09IFwiaW52aXRlXCIpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgRE1Sb29tTWFwLnNoYXJlZCgpLmdldERNUm9vbXNGb3JVc2VySWQobWVtYmVyLnVzZXJJZCkuZm9yRWFjaChyb29tSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vbUlkcy5hZGQocm9vbUlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdQYXRoID0gbmV3IFNldChwYXJlbnRQYXRoKS5hZGQoc3BhY2VJZCk7XG4gICAgICAgICAgICAgICAgY2hpbGRTcGFjZXMuZm9yRWFjaChjaGlsZFNwYWNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZm4oY2hpbGRTcGFjZS5yb29tSWQsIG5ld1BhdGgpPy5mb3JFYWNoKHJvb21JZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb29tSWRzLmFkZChyb29tSWQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBoaWRkZW5DaGlsZHJlbi5nZXQoc3BhY2VJZCk/LmZvckVhY2gocm9vbUlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcm9vbUlkcy5hZGQocm9vbUlkKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEV4cGFuZCByb29tIElEcyB0byBhbGwga25vd24gdmVyc2lvbnMgb2YgdGhlIGdpdmVuIHJvb21zXG4gICAgICAgICAgICAgICAgY29uc3QgZXhwYW5kZWRSb29tSWRzID0gbmV3IFNldChBcnJheS5mcm9tKHJvb21JZHMpLmZsYXRNYXAocm9vbUlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4Q2xpZW50LmdldFJvb21VcGdyYWRlSGlzdG9yeShyb29tSWQsIHRydWUpLm1hcChyID0+IHIucm9vbUlkKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGFjZUZpbHRlcmVkUm9vbXMuc2V0KHNwYWNlSWQsIGV4cGFuZGVkUm9vbUlkcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cGFuZGVkUm9vbUlkcztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZuKHMucm9vbUlkLCBuZXcgU2V0KCkpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBkaWZmID0gbWFwRGlmZihvbGRGaWx0ZXJlZFJvb21zLCB0aGlzLnNwYWNlRmlsdGVyZWRSb29tcyk7XG4gICAgICAgIC8vIGZpbHRlciBvdXQga2V5cyB3aGljaCBjaGFuZ2VkIGJ5IHJlZmVyZW5jZSBvbmx5IGJ5IGNoZWNraW5nIHdoZXRoZXIgdGhlIHNldHMgZGlmZmVyXG4gICAgICAgIGNvbnN0IGNoYW5nZWQgPSBkaWZmLmNoYW5nZWQuZmlsdGVyKGsgPT4gc2V0SGFzRGlmZihvbGRGaWx0ZXJlZFJvb21zLmdldChrKSwgdGhpcy5zcGFjZUZpbHRlcmVkUm9vbXMuZ2V0KGspKSk7XG4gICAgICAgIFsuLi5kaWZmLmFkZGVkLCAuLi5kaWZmLnJlbW92ZWQsIC4uLmNoYW5nZWRdLmZvckVhY2goayA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoayk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCBkbUJhZGdlU3BhY2U6IE1ldGFTcGFjZTtcbiAgICAgICAgLy8gb25seSBzaG93IGJhZGdlcyBvbiBkbXMgb24gdGhlIG1vc3QgcmVsZXZhbnQgc3BhY2UgaWYgc3VjaCBleGlzdHNcbiAgICAgICAgaWYgKGVuYWJsZWRNZXRhU3BhY2VzLmhhcyhNZXRhU3BhY2UuUGVvcGxlKSkge1xuICAgICAgICAgICAgZG1CYWRnZVNwYWNlID0gTWV0YVNwYWNlLlBlb3BsZTtcbiAgICAgICAgfSBlbHNlIGlmIChlbmFibGVkTWV0YVNwYWNlcy5oYXMoTWV0YVNwYWNlLkhvbWUpKSB7XG4gICAgICAgICAgICBkbUJhZGdlU3BhY2UgPSBNZXRhU3BhY2UuSG9tZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3BhY2VGaWx0ZXJlZFJvb21zLmZvckVhY2goKHJvb21JZHMsIHMpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbFJvb21zSW5Ib21lICYmIHMgPT09IE1ldGFTcGFjZS5Ib21lKSByZXR1cm47IC8vIHdlJ2xsIGJlIHVzaW5nIHRoZSBnbG9iYWwgbm90aWZpY2F0aW9uIHN0YXRlLCBza2lwXG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBOb3RpZmljYXRpb25TdGF0ZXNcbiAgICAgICAgICAgIHRoaXMuZ2V0Tm90aWZpY2F0aW9uU3RhdGUocykuc2V0Um9vbXModmlzaWJsZVJvb21zLmZpbHRlcihyb29tID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJvb21JZHMuaGFzKHJvb20ucm9vbUlkKSB8fCByb29tLmlzU3BhY2VSb29tKCkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGlmIChkbUJhZGdlU3BhY2UgJiYgRE1Sb29tTWFwLnNoYXJlZCgpLmdldFVzZXJJZEZvclJvb21JZChyb29tLnJvb21JZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMgPT09IGRtQmFkZ2VTcGFjZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfSwgMTAwLCB7IHRyYWlsaW5nOiB0cnVlLCBsZWFkaW5nOiB0cnVlIH0pO1xuXG4gICAgcHJpdmF0ZSBzd2l0Y2hUb1JlbGF0ZWRTcGFjZSA9IChyb29tSWQ6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAodGhpcy5zdWdnZXN0ZWRSb29tcy5maW5kKHIgPT4gci5yb29tX2lkID09PSByb29tSWQpKSByZXR1cm47XG5cbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuZ2V0Q2Fub25pY2FsUGFyZW50KHJvb21JZCk7XG4gICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQgPSB0aGlzLnJvb3RTcGFjZXMuZmluZChzID0+IHRoaXMuc3BhY2VGaWx0ZXJlZFJvb21zLmdldChzLnJvb21JZCk/Lmhhcyhyb29tSWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50SWRzID0gQXJyYXkuZnJvbSh0aGlzLnBhcmVudE1hcC5nZXQocm9vbUlkKSB8fCBbXSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhcmVudElkIG9mIHBhcmVudElkcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvb20gPSB0aGlzLm1hdHJpeENsaWVudC5nZXRSb29tKHBhcmVudElkKTtcbiAgICAgICAgICAgICAgICBpZiAocm9vbSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSByb29tO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkb24ndCB0cmlnZ2VyIGEgY29udGV4dCBzd2l0Y2ggd2hlbiB3ZSBhcmUgc3dpdGNoaW5nIGEgc3BhY2UgdG8gbWF0Y2ggdGhlIGNob3NlbiByb29tXG4gICAgICAgIHRoaXMuc2V0QWN0aXZlU3BhY2UocGFyZW50Py5yb29tSWQgPz8gTWV0YVNwYWNlLkhvbWUsIGZhbHNlKTsgLy8gVE9ET1xuICAgIH07XG5cbiAgICBwcml2YXRlIG9uUm9vbSA9IChyb29tOiBSb29tLCBuZXdNZW1iZXJzaGlwPzogc3RyaW5nLCBvbGRNZW1iZXJzaGlwPzogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHJvb21NZW1iZXJzaGlwID0gcm9vbS5nZXRNeU1lbWJlcnNoaXAoKTtcbiAgICAgICAgaWYgKCFyb29tTWVtYmVyc2hpcCkge1xuICAgICAgICAgICAgLy8gcm9vbSBpcyBzdGlsbCBiZWluZyBiYWtlZCBpbiB0aGUganMtc2RrLCB3ZSdsbCBwcm9jZXNzIGl0IGF0IFJvb20ubXlNZW1iZXJzaGlwIGluc3RlYWRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZW1iZXJzaGlwID0gbmV3TWVtYmVyc2hpcCB8fCByb29tTWVtYmVyc2hpcDtcblxuICAgICAgICBpZiAoIXJvb20uaXNTcGFjZVJvb20oKSkge1xuICAgICAgICAgICAgLy8gdGhpcy5vblJvb21VcGRhdGUocm9vbSk7XG4gICAgICAgICAgICAvLyB0aGlzLm9uUm9vbXNVcGRhdGUoKTtcbiAgICAgICAgICAgIC8vIGlkZWFsbHkgd2Ugb25seSBuZWVkIG9uUm9vbXNVcGRhdGUgaGVyZSBidXQgaXQgZG9lc24ndCByZWJ1aWxkIHBhcmVudE1hcCBzbyBhbHdheXMgYWRkcyBuZXcgcm9vbXMgdG8gSG9tZVxuICAgICAgICAgICAgdGhpcy5yZWJ1aWxkKCk7XG5cbiAgICAgICAgICAgIGlmIChtZW1iZXJzaGlwID09PSBcImpvaW5cIikge1xuICAgICAgICAgICAgICAgIC8vIHRoZSB1c2VyIGp1c3Qgam9pbmVkIGEgcm9vbSwgcmVtb3ZlIGl0IGZyb20gdGhlIHN1Z2dlc3RlZCBsaXN0IGlmIGl0IHdhcyB0aGVyZVxuICAgICAgICAgICAgICAgIGNvbnN0IG51bVN1Z2dlc3RlZFJvb21zID0gdGhpcy5fc3VnZ2VzdGVkUm9vbXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N1Z2dlc3RlZFJvb21zID0gdGhpcy5fc3VnZ2VzdGVkUm9vbXMuZmlsdGVyKHIgPT4gci5yb29tX2lkICE9PSByb29tLnJvb21JZCk7XG4gICAgICAgICAgICAgICAgaWYgKG51bVN1Z2dlc3RlZFJvb21zICE9PSB0aGlzLl9zdWdnZXN0ZWRSb29tcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFVQREFURV9TVUdHRVNURURfUk9PTVMsIHRoaXMuX3N1Z2dlc3RlZFJvb21zKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcm9vbSBjdXJyZW50bHkgYmVpbmcgdmlld2VkIHdhcyBqdXN0IGpvaW5lZCB0aGVuIHN3aXRjaCB0byBpdHMgcmVsYXRlZCBzcGFjZVxuICAgICAgICAgICAgICAgIGlmIChuZXdNZW1iZXJzaGlwID09PSBcImpvaW5cIiAmJiByb29tLnJvb21JZCA9PT0gUm9vbVZpZXdTdG9yZS5nZXRSb29tSWQoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN3aXRjaFRvUmVsYXRlZFNwYWNlKHJvb20ucm9vbUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTcGFjZVxuICAgICAgICBpZiAobWVtYmVyc2hpcCA9PT0gXCJpbnZpdGVcIikge1xuICAgICAgICAgICAgdGhpcy5faW52aXRlZFNwYWNlcy5hZGQocm9vbSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoVVBEQVRFX0lOVklURURfU1BBQ0VTLCB0aGlzLmludml0ZWRTcGFjZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKG9sZE1lbWJlcnNoaXAgPT09IFwiaW52aXRlXCIgJiYgbWVtYmVyc2hpcCAhPT0gXCJqb2luXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludml0ZWRTcGFjZXMuZGVsZXRlKHJvb20pO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFVQREFURV9JTlZJVEVEX1NQQUNFUywgdGhpcy5pbnZpdGVkU3BhY2VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25TcGFjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KHJvb20ucm9vbUlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZW1iZXJzaGlwID09PSBcImpvaW5cIiAmJiByb29tLnJvb21JZCA9PT0gUm9vbVZpZXdTdG9yZS5nZXRSb29tSWQoKSkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHVzZXIgd2FzIGxvb2tpbmcgYXQgdGhlIHNwYWNlIGFuZCB0aGVuIGpvaW5lZDogc2VsZWN0IHRoYXQgc3BhY2VcbiAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlU3BhY2Uocm9vbS5yb29tSWQsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChtZW1iZXJzaGlwID09PSBcImxlYXZlXCIgJiYgcm9vbS5yb29tSWQgPT09IHRoaXMuYWN0aXZlU3BhY2UpIHtcbiAgICAgICAgICAgIC8vIHVzZXIncyBhY3RpdmUgc3BhY2UgaGFzIGdvbmUgYXdheSwgZ28gYmFjayB0byBob21lXG4gICAgICAgICAgICB0aGlzLmdvVG9GaXJzdFNwYWNlKHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByaXZhdGUgbm90aWZ5SWZPcmRlckNoYW5nZWQoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHJvb3RTcGFjZXMgPSB0aGlzLnNvcnRSb290U3BhY2VzKHRoaXMucm9vdFNwYWNlcyk7XG4gICAgICAgIGlmIChhcnJheUhhc09yZGVyQ2hhbmdlKHRoaXMucm9vdFNwYWNlcywgcm9vdFNwYWNlcykpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdFNwYWNlcyA9IHJvb3RTcGFjZXM7XG4gICAgICAgICAgICB0aGlzLmVtaXQoVVBEQVRFX1RPUF9MRVZFTF9TUEFDRVMsIHRoaXMuc3BhY2VQYW5lbFNwYWNlcywgdGhpcy5lbmFibGVkTWV0YVNwYWNlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIG9uUm9vbVN0YXRlID0gKGV2OiBNYXRyaXhFdmVudCkgPT4ge1xuICAgICAgICBjb25zdCByb29tID0gdGhpcy5tYXRyaXhDbGllbnQuZ2V0Um9vbShldi5nZXRSb29tSWQoKSk7XG4gICAgICAgIGlmICghcm9vbSkgcmV0dXJuO1xuXG4gICAgICAgIHN3aXRjaCAoZXYuZ2V0VHlwZSgpKSB7XG4gICAgICAgICAgICBjYXNlIEV2ZW50VHlwZS5TcGFjZUNoaWxkOlxuICAgICAgICAgICAgICAgIGlmIChyb29tLmlzU3BhY2VSb29tKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblNwYWNlVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChyb29tLnJvb21JZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJvb20ucm9vbUlkID09PSB0aGlzLmFjdGl2ZVNwYWNlICYmIC8vIGN1cnJlbnQgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRyaXhDbGllbnQuZ2V0Um9vbShldi5nZXRTdGF0ZUtleSgpKT8uZ2V0TXlNZW1iZXJzaGlwKCkgIT09IFwiam9pblwiICYmIC8vIHRhcmdldCBub3Qgam9pbmVkXG4gICAgICAgICAgICAgICAgICAgIGV2LmdldFByZXZDb250ZW50KCkuc3VnZ2VzdGVkICE9PSBldi5nZXRDb250ZW50KCkuc3VnZ2VzdGVkIC8vIHN1Z2dlc3RlZCBmbGFnIGNoYW5nZWRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkU3VnZ2VzdGVkUm9vbXMocm9vbSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgRXZlbnRUeXBlLlNwYWNlUGFyZW50OlxuICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVidWlsZCB0aGUgc3BhY2UgcGFyZW50IGFuZCBub3QgdGhlIHJvb20gLSBjaGVjayBwZXJtaXNzaW9ucz9cbiAgICAgICAgICAgICAgICAvLyBUT0RPIGNvbmZpcm0gdGhpcyBhZnRlciBpbXBsZW1lbnRpbmcgcGFyZW50aW5nIGJlaGF2aW91clxuICAgICAgICAgICAgICAgIGlmIChyb29tLmlzU3BhY2VSb29tKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblNwYWNlVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5hbGxSb29tc0luSG9tZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUm9vbVVwZGF0ZShyb29tKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KHJvb20ucm9vbUlkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBFdmVudFR5cGUuUm9vbVBvd2VyTGV2ZWxzOlxuICAgICAgICAgICAgICAgIGlmIChyb29tLmlzU3BhY2VSb29tKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblJvb21zVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIGxpc3RlbmluZyBmb3IgbS5yb29tLm1lbWJlciBldmVudHMgaW4gb25Sb29tU3RhdGUgYWJvdmUgZG9lc24ndCB3b3JrIGFzIHRoZSBNZW1iZXIgb2JqZWN0IGlzbid0IHVwZGF0ZWQgYnkgdGhlblxuICAgIHByaXZhdGUgb25Sb29tU3RhdGVNZW1iZXJzID0gKGV2OiBNYXRyaXhFdmVudCkgPT4ge1xuICAgICAgICBjb25zdCByb29tID0gdGhpcy5tYXRyaXhDbGllbnQuZ2V0Um9vbShldi5nZXRSb29tSWQoKSk7XG4gICAgICAgIGlmIChyb29tPy5pc1NwYWNlUm9vbSgpKSB7XG4gICAgICAgICAgICB0aGlzLm9uU3BhY2VNZW1iZXJzQ2hhbmdlKGV2KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcml2YXRlIG9uUm9vbUFjY291bnREYXRhID0gKGV2OiBNYXRyaXhFdmVudCwgcm9vbTogUm9vbSwgbGFzdEV2PzogTWF0cml4RXZlbnQpID0+IHtcbiAgICAgICAgaWYgKCFyb29tLmlzU3BhY2VSb29tKCkpIHJldHVybjtcblxuICAgICAgICBpZiAoZXYuZ2V0VHlwZSgpID09PSBFdmVudFR5cGUuU3BhY2VPcmRlcikge1xuICAgICAgICAgICAgdGhpcy5zcGFjZU9yZGVyTG9jYWxFY2hvTWFwLmRlbGV0ZShyb29tLnJvb21JZCk7IC8vIGNsZWFyIGFueSBsb2NhbCBlY2hvXG4gICAgICAgICAgICBjb25zdCBvcmRlciA9IGV2LmdldENvbnRlbnQoKT8ub3JkZXI7XG4gICAgICAgICAgICBjb25zdCBsYXN0T3JkZXIgPSBsYXN0RXY/LmdldENvbnRlbnQoKT8ub3JkZXI7XG4gICAgICAgICAgICBpZiAob3JkZXIgIT09IGxhc3RPcmRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5SWZPcmRlckNoYW5nZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChldi5nZXRUeXBlKCkgPT09IEV2ZW50VHlwZS5UYWcpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSByb29tIHdhcyBpbiBmYXZvdXJpdGVzIGFuZCBub3cgaXNuJ3Qgb3IgdGhlIG9wcG9zaXRlIHRoZW4gdXBkYXRlIGl0cyBwb3NpdGlvbiBpbiB0aGUgdHJlZXNcbiAgICAgICAgICAgIGNvbnN0IG9sZFRhZ3MgPSBsYXN0RXY/LmdldENvbnRlbnQoKT8udGFncyB8fCB7fTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1RhZ3MgPSBldi5nZXRDb250ZW50KCk/LnRhZ3MgfHwge307XG4gICAgICAgICAgICBpZiAoISFvbGRUYWdzW0RlZmF1bHRUYWdJRC5GYXZvdXJpdGVdICE9PSAhIW5ld1RhZ3NbRGVmYXVsdFRhZ0lELkZhdm91cml0ZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uUm9vbVVwZGF0ZShyb29tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcml2YXRlIG9uQWNjb3VudERhdGEgPSAoZXY6IE1hdHJpeEV2ZW50LCBwcmV2RXZlbnQ/OiBNYXRyaXhFdmVudCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuYWxsUm9vbXNJbkhvbWUgJiYgZXYuZ2V0VHlwZSgpID09PSBFdmVudFR5cGUuRGlyZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0Q29udGVudCA9IHByZXZFdmVudD8uZ2V0Q29udGVudCgpID8/IHt9O1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGV2LmdldENvbnRlbnQoKTtcblxuICAgICAgICAgICAgY29uc3QgZGlmZiA9IG9iamVjdERpZmY8UmVjb3JkPHN0cmluZywgc3RyaW5nW10+PihsYXN0Q29udGVudCwgY29udGVudCk7XG4gICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IGtleXMgd2hpY2ggY2hhbmdlZCBieSByZWZlcmVuY2Ugb25seSBieSBjaGVja2luZyB3aGV0aGVyIHRoZSBzZXRzIGRpZmZlclxuICAgICAgICAgICAgY29uc3QgY2hhbmdlZCA9IGRpZmYuY2hhbmdlZC5maWx0ZXIoayA9PiBhcnJheUhhc0RpZmYobGFzdENvbnRlbnRba10sIGNvbnRlbnRba10pKTtcbiAgICAgICAgICAgIC8vIERNIHRhZyBjaGFuZ2VzLCByZWZyZXNoIHJlbGV2YW50IHJvb21zXG4gICAgICAgICAgICBuZXcgU2V0KFsuLi5kaWZmLmFkZGVkLCAuLi5kaWZmLnJlbW92ZWQsIC4uLmNoYW5nZWRdKS5mb3JFYWNoKHJvb21JZCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm9vbSA9IHRoaXMubWF0cml4Q2xpZW50Py5nZXRSb29tKHJvb21JZCk7XG4gICAgICAgICAgICAgICAgaWYgKHJvb20pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblJvb21VcGRhdGUocm9vbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIGFzeW5jIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnJvb3RTcGFjZXMgPSBbXTtcbiAgICAgICAgdGhpcy5vcnBoYW5lZFJvb21zID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLnBhcmVudE1hcCA9IG5ldyBFbmhhbmNlZE1hcCgpO1xuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvblN0YXRlTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNwYWNlRmlsdGVyZWRSb29tcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fYWN0aXZlU3BhY2UgPSBNZXRhU3BhY2UuSG9tZTsgLy8gc2V0IHByb3Blcmx5IGJ5IG9uUmVhZHlcbiAgICAgICAgdGhpcy5fc3VnZ2VzdGVkUm9vbXMgPSBbXTtcbiAgICAgICAgdGhpcy5faW52aXRlZFNwYWNlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5fZW5hYmxlZE1ldGFTcGFjZXMgPSBbXTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgYXN5bmMgb25Ob3RSZWFkeSgpIHtcbiAgICAgICAgaWYgKCFTcGFjZVN0b3JlLnNwYWNlc0VuYWJsZWQpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMubWF0cml4Q2xpZW50KSB7XG4gICAgICAgICAgICB0aGlzLm1hdHJpeENsaWVudC5yZW1vdmVMaXN0ZW5lcihcIlJvb21cIiwgdGhpcy5vblJvb20pO1xuICAgICAgICAgICAgdGhpcy5tYXRyaXhDbGllbnQucmVtb3ZlTGlzdGVuZXIoXCJSb29tLm15TWVtYmVyc2hpcFwiLCB0aGlzLm9uUm9vbSk7XG4gICAgICAgICAgICB0aGlzLm1hdHJpeENsaWVudC5yZW1vdmVMaXN0ZW5lcihcIlJvb20uYWNjb3VudERhdGFcIiwgdGhpcy5vblJvb21BY2NvdW50RGF0YSk7XG4gICAgICAgICAgICB0aGlzLm1hdHJpeENsaWVudC5yZW1vdmVMaXN0ZW5lcihcIlJvb21TdGF0ZS5ldmVudHNcIiwgdGhpcy5vblJvb21TdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLm1hdHJpeENsaWVudC5yZW1vdmVMaXN0ZW5lcihcIlJvb21TdGF0ZS5tZW1iZXJzXCIsIHRoaXMub25Sb29tU3RhdGVNZW1iZXJzKTtcbiAgICAgICAgICAgIHRoaXMubWF0cml4Q2xpZW50LnJlbW92ZUxpc3RlbmVyKFwiYWNjb3VudERhdGFcIiwgdGhpcy5vbkFjY291bnREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGFzeW5jIG9uUmVhZHkoKSB7XG4gICAgICAgIGlmICghc3BhY2VzRW5hYmxlZCkgcmV0dXJuO1xuICAgICAgICB0aGlzLm1hdHJpeENsaWVudC5vbihcIlJvb21cIiwgdGhpcy5vblJvb20pO1xuICAgICAgICB0aGlzLm1hdHJpeENsaWVudC5vbihcIlJvb20ubXlNZW1iZXJzaGlwXCIsIHRoaXMub25Sb29tKTtcbiAgICAgICAgdGhpcy5tYXRyaXhDbGllbnQub24oXCJSb29tLmFjY291bnREYXRhXCIsIHRoaXMub25Sb29tQWNjb3VudERhdGEpO1xuICAgICAgICB0aGlzLm1hdHJpeENsaWVudC5vbihcIlJvb21TdGF0ZS5ldmVudHNcIiwgdGhpcy5vblJvb21TdGF0ZSk7XG4gICAgICAgIHRoaXMubWF0cml4Q2xpZW50Lm9uKFwiUm9vbVN0YXRlLm1lbWJlcnNcIiwgdGhpcy5vblJvb21TdGF0ZU1lbWJlcnMpO1xuICAgICAgICB0aGlzLm1hdHJpeENsaWVudC5vbihcImFjY291bnREYXRhXCIsIHRoaXMub25BY2NvdW50RGF0YSk7XG5cbiAgICAgICAgdGhpcy5tYXRyaXhDbGllbnQuZ2V0Q2FwYWJpbGl0aWVzKCkudGhlbihjYXBhYmlsaXRpZXMgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVzdHJpY3RlZEpvaW5SdWxlU3VwcG9ydCA9IGNhcGFiaWxpdGllc1xuICAgICAgICAgICAgICAgID8uW1wibS5yb29tX3ZlcnNpb25zXCJdPy5bXCJvcmcubWF0cml4Lm1zYzMyNDQucm9vbV9jYXBhYmlsaXRpZXNcIl0/LltcInJlc3RyaWN0ZWRcIl07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGVuYWJsZWRNZXRhU3BhY2VzID0gU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZShcIlNwYWNlcy5lbmFibGVkTWV0YVNwYWNlc1wiKTtcbiAgICAgICAgdGhpcy5fZW5hYmxlZE1ldGFTcGFjZXMgPSBtZXRhU3BhY2VPcmRlci5maWx0ZXIoayA9PiBlbmFibGVkTWV0YVNwYWNlc1trXSkgYXMgTWV0YVNwYWNlW107XG5cbiAgICAgICAgYXdhaXQgdGhpcy5vblNwYWNlVXBkYXRlKCk7IC8vIHRyaWdnZXIgYW4gaW5pdGlhbCB1cGRhdGVcblxuICAgICAgICAvLyByZXN0b3JlIHNlbGVjdGVkIHN0YXRlIGZyb20gbGFzdCBzZXNzaW9uIGlmIGFueSBhbmQgc3RpbGwgdmFsaWRcbiAgICAgICAgY29uc3QgbGFzdFNwYWNlSWQgPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oQUNUSVZFX1NQQUNFX0xTX0tFWSk7XG4gICAgICAgIGlmIChsYXN0U3BhY2VJZCAmJiAoXG4gICAgICAgICAgICBsYXN0U3BhY2VJZFswXSA9PT0gXCIhXCIgPyB0aGlzLm1hdHJpeENsaWVudC5nZXRSb29tKGxhc3RTcGFjZUlkKSA6IGVuYWJsZWRNZXRhU3BhY2VzW2xhc3RTcGFjZUlkXVxuICAgICAgICApKSB7XG4gICAgICAgICAgICAvLyBkb24ndCBjb250ZXh0IHN3aXRjaCBoZXJlIGFzIGl0IG1heSBicmVhayBwZXJtYWxpbmtzXG4gICAgICAgICAgICB0aGlzLnNldEFjdGl2ZVNwYWNlKGxhc3RTcGFjZUlkLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdvVG9GaXJzdFNwYWNlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdvVG9GaXJzdFNwYWNlKGNvbnRleHRTd2l0Y2ggPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnNldEFjdGl2ZVNwYWNlKHRoaXMuZW5hYmxlZE1ldGFTcGFjZXNbMF0gPz8gdGhpcy5zcGFjZVBhbmVsU3BhY2VzWzBdPy5yb29tSWQsIGNvbnRleHRTd2l0Y2gpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBhc3luYyBvbkFjdGlvbihwYXlsb2FkOiBBY3Rpb25QYXlsb2FkKSB7XG4gICAgICAgIGlmICghc3BhY2VzRW5hYmxlZCkgcmV0dXJuO1xuICAgICAgICBzd2l0Y2ggKHBheWxvYWQuYWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIFwidmlld19yb29tXCI6IHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBhdXRvLXN3aXRjaCByb29tcyB3aGVuIHJlYWN0aW5nIHRvIGEgY29udGV4dC1zd2l0Y2hcbiAgICAgICAgICAgICAgICAvLyBhcyB0aGlzIGlzIG5vdCBoZWxwZnVsIGFuZCBjYW4gY3JlYXRlIGxvb3BzIG9mIHJvb21zL3NwYWNlIHN3aXRjaGluZ1xuICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLmNvbnRleHRfc3dpdGNoKSBicmVhaztcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJvb21JZCA9IHBheWxvYWQucm9vbV9pZDtcbiAgICAgICAgICAgICAgICBjb25zdCByb29tID0gdGhpcy5tYXRyaXhDbGllbnQ/LmdldFJvb20ocm9vbUlkKTtcbiAgICAgICAgICAgICAgICBpZiAocm9vbT8uaXNTcGFjZVJvb20oKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBjb250ZXh0IHN3aXRjaCB3aGVuIG5hdmlnYXRpbmcgdG8gdGhlIHNwYWNlIHJvb21cbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgaXQgd2lsbCBjYXVzZSB5b3UgdG8gZW5kIHVwIGluIHRoZSB3cm9uZyByb29tXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlU3BhY2Uocm9vbS5yb29tSWQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgICAoIXRoaXMuYWxsUm9vbXNJbkhvbWUgfHwgdGhpcy5hY3RpdmVTcGFjZVswXSA9PT0gXCIhXCIpICYmXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLmdldFNwYWNlRmlsdGVyZWRSb29tSWRzKHRoaXMuYWN0aXZlU3BhY2UpLmhhcyhyb29tSWQpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3dpdGNoVG9SZWxhdGVkU3BhY2Uocm9vbUlkKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBQZXJzaXN0IGxhc3Qgdmlld2VkIHJvb20gZnJvbSBhIHNwYWNlXG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgYXdhaXQgc2V0QWN0aXZlU3BhY2UgYWJvdmUgYXMgd2Ugb25seSBjYXJlIGFib3V0IHRoaXMuYWN0aXZlU3BhY2UgYmVpbmcgdXAgdG8gZGF0ZVxuICAgICAgICAgICAgICAgIC8vIHN5bmNocm9ub3VzbHkgZm9yIHRoZSBiZWxvdyBjb2RlIC0gZXZlcnl0aGluZyBlbHNlIGNhbiBhbmQgc2hvdWxkIGJlIGFzeW5jLlxuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShnZXRTcGFjZUNvbnRleHRLZXkodGhpcy5hY3RpdmVTcGFjZSksIHBheWxvYWQucm9vbV9pZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgXCJ2aWV3X2hvbWVfcGFnZVwiOlxuICAgICAgICAgICAgICAgIGlmICghcGF5bG9hZC5jb250ZXh0X3N3aXRjaCAmJiB0aGlzLmVuYWJsZWRNZXRhU3BhY2VzLmluY2x1ZGVzKE1ldGFTcGFjZS5Ib21lKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEFjdGl2ZVNwYWNlKE1ldGFTcGFjZS5Ib21lLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShnZXRTcGFjZUNvbnRleHRLZXkodGhpcy5hY3RpdmVTcGFjZSksIFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcImFmdGVyX2xlYXZlX3Jvb21cIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYWN0aXZlU3BhY2VbMF0gPT09IFwiIVwiICYmIHBheWxvYWQucm9vbV9pZCA9PT0gdGhpcy5fYWN0aXZlU3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlciBoYXMgbGVmdCB0aGUgY3VycmVudCBzcGFjZSwgZ28gdG8gZmlyc3Qgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nb1RvRmlyc3RTcGFjZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBBY3Rpb24uU3dpdGNoU3BhY2U6IHtcbiAgICAgICAgICAgICAgICAvLyBNZXRhc3BhY2VzIHN0YXJ0IGF0IDEsIFNwYWNlcyBmb2xsb3dcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5udW0gPCAxIHx8IHBheWxvYWQubnVtID4gOSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtTWV0YVNwYWNlcyA9IHRoaXMuZW5hYmxlZE1ldGFTcGFjZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLm51bSA8PSBudW1NZXRhU3BhY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlU3BhY2UodGhpcy5lbmFibGVkTWV0YVNwYWNlc1twYXlsb2FkLm51bSAtIDFdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3BhY2VQYW5lbFNwYWNlcy5sZW5ndGggPiBwYXlsb2FkLm51bSAtIG51bU1ldGFTcGFjZXMgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlU3BhY2UodGhpcy5zcGFjZVBhbmVsU3BhY2VzW3BheWxvYWQubnVtIC0gbnVtTWV0YVNwYWNlcyAtIDFdLnJvb21JZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlIEFjdGlvbi5TZXR0aW5nVXBkYXRlZDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdVcGRhdGVkUGF5bG9hZCA9IHBheWxvYWQgYXMgU2V0dGluZ1VwZGF0ZWRQYXlsb2FkO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ1VwZGF0ZWRQYXlsb2FkLnNldHRpbmdOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJTcGFjZXMuYWxsUm9vbXNJbkhvbWVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFwiU3BhY2VzLmFsbFJvb21zSW5Ib21lXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYWxsUm9vbXNJbkhvbWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWxsUm9vbXNJbkhvbWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoVVBEQVRFX0hPTUVfQkVIQVZJT1VSLCB0aGlzLmFsbFJvb21zSW5Ib21lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYnVpbGQoKTsgLy8gcmVidWlsZCBldmVyeXRoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJTcGFjZXMuZW5hYmxlZE1ldGFTcGFjZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFwiU3BhY2VzLmVuYWJsZWRNZXRhU3BhY2VzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5hYmxlZE1ldGFTcGFjZXMgPSBtZXRhU3BhY2VPcmRlci5maWx0ZXIoayA9PiBuZXdWYWx1ZVtrXSkgYXMgTWV0YVNwYWNlW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJyYXlIYXNEaWZmKHRoaXMuX2VuYWJsZWRNZXRhU3BhY2VzLCBlbmFibGVkTWV0YVNwYWNlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbmFibGVkTWV0YVNwYWNlcyA9IGVuYWJsZWRNZXRhU3BhY2VzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGEgbWV0YXNwYWNlIGN1cnJlbnRseSBiZWluZyB2aWV3ZWQgd2FzIHJlbW92ZSwgZ28gdG8gYW5vdGhlciBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVTcGFjZVswXSAhPT0gXCIhXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWVuYWJsZWRNZXRhU3BhY2VzLmluY2x1ZGVzKHRoaXMuYWN0aXZlU3BhY2UgYXMgTWV0YVNwYWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdvVG9GaXJzdFNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChVUERBVEVfVE9QX0xFVkVMX1NQQUNFUywgdGhpcy5zcGFjZVBhbmVsU3BhY2VzLCB0aGlzLmVuYWJsZWRNZXRhU3BhY2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYnVpbGQoKTsgLy8gcmVidWlsZCBldmVyeXRoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXROb3RpZmljYXRpb25TdGF0ZShrZXk6IFNwYWNlS2V5KTogU3BhY2VOb3RpZmljYXRpb25TdGF0ZSB7XG4gICAgICAgIGlmICh0aGlzLm5vdGlmaWNhdGlvblN0YXRlTWFwLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub3RpZmljYXRpb25TdGF0ZU1hcC5nZXQoa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0YXRlID0gbmV3IFNwYWNlTm90aWZpY2F0aW9uU3RhdGUoa2V5LCBnZXRSb29tRm4pO1xuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvblN0YXRlTWFwLnNldChrZXksIHN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIC8vIHRyYXZlcnNlIHNwYWNlIHRyZWUgd2l0aCBERlMgY2FsbGluZyBmbiBvbiBlYWNoIHNwYWNlIGluY2x1ZGluZyB0aGUgZ2l2ZW4gcm9vdCBvbmUsXG4gICAgLy8gaWYgaW5jbHVkZVJvb21zIGlzIHRydWUgdGhlbiBmbiB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIGxlYWYgcm9vbSwgaWYgaXQgaXMgcHJlc2VudCBpbiBtdWx0aXBsZSBzdWItc3BhY2VzXG4gICAgLy8gdGhlbiBmbiB3aWxsIGJlIGNhbGxlZCB3aXRoIGl0IG11bHRpcGxlIHRpbWVzLlxuICAgIHB1YmxpYyB0cmF2ZXJzZVNwYWNlKFxuICAgICAgICBzcGFjZUlkOiBzdHJpbmcsXG4gICAgICAgIGZuOiAocm9vbUlkOiBzdHJpbmcpID0+IHZvaWQsXG4gICAgICAgIGluY2x1ZGVSb29tcyA9IGZhbHNlLFxuICAgICAgICBwYXJlbnRQYXRoPzogU2V0PHN0cmluZz4sXG4gICAgKSB7XG4gICAgICAgIGlmIChwYXJlbnRQYXRoICYmIHBhcmVudFBhdGguaGFzKHNwYWNlSWQpKSByZXR1cm47IC8vIHByZXZlbnQgY3ljbGVzXG5cbiAgICAgICAgZm4oc3BhY2VJZCk7XG5cbiAgICAgICAgY29uc3QgbmV3UGF0aCA9IG5ldyBTZXQocGFyZW50UGF0aCkuYWRkKHNwYWNlSWQpO1xuICAgICAgICBjb25zdCBbY2hpbGRTcGFjZXMsIGNoaWxkUm9vbXNdID0gcGFydGl0aW9uU3BhY2VzQW5kUm9vbXModGhpcy5nZXRDaGlsZHJlbihzcGFjZUlkKSk7XG5cbiAgICAgICAgaWYgKGluY2x1ZGVSb29tcykge1xuICAgICAgICAgICAgY2hpbGRSb29tcy5mb3JFYWNoKHIgPT4gZm4oci5yb29tSWQpKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZFNwYWNlcy5mb3JFYWNoKHMgPT4gdGhpcy50cmF2ZXJzZVNwYWNlKHMucm9vbUlkLCBmbiwgaW5jbHVkZVJvb21zLCBuZXdQYXRoKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRTcGFjZVRhZ09yZGVyaW5nID0gKHNwYWNlOiBSb29tKTogc3RyaW5nIHwgdW5kZWZpbmVkID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3BhY2VPcmRlckxvY2FsRWNob01hcC5oYXMoc3BhY2Uucm9vbUlkKSkgcmV0dXJuIHRoaXMuc3BhY2VPcmRlckxvY2FsRWNob01hcC5nZXQoc3BhY2Uucm9vbUlkKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkT3JkZXIoc3BhY2UuZ2V0QWNjb3VudERhdGEoRXZlbnRUeXBlLlNwYWNlT3JkZXIpPy5nZXRDb250ZW50KCk/Lm9yZGVyKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBzb3J0Um9vdFNwYWNlcyhzcGFjZXM6IFJvb21bXSk6IFJvb21bXSB7XG4gICAgICAgIHJldHVybiBzb3J0Qnkoc3BhY2VzLCBbdGhpcy5nZXRTcGFjZVRhZ09yZGVyaW5nLCBcInJvb21JZFwiXSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBzZXRSb290U3BhY2VPcmRlcihzcGFjZTogUm9vbSwgb3JkZXI6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICB0aGlzLnNwYWNlT3JkZXJMb2NhbEVjaG9NYXAuc2V0KHNwYWNlLnJvb21JZCwgb3JkZXIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5tYXRyaXhDbGllbnQuc2V0Um9vbUFjY291bnREYXRhKHNwYWNlLnJvb21JZCwgRXZlbnRUeXBlLlNwYWNlT3JkZXIsIHsgb3JkZXIgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiRmFpbGVkIHRvIHNldCByb290IHNwYWNlIG9yZGVyXCIsIGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3BhY2VPcmRlckxvY2FsRWNob01hcC5nZXQoc3BhY2Uucm9vbUlkKSA9PT0gb3JkZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwYWNlT3JkZXJMb2NhbEVjaG9NYXAuZGVsZXRlKHNwYWNlLnJvb21JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgbW92ZVJvb3RTcGFjZShmcm9tSW5kZXg6IG51bWJlciwgdG9JbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRPcmRlcnMgPSB0aGlzLnJvb3RTcGFjZXMubWFwKHRoaXMuZ2V0U3BhY2VUYWdPcmRlcmluZyk7XG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSByZW9yZGVyTGV4aWNvZ3JhcGhpY2FsbHkoY3VycmVudE9yZGVycywgZnJvbUluZGV4LCB0b0luZGV4KTtcblxuICAgICAgICBjaGFuZ2VzLmZvckVhY2goKHsgaW5kZXgsIG9yZGVyIH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0Um9vdFNwYWNlT3JkZXIodGhpcy5yb290U3BhY2VzW2luZGV4XSwgb3JkZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm5vdGlmeUlmT3JkZXJDaGFuZ2VkKCk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGFjZVN0b3JlIHtcbiAgICBwdWJsaWMgc3RhdGljIHNwYWNlc0VuYWJsZWQgPSBzcGFjZXNFbmFibGVkO1xuXG4gICAgcHJpdmF0ZSBzdGF0aWMgaW50ZXJuYWxJbnN0YW5jZSA9IG5ldyBTcGFjZVN0b3JlQ2xhc3MoKTtcblxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IGluc3RhbmNlKCk6IFNwYWNlU3RvcmVDbGFzcyB7XG4gICAgICAgIHJldHVybiBTcGFjZVN0b3JlLmludGVybmFsSW5zdGFuY2U7XG4gICAgfVxufVxuXG53aW5kb3cubXhTcGFjZVN0b3JlID0gU3BhY2VTdG9yZS5pbnN0YW5jZTtcbiJdfQ==