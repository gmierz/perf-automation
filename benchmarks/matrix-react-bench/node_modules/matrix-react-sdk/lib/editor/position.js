"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _offset = _interopRequireDefault(require("./offset"));

/*
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
class DocumentPosition {
  constructor(index, offset) {
    this.index = index;
    this.offset = offset;
  }

  compare(otherPos) {
    if (this.index === otherPos.index) {
      return this.offset - otherPos.offset;
    } else {
      return this.index - otherPos.index;
    }
  }

  iteratePartsBetween(other, model, callback) {
    if (this.index === -1 || other.index === -1) {
      return;
    }

    const [startPos, endPos] = this.compare(other) < 0 ? [this, other] : [other, this];

    if (startPos.index === endPos.index) {
      callback(model.parts[this.index], startPos.offset, endPos.offset);
    } else {
      const firstPart = model.parts[startPos.index];
      callback(firstPart, startPos.offset, firstPart.text.length);

      for (let i = startPos.index + 1; i < endPos.index; ++i) {
        const part = model.parts[i];
        callback(part, 0, part.text.length);
      }

      const lastPart = model.parts[endPos.index];
      callback(lastPart, 0, endPos.offset);
    }
  }

  forwardsWhile(model, predicate) {
    if (this.index === -1) {
      return this;
    }

    let {
      index,
      offset
    } = this;
    const {
      parts
    } = model;

    while (index < parts.length) {
      const part = parts[index];

      while (offset < part.text.length) {
        if (!predicate(index, offset, part)) {
          return new DocumentPosition(index, offset);
        }

        offset += 1;
      } // end reached


      if (index === parts.length - 1) {
        return new DocumentPosition(index, offset);
      } else {
        index += 1;
        offset = 0;
      }
    }
  }

  backwardsWhile(model, predicate) {
    if (this.index === -1) {
      return this;
    }

    let {
      index,
      offset
    } = this;
    const parts = model.parts;

    while (index >= 0) {
      const part = parts[index];

      while (offset > 0) {
        if (!predicate(index, offset - 1, part)) {
          return new DocumentPosition(index, offset);
        }

        offset -= 1;
      } // start reached


      if (index === 0) {
        return new DocumentPosition(index, offset);
      } else {
        index -= 1;
        offset = parts[index].text.length;
      }
    }
  }

  asOffset(model) {
    if (this.index === -1) {
      return new _offset.default(0, true);
    }

    let offset = 0;

    for (let i = 0; i < this.index; ++i) {
      offset += model.parts[i].text.length;
    }

    offset += this.offset;
    const lastPart = model.parts[this.index];
    const atEnd = !lastPart || offset >= lastPart.text.length; // if no last part, we're at the end

    return new _offset.default(offset, atEnd);
  }

  isAtEnd(model) {
    if (model.parts.length === 0) {
      return true;
    }

    const lastPartIdx = model.parts.length - 1;
    const lastPart = model.parts[lastPartIdx];
    return this.index === lastPartIdx && this.offset === lastPart.text.length;
  }

  isAtStart() {
    return this.index === 0 && this.offset === 0;
  }

}

exports.default = DocumentPosition;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9lZGl0b3IvcG9zaXRpb24udHMiXSwibmFtZXMiOlsiRG9jdW1lbnRQb3NpdGlvbiIsImNvbnN0cnVjdG9yIiwiaW5kZXgiLCJvZmZzZXQiLCJjb21wYXJlIiwib3RoZXJQb3MiLCJpdGVyYXRlUGFydHNCZXR3ZWVuIiwib3RoZXIiLCJtb2RlbCIsImNhbGxiYWNrIiwic3RhcnRQb3MiLCJlbmRQb3MiLCJwYXJ0cyIsImZpcnN0UGFydCIsInRleHQiLCJsZW5ndGgiLCJpIiwicGFydCIsImxhc3RQYXJ0IiwiZm9yd2FyZHNXaGlsZSIsInByZWRpY2F0ZSIsImJhY2t3YXJkc1doaWxlIiwiYXNPZmZzZXQiLCJEb2N1bWVudE9mZnNldCIsImF0RW5kIiwiaXNBdEVuZCIsImxhc3RQYXJ0SWR4IiwiaXNBdFN0YXJ0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFnQkE7O0FBaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWNlLE1BQU1BLGdCQUFOLENBQTRDO0FBQ3ZEQyxFQUFBQSxXQUFXLENBQWlCQyxLQUFqQixFQUFnREMsTUFBaEQsRUFBZ0U7QUFBQSxTQUEvQ0QsS0FBK0MsR0FBL0NBLEtBQStDO0FBQUEsU0FBaEJDLE1BQWdCLEdBQWhCQSxNQUFnQjtBQUMxRTs7QUFFTUMsRUFBQUEsT0FBTyxDQUFDQyxRQUFELEVBQXFDO0FBQy9DLFFBQUksS0FBS0gsS0FBTCxLQUFlRyxRQUFRLENBQUNILEtBQTVCLEVBQW1DO0FBQy9CLGFBQU8sS0FBS0MsTUFBTCxHQUFjRSxRQUFRLENBQUNGLE1BQTlCO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsYUFBTyxLQUFLRCxLQUFMLEdBQWFHLFFBQVEsQ0FBQ0gsS0FBN0I7QUFDSDtBQUNKOztBQUVNSSxFQUFBQSxtQkFBbUIsQ0FBQ0MsS0FBRCxFQUEwQkMsS0FBMUIsRUFBOENDLFFBQTlDLEVBQXdFO0FBQzlGLFFBQUks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TixDQUFZSSxDQUFaLEVBQWVGLElBQWYsQ0FBb0JDLE1BQTlCO0FBQ0g7O0FBQ0RaLElBQUFBLE1BQU0sSUFBSSxLQUFLQSxNQUFmO0FBQ0EsVUFBTWUsUUFBUSxHQUFHVixLQUFLLENBQUNJLEtBQU4sQ0FBWSxLQUFLVixLQUFqQixDQUFqQjtBQUNBLFVBQU1zQixLQUFLLEdBQUcsQ0FBQ04sUUFBRCxJQUFhZixNQUFNLElBQUllLFFBQVEsQ0FBQ0osSUFBVCxDQUFjQyxNQUFuRCxDQVZnRCxDQVVXOztBQUMzRCxXQUFPLElBQUlRLGVBQUosQ0FBbUJwQixNQUFuQixFQUEyQnFCLEtBQTNCLENBQVA7QUFDSDs7QUFFTUMsRUFBQUEsT0FBTyxDQUFDakIsS0FBRCxFQUE4QjtBQUN4QyxRQUFJQSxLQUFLLENBQUNJLEtBQU4sQ0FBWUcsTUFBWixLQUF1QixDQUEzQixFQUE4QjtBQUMxQixhQUFPLElBQVA7QUFDSDs7QUFDRCxVQUFNVyxXQUFXLEdBQUdsQixLQUFLLENBQUNJLEtBQU4sQ0FBWUcsTUFBWixHQUFxQixDQUF6QztBQUNBLFVBQU1HLFFBQVEsR0FBR1YsS0FBSyxDQUFDSSxLQUFOLENBQVljLFdBQVosQ0FBakI7QUFDQSxXQUFPLEtBQUt4QixLQUFMLEtBQWV3QixXQUFmLElBQThCLEtBQUt2QixNQUFMLEtBQWdCZSxRQUFRLENBQUNKLElBQVQsQ0FBY0MsTUFBbkU7QUFDSDs7QUFFTVksRUFBQUEsU0FBUyxHQUFZO0FBQ3hCLFdBQU8sS0FBS3pCLEtBQUwsS0FBZSxDQUFmLElBQW9CLEtBQUtDLE1BQUwsS0FBZ0IsQ0FBM0M7QUFDSDs7QUExR3NEIiwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE5IFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IERvY3VtZW50T2Zmc2V0IGZyb20gXCIuL29mZnNldFwiO1xuaW1wb3J0IEVkaXRvck1vZGVsIGZyb20gXCIuL21vZGVsXCI7XG5pbXBvcnQgeyBQYXJ0IH0gZnJvbSBcIi4vcGFydHNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBJUG9zaXRpb24ge1xuICAgIGluZGV4OiBudW1iZXI7XG4gICAgb2Zmc2V0OiBudW1iZXI7XG59XG5cbnR5cGUgQ2FsbGJhY2sgPSAocGFydDogUGFydCwgc3RhcnRJZHg6IG51bWJlciwgZW5kSWR4OiBudW1iZXIpID0+IHZvaWQ7XG5leHBvcnQgdHlwZSBQcmVkaWNhdGUgPSAoaW5kZXg6IG51bWJlciwgb2Zmc2V0OiBudW1iZXIsIHBhcnQ6IFBhcnQpID0+IGJvb2xlYW47XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvY3VtZW50UG9zaXRpb24gaW1wbGVtZW50cyBJUG9zaXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBpbmRleDogbnVtYmVyLCBwdWJsaWMgcmVhZG9ubHkgb2Zmc2V0OiBudW1iZXIpIHtcbiAgICB9XG5cbiAgICBwdWJsaWMgY29tcGFyZShvdGhlclBvczogRG9jdW1lbnRQb3NpdGlvbik6IG51bWJlciB7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09PSBvdGhlclBvcy5pbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0IC0gb3RoZXJQb3Mub2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXggLSBvdGhlclBvcy5pbmRleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBpdGVyYXRlUGFydHNCZXR3ZWVuKG90aGVyOiBEb2N1bWVudFBvc2l0aW9uLCBtb2RlbDogRWRpdG9yTW9kZWwsIGNhbGxiYWNrOiBDYWxsYmFjayk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PT0gLTEgfHwgb3RoZXIuaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3N0YXJ0UG9zLCBlbmRQb3NdID0gdGhpcy5jb21wYXJlKG90aGVyKSA8IDAgPyBbdGhpcywgb3RoZXJdIDogW290aGVyLCB0aGlzXTtcbiAgICAgICAgaWYgKHN0YXJ0UG9zLmluZGV4ID09PSBlbmRQb3MuaW5kZXgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG1vZGVsLnBhcnRzW3RoaXMuaW5kZXhdLCBzdGFydFBvcy5vZmZzZXQsIGVuZFBvcy5vZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RQYXJ0ID0gbW9kZWwucGFydHNbc3RhcnRQb3MuaW5kZXhdO1xuICAgICAgICAgICAgY2FsbGJhY2soZmlyc3RQYXJ0LCBzdGFydFBvcy5vZmZzZXQsIGZpcnN0UGFydC50ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRQb3MuaW5kZXggKyAxOyBpIDwgZW5kUG9zLmluZGV4OyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0ID0gbW9kZWwucGFydHNbaV07XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socGFydCwgMCwgcGFydC50ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsYXN0UGFydCA9IG1vZGVsLnBhcnRzW2VuZFBvcy5pbmRleF07XG4gICAgICAgICAgICBjYWxsYmFjayhsYXN0UGFydCwgMCwgZW5kUG9zLm9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgZm9yd2FyZHNXaGlsZShtb2RlbDogRWRpdG9yTW9kZWwsIHByZWRpY2F0ZTogUHJlZGljYXRlKTogRG9jdW1lbnRQb3NpdGlvbiB7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHBhcnRzIH0gPSBtb2RlbDtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgcGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaW5kZXhdO1xuICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IHBhcnQudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByZWRpY2F0ZShpbmRleCwgb2Zmc2V0LCBwYXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50UG9zaXRpb24oaW5kZXgsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZW5kIHJlYWNoZWRcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gKHBhcnRzLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFBvc2l0aW9uKGluZGV4LCBvZmZzZXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgYmFja3dhcmRzV2hpbGUobW9kZWw6IEVkaXRvck1vZGVsLCBwcmVkaWNhdGU6IFByZWRpY2F0ZSk6IERvY3VtZW50UG9zaXRpb24ge1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgcGFydHMgPSBtb2RlbC5wYXJ0cztcbiAgICAgICAgd2hpbGUgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1tpbmRleF07XG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICghcHJlZGljYXRlKGluZGV4LCBvZmZzZXQgLSAxLCBwYXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50UG9zaXRpb24oaW5kZXgsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3RhcnQgcmVhY2hlZFxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFBvc2l0aW9uKGluZGV4LCBvZmZzZXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmRleCAtPSAxO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHBhcnRzW2luZGV4XS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBhc09mZnNldChtb2RlbDogRWRpdG9yTW9kZWwpOiBEb2N1bWVudE9mZnNldCB7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudE9mZnNldCgwLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluZGV4OyArK2kpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSBtb2RlbC5wYXJ0c1tpXS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGNvbnN0IGxhc3RQYXJ0ID0gbW9kZWwucGFydHNbdGhpcy5pbmRleF07XG4gICAgICAgIGNvbnN0IGF0RW5kID0gIWxhc3RQYXJ0IHx8IG9mZnNldCA+PSBsYXN0UGFydC50ZXh0Lmxlbmd0aDsgLy8gaWYgbm8gbGFzdCBwYXJ0LCB3ZSdyZSBhdCB0aGUgZW5kXG4gICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRPZmZzZXQob2Zmc2V0LCBhdEVuZCk7XG4gICAgfVxuXG4gICAgcHVibGljIGlzQXRFbmQobW9kZWw6IEVkaXRvck1vZGVsKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChtb2RlbC5wYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3RQYXJ0SWR4ID0gbW9kZWwucGFydHMubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgbGFzdFBhcnQgPSBtb2RlbC5wYXJ0c1tsYXN0UGFydElkeF07XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4ID09PSBsYXN0UGFydElkeCAmJiB0aGlzLm9mZnNldCA9PT0gbGFzdFBhcnQudGV4dC5sZW5ndGg7XG4gICAgfVxuXG4gICAgcHVibGljIGlzQXRTdGFydCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXggPT09IDAgJiYgdGhpcy5vZmZzZXQgPT09IDA7XG4gICAgfVxufVxuIl19