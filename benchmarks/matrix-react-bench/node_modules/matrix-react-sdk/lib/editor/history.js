"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.MAX_STEP_LENGTH = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

/*
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
const MAX_STEP_LENGTH = 10;
exports.MAX_STEP_LENGTH = MAX_STEP_LENGTH;

class HistoryManager {
  constructor() {
    (0, _defineProperty2.default)(this, "stack", []);
    (0, _defineProperty2.default)(this, "newlyTypedCharCount", 0);
    (0, _defineProperty2.default)(this, "currentIndex", -1);
    (0, _defineProperty2.default)(this, "changedSinceLastPush", false);
    (0, _defineProperty2.default)(this, "lastCaret", null);
    (0, _defineProperty2.default)(this, "nonWordBoundarySinceLastPush", false);
    (0, _defineProperty2.default)(this, "addedSinceLastPush", false);
    (0, _defineProperty2.default)(this, "removedSinceLastPush", false);
  }

  clear() {
    this.stack = [];
    this.newlyTypedCharCount = 0;
    this.currentIndex = -1;
    this.changedSinceLastPush = false;
    this.lastCaret = null;
    this.nonWordBoundarySinceLastPush = false;
    this.addedSinceLastPush = false;
    this.removedSinceLastPush = false;
  }

  shouldPush(inputType, diff) {
    // right now we can only push a step after
    // the input has been applied to the model,
    // so we can't push the state before something happened.
    // not ideal but changing this would be harder to fit cleanly into
    // the editor model.
    const isNonBulkInput = inputType === "insertText" || inputType === "deleteContentForward" || inputType === "deleteContentBackward";

    if (diff && isNonBulkInput) {
      if (diff.added) {
        this.addedSinceLastPush = true;
      }

      if (diff.removed) {
        this.removedSinceLastPush = true;
      } // as long as you've only been adding or removing since the last push


      if (this.addedSinceLastPush !== this.removedSinceLastPush) {
        // add steps by word boundary, up to MAX_STEP_LENGTH characters
        const str = diff.added ? diff.added : diff.removed;
        const isWordBoundary = str === " " || str === "\t" || str === "\n";

        if (this.nonWordBoundarySinceLastPush && isWordBoundary) {
          return true;
        }

        if (!isWordBoundary) {
          this.nonWordBoundarySinceLastPush = true;
        }

        this.newlyTypedCharCount += str.length;
        return this.newlyTypedCharCount > MAX_STEP_LENGTH;
      } else {
        // if starting to remove while adding before, or the opposite, push
        return true;
      }
    } else {
      // bulk input (paste, ...) should be pushed every time
      return true;
    }
  }

  pushState(model, caret) {
    // remove all steps after current step
    while (this.currentIndex < this.stack.length - 1) {
      this.stack.pop();
    }

    const parts = model.serializeParts();
    this.stack.push({
      parts,
      caret
    });
    this.currentIndex = this.stack.length - 1;
    this.lastCaret = null;
    this.changedSinceLastPush = false;
    this.newlyTypedCharCount = 0;
    this.nonWordBoundarySinceLastPush = false;
    this.addedSinceLastPush = false;
    this.removedSinceLastPush = false;
  } // needs to persist parts and caret position


  tryPush(model, caret, inputType, diff) {
    // ignore state restoration echos.
    // these respect the inputType values of the input event,
    // but are actually passed in from MessageEditor calling model.reset()
    // in the keydown event handler.
    if (inputType === "historyUndo" || inputType === "historyRedo") {
      return false;
    }

    const shouldPush = this.shouldPush(inputType, diff);

    if (shouldPush) {
      this.pushState(model, caret);
    } else {
      this.lastCaret = caret;
      this.changedSinceLastPush = true;
    }

    return shouldPush;
  }

  ensureLastChangesPushed(model) {
    if (this.changedSinceLastPush) {
      this.pushState(model, this.lastCaret);
    }
  }

  canUndo() {
    return this.currentIndex >= 1 || this.changedSinceLastPush;
  }

  canRedo() {
    return this.currentIndex < this.stack.length - 1;
  } // returns state that should be applied to model


  undo(model) {
    if (this.canUndo()) {
      this.ensureLastChangesPushed(model);
      this.currentIndex -= 1;
      return this.stack[this.currentIndex];
    }
  } // returns state that should be applied to model


  redo() {
    if (this.canRedo()) {
      this.changedSinceLastPush = false;
      this.currentIndex += 1;
      return this.stack[this.currentIndex];
    }
  }

}

exports.default = HistoryManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9lZGl0b3IvaGlzdG9yeS50cyJdLCJuYW1lcyI6WyJNQVhfU1RFUF9MRU5HVEgiLCJIaXN0b3J5TWFuYWdlciIsImNsZWFyIiwic3RhY2siLCJuZXdseVR5cGVkQ2hhckNvdW50IiwiY3VycmVudEluZGV4IiwiY2hhbmdlZFNpbmNlTGFzdFB1c2giLCJsYXN0Q2FyZXQiLCJub25Xb3JkQm91bmRhcnlTaW5jZUxhc3RQdXNoIiwiYWRkZWRTaW5jZUxhc3RQdXNoIiwicmVtb3ZlZFNpbmNlTGFzdFB1c2giLCJzaG91bGRQdXNoIiwiaW5wdXRUeXBlIiwiZGlmZiIsImlzTm9uQnVsa0lucHV0IiwiYWRkZWQiLCJyZW1vdmVkIiwic3RyIiwiaXNXb3JkQm91bmRhcnkiLCJsZW5ndGgiLCJwdXNoU3RhdGUiLCJtb2RlbCIsImNhcmV0IiwicG9wIiwicGFydHMiLCJzZXJpYWxpemVQYXJ0cyIsInB1c2giLCJ0cnlQdXNoIiwiZW5zdXJlTGFzdENoYW5nZXNQdXNoZWQiLCJjYW5VbmRvIiwiY2FuUmVkbyIsInVuZG8iLCJyZWRvIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVlPLE1BQU1BLGVBQWUsR0FBRyxFQUF4Qjs7O0FBRVEsTUFBTUMsY0FBTixDQUFxQjtBQUFBO0FBQUEsaURBQ0osRUFESTtBQUFBLCtEQUVGLENBRkU7QUFBQSx3REFHVCxDQUFDLENBSFE7QUFBQSxnRUFJRCxLQUpDO0FBQUEscURBS0wsSUFMSztBQUFBLHdFQU1PLEtBTlA7QUFBQSw4REFPSCxLQVBHO0FBQUEsZ0VBUUQsS0FSQztBQUFBOztBQVV6QkMsRUFBQUEsS0FBSyxHQUFTO0FBQ2pCLFNBQUtDLEtBQUwsR0FBYSxFQUFiO0FBQ0EsU0FBS0MsbUJBQUwsR0FBMkIsQ0FBM0I7QUFDQSxTQUFLQyxZQUFMLEdBQW9CLENBQUMsQ0FB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LFNBQUwsQ0FBZUMsS0FBZixFQUFzQkMsS0FBdEI7QUFDSCxLQUZELE1BRU87QUFDSCxXQUFLZixTQUFMLEdBQWlCZSxLQUFqQjtBQUNBLFdBQUtoQixvQkFBTCxHQUE0QixJQUE1QjtBQUNIOztBQUNELFdBQU9LLFVBQVA7QUFDSDs7QUFFTWlCLEVBQUFBLHVCQUF1QixDQUFDUCxLQUFELEVBQTJCO0FBQ3JELFFBQUksS0FBS2Ysb0JBQVQsRUFBK0I7QUFDM0IsV0FBS2MsU0FBTCxDQUFlQyxLQUFmLEVBQXNCLEtBQUtkLFNBQTNCO0FBQ0g7QUFDSjs7QUFFTXNCLEVBQUFBLE9BQU8sR0FBWTtBQUN0QixXQUFPLEtBQUt4QixZQUFMLElBQXFCLENBQXJCLElBQTBCLEtBQUtDLG9CQUF0QztBQUNIOztBQUVNd0IsRUFBQUEsT0FBTyxHQUFZO0FBQ3RCLFdBQU8sS0FBS3pCLFlBQUwsR0FBcUIsS0FBS0YsS0FBTCxDQUFXZ0IsTUFBWCxHQUFvQixDQUFoRDtBQUNILEdBM0crQixDQTZHaEM7OztBQUNPWSxFQUFBQSxJQUFJLENBQUNWLEtBQUQsRUFBK0I7QUFDdEMsUUFBSSxLQUFLUSxPQUFMLEVBQUosRUFBb0I7QUFDaEIsV0FBS0QsdUJBQUwsQ0FBNkJQLEtBQTdCO0FBQ0EsV0FBS2hCLFlBQUwsSUFBcUIsQ0FBckI7QUFDQSxhQUFPLEtBQUtGLEtBQUwsQ0FBVyxLQUFLRSxZQUFoQixDQUFQO0FBQ0g7QUFDSixHQXBIK0IsQ0FzSGhDOzs7QUFDTzJCLEVBQUFBLElBQUksR0FBYTtBQUNwQixRQUFJLEtBQUtGLE9BQUwsRUFBSixFQUFvQjtBQUNoQixXQUFLeEIsb0JBQUwsR0FBNEIsS0FBNUI7QUFDQSxXQUFLRCxZQUFMLElBQXFCLENBQXJCO0FBQ0EsYUFBTyxLQUFLRixLQUFMLENBQVcsS0FBS0UsWUFBaEIsQ0FBUDtBQUNIO0FBQ0o7O0FBN0grQiIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxOSBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBFZGl0b3JNb2RlbCBmcm9tIFwiLi9tb2RlbFwiO1xuaW1wb3J0IHsgSURpZmYgfSBmcm9tIFwiLi9kaWZmXCI7XG5pbXBvcnQgeyBTZXJpYWxpemVkUGFydCB9IGZyb20gXCIuL3BhcnRzXCI7XG5pbXBvcnQgeyBDYXJldCB9IGZyb20gXCIuL2NhcmV0XCI7XG5cbmludGVyZmFjZSBJSGlzdG9yeSB7XG4gICAgcGFydHM6IFNlcmlhbGl6ZWRQYXJ0W107XG4gICAgY2FyZXQ6IENhcmV0O1xufVxuXG5leHBvcnQgY29uc3QgTUFYX1NURVBfTEVOR1RIID0gMTA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhpc3RvcnlNYW5hZ2VyIHtcbiAgICBwcml2YXRlIHN0YWNrOiBJSGlzdG9yeVtdID0gW107XG4gICAgcHJpdmF0ZSBuZXdseVR5cGVkQ2hhckNvdW50ID0gMDtcbiAgICBwcml2YXRlIGN1cnJlbnRJbmRleCA9IC0xO1xuICAgIHByaXZhdGUgY2hhbmdlZFNpbmNlTGFzdFB1c2ggPSBmYWxzZTtcbiAgICBwcml2YXRlIGxhc3RDYXJldDogQ2FyZXQgPSBudWxsO1xuICAgIHByaXZhdGUgbm9uV29yZEJvdW5kYXJ5U2luY2VMYXN0UHVzaCA9IGZhbHNlO1xuICAgIHByaXZhdGUgYWRkZWRTaW5jZUxhc3RQdXNoID0gZmFsc2U7XG4gICAgcHJpdmF0ZSByZW1vdmVkU2luY2VMYXN0UHVzaCA9IGZhbHNlO1xuXG4gICAgcHVibGljIGNsZWFyKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIHRoaXMubmV3bHlUeXBlZENoYXJDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuY3VycmVudEluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuY2hhbmdlZFNpbmNlTGFzdFB1c2ggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sYXN0Q2FyZXQgPSBudWxsO1xuICAgICAgICB0aGlzLm5vbldvcmRCb3VuZGFyeVNpbmNlTGFzdFB1c2ggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hZGRlZFNpbmNlTGFzdFB1c2ggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZW1vdmVkU2luY2VMYXN0UHVzaCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2hvdWxkUHVzaChpbnB1dFR5cGUsIGRpZmYpIHtcbiAgICAgICAgLy8gcmlnaHQgbm93IHdlIGNhbiBvbmx5IHB1c2ggYSBzdGVwIGFmdGVyXG4gICAgICAgIC8vIHRoZSBpbnB1dCBoYXMgYmVlbiBhcHBsaWVkIHRvIHRoZSBtb2RlbCxcbiAgICAgICAgLy8gc28gd2UgY2FuJ3QgcHVzaCB0aGUgc3RhdGUgYmVmb3JlIHNvbWV0aGluZyBoYXBwZW5lZC5cbiAgICAgICAgLy8gbm90IGlkZWFsIGJ1dCBjaGFuZ2luZyB0aGlzIHdvdWxkIGJlIGhhcmRlciB0byBmaXQgY2xlYW5seSBpbnRvXG4gICAgICAgIC8vIHRoZSBlZGl0b3IgbW9kZWwuXG4gICAgICAgIGNvbnN0IGlzTm9uQnVsa0lucHV0ID0gaW5wdXRUeXBlID09PSBcImluc2VydFRleHRcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VHlwZSA9PT0gXCJkZWxldGVDb250ZW50Rm9yd2FyZFwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRUeXBlID09PSBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiO1xuICAgICAgICBpZiAoZGlmZiAmJiBpc05vbkJ1bGtJbnB1dCkge1xuICAgICAgICAgICAgaWYgKGRpZmYuYWRkZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZGVkU2luY2VMYXN0UHVzaCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlmZi5yZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVkU2luY2VMYXN0UHVzaCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhcyBsb25nIGFzIHlvdSd2ZSBvbmx5IGJlZW4gYWRkaW5nIG9yIHJlbW92aW5nIHNpbmNlIHRoZSBsYXN0IHB1c2hcbiAgICAgICAgICAgIGlmICh0aGlzLmFkZGVkU2luY2VMYXN0UHVzaCAhPT0gdGhpcy5yZW1vdmVkU2luY2VMYXN0UHVzaCkge1xuICAgICAgICAgICAgICAgIC8vIGFkZCBzdGVwcyBieSB3b3JkIGJvdW5kYXJ5LCB1cCB0byBNQVhfU1RFUF9MRU5HVEggY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0ciA9IGRpZmYuYWRkZWQgPyBkaWZmLmFkZGVkIDogZGlmZi5yZW1vdmVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzV29yZEJvdW5kYXJ5ID0gc3RyID09PSBcIiBcIiB8fCBzdHIgPT09IFwiXFx0XCIgfHwgc3RyID09PSBcIlxcblwiO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vbldvcmRCb3VuZGFyeVNpbmNlTGFzdFB1c2ggJiYgaXNXb3JkQm91bmRhcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNXb3JkQm91bmRhcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub25Xb3JkQm91bmRhcnlTaW5jZUxhc3RQdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5uZXdseVR5cGVkQ2hhckNvdW50ICs9IHN0ci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV3bHlUeXBlZENoYXJDb3VudCA+IE1BWF9TVEVQX0xFTkdUSDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgc3RhcnRpbmcgdG8gcmVtb3ZlIHdoaWxlIGFkZGluZyBiZWZvcmUsIG9yIHRoZSBvcHBvc2l0ZSwgcHVzaFxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gYnVsayBpbnB1dCAocGFzdGUsIC4uLikgc2hvdWxkIGJlIHB1c2hlZCBldmVyeSB0aW1lXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcHVzaFN0YXRlKG1vZGVsOiBFZGl0b3JNb2RlbCwgY2FyZXQ6IENhcmV0KSB7XG4gICAgICAgIC8vIHJlbW92ZSBhbGwgc3RlcHMgYWZ0ZXIgY3VycmVudCBzdGVwXG4gICAgICAgIHdoaWxlICh0aGlzLmN1cnJlbnRJbmRleCA8ICh0aGlzLnN0YWNrLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnRzID0gbW9kZWwuc2VyaWFsaXplUGFydHMoKTtcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKHsgcGFydHMsIGNhcmV0IH0pO1xuICAgICAgICB0aGlzLmN1cnJlbnRJbmRleCA9IHRoaXMuc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgdGhpcy5sYXN0Q2FyZXQgPSBudWxsO1xuICAgICAgICB0aGlzLmNoYW5nZWRTaW5jZUxhc3RQdXNoID0gZmFsc2U7XG4gICAgICAgIHRoaXMubmV3bHlUeXBlZENoYXJDb3VudCA9IDA7XG4gICAgICAgIHRoaXMubm9uV29yZEJvdW5kYXJ5U2luY2VMYXN0UHVzaCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFkZGVkU2luY2VMYXN0UHVzaCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlbW92ZWRTaW5jZUxhc3RQdXNoID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gbmVlZHMgdG8gcGVyc2lzdCBwYXJ0cyBhbmQgY2FyZXQgcG9zaXRpb25cbiAgICBwdWJsaWMgdHJ5UHVzaChtb2RlbDogRWRpdG9yTW9kZWwsIGNhcmV0OiBDYXJldCwgaW5wdXRUeXBlOiBzdHJpbmcsIGRpZmY6IElEaWZmKTogYm9vbGVhbiB7XG4gICAgICAgIC8vIGlnbm9yZSBzdGF0ZSByZXN0b3JhdGlvbiBlY2hvcy5cbiAgICAgICAgLy8gdGhlc2UgcmVzcGVjdCB0aGUgaW5wdXRUeXBlIHZhbHVlcyBvZiB0aGUgaW5wdXQgZXZlbnQsXG4gICAgICAgIC8vIGJ1dCBhcmUgYWN0dWFsbHkgcGFzc2VkIGluIGZyb20gTWVzc2FnZUVkaXRvciBjYWxsaW5nIG1vZGVsLnJlc2V0KClcbiAgICAgICAgLy8gaW4gdGhlIGtleWRvd24gZXZlbnQgaGFuZGxlci5cbiAgICAgICAgaWYgKGlucHV0VHlwZSA9PT0gXCJoaXN0b3J5VW5kb1wiIHx8IGlucHV0VHlwZSA9PT0gXCJoaXN0b3J5UmVkb1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2hvdWxkUHVzaCA9IHRoaXMuc2hvdWxkUHVzaChpbnB1dFR5cGUsIGRpZmYpO1xuICAgICAgICBpZiAoc2hvdWxkUHVzaCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUobW9kZWwsIGNhcmV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGFzdENhcmV0ID0gY2FyZXQ7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWRTaW5jZUxhc3RQdXNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2hvdWxkUHVzaDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZW5zdXJlTGFzdENoYW5nZXNQdXNoZWQobW9kZWw6IEVkaXRvck1vZGVsKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmNoYW5nZWRTaW5jZUxhc3RQdXNoKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShtb2RlbCwgdGhpcy5sYXN0Q2FyZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGNhblVuZG8oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRJbmRleCA+PSAxIHx8IHRoaXMuY2hhbmdlZFNpbmNlTGFzdFB1c2g7XG4gICAgfVxuXG4gICAgcHVibGljIGNhblJlZG8oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRJbmRleCA8ICh0aGlzLnN0YWNrLmxlbmd0aCAtIDEpO1xuICAgIH1cblxuICAgIC8vIHJldHVybnMgc3RhdGUgdGhhdCBzaG91bGQgYmUgYXBwbGllZCB0byBtb2RlbFxuICAgIHB1YmxpYyB1bmRvKG1vZGVsOiBFZGl0b3JNb2RlbCk6IElIaXN0b3J5IHtcbiAgICAgICAgaWYgKHRoaXMuY2FuVW5kbygpKSB7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZUxhc3RDaGFuZ2VzUHVzaGVkKG1vZGVsKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEluZGV4IC09IDE7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLmN1cnJlbnRJbmRleF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIHN0YXRlIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gbW9kZWxcbiAgICBwdWJsaWMgcmVkbygpOiBJSGlzdG9yeSB7XG4gICAgICAgIGlmICh0aGlzLmNhblJlZG8oKSkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkU2luY2VMYXN0UHVzaCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50SW5kZXggKz0gMTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrW3RoaXMuY3VycmVudEluZGV4XTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==