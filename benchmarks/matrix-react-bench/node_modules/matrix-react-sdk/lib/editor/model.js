"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _diff = require("./diff");

var _position = _interopRequireDefault(require("./position"));

var _range = _interopRequireDefault(require("./range"));

/*
Copyright 2019 New Vector Ltd
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
class EditorModel {
  constructor(parts, partCreator, updateCallback = null) {
    this.updateCallback = updateCallback;
    (0, _defineProperty2.default)(this, "_parts", void 0);
    (0, _defineProperty2.default)(this, "_partCreator", void 0);
    (0, _defineProperty2.default)(this, "activePartIdx", null);
    (0, _defineProperty2.default)(this, "_autoComplete", null);
    (0, _defineProperty2.default)(this, "autoCompletePartIdx", null);
    (0, _defineProperty2.default)(this, "autoCompletePartCount", 0);
    (0, _defineProperty2.default)(this, "transformCallback", null);
    (0, _defineProperty2.default)(this, "onAutoComplete", ({
      replaceParts,
      close
    }) => {
      let pos;

      if (replaceParts) {
        this._parts.splice(this.autoCompletePartIdx, this.autoCompletePartCount, ...replaceParts);

        this.autoCompletePartCount = replaceParts.length;
        const lastPart = replaceParts[replaceParts.length - 1];
        const lastPartIndex = this.autoCompletePartIdx + replaceParts.length - 1;
        pos = new _position.default(lastPartIndex, lastPart.text.length);
      }

      if (close) {
        this._autoComplete = null;
        this.autoCompletePartIdx = null;
        this.autoCompletePartCount = 0;
      } // rerender even if editor contents didn't change
      // to make sure the MessageEditor checks
      // model.autoComplete being empty and closes it


      this.updateCallback(pos);
    });
    this._parts = parts;
    this._partCreator = partCreator;
    this.transformCallback = null;
  }
  /**
   * Set a callback for the transformation step.
   * While processing an update, right before calling the update callback,
   * a transform callback can be called, which serves to do modifications
   * on the model that can span multiple parts. Also see `startRange()`.
   * @param {TransformCallback} transformCallback
   */


  setTransformCallback(transformCallback) {
    this.transformCallback = transformCallback;
  }
  /**
   * Set a callback for rerendering the model after it has been updated.
   * @param {ModelCallback} updateCallback
   */


  setUpdateCallback(updateCallback) {
    this.updateCallback = updateCallback;
  }

  get partCreator() {
    return this._partCreator;
  }

  get isEmpty() {
    return this._parts.reduce((len, part) => len + part.text.length, 0) === 0;
  }

  clone() {
    const clonedParts = this.parts.map(p => this.partCreator.deserializePart(p.serialize()));
    return new EditorModel(clonedParts, this._partCreator, this.updateCallback);
  }

  insertPart(index, part) {
    this._parts.splice(index, 0, part);

    if (this.activePartIdx >= index) {
      ++this.activePartIdx;
    }

    if (this.autoCompletePartIdx >= index) {
      ++this.autoCompletePartIdx;
    }
  }

  removePart(index) {
    this._parts.splice(index, 1);

    if (index === this.activePartIdx) {
      this.activePartIdx = null;
    } else if (this.activePartIdx > index) {
      --this.activePartIdx;
    }

    if (index === this.autoCompletePartIdx) {
      this.autoCompletePartIdx = null;
    } else if (this.autoCompletePartIdx > index) {
      --this.autoCompletePartIdx;
    }
  }

  replacePart(index, part) {
    this._parts.splice(index, 1, part);
  }

  get parts() {
    return this._parts;
  }

  get autoComplete() {
    if (this.activePartIdx === this.autoCompletePartIdx) {
      return this._autoComplete;
    }

    return null;
  }

  getPositionAtEnd() {
    if (this._parts.length) {
      const index = this._parts.length - 1;
      const part = this._parts[index];
      return new _position.default(index, part.text.length);
    } else {
      // part index -1, as there are no parts to point at
      return new _position.default(-1, 0);
    }
  }

  serializeParts() {
    return this._parts.map(p => p.serialize());
  }

  diff(newValue, inputType, caret) {
    const previousValue = this.parts.reduce((text, p) => text + p.text, ""); // can't use caret position with drag and drop

    if (inputType === "deleteByDrag") {
      return (0, _diff.diffDeletion)(previousValue, newValue);
    } else {
      return (0, _diff.diffAtCaret)(previousValue, newValue, caret.offset);
    }
  }

  reset(serializedParts, caret, inputType) {
    this._parts = serializedParts.map(p => this._partCreator.deserializePart(p));

    if (!caret) {
      caret = this.getPositionAtEnd();
    } // close auto complete if open
    // this would happen when clearing the composer after sending
    // a message with the autocomplete still open


    if (this._autoComplete) {
      this._autoComplete = null;
      this.autoCompletePartIdx = null;
    }

    this.updateCallback(caret, inputType);
  }
  /**
   * Inserts the given parts at the given position.
   * Should be run inside a `model.transform()` callback.
   * @param {Part[]} parts the parts to replace the range with
   * @param {DocumentPosition} position the position to start inserting at
   * @return {Number} the amount of characters added
   */


  insert(parts, position) {
    const insertIndex = this.splitAt(position);
    let newTextLength = 0;

    for (let i = 0; i < parts.length; ++i) {
      const part = parts[i];
      newTextLength += part.text.length;
      this.insertPart(insertIndex + i, part);
    }

    return newTextLength;
  }

  update(newValue, inputType, caret) {
    const diff = this.diff(newValue, inputType, caret);
    const position = this.positionForOffset(diff.at, caret.atNodeEnd);
    let removedOffsetDecrease = 0;

    if (diff.removed) {
      removedOffsetDecrease = this.removeText(position, diff.removed.length);
    }

    let addedLen = 0;

    if (diff.added) {
      addedLen = this.addText(position, diff.added, inputType);
    }

    this.mergeAdjacentParts();
    const caretOffset = diff.at - removedOffsetDecrease + addedLen;
    let newPosition = this.positionForOffset(caretOffset, true);
    const canOpenAutoComplete = inputType !== "insertFromPaste" && inputType !== "insertFromDrop";
    const acPromise = this.setActivePart(newPosition, canOpenAutoComplete);

    if (this.transformCallback) {
      const transformAddedLen = this.getTransformAddedLen(newPosition, inputType, diff);
      newPosition = this.positionForOffset(caretOffset + transformAddedLen, true);
    }

    this.updateCallback(newPosition, inputType, diff);
    return acPromise;
  }

  getTransformAddedLen(newPosition, inputType, diff) {
    const result = this.transformCallback(newPosition, inputType, diff);
    return Number.isFinite(result) ? result : 0;
  }

  setActivePart(pos, canOpenAutoComplete) {
    const {
      index
    } = pos;
    const part = this._parts[index];

    if (part) {
      if (index !== this.activePartIdx) {
        this.activePartIdx = index;

        if (canOpenAutoComplete && this.activePartIdx !== this.autoCompletePartIdx) {
          // else try to create one
          const ac = part.createAutoComplete(this.onAutoComplete);

          if (ac) {
            // make sure that react picks up the difference between both acs
            this._autoComplete = ac;
            this.autoCompletePartIdx = index;
            this.autoCompletePartCount = 1;
          }
        }
      } // not autoComplete, only there if active part is autocomplete part


      if (this.autoComplete) {
        return this.autoComplete.onPartUpdate(part, pos);
      }
    } else {
      this.activePartIdx = null;
      this._autoComplete = null;
      this.autoCompletePartIdx = null;
      this.autoCompletePartCount = 0;
    }

    return Promise.resolve();
  }

  mergeAdjacentParts() {
    let prevPart;

    for (let i = 0; i < this._parts.length; ++i) {
      let part = this._parts[i];
      const isEmpty = !part.text.length;
      const isMerged = !isEmpty && prevPart && prevPart.merge(part);

      if (isEmpty || isMerged) {
        // remove empty or merged part
        part = prevPart;
        this.removePart(i); //repeat this index, as it's removed now

        --i;
      }

      prevPart = part;
    }
  }
  /**
   * removes `len` amount of characters at `pos`.
   * @param {Object} pos
   * @param {Number} len
   * @return {Number} how many characters before pos were also removed,
   * usually because of non-editable parts that can only be removed in their entirety.
   */


  removeText(pos, len) {
    let {
      index,
      offset
    } = pos;
    let removedOffsetDecrease = 0;

    while (len > 0) {
      // part might be undefined here
      let part = this._parts[index];
      const amount = Math.min(len, part.text.length - offset); // don't allow 0 amount deletions

      if (amount) {
        if (part.canEdit) {
          const replaceWith = part.remove(offset, amount);

          if (typeof replaceWith === "string") {
            this.replacePart(index, this._partCreator.createDefaultPart(replaceWith));
          }

          part = this._parts[index]; // remove empty part

          if (!part.text.length) {
            this.removePart(index);
          } else {
            index += 1;
          }
        } else {
          removedOffsetDecrease += offset;
          this.removePart(index);
        }
      } else {
        index += 1;
      }

      len -= amount;
      offset = 0;
    }

    return removedOffsetDecrease;
  } // return part index where insertion will insert between at offset


  splitAt(pos) {
    if (pos.index === -1) {
      return 0;
    }

    if (pos.offset === 0) {
      return pos.index;
    }

    const part = this._parts[pos.index];

    if (pos.offset >= part.text.length) {
      return pos.index + 1;
    }

    const secondPart = part.split(pos.offset);
    this.insertPart(pos.index + 1, secondPart);
    return pos.index + 1;
  }
  /**
   * inserts `str` into the model at `pos`.
   * @param {Object} pos
   * @param {string} str
   * @param {string} inputType the source of the input, see html InputEvent.inputType
   * @param {bool} options.validate Whether characters will be validated by the part.
   *                                Validating allows the inserted text to be parsed according to the part rules.
   * @return {Number} how far from position (in characters) the insertion ended.
   * This can be more than the length of `str` when crossing non-editable parts, which are skipped.
   */


  addText(pos, str, inputType) {
    let {
      index
    } = pos;
    const {
      offset
    } = pos;
    let addLen = str.length;
    const part = this._parts[index];

    if (part) {
      if (part.canEdit) {
        if (part.validateAndInsert(offset, str, inputType)) {
          str = null;
        } else {
          const splitPart = part.split(offset);
          index += 1;
          this.insertPart(index, splitPart);
        }
      } else if (offset !== 0) {
        // not-editable part, caret is not at start,
        // so insert str after this part
        addLen += part.text.length - offset;
        index += 1;
      }
    } else if (index < 0) {
      // if position was not found (index: -1, as happens for empty editor)
      // reset it to insert as first part
      index = 0;
    }

    while (str) {
      const newPart = this._partCreator.createPartForInput(str, index, inputType);

      str = newPart.appendUntilRejected(str, inputType);
      this.insertPart(index, newPart);
      index += 1;
    }

    return addLen;
  }

  positionForOffset(totalOffset, atPartEnd = false) {
    let currentOffset = 0;

    const index = this._parts.findIndex(part => {
      const partLen = part.text.length;

      if (atPartEnd && currentOffset + partLen >= totalOffset || !atPartEnd && currentOffset + partLen > totalOffset) {
        return true;
      }

      currentOffset += partLen;
      return false;
    });

    if (index === -1) {
      return this.getPositionAtEnd();
    } else {
      return new _position.default(index, totalOffset - currentOffset);
    }
  }
  /**
   * Starts a range, which can span across multiple parts, to find and replace text.
   * @param {DocumentPosition} positionA a boundary of the range
   * @param {DocumentPosition?} positionB the other boundary of the range, optional
   * @return {Range}
   */


  startRange(positionA, positionB = positionA) {
    return new _range.default(this, positionA, positionB);
  }

  replaceRange(startPosition, endPosition, parts) {
    // convert end position to offset, so it is independent of how the document is split into parts
    // which we'll change when splitting up at the start position
    const endOffset = endPosition.asOffset(this);
    const newStartPartIndex = this.splitAt(startPosition); // convert it back to position once split at start

    endPosition = endOffset.asPosition(this);
    const newEndPartIndex = this.splitAt(endPosition);

    for (let i = newEndPartIndex - 1; i >= newStartPartIndex; --i) {
      this.removePart(i);
    }

    let insertIdx = newStartPartIndex;

    for (const part of parts) {
      this.insertPart(insertIdx, part);
      insertIdx += 1;
    }

    this.mergeAdjacentParts();
  }
  /**
   * Performs a transformation not part of an update cycle.
   * Modifying the model should only happen inside a transform call if not part of an update call.
   * @param {ManualTransformCallback} callback to run the transformations in
   * @return {Promise} a promise when auto-complete (if applicable) is done updating
   */


  transform(callback) {
    const pos = callback();
    let acPromise = null;

    if (!(pos instanceof _range.default)) {
      acPromise = this.setActivePart(pos, true);
    } else {
      acPromise = Promise.resolve();
    }

    this.updateCallback(pos);
    return acPromise;
  }

}

exports.default = EditorModel;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9lZGl0b3IvbW9kZWwudHMiXSwibmFtZXMiOlsiRWRpdG9yTW9kZWwiLCJjb25zdHJ1Y3RvciIsInBhcnRzIiwicGFydENyZWF0b3IiLCJ1cGRhdGVDYWxsYmFjayIsInJlcGxhY2VQYXJ0cyIsImNsb3NlIiwicG9zIiwiX3BhcnRzIiwic3BsaWNlIiwiYXV0b0NvbXBsZXRlUGFydElkeCIsImF1dG9Db21wbGV0ZVBhcnRDb3VudCIsImxlbmd0aCIsImxhc3RQYXJ0IiwibGFzdFBhcnRJbmRleCIsIkRvY3VtZW50UG9zaXRpb24iLCJ0ZXh0IiwiX2F1dG9Db21wbGV0ZSIsIl9wYXJ0Q3JlYXRvciIsInRyYW5zZm9ybUNhbGxiYWNrIiwic2V0VHJhbnNmb3JtQ2FsbGJhY2siLCJzZXRVcGRhdGVDYWxsYmFjayIsImlzRW1wdHkiLCJyZWR1Y2UiLCJsZW4iLCJwYXJ0IiwiY2xvbmUiLCJjbG9uZWRQYXJ0cyIsIm1hcCIsInAiLCJkZXNlcmlhbGl6ZVBhcnQiLCJzZXJpYWxpemUiLCJpbnNlcnRQYXJ0IiwiaW5kZXgiLCJhY3RpdmVQYXJ0SWR4IiwicmVtb3ZlUGFydCIsInJlcGxhY2VQYXJ0IiwiYXV0b0NvbXBsZXRlIiwiZ2V0UG9zaXRpb25BdEVuZCIsInNlcmlhbGl6ZVBhcnRzIiwiZGlmZiIsIm5ld1ZhbHVlIiwiaW5wdXRUeXBlIiwiY2FyZXQiLCJwcmV2aW91c1ZhbHVlIiwib2Zmc2V0IiwicmVzZXQiLCJzZXJpYWxpemVkUGFydHMiLCJpbnNlcnQiLCJwb3NpdGlvbiIsImluc2VydEluZGV4Iiwic3BsaXRBdCIsIm5ld1RleHRMZW5ndGgiLCJpIiwidXBkYXRlIiwicG9zaXRpb25Gb3JPZmZzZXQiLCJhdCIsImF0Tm9kZUVuZCIsInJlbW92ZWRPZmZzZXREZWNyZWFzZSIsInJlbW92ZWQiLCJyZW1vdmVUZXh0IiwiYWRkZWRMZW4iLCJhZGRlZCIsImFkZFRleHQiLCJtZXJnZUFkamFjZW50UGFydHMiLCJjYXJldE9mZnNldCIsIm5ld1Bvc2l0aW9uIiwiY2FuT3BlbkF1dG9Db21wbGV0ZSIsImFjUHJvbWlzZSIsInNldEFjdGl2ZVBhcnQiLCJ0cmFuc2Zvcm1BZGRlZExlbiIsImdldFRyYW5zZm9ybUFkZGVkTGVuIiwicmVzdWx0IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJhYyIsImNyZWF0ZUF1dG9Db21wbGV0ZSIsIm9uQXV0b0NvbXBsZXRlIiwib25QYXJ0VXBkYXRlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJwcmV2UGFydCIsImlzTWVyZ2VkIiwibWVyZ2UiLCJhbW91bnQiLCJNYXRoIiwibWluIiwiY2FuRWRpdCIsInJlcGxhY2VXaXRoIiwicmVtb3ZlIiwiY3JlYXRlRGVmYXVsdFBhcnQiLCJzZWNvbmRQYXJ0Iiwic3BsaXQiLCJzdHIiLCJhZGRMZW4iLCJ2YWxpZGF0ZUFuZEluc2VydCIsInNwbGl0UGFydCIsIm5ld1BhcnQiLCJjcmVhdGVQYXJ0Rm9ySW5wdXQiLCJhcHBlbmRVbnRpbFJlamVjdGVkIiwidG90YWxPZmZzZXQiLCJhdFBhcnRFbmQiLCJjdXJyZW50T2Zmc2V0IiwiZmluZEluZGV4IiwicGFydExlbiIsInN0YXJ0UmFuZ2UiLCJwb3NpdGlvbkEiLCJwb3NpdGlvbkIiLCJSYW5nZSIsInJlcGxhY2VSYW5nZSIsInN0YXJ0UG9zaXRpb24iLCJlbmRQb3NpdGlvbiIsImVuZE9mZnNldCIsImFzT2Zmc2V0IiwibmV3U3RhcnRQYXJ0SW5kZXgiLCJhc1Bvc2l0aW9uIiwibmV3RW5kUGFydEluZGV4IiwiaW5zZXJ0SWR4IiwidHJhbnNmb3JtIiwiY2FsbGJhY2siXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBaUJBOztBQUNBOztBQUNBOztBQW5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW1DZSxNQUFNQSxXQUFOLENBQWtCO0FBUzdCQyxFQUFBQSxXQUFXLENBQUNDLEtBQUQsRUFBZ0JDLFdBQWhCLEVBQWtEQyxjQUE4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SUFBSSxDQUFiO0FBQ0g7O0FBQ0QsU0FBS3JELGtCQUFMO0FBQ0g7QUFFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNXc0QsRUFBQUEsU0FBUyxDQUFDQyxRQUFELEVBQW1EO0FBQy9ELFVBQU1oSCxHQUFHLEdBQUdnSCxRQUFRLEVBQXBCO0FBQ0EsUUFBSW5ELFNBQXdCLEdBQUcsSUFBL0I7O0FBQ0EsUUFBSSxFQUFFN0QsR0FBRyxZQUFZcUcsY0FBakIsQ0FBSixFQUE2QjtBQUN6QnhDLE1BQUFBLFNBQVMsR0FBRyxLQUFLQyxhQUFMLENBQW1COUQsR0FBbkIsRUFBd0IsSUFBeEIsQ0FBWjtBQUNILEtBRkQsTUFFTztBQUNINkQsTUFBQUEsU0FBUyxHQUFHVyxPQUFPLENBQUNDLE9BQVIsRUFBWjtBQUNIOztBQUNELFNBQUs1RSxjQUFMLENBQW9CRyxHQUFwQjtBQUNBLFdBQU82RCxTQUFQO0FBQ0g7O0FBeFo0QiIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxOSBOZXcgVmVjdG9yIEx0ZFxuQ29weXJpZ2h0IDIwMTkgVGhlIE1hdHJpeC5vcmcgRm91bmRhdGlvbiBDLkkuQy5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgeyBkaWZmQXRDYXJldCwgZGlmZkRlbGV0aW9uLCBJRGlmZiB9IGZyb20gXCIuL2RpZmZcIjtcbmltcG9ydCBEb2N1bWVudFBvc2l0aW9uLCB7IElQb3NpdGlvbiB9IGZyb20gXCIuL3Bvc2l0aW9uXCI7XG5pbXBvcnQgUmFuZ2UgZnJvbSBcIi4vcmFuZ2VcIjtcbmltcG9ydCB7IFNlcmlhbGl6ZWRQYXJ0LCBQYXJ0LCBQYXJ0Q3JlYXRvciB9IGZyb20gXCIuL3BhcnRzXCI7XG5pbXBvcnQgQXV0b2NvbXBsZXRlV3JhcHBlck1vZGVsLCB7IElDYWxsYmFjayB9IGZyb20gXCIuL2F1dG9jb21wbGV0ZVwiO1xuaW1wb3J0IERvY3VtZW50T2Zmc2V0IGZyb20gXCIuL29mZnNldFwiO1xuaW1wb3J0IHsgQ2FyZXQgfSBmcm9tIFwiLi9jYXJldFwiO1xuXG4vKipcbiAqIEBjYWxsYmFjayBNb2RlbENhbGxiYWNrXG4gKiBAcGFyYW0ge0RvY3VtZW50UG9zaXRpb24/fSBjYXJldFBvc2l0aW9uIHRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgY2FyZXQgc2hvdWxkIGJlIHBvc2l0aW9uXG4gKiBAcGFyYW0ge3N0cmluZz99IGlucHV0VHlwZSB0aGUgaW5wdXRUeXBlIG9mIHRoZSBET00gaW5wdXQgZXZlbnRcbiAqIEBwYXJhbSB7b2JqZWN0P30gZGlmZiBhbiBvYmplY3Qgd2l0aCBgcmVtb3ZlZGAgYW5kIGBhZGRlZGAgc3RyaW5nc1xuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFRyYW5zZm9ybUNhbGxiYWNrXG4gKiBAcGFyYW0ge0RvY3VtZW50UG9zaXRpb24/fSBjYXJldFBvc2l0aW9uIHRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgY2FyZXQgc2hvdWxkIGJlIHBvc2l0aW9uXG4gKiBAcGFyYW0ge3N0cmluZz99IGlucHV0VHlwZSB0aGUgaW5wdXRUeXBlIG9mIHRoZSBET00gaW5wdXQgZXZlbnRcbiAqIEBwYXJhbSB7b2JqZWN0P30gZGlmZiBhbiBvYmplY3Qgd2l0aCBgcmVtb3ZlZGAgYW5kIGBhZGRlZGAgc3RyaW5nc1xuICogQHJldHVybiB7TnVtYmVyP30gYWRkZWRMZW4gaG93IG1hbnkgY2hhcmFjdGVycyB3ZXJlIGFkZGVkL3JlbW92ZWQgKC0pIGJlZm9yZSB0aGUgY2FyZXQgZHVyaW5nIHRoZSB0cmFuc2Zvcm1hdGlvbiBzdGVwLlxuICogICAgVGhpcyBpcyB1c2VkIHRvIGFkanVzdCB0aGUgY2FyZXQgcG9zaXRpb24uXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgTWFudWFsVHJhbnNmb3JtQ2FsbGJhY2tcbiAqIEByZXR1cm4gdGhlIGNhcmV0IHBvc2l0aW9uXG4gKi9cblxudHlwZSBUcmFuc2Zvcm1DYWxsYmFjayA9IChjYXJldFBvc2l0aW9uOiBEb2N1bWVudFBvc2l0aW9uLCBpbnB1dFR5cGU6IHN0cmluZywgZGlmZjogSURpZmYpID0+IG51bWJlciB8IHZvaWQ7XG50eXBlIFVwZGF0ZUNhbGxiYWNrID0gKGNhcmV0OiBDYXJldCwgaW5wdXRUeXBlPzogc3RyaW5nLCBkaWZmPzogSURpZmYpID0+IHZvaWQ7XG50eXBlIE1hbnVhbFRyYW5zZm9ybUNhbGxiYWNrID0gKCkgPT4gQ2FyZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVkaXRvck1vZGVsIHtcbiAgICBwcml2YXRlIF9wYXJ0czogUGFydFtdO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX3BhcnRDcmVhdG9yOiBQYXJ0Q3JlYXRvcjtcbiAgICBwcml2YXRlIGFjdGl2ZVBhcnRJZHg6IG51bWJlciA9IG51bGw7XG4gICAgcHJpdmF0ZSBfYXV0b0NvbXBsZXRlOiBBdXRvY29tcGxldGVXcmFwcGVyTW9kZWwgPSBudWxsO1xuICAgIHByaXZhdGUgYXV0b0NvbXBsZXRlUGFydElkeDogbnVtYmVyID0gbnVsbDtcbiAgICBwcml2YXRlIGF1dG9Db21wbGV0ZVBhcnRDb3VudCA9IDA7XG4gICAgcHJpdmF0ZSB0cmFuc2Zvcm1DYWxsYmFjazogVHJhbnNmb3JtQ2FsbGJhY2sgPSBudWxsO1xuXG4gICAgY29uc3RydWN0b3IocGFydHM6IFBhcnRbXSwgcGFydENyZWF0b3I6IFBhcnRDcmVhdG9yLCBwcml2YXRlIHVwZGF0ZUNhbGxiYWNrOiBVcGRhdGVDYWxsYmFjayA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcGFydHMgPSBwYXJ0cztcbiAgICAgICAgdGhpcy5fcGFydENyZWF0b3IgPSBwYXJ0Q3JlYXRvcjtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYWxsYmFjayA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGEgY2FsbGJhY2sgZm9yIHRoZSB0cmFuc2Zvcm1hdGlvbiBzdGVwLlxuICAgICAqIFdoaWxlIHByb2Nlc3NpbmcgYW4gdXBkYXRlLCByaWdodCBiZWZvcmUgY2FsbGluZyB0aGUgdXBkYXRlIGNhbGxiYWNrLFxuICAgICAqIGEgdHJhbnNmb3JtIGNhbGxiYWNrIGNhbiBiZSBjYWxsZWQsIHdoaWNoIHNlcnZlcyB0byBkbyBtb2RpZmljYXRpb25zXG4gICAgICogb24gdGhlIG1vZGVsIHRoYXQgY2FuIHNwYW4gbXVsdGlwbGUgcGFydHMuIEFsc28gc2VlIGBzdGFydFJhbmdlKClgLlxuICAgICAqIEBwYXJhbSB7VHJhbnNmb3JtQ2FsbGJhY2t9IHRyYW5zZm9ybUNhbGxiYWNrXG4gICAgICovXG4gICAgcHVibGljIHNldFRyYW5zZm9ybUNhbGxiYWNrKHRyYW5zZm9ybUNhbGxiYWNrOiBUcmFuc2Zvcm1DYWxsYmFjayk6IHZvaWQge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybUNhbGxiYWNrID0gdHJhbnNmb3JtQ2FsbGJhY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGEgY2FsbGJhY2sgZm9yIHJlcmVuZGVyaW5nIHRoZSBtb2RlbCBhZnRlciBpdCBoYXMgYmVlbiB1cGRhdGVkLlxuICAgICAqIEBwYXJhbSB7TW9kZWxDYWxsYmFja30gdXBkYXRlQ2FsbGJhY2tcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0VXBkYXRlQ2FsbGJhY2sodXBkYXRlQ2FsbGJhY2s6IFVwZGF0ZUNhbGxiYWNrKTogdm9pZCB7XG4gICAgICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sgPSB1cGRhdGVDYWxsYmFjaztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHBhcnRDcmVhdG9yKCk6IFBhcnRDcmVhdG9yIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnRDcmVhdG9yO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgaXNFbXB0eSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnRzLnJlZHVjZSgobGVuLCBwYXJ0KSA9PiBsZW4gKyBwYXJ0LnRleHQubGVuZ3RoLCAwKSA9PT0gMDtcbiAgICB9XG5cbiAgICBwdWJsaWMgY2xvbmUoKTogRWRpdG9yTW9kZWwge1xuICAgICAgICBjb25zdCBjbG9uZWRQYXJ0cyA9IHRoaXMucGFydHMubWFwKHAgPT4gdGhpcy5wYXJ0Q3JlYXRvci5kZXNlcmlhbGl6ZVBhcnQocC5zZXJpYWxpemUoKSkpO1xuICAgICAgICByZXR1cm4gbmV3IEVkaXRvck1vZGVsKGNsb25lZFBhcnRzLCB0aGlzLl9wYXJ0Q3JlYXRvciwgdGhpcy51cGRhdGVDYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbnNlcnRQYXJ0KGluZGV4OiBudW1iZXIsIHBhcnQ6IFBhcnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fcGFydHMuc3BsaWNlKGluZGV4LCAwLCBwYXJ0KTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlUGFydElkeCA+PSBpbmRleCkge1xuICAgICAgICAgICAgKyt0aGlzLmFjdGl2ZVBhcnRJZHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXV0b0NvbXBsZXRlUGFydElkeCA+PSBpbmRleCkge1xuICAgICAgICAgICAgKyt0aGlzLmF1dG9Db21wbGV0ZVBhcnRJZHg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHJlbW92ZVBhcnQoaW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLl9wYXJ0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpZiAoaW5kZXggPT09IHRoaXMuYWN0aXZlUGFydElkeCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVQYXJ0SWR4ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFjdGl2ZVBhcnRJZHggPiBpbmRleCkge1xuICAgICAgICAgICAgLS10aGlzLmFjdGl2ZVBhcnRJZHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLmF1dG9Db21wbGV0ZVBhcnRJZHgpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b0NvbXBsZXRlUGFydElkeCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5hdXRvQ29tcGxldGVQYXJ0SWR4ID4gaW5kZXgpIHtcbiAgICAgICAgICAgIC0tdGhpcy5hdXRvQ29tcGxldGVQYXJ0SWR4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZXBsYWNlUGFydChpbmRleDogbnVtYmVyLCBwYXJ0OiBQYXJ0KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3BhcnRzLnNwbGljZShpbmRleCwgMSwgcGFydCk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBwYXJ0cygpOiBQYXJ0W10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFydHM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBhdXRvQ29tcGxldGUoKTogQXV0b2NvbXBsZXRlV3JhcHBlck1vZGVsIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlUGFydElkeCA9PT0gdGhpcy5hdXRvQ29tcGxldGVQYXJ0SWR4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXV0b0NvbXBsZXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRQb3NpdGlvbkF0RW5kKCk6IERvY3VtZW50UG9zaXRpb24ge1xuICAgICAgICBpZiAodGhpcy5fcGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX3BhcnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBjb25zdCBwYXJ0ID0gdGhpcy5fcGFydHNbaW5kZXhdO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFBvc2l0aW9uKGluZGV4LCBwYXJ0LnRleHQubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhcnQgaW5kZXggLTEsIGFzIHRoZXJlIGFyZSBubyBwYXJ0cyB0byBwb2ludCBhdFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFBvc2l0aW9uKC0xLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBzZXJpYWxpemVQYXJ0cygpOiBTZXJpYWxpemVkUGFydFtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnRzLm1hcChwID0+IHAuc2VyaWFsaXplKCkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZGlmZihuZXdWYWx1ZTogc3RyaW5nLCBpbnB1dFR5cGU6IHN0cmluZywgY2FyZXQ6IERvY3VtZW50T2Zmc2V0KTogSURpZmYge1xuICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5wYXJ0cy5yZWR1Y2UoKHRleHQsIHApID0+IHRleHQgKyBwLnRleHQsIFwiXCIpO1xuICAgICAgICAvLyBjYW4ndCB1c2UgY2FyZXQgcG9zaXRpb24gd2l0aCBkcmFnIGFuZCBkcm9wXG4gICAgICAgIGlmIChpbnB1dFR5cGUgPT09IFwiZGVsZXRlQnlEcmFnXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBkaWZmRGVsZXRpb24ocHJldmlvdXNWYWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRpZmZBdENhcmV0KHByZXZpb3VzVmFsdWUsIG5ld1ZhbHVlLCBjYXJldC5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIHJlc2V0KHNlcmlhbGl6ZWRQYXJ0czogU2VyaWFsaXplZFBhcnRbXSwgY2FyZXQ/OiBDYXJldCwgaW5wdXRUeXBlPzogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3BhcnRzID0gc2VyaWFsaXplZFBhcnRzLm1hcChwID0+IHRoaXMuX3BhcnRDcmVhdG9yLmRlc2VyaWFsaXplUGFydChwKSk7XG4gICAgICAgIGlmICghY2FyZXQpIHtcbiAgICAgICAgICAgIGNhcmV0ID0gdGhpcy5nZXRQb3NpdGlvbkF0RW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2xvc2UgYXV0byBjb21wbGV0ZSBpZiBvcGVuXG4gICAgICAgIC8vIHRoaXMgd291bGQgaGFwcGVuIHdoZW4gY2xlYXJpbmcgdGhlIGNvbXBvc2VyIGFmdGVyIHNlbmRpbmdcbiAgICAgICAgLy8gYSBtZXNzYWdlIHdpdGggdGhlIGF1dG9jb21wbGV0ZSBzdGlsbCBvcGVuXG4gICAgICAgIGlmICh0aGlzLl9hdXRvQ29tcGxldGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2F1dG9Db21wbGV0ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmF1dG9Db21wbGV0ZVBhcnRJZHggPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlQ2FsbGJhY2soY2FyZXQsIGlucHV0VHlwZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyB0aGUgZ2l2ZW4gcGFydHMgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICAqIFNob3VsZCBiZSBydW4gaW5zaWRlIGEgYG1vZGVsLnRyYW5zZm9ybSgpYCBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge1BhcnRbXX0gcGFydHMgdGhlIHBhcnRzIHRvIHJlcGxhY2UgdGhlIHJhbmdlIHdpdGhcbiAgICAgKiBAcGFyYW0ge0RvY3VtZW50UG9zaXRpb259IHBvc2l0aW9uIHRoZSBwb3NpdGlvbiB0byBzdGFydCBpbnNlcnRpbmcgYXRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBhbW91bnQgb2YgY2hhcmFjdGVycyBhZGRlZFxuICAgICAqL1xuICAgIHB1YmxpYyBpbnNlcnQocGFydHM6IFBhcnRbXSwgcG9zaXRpb246IElQb3NpdGlvbik6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGluc2VydEluZGV4ID0gdGhpcy5zcGxpdEF0KHBvc2l0aW9uKTtcbiAgICAgICAgbGV0IG5ld1RleHRMZW5ndGggPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgICBuZXdUZXh0TGVuZ3RoICs9IHBhcnQudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmluc2VydFBhcnQoaW5zZXJ0SW5kZXggKyBpLCBwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3VGV4dExlbmd0aDtcbiAgICB9XG5cbiAgICBwdWJsaWMgdXBkYXRlKG5ld1ZhbHVlOiBzdHJpbmcsIGlucHV0VHlwZTogc3RyaW5nLCBjYXJldDogRG9jdW1lbnRPZmZzZXQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgZGlmZiA9IHRoaXMuZGlmZihuZXdWYWx1ZSwgaW5wdXRUeXBlLCBjYXJldCk7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbkZvck9mZnNldChkaWZmLmF0LCBjYXJldC5hdE5vZGVFbmQpO1xuICAgICAgICBsZXQgcmVtb3ZlZE9mZnNldERlY3JlYXNlID0gMDtcbiAgICAgICAgaWYgKGRpZmYucmVtb3ZlZCkge1xuICAgICAgICAgICAgcmVtb3ZlZE9mZnNldERlY3JlYXNlID0gdGhpcy5yZW1vdmVUZXh0KHBvc2l0aW9uLCBkaWZmLnJlbW92ZWQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWRkZWRMZW4gPSAwO1xuICAgICAgICBpZiAoZGlmZi5hZGRlZCkge1xuICAgICAgICAgICAgYWRkZWRMZW4gPSB0aGlzLmFkZFRleHQocG9zaXRpb24sIGRpZmYuYWRkZWQsIGlucHV0VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXJnZUFkamFjZW50UGFydHMoKTtcbiAgICAgICAgY29uc3QgY2FyZXRPZmZzZXQgPSBkaWZmLmF0IC0gcmVtb3ZlZE9mZnNldERlY3JlYXNlICsgYWRkZWRMZW47XG4gICAgICAgIGxldCBuZXdQb3NpdGlvbiA9IHRoaXMucG9zaXRpb25Gb3JPZmZzZXQoY2FyZXRPZmZzZXQsIHRydWUpO1xuICAgICAgICBjb25zdCBjYW5PcGVuQXV0b0NvbXBsZXRlID0gaW5wdXRUeXBlICE9PSBcImluc2VydEZyb21QYXN0ZVwiICYmIGlucHV0VHlwZSAhPT0gXCJpbnNlcnRGcm9tRHJvcFwiO1xuICAgICAgICBjb25zdCBhY1Byb21pc2UgPSB0aGlzLnNldEFjdGl2ZVBhcnQobmV3UG9zaXRpb24sIGNhbk9wZW5BdXRvQ29tcGxldGUpO1xuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm1DYWxsYmFjaykge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtQWRkZWRMZW4gPSB0aGlzLmdldFRyYW5zZm9ybUFkZGVkTGVuKG5ld1Bvc2l0aW9uLCBpbnB1dFR5cGUsIGRpZmYpO1xuICAgICAgICAgICAgbmV3UG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uRm9yT2Zmc2V0KGNhcmV0T2Zmc2V0ICsgdHJhbnNmb3JtQWRkZWRMZW4sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sobmV3UG9zaXRpb24sIGlucHV0VHlwZSwgZGlmZik7XG4gICAgICAgIHJldHVybiBhY1Byb21pc2U7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUcmFuc2Zvcm1BZGRlZExlbihuZXdQb3NpdGlvbjogRG9jdW1lbnRQb3NpdGlvbiwgaW5wdXRUeXBlOiBzdHJpbmcsIGRpZmY6IElEaWZmKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy50cmFuc2Zvcm1DYWxsYmFjayhuZXdQb3NpdGlvbiwgaW5wdXRUeXBlLCBkaWZmKTtcbiAgICAgICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShyZXN1bHQpID8gcmVzdWx0IGFzIG51bWJlciA6IDA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRBY3RpdmVQYXJ0KHBvczogRG9jdW1lbnRQb3NpdGlvbiwgY2FuT3BlbkF1dG9Db21wbGV0ZTogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCB7IGluZGV4IH0gPSBwb3M7XG4gICAgICAgIGNvbnN0IHBhcnQgPSB0aGlzLl9wYXJ0c1tpbmRleF07XG4gICAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IHRoaXMuYWN0aXZlUGFydElkeCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlUGFydElkeCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChjYW5PcGVuQXV0b0NvbXBsZXRlICYmIHRoaXMuYWN0aXZlUGFydElkeCAhPT0gdGhpcy5hdXRvQ29tcGxldGVQYXJ0SWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgdHJ5IHRvIGNyZWF0ZSBvbmVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWMgPSBwYXJ0LmNyZWF0ZUF1dG9Db21wbGV0ZSh0aGlzLm9uQXV0b0NvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhhdCByZWFjdCBwaWNrcyB1cCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGJvdGggYWNzXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdXRvQ29tcGxldGUgPSBhYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0b0NvbXBsZXRlUGFydElkeCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRvQ29tcGxldGVQYXJ0Q291bnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm90IGF1dG9Db21wbGV0ZSwgb25seSB0aGVyZSBpZiBhY3RpdmUgcGFydCBpcyBhdXRvY29tcGxldGUgcGFydFxuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b0NvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXV0b0NvbXBsZXRlLm9uUGFydFVwZGF0ZShwYXJ0LCBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVQYXJ0SWR4ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2F1dG9Db21wbGV0ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmF1dG9Db21wbGV0ZVBhcnRJZHggPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5hdXRvQ29tcGxldGVQYXJ0Q291bnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uQXV0b0NvbXBsZXRlID0gKHsgcmVwbGFjZVBhcnRzLCBjbG9zZSB9OiBJQ2FsbGJhY2spOiB2b2lkID0+IHtcbiAgICAgICAgbGV0IHBvcztcbiAgICAgICAgaWYgKHJlcGxhY2VQYXJ0cykge1xuICAgICAgICAgICAgdGhpcy5fcGFydHMuc3BsaWNlKHRoaXMuYXV0b0NvbXBsZXRlUGFydElkeCwgdGhpcy5hdXRvQ29tcGxldGVQYXJ0Q291bnQsIC4uLnJlcGxhY2VQYXJ0cyk7XG4gICAgICAgICAgICB0aGlzLmF1dG9Db21wbGV0ZVBhcnRDb3VudCA9IHJlcGxhY2VQYXJ0cy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBsYXN0UGFydCA9IHJlcGxhY2VQYXJ0c1tyZXBsYWNlUGFydHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBsYXN0UGFydEluZGV4ID0gdGhpcy5hdXRvQ29tcGxldGVQYXJ0SWR4ICsgcmVwbGFjZVBhcnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBwb3MgPSBuZXcgRG9jdW1lbnRQb3NpdGlvbihsYXN0UGFydEluZGV4LCBsYXN0UGFydC50ZXh0Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsb3NlKSB7XG4gICAgICAgICAgICB0aGlzLl9hdXRvQ29tcGxldGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5hdXRvQ29tcGxldGVQYXJ0SWR4ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYXV0b0NvbXBsZXRlUGFydENvdW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXJlbmRlciBldmVuIGlmIGVkaXRvciBjb250ZW50cyBkaWRuJ3QgY2hhbmdlXG4gICAgICAgIC8vIHRvIG1ha2Ugc3VyZSB0aGUgTWVzc2FnZUVkaXRvciBjaGVja3NcbiAgICAgICAgLy8gbW9kZWwuYXV0b0NvbXBsZXRlIGJlaW5nIGVtcHR5IGFuZCBjbG9zZXMgaXRcbiAgICAgICAgdGhpcy51cGRhdGVDYWxsYmFjayhwb3MpO1xuICAgIH07XG5cbiAgICBwcml2YXRlIG1lcmdlQWRqYWNlbnRQYXJ0cygpOiB2b2lkIHtcbiAgICAgICAgbGV0IHByZXZQYXJ0O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3BhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgcGFydCA9IHRoaXMuX3BhcnRzW2ldO1xuICAgICAgICAgICAgY29uc3QgaXNFbXB0eSA9ICFwYXJ0LnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaXNNZXJnZWQgPSAhaXNFbXB0eSAmJiBwcmV2UGFydCAmJiBwcmV2UGFydC5tZXJnZShwYXJ0KTtcbiAgICAgICAgICAgIGlmIChpc0VtcHR5IHx8IGlzTWVyZ2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGVtcHR5IG9yIG1lcmdlZCBwYXJ0XG4gICAgICAgICAgICAgICAgcGFydCA9IHByZXZQYXJ0O1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlUGFydChpKTtcbiAgICAgICAgICAgICAgICAvL3JlcGVhdCB0aGlzIGluZGV4LCBhcyBpdCdzIHJlbW92ZWQgbm93XG4gICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldlBhcnQgPSBwYXJ0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlcyBgbGVuYCBhbW91bnQgb2YgY2hhcmFjdGVycyBhdCBgcG9zYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlblxuICAgICAqIEByZXR1cm4ge051bWJlcn0gaG93IG1hbnkgY2hhcmFjdGVycyBiZWZvcmUgcG9zIHdlcmUgYWxzbyByZW1vdmVkLFxuICAgICAqIHVzdWFsbHkgYmVjYXVzZSBvZiBub24tZWRpdGFibGUgcGFydHMgdGhhdCBjYW4gb25seSBiZSByZW1vdmVkIGluIHRoZWlyIGVudGlyZXR5LlxuICAgICAqL1xuICAgIHB1YmxpYyByZW1vdmVUZXh0KHBvczogSVBvc2l0aW9uLCBsZW46IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IHBvcztcbiAgICAgICAgbGV0IHJlbW92ZWRPZmZzZXREZWNyZWFzZSA9IDA7XG4gICAgICAgIHdoaWxlIChsZW4gPiAwKSB7XG4gICAgICAgICAgICAvLyBwYXJ0IG1pZ2h0IGJlIHVuZGVmaW5lZCBoZXJlXG4gICAgICAgICAgICBsZXQgcGFydCA9IHRoaXMuX3BhcnRzW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGFtb3VudCA9IE1hdGgubWluKGxlbiwgcGFydC50ZXh0Lmxlbmd0aCAtIG9mZnNldCk7XG4gICAgICAgICAgICAvLyBkb24ndCBhbGxvdyAwIGFtb3VudCBkZWxldGlvbnNcbiAgICAgICAgICAgIGlmIChhbW91bnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFydC5jYW5FZGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VXaXRoID0gcGFydC5yZW1vdmUob2Zmc2V0LCBhbW91bnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VXaXRoID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VQYXJ0KGluZGV4LCB0aGlzLl9wYXJ0Q3JlYXRvci5jcmVhdGVEZWZhdWx0UGFydChyZXBsYWNlV2l0aCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcnQgPSB0aGlzLl9wYXJ0c1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBlbXB0eSBwYXJ0XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFydC50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVQYXJ0KGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVkT2Zmc2V0RGVjcmVhc2UgKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVBhcnQoaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxlbiAtPSBhbW91bnQ7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW1vdmVkT2Zmc2V0RGVjcmVhc2U7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIHBhcnQgaW5kZXggd2hlcmUgaW5zZXJ0aW9uIHdpbGwgaW5zZXJ0IGJldHdlZW4gYXQgb2Zmc2V0XG4gICAgcHJpdmF0ZSBzcGxpdEF0KHBvczogSVBvc2l0aW9uKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKHBvcy5pbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3Mub2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9zLmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnQgPSB0aGlzLl9wYXJ0c1twb3MuaW5kZXhdO1xuICAgICAgICBpZiAocG9zLm9mZnNldCA+PSBwYXJ0LnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9zLmluZGV4ICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNlY29uZFBhcnQgPSBwYXJ0LnNwbGl0KHBvcy5vZmZzZXQpO1xuICAgICAgICB0aGlzLmluc2VydFBhcnQocG9zLmluZGV4ICsgMSwgc2Vjb25kUGFydCk7XG4gICAgICAgIHJldHVybiBwb3MuaW5kZXggKyAxO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGluc2VydHMgYHN0cmAgaW50byB0aGUgbW9kZWwgYXQgYHBvc2AuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRUeXBlIHRoZSBzb3VyY2Ugb2YgdGhlIGlucHV0LCBzZWUgaHRtbCBJbnB1dEV2ZW50LmlucHV0VHlwZVxuICAgICAqIEBwYXJhbSB7Ym9vbH0gb3B0aW9ucy52YWxpZGF0ZSBXaGV0aGVyIGNoYXJhY3RlcnMgd2lsbCBiZSB2YWxpZGF0ZWQgYnkgdGhlIHBhcnQuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZhbGlkYXRpbmcgYWxsb3dzIHRoZSBpbnNlcnRlZCB0ZXh0IHRvIGJlIHBhcnNlZCBhY2NvcmRpbmcgdG8gdGhlIHBhcnQgcnVsZXMuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBob3cgZmFyIGZyb20gcG9zaXRpb24gKGluIGNoYXJhY3RlcnMpIHRoZSBpbnNlcnRpb24gZW5kZWQuXG4gICAgICogVGhpcyBjYW4gYmUgbW9yZSB0aGFuIHRoZSBsZW5ndGggb2YgYHN0cmAgd2hlbiBjcm9zc2luZyBub24tZWRpdGFibGUgcGFydHMsIHdoaWNoIGFyZSBza2lwcGVkLlxuICAgICAqL1xuICAgIHByaXZhdGUgYWRkVGV4dChwb3M6IElQb3NpdGlvbiwgc3RyOiBzdHJpbmcsIGlucHV0VHlwZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IHsgaW5kZXggfSA9IHBvcztcbiAgICAgICAgY29uc3QgeyBvZmZzZXQgfSA9IHBvcztcbiAgICAgICAgbGV0IGFkZExlbiA9IHN0ci5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHBhcnQgPSB0aGlzLl9wYXJ0c1tpbmRleF07XG4gICAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgICAgICBpZiAocGFydC5jYW5FZGl0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQudmFsaWRhdGVBbmRJbnNlcnQob2Zmc2V0LCBzdHIsIGlucHV0VHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzcGxpdFBhcnQgPSBwYXJ0LnNwbGl0KG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0UGFydChpbmRleCwgc3BsaXRQYXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9mZnNldCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIG5vdC1lZGl0YWJsZSBwYXJ0LCBjYXJldCBpcyBub3QgYXQgc3RhcnQsXG4gICAgICAgICAgICAgICAgLy8gc28gaW5zZXJ0IHN0ciBhZnRlciB0aGlzIHBhcnRcbiAgICAgICAgICAgICAgICBhZGRMZW4gKz0gcGFydC50ZXh0Lmxlbmd0aCAtIG9mZnNldDtcbiAgICAgICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgLy8gaWYgcG9zaXRpb24gd2FzIG5vdCBmb3VuZCAoaW5kZXg6IC0xLCBhcyBoYXBwZW5zIGZvciBlbXB0eSBlZGl0b3IpXG4gICAgICAgICAgICAvLyByZXNldCBpdCB0byBpbnNlcnQgYXMgZmlyc3QgcGFydFxuICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzdHIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1BhcnQgPSB0aGlzLl9wYXJ0Q3JlYXRvci5jcmVhdGVQYXJ0Rm9ySW5wdXQoc3RyLCBpbmRleCwgaW5wdXRUeXBlKTtcbiAgICAgICAgICAgIHN0ciA9IG5ld1BhcnQuYXBwZW5kVW50aWxSZWplY3RlZChzdHIsIGlucHV0VHlwZSk7XG4gICAgICAgICAgICB0aGlzLmluc2VydFBhcnQoaW5kZXgsIG5ld1BhcnQpO1xuICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRkTGVuO1xuICAgIH1cblxuICAgIHB1YmxpYyBwb3NpdGlvbkZvck9mZnNldCh0b3RhbE9mZnNldDogbnVtYmVyLCBhdFBhcnRFbmQgPSBmYWxzZSk6IERvY3VtZW50UG9zaXRpb24ge1xuICAgICAgICBsZXQgY3VycmVudE9mZnNldCA9IDA7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fcGFydHMuZmluZEluZGV4KHBhcnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFydExlbiA9IHBhcnQudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKGF0UGFydEVuZCAmJiAoY3VycmVudE9mZnNldCArIHBhcnRMZW4pID49IHRvdGFsT2Zmc2V0KSB8fFxuICAgICAgICAgICAgICAgICghYXRQYXJ0RW5kICYmIChjdXJyZW50T2Zmc2V0ICsgcGFydExlbikgPiB0b3RhbE9mZnNldClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudE9mZnNldCArPSBwYXJ0TGVuO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UG9zaXRpb25BdEVuZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFBvc2l0aW9uKGluZGV4LCB0b3RhbE9mZnNldCAtIGN1cnJlbnRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIGEgcmFuZ2UsIHdoaWNoIGNhbiBzcGFuIGFjcm9zcyBtdWx0aXBsZSBwYXJ0cywgdG8gZmluZCBhbmQgcmVwbGFjZSB0ZXh0LlxuICAgICAqIEBwYXJhbSB7RG9jdW1lbnRQb3NpdGlvbn0gcG9zaXRpb25BIGEgYm91bmRhcnkgb2YgdGhlIHJhbmdlXG4gICAgICogQHBhcmFtIHtEb2N1bWVudFBvc2l0aW9uP30gcG9zaXRpb25CIHRoZSBvdGhlciBib3VuZGFyeSBvZiB0aGUgcmFuZ2UsIG9wdGlvbmFsXG4gICAgICogQHJldHVybiB7UmFuZ2V9XG4gICAgICovXG4gICAgcHVibGljIHN0YXJ0UmFuZ2UocG9zaXRpb25BOiBEb2N1bWVudFBvc2l0aW9uLCBwb3NpdGlvbkIgPSBwb3NpdGlvbkEpOiBSYW5nZSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UodGhpcywgcG9zaXRpb25BLCBwb3NpdGlvbkIpO1xuICAgIH1cblxuICAgIHB1YmxpYyByZXBsYWNlUmFuZ2Uoc3RhcnRQb3NpdGlvbjogRG9jdW1lbnRQb3NpdGlvbiwgZW5kUG9zaXRpb246IERvY3VtZW50UG9zaXRpb24sIHBhcnRzOiBQYXJ0W10pOiB2b2lkIHtcbiAgICAgICAgLy8gY29udmVydCBlbmQgcG9zaXRpb24gdG8gb2Zmc2V0LCBzbyBpdCBpcyBpbmRlcGVuZGVudCBvZiBob3cgdGhlIGRvY3VtZW50IGlzIHNwbGl0IGludG8gcGFydHNcbiAgICAgICAgLy8gd2hpY2ggd2UnbGwgY2hhbmdlIHdoZW4gc3BsaXR0aW5nIHVwIGF0IHRoZSBzdGFydCBwb3NpdGlvblxuICAgICAgICBjb25zdCBlbmRPZmZzZXQgPSBlbmRQb3NpdGlvbi5hc09mZnNldCh0aGlzKTtcbiAgICAgICAgY29uc3QgbmV3U3RhcnRQYXJ0SW5kZXggPSB0aGlzLnNwbGl0QXQoc3RhcnRQb3NpdGlvbik7XG4gICAgICAgIC8vIGNvbnZlcnQgaXQgYmFjayB0byBwb3NpdGlvbiBvbmNlIHNwbGl0IGF0IHN0YXJ0XG4gICAgICAgIGVuZFBvc2l0aW9uID0gZW5kT2Zmc2V0LmFzUG9zaXRpb24odGhpcyk7XG4gICAgICAgIGNvbnN0IG5ld0VuZFBhcnRJbmRleCA9IHRoaXMuc3BsaXRBdChlbmRQb3NpdGlvbik7XG4gICAgICAgIGZvciAobGV0IGkgPSBuZXdFbmRQYXJ0SW5kZXggLSAxOyBpID49IG5ld1N0YXJ0UGFydEluZGV4OyAtLWkpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUGFydChpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5zZXJ0SWR4ID0gbmV3U3RhcnRQYXJ0SW5kZXg7XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRQYXJ0KGluc2VydElkeCwgcGFydCk7XG4gICAgICAgICAgICBpbnNlcnRJZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lcmdlQWRqYWNlbnRQYXJ0cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgdHJhbnNmb3JtYXRpb24gbm90IHBhcnQgb2YgYW4gdXBkYXRlIGN5Y2xlLlxuICAgICAqIE1vZGlmeWluZyB0aGUgbW9kZWwgc2hvdWxkIG9ubHkgaGFwcGVuIGluc2lkZSBhIHRyYW5zZm9ybSBjYWxsIGlmIG5vdCBwYXJ0IG9mIGFuIHVwZGF0ZSBjYWxsLlxuICAgICAqIEBwYXJhbSB7TWFudWFsVHJhbnNmb3JtQ2FsbGJhY2t9IGNhbGxiYWNrIHRvIHJ1biB0aGUgdHJhbnNmb3JtYXRpb25zIGluXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHdoZW4gYXV0by1jb21wbGV0ZSAoaWYgYXBwbGljYWJsZSkgaXMgZG9uZSB1cGRhdGluZ1xuICAgICAqL1xuICAgIHB1YmxpYyB0cmFuc2Zvcm0oY2FsbGJhY2s6IE1hbnVhbFRyYW5zZm9ybUNhbGxiYWNrKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGNhbGxiYWNrKCk7XG4gICAgICAgIGxldCBhY1Byb21pc2U6IFByb21pc2U8dm9pZD4gPSBudWxsO1xuICAgICAgICBpZiAoIShwb3MgaW5zdGFuY2VvZiBSYW5nZSkpIHtcbiAgICAgICAgICAgIGFjUHJvbWlzZSA9IHRoaXMuc2V0QWN0aXZlUGFydChwb3MsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWNQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVDYWxsYmFjayhwb3MpO1xuICAgICAgICByZXR1cm4gYWNQcm9taXNlO1xuICAgIH1cbn1cbiJdfQ==