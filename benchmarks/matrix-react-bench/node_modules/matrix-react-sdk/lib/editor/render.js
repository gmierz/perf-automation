"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CARET_NODE_CHAR = void 0;
exports.isCaretNode = isCaretNode;
exports.needsCaretNodeAfter = needsCaretNodeAfter;
exports.needsCaretNodeBefore = needsCaretNodeBefore;
exports.renderModel = renderModel;

var _parts = require("./parts");

/*
Copyright 2019 New Vector Ltd
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
function needsCaretNodeBefore(part, prevPart) {
  const isFirst = !prevPart || prevPart.type === _parts.Type.Newline;
  return !part.canEdit && (isFirst || !prevPart.canEdit);
}

function needsCaretNodeAfter(part, isLastOfLine) {
  return !part.canEdit && isLastOfLine;
}

function insertAfter(node, nodeToInsert) {
  const next = node.nextSibling;

  if (next) {
    node.parentElement.insertBefore(nodeToInsert, next);
  } else {
    node.parentElement.appendChild(nodeToInsert);
  }
} // Use a BOM marker for caret nodes.
// On a first test, they seem to be filtered out when copying text out of the editor,
// but this could be platform dependent.
// As a precautionary measure, I chose the character that slate also uses.


const CARET_NODE_CHAR = "\ufeff"; // a caret node is a node that allows the caret to be placed
// where otherwise it wouldn't be possible
// (e.g. next to a pill span without adjacent text node)

exports.CARET_NODE_CHAR = CARET_NODE_CHAR;

function createCaretNode() {
  const span = document.createElement("span");
  span.className = "caretNode";
  span.appendChild(document.createTextNode(CARET_NODE_CHAR));
  return span;
}

function updateCaretNode(node) {
  // ensure the caret node contains only a zero-width space
  if (node.textContent !== CARET_NODE_CHAR) {
    node.textContent = CARET_NODE_CHAR;
  }
}

function isCaretNode(node) {
  return node && node.tagName === "SPAN" && node.className === "caretNode";
}

function removeNextSiblings(node) {
  if (!node) {
    return;
  }

  node = node.nextSibling;

  while (node) {
    const removeNode = node;
    node = node.nextSibling;
    removeNode.remove();
  }
}

function removeChildren(parent) {
  const firstChild = parent.firstChild;

  if (firstChild) {
    removeNextSiblings(firstChild);
    firstChild.remove();
  }
}

function reconcileLine(lineContainer, parts) {
  let currentNode;
  let prevPart;
  const lastPart = parts[parts.length - 1];

  for (const part of parts) {
    const isFirst = !prevPart;
    currentNode = isFirst ? lineContainer.firstChild : currentNode.nextSibling;

    if (needsCaretNodeBefore(part, prevPart)) {
      if (isCaretNode(currentNode)) {
        updateCaretNode(currentNode);
        currentNode = currentNode.nextSibling;
      } else {
        lineContainer.insertBefore(createCaretNode(), currentNode);
      }
    } // remove nodes until matching current part


    while (currentNode && !part.canUpdateDOMNode(currentNode)) {
      const nextNode = currentNode.nextSibling;
      lineContainer.removeChild(currentNode);
      currentNode = nextNode;
    } // update or insert node for current part


    if (currentNode && part) {
      part.updateDOMNode(currentNode);
    } else if (part) {
      currentNode = part.toDOMNode(); // hooks up nextSibling for next iteration

      lineContainer.appendChild(currentNode);
    }

    if (needsCaretNodeAfter(part, part === lastPart)) {
      if (isCaretNode(currentNode.nextSibling)) {
        currentNode = currentNode.nextSibling;
        updateCaretNode(currentNode);
      } else {
        const caretNode = createCaretNode();
        insertAfter(currentNode, caretNode);
        currentNode = caretNode;
      }
    }

    prevPart = part;
  }

  removeNextSiblings(currentNode);
}

function reconcileEmptyLine(lineContainer) {
  // empty div needs to have a BR in it to give it height
  let foundBR = false;
  let partNode = lineContainer.firstChild;

  while (partNode) {
    const nextNode = partNode.nextSibling;

    if (!foundBR && partNode.tagName === "BR") {
      foundBR = true;
    } else {
      partNode.remove();
    }

    partNode = nextNode;
  }

  if (!foundBR) {
    lineContainer.appendChild(document.createElement("br"));
  }
}

function renderModel(editor, model) {
  const lines = model.parts.reduce((linesArr, part) => {
    if (part.type === _parts.Type.Newline) {
      linesArr.push([]);
    } else {
      const lastLine = linesArr[linesArr.length - 1];
      lastLine.push(part);
    }

    return linesArr;
  }, [[]]);
  lines.forEach((parts, i) => {
    // find first (and remove anything else) div without className
    // (as browsers insert these in contenteditable) line container
    let lineContainer = editor.childNodes[i];

    while (lineContainer && (lineContainer.tagName !== "DIV" || !!lineContainer.className)) {
      editor.removeChild(lineContainer);
      lineContainer = editor.childNodes[i];
    }

    if (!lineContainer) {
      lineContainer = document.createElement("div");
      editor.appendChild(lineContainer);
    }

    if (parts.length) {
      reconcileLine(lineContainer, parts);
    } else {
      reconcileEmptyLine(lineContainer);
    }
  });

  if (lines.length) {
    removeNextSiblings(editor.children[lines.length - 1]);
  } else {
    removeChildren(editor);
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9lZGl0b3IvcmVuZGVyLnRzIl0sIm5hbWVzIjpbIm5lZWRzQ2FyZXROb2RlQmVmb3JlIiwicGFydCIsInByZXZQYXJ0IiwiaXNGaXJzdCIsInR5cGUiLCJUeXBlIiwiTmV3bGluZSIsImNhbkVkaXQiLCJuZWVkc0NhcmV0Tm9kZUFmdGVyIiwiaXNMYXN0T2ZMaW5lIiwiaW5zZXJ0QWZ0ZXIiLCJub2RlIiwibm9kZVRvSW5zZXJ0IiwibmV4dCIsIm5leHRTaWJsaW5nIiwicGFyZW50RWxlbWVudCIsImluc2VydEJlZm9yZSIsImFwcGVuZENoaWxkIiwiQ0FSRVRfTk9ERV9DSEFSIiwiY3JlYXRlQ2FyZXROb2RlIiwic3BhbiIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsImNyZWF0ZVRleHROb2RlIiwidXBkYXRlQ2FyZXROb2RlIiwidGV4dENvbnRlbnQiLCJpc0NhcmV0Tm9kZSIsInRhZ05hbWUiLCJyZW1vdmVOZXh0U2libGluZ3MiLCJyZW1vdmVOb2RlIiwicmVtb3ZlIiwicmVtb3ZlQ2hpbGRyZW4iLCJwYXJlbnQiLCJmaXJzdENoaWxkIiwicmVjb25jaWxlTGluZSIsImxpbmVDb250YWluZXIiLCJwYXJ0cyIsImN1cnJlbnROb2RlIiwibGFzdFBhcnQiLCJsZW5ndGgiLCJjYW5VcGRhdGVET01Ob2RlIiwibmV4dE5vZGUiLCJyZW1vdmVDaGlsZCIsInVwZGF0ZURPTU5vZGUiLCJ0b0RPTU5vZGUiLCJjYXJldE5vZGUiLCJyZWNvbmNpbGVFbXB0eUxpbmUiLCJmb3VuZEJSIiwicGFydE5vZGUiLCJyZW5kZXJNb2RlbCIsImVkaXRvciIsIm1vZGVsIiwibGluZXMiLCJyZWR1Y2UiLCJsaW5lc0FyciIsInB1c2giLCJsYXN0TGluZSIsImZvckVhY2giLCJpIiwiY2hpbGROb2RlcyIsImNoaWxkcmVuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWlCQTs7QUFqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QWtCO0FBQ2RYLElBQUFBLGtCQUFrQixDQUFDc0IsTUFBTSxDQUFDVSxRQUFQLENBQWdCUixLQUFLLENBQUNiLE1BQU4sR0FBZSxDQUEvQixDQUFELENBQWxCO0FBQ0gsR0FGRCxNQUVPO0FBQ0hSLElBQUFBLGNBQWMsQ0FBQ21CLE1BQUQsQ0FBZDtBQUNIO0FBQ0oiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMTkgTmV3IFZlY3RvciBMdGRcbkNvcHlyaWdodCAyMDE5IFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IHsgUGFydCwgVHlwZSB9IGZyb20gXCIuL3BhcnRzXCI7XG5pbXBvcnQgRWRpdG9yTW9kZWwgZnJvbSBcIi4vbW9kZWxcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG5lZWRzQ2FyZXROb2RlQmVmb3JlKHBhcnQ6IFBhcnQsIHByZXZQYXJ0OiBQYXJ0KTogYm9vbGVhbiB7XG4gICAgY29uc3QgaXNGaXJzdCA9ICFwcmV2UGFydCB8fCBwcmV2UGFydC50eXBlID09PSBUeXBlLk5ld2xpbmU7XG4gICAgcmV0dXJuICFwYXJ0LmNhbkVkaXQgJiYgKGlzRmlyc3QgfHwgIXByZXZQYXJ0LmNhbkVkaXQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbmVlZHNDYXJldE5vZGVBZnRlcihwYXJ0OiBQYXJ0LCBpc0xhc3RPZkxpbmU6IGJvb2xlYW4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXBhcnQuY2FuRWRpdCAmJiBpc0xhc3RPZkxpbmU7XG59XG5cbmZ1bmN0aW9uIGluc2VydEFmdGVyKG5vZGU6IEhUTUxFbGVtZW50LCBub2RlVG9JbnNlcnQ6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgY29uc3QgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgaWYgKG5leHQpIHtcbiAgICAgICAgbm9kZS5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZShub2RlVG9JbnNlcnQsIG5leHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUucGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZChub2RlVG9JbnNlcnQpO1xuICAgIH1cbn1cblxuLy8gVXNlIGEgQk9NIG1hcmtlciBmb3IgY2FyZXQgbm9kZXMuXG4vLyBPbiBhIGZpcnN0IHRlc3QsIHRoZXkgc2VlbSB0byBiZSBmaWx0ZXJlZCBvdXQgd2hlbiBjb3B5aW5nIHRleHQgb3V0IG9mIHRoZSBlZGl0b3IsXG4vLyBidXQgdGhpcyBjb3VsZCBiZSBwbGF0Zm9ybSBkZXBlbmRlbnQuXG4vLyBBcyBhIHByZWNhdXRpb25hcnkgbWVhc3VyZSwgSSBjaG9zZSB0aGUgY2hhcmFjdGVyIHRoYXQgc2xhdGUgYWxzbyB1c2VzLlxuZXhwb3J0IGNvbnN0IENBUkVUX05PREVfQ0hBUiA9IFwiXFx1ZmVmZlwiO1xuLy8gYSBjYXJldCBub2RlIGlzIGEgbm9kZSB0aGF0IGFsbG93cyB0aGUgY2FyZXQgdG8gYmUgcGxhY2VkXG4vLyB3aGVyZSBvdGhlcndpc2UgaXQgd291bGRuJ3QgYmUgcG9zc2libGVcbi8vIChlLmcuIG5leHQgdG8gYSBwaWxsIHNwYW4gd2l0aG91dCBhZGphY2VudCB0ZXh0IG5vZGUpXG5mdW5jdGlvbiBjcmVhdGVDYXJldE5vZGUoKTogSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBzcGFuLmNsYXNzTmFtZSA9IFwiY2FyZXROb2RlXCI7XG4gICAgc3Bhbi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShDQVJFVF9OT0RFX0NIQVIpKTtcbiAgICByZXR1cm4gc3Bhbjtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2FyZXROb2RlKG5vZGU6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgLy8gZW5zdXJlIHRoZSBjYXJldCBub2RlIGNvbnRhaW5zIG9ubHkgYSB6ZXJvLXdpZHRoIHNwYWNlXG4gICAgaWYgKG5vZGUudGV4dENvbnRlbnQgIT09IENBUkVUX05PREVfQ0hBUikge1xuICAgICAgICBub2RlLnRleHRDb250ZW50ID0gQ0FSRVRfTk9ERV9DSEFSO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ2FyZXROb2RlKG5vZGU6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS50YWdOYW1lID09PSBcIlNQQU5cIiAmJiBub2RlLmNsYXNzTmFtZSA9PT0gXCJjYXJldE5vZGVcIjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlTmV4dFNpYmxpbmdzKG5vZGU6IENoaWxkTm9kZSk6IHZvaWQge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGNvbnN0IHJlbW92ZU5vZGUgPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgcmVtb3ZlTm9kZS5yZW1vdmUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuKHBhcmVudDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICBjb25zdCBmaXJzdENoaWxkID0gcGFyZW50LmZpcnN0Q2hpbGQ7XG4gICAgaWYgKGZpcnN0Q2hpbGQpIHtcbiAgICAgICAgcmVtb3ZlTmV4dFNpYmxpbmdzKGZpcnN0Q2hpbGQpO1xuICAgICAgICBmaXJzdENoaWxkLnJlbW92ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVjb25jaWxlTGluZShsaW5lQ29udGFpbmVyOiBDaGlsZE5vZGUsIHBhcnRzOiBQYXJ0W10pOiB2b2lkIHtcbiAgICBsZXQgY3VycmVudE5vZGU7XG4gICAgbGV0IHByZXZQYXJ0O1xuICAgIGNvbnN0IGxhc3RQYXJ0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG5cbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgICAgY29uc3QgaXNGaXJzdCA9ICFwcmV2UGFydDtcbiAgICAgICAgY3VycmVudE5vZGUgPSBpc0ZpcnN0ID8gbGluZUNvbnRhaW5lci5maXJzdENoaWxkIDogY3VycmVudE5vZGUubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgaWYgKG5lZWRzQ2FyZXROb2RlQmVmb3JlKHBhcnQsIHByZXZQYXJ0KSkge1xuICAgICAgICAgICAgaWYgKGlzQ2FyZXROb2RlKGN1cnJlbnROb2RlKSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUNhcmV0Tm9kZShjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGluZUNvbnRhaW5lci5pbnNlcnRCZWZvcmUoY3JlYXRlQ2FyZXROb2RlKCksIGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyByZW1vdmUgbm9kZXMgdW50aWwgbWF0Y2hpbmcgY3VycmVudCBwYXJ0XG4gICAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSAmJiAhcGFydC5jYW5VcGRhdGVET01Ob2RlKGN1cnJlbnROb2RlKSkge1xuICAgICAgICAgICAgY29uc3QgbmV4dE5vZGUgPSBjdXJyZW50Tm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIGxpbmVDb250YWluZXIucmVtb3ZlQ2hpbGQoY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgY3VycmVudE5vZGUgPSBuZXh0Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgb3IgaW5zZXJ0IG5vZGUgZm9yIGN1cnJlbnQgcGFydFxuICAgICAgICBpZiAoY3VycmVudE5vZGUgJiYgcGFydCkge1xuICAgICAgICAgICAgcGFydC51cGRhdGVET01Ob2RlKGN1cnJlbnROb2RlKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJ0KSB7XG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IHBhcnQudG9ET01Ob2RlKCk7XG4gICAgICAgICAgICAvLyBob29rcyB1cCBuZXh0U2libGluZyBmb3IgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgIGxpbmVDb250YWluZXIuYXBwZW5kQ2hpbGQoY3VycmVudE5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5lZWRzQ2FyZXROb2RlQWZ0ZXIocGFydCwgcGFydCA9PT0gbGFzdFBhcnQpKSB7XG4gICAgICAgICAgICBpZiAoaXNDYXJldE5vZGUoY3VycmVudE5vZGUubmV4dFNpYmxpbmcpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB1cGRhdGVDYXJldE5vZGUoY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXJldE5vZGUgPSBjcmVhdGVDYXJldE5vZGUoKTtcbiAgICAgICAgICAgICAgICBpbnNlcnRBZnRlcihjdXJyZW50Tm9kZSwgY2FyZXROb2RlKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGNhcmV0Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZQYXJ0ID0gcGFydDtcbiAgICB9XG5cbiAgICByZW1vdmVOZXh0U2libGluZ3MoY3VycmVudE5vZGUpO1xufVxuXG5mdW5jdGlvbiByZWNvbmNpbGVFbXB0eUxpbmUobGluZUNvbnRhaW5lcjogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAvLyBlbXB0eSBkaXYgbmVlZHMgdG8gaGF2ZSBhIEJSIGluIGl0IHRvIGdpdmUgaXQgaGVpZ2h0XG4gICAgbGV0IGZvdW5kQlIgPSBmYWxzZTtcbiAgICBsZXQgcGFydE5vZGUgPSBsaW5lQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKHBhcnROb2RlKSB7XG4gICAgICAgIGNvbnN0IG5leHROb2RlID0gcGFydE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIGlmICghZm91bmRCUiAmJiAocGFydE5vZGUgYXMgSFRNTEVsZW1lbnQpLnRhZ05hbWUgPT09IFwiQlJcIikge1xuICAgICAgICAgICAgZm91bmRCUiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJ0Tm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0Tm9kZSA9IG5leHROb2RlO1xuICAgIH1cbiAgICBpZiAoIWZvdW5kQlIpIHtcbiAgICAgICAgbGluZUNvbnRhaW5lci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlck1vZGVsKGVkaXRvcjogSFRNTERpdkVsZW1lbnQsIG1vZGVsOiBFZGl0b3JNb2RlbCk6IHZvaWQge1xuICAgIGNvbnN0IGxpbmVzID0gbW9kZWwucGFydHMucmVkdWNlKChsaW5lc0FyciwgcGFydCkgPT4ge1xuICAgICAgICBpZiAocGFydC50eXBlID09PSBUeXBlLk5ld2xpbmUpIHtcbiAgICAgICAgICAgIGxpbmVzQXJyLnB1c2goW10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbGFzdExpbmUgPSBsaW5lc0FycltsaW5lc0Fyci5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGxhc3RMaW5lLnB1c2gocGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmVzQXJyO1xuICAgIH0sIFtbXV0pO1xuICAgIGxpbmVzLmZvckVhY2goKHBhcnRzLCBpKSA9PiB7XG4gICAgICAgIC8vIGZpbmQgZmlyc3QgKGFuZCByZW1vdmUgYW55dGhpbmcgZWxzZSkgZGl2IHdpdGhvdXQgY2xhc3NOYW1lXG4gICAgICAgIC8vIChhcyBicm93c2VycyBpbnNlcnQgdGhlc2UgaW4gY29udGVudGVkaXRhYmxlKSBsaW5lIGNvbnRhaW5lclxuICAgICAgICBsZXQgbGluZUNvbnRhaW5lciA9IGVkaXRvci5jaGlsZE5vZGVzW2ldO1xuICAgICAgICB3aGlsZSAobGluZUNvbnRhaW5lciAmJiAoKDxFbGVtZW50PmxpbmVDb250YWluZXIpLnRhZ05hbWUgIT09IFwiRElWXCIgfHwgISEoPEVsZW1lbnQ+bGluZUNvbnRhaW5lcikuY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgZWRpdG9yLnJlbW92ZUNoaWxkKGxpbmVDb250YWluZXIpO1xuICAgICAgICAgICAgbGluZUNvbnRhaW5lciA9IGVkaXRvci5jaGlsZE5vZGVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGluZUNvbnRhaW5lcikge1xuICAgICAgICAgICAgbGluZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBlZGl0b3IuYXBwZW5kQ2hpbGQobGluZUNvbnRhaW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZWNvbmNpbGVMaW5lKGxpbmVDb250YWluZXIsIHBhcnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlY29uY2lsZUVtcHR5TGluZShsaW5lQ29udGFpbmVyIGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChsaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgcmVtb3ZlTmV4dFNpYmxpbmdzKGVkaXRvci5jaGlsZHJlbltsaW5lcy5sZW5ndGggLSAxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlQ2hpbGRyZW4oZWRpdG9yKTtcbiAgICB9XG59XG4iXX0=