"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLineAndNodePosition = getLineAndNodePosition;
exports.setCaretPosition = setCaretPosition;
exports.setSelection = setSelection;

var _render = require("./render");

var _range = _interopRequireDefault(require("./range"));

var _parts = require("./parts");

/*
Copyright 2019 New Vector Ltd
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
function setSelection(editor, model, selection) {
  if (selection instanceof _range.default) {
    setDocumentRangeSelection(editor, model, selection);
  } else {
    setCaretPosition(editor, model, selection);
  }
}

function setDocumentRangeSelection(editor, model, range) {
  const sel = document.getSelection();
  sel.removeAllRanges();
  const selectionRange = document.createRange();
  const start = getNodeAndOffsetForPosition(editor, model, range.start);
  selectionRange.setStart(start.node, start.offset);
  const end = getNodeAndOffsetForPosition(editor, model, range.end);
  selectionRange.setEnd(end.node, end.offset);
  sel.addRange(selectionRange);
}

function setCaretPosition(editor, model, caretPosition) {
  const range = document.createRange();
  const {
    node,
    offset
  } = getNodeAndOffsetForPosition(editor, model, caretPosition);
  range.setStart(node, offset);
  range.collapse(true);
  const sel = document.getSelection();

  if (sel.rangeCount === 1) {
    const existingRange = sel.getRangeAt(0);

    if (existingRange.startContainer === range.startContainer && existingRange.startOffset === range.startOffset && existingRange.collapsed === range.collapsed) {
      // If the selection matches, it's important to leave it alone.
      // Recreating the selection state in at least Chrome can cause
      // strange side effects, like touch bar flickering on every key.
      // See https://github.com/vector-im/element-web/issues/9299
      return;
    }
  }

  sel.removeAllRanges();
  sel.addRange(range);
}

function getNodeAndOffsetForPosition(editor, model, position) {
  const {
    offset,
    lineIndex,
    nodeIndex
  } = getLineAndNodePosition(model, position);
  const lineNode = editor.childNodes[lineIndex];
  let focusNode; // empty line with just a <br>

  if (nodeIndex === -1) {
    focusNode = lineNode;
  } else {
    focusNode = lineNode.childNodes[nodeIndex]; // make sure we have a text node

    if (focusNode.nodeType === Node.ELEMENT_NODE && focusNode.firstChild) {
      focusNode = focusNode.firstChild;
    }
  }

  return {
    node: focusNode,
    offset
  };
}

function getLineAndNodePosition(model, caretPosition) {
  const {
    parts
  } = model;
  const partIndex = caretPosition.index;
  const lineResult = findNodeInLineForPart(parts, partIndex);
  const {
    lineIndex
  } = lineResult;
  let {
    nodeIndex
  } = lineResult;
  let {
    offset
  } = caretPosition; // we're at an empty line between a newline part
  // and another newline part or end/start of parts.
  // set offset to 0 so it gets set to the <br> inside the line container

  if (nodeIndex === -1) {
    offset = 0;
  } else {
    // move caret out of uneditable part (into caret node, or empty line br) if needed
    ({
      nodeIndex,
      offset
    } = moveOutOfUneditablePart(parts, partIndex, nodeIndex, offset));
  }

  return {
    lineIndex,
    nodeIndex,
    offset
  };
}

function findNodeInLineForPart(parts, partIndex) {
  let lineIndex = 0;
  let nodeIndex = -1;
  let prevPart = null; // go through to parts up till (and including) the index
  // to find newline parts

  for (let i = 0; i <= partIndex; ++i) {
    const part = parts[i];

    if (part.type === _parts.Type.Newline) {
      lineIndex += 1;
      nodeIndex = -1;
      prevPart = null;
    } else {
      nodeIndex += 1;

      if ((0, _render.needsCaretNodeBefore)(part, prevPart)) {
        nodeIndex += 1;
      } // only jump over caret node if we're not at our destination node already,
      // as we'll assume in moveOutOfUneditablePart that nodeIndex
      // refers to the node  corresponding to the part,
      // and not an adjacent caret node


      if (i < partIndex) {
        const nextPart = parts[i + 1];
        const isLastOfLine = !nextPart || nextPart.type === _parts.Type.Newline;

        if ((0, _render.needsCaretNodeAfter)(part, isLastOfLine)) {
          nodeIndex += 1;
        }
      }

      prevPart = part;
    }
  }

  return {
    lineIndex,
    nodeIndex
  };
}

function moveOutOfUneditablePart(parts, partIndex, nodeIndex, offset) {
  // move caret before or after uneditable part
  const part = parts[partIndex];

  if (part && !part.canEdit) {
    if (offset === 0) {
      nodeIndex -= 1;
      const prevPart = parts[partIndex - 1]; // if the previous node is a caret node, it's empty
      // so the offset can stay at 0
      // only when it's not, we need to set the offset
      // at the end of the node

      if (!(0, _render.needsCaretNodeBefore)(part, prevPart)) {
        offset = prevPart.text.length;
      }
    } else {
      nodeIndex += 1;
      offset = 0;
    }
  }

  return {
    nodeIndex,
    offset
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9lZGl0b3IvY2FyZXQudHMiXSwibmFtZXMiOlsic2V0U2VsZWN0aW9uIiwiZWRpdG9yIiwibW9kZWwiLCJzZWxlY3Rpb24iLCJSYW5nZSIsInNldERvY3VtZW50UmFuZ2VTZWxlY3Rpb24iLCJzZXRDYXJldFBvc2l0aW9uIiwicmFuZ2UiLCJzZWwiLCJkb2N1bWVudCIsImdldFNlbGVjdGlvbiIsInJlbW92ZUFsbFJhbmdlcyIsInNlbGVjdGlvblJhbmdlIiwiY3JlYXRlUmFuZ2UiLCJzdGFydCIsImdldE5vZGVBbmRPZmZzZXRGb3JQb3NpdGlvbiIsInNldFN0YXJ0Iiwibm9kZSIsIm9mZnNldCIsImVuZCIsInNldEVuZCIsImFkZFJhbmdlIiwiY2FyZXRQb3NpdGlvbiIsImNvbGxhcHNlIiwicmFuZ2VDb3VudCIsImV4aXN0aW5nUmFuZ2UiLCJnZXRSYW5nZUF0Iiwic3RhcnRDb250YWluZXIiLCJzdGFydE9mZnNldCIsImNvbGxhcHNlZCIsInBvc2l0aW9uIiwibGluZUluZGV4Iiwibm9kZUluZGV4IiwiZ2V0TGluZUFuZE5vZGVQb3NpdGlvbiIsImxpbmVOb2RlIiwiY2hpbGROb2RlcyIsImZvY3VzTm9kZSIsIm5vZGVUeXBlIiwiTm9kZSIsIkVMRU1FTlRfTk9ERSIsImZpcnN0Q2hpbGQiLCJwYXJ0cyIsInBhcnRJbmRleCIsImluZGV4IiwibGluZVJlc3VsdCIsImZpbmROb2RlSW5MaW5lRm9yUGFydCIsIm1vdmVPdXRPZlVuZWRpdGFibGVQYXJ0IiwicHJldlBhcnQiLCJpIiwicGFydCIsInR5cGUiLCJUeXBlIiwiTmV3bGluZSIsIm5leHRQYXJ0IiwiaXNMYXN0T2ZMaW5lIiwiY2FuRWRpdCIsInRleHQiLCJsZW5ndGgiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBaUJBOztBQUNBOztBQUdBOztBQXJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LElBQUFBLFNBQUY7QUFBYUMsSUFBQUE7QUFBYixHQUFQO0FBQ0g7O0FBRUQsU0FBU2MsdUJBQVQsQ0FBaUNMLEtBQWpDLEVBQWdEQyxTQUFoRCxFQUFtRVYsU0FBbkUsRUFBc0ZkLE1BQXRGLEVBQXNHO0FBQ2xHO0FBQ0EsUUFBTStCLElBQUksR0FBR1IsS0FBSyxDQUFDQyxTQUFELENBQWxCOztBQUNBLE1BQUlPLElBQUksSUFBSSxDQUFDQSxJQUFJLENBQUNNLE9BQWxCLEVBQTJCO0FBQ3ZCLFFBQUlyQyxNQUFNLEtBQUssQ0FBZixFQUFrQjtBQUNkYyxNQUFBQSxTQUFTLElBQUksQ0FBYjtBQUNBLFlBQU1lLFFBQVEsR0FBR04sS0FBSyxDQUFDQyxTQUFTLEdBQUcsQ0FBYixDQUF0QixDQUZjLENBR2Q7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsVUFBSSxDQUFDLGtDQUFxQk8sSUFBckIsRUFBMkJGLFFBQTNCLENBQUwsRUFBMkM7QUFDdkM3QixRQUFBQSxNQUFNLEdBQUc2QixRQUFRLENBQUNTLElBQVQsQ0FBY0MsTUFBdkI7QUFDSDtBQUNKLEtBVkQsTUFVTztBQUNIekIsTUFBQUEsU0FBUyxJQUFJLENBQWI7QUFDQWQsTUFBQUEsTUFBTSxHQUFHLENBQVQ7QUFDSDtBQUNKOztBQUNELFNBQU87QUFBRWMsSUFBQUEsU0FBRjtBQUFhZCxJQUFBQTtBQUFiLEdBQVA7QUFDSCIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxOSBOZXcgVmVjdG9yIEx0ZFxuQ29weXJpZ2h0IDIwMTkgVGhlIE1hdHJpeC5vcmcgRm91bmRhdGlvbiBDLkkuQy5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgeyBuZWVkc0NhcmV0Tm9kZUJlZm9yZSwgbmVlZHNDYXJldE5vZGVBZnRlciB9IGZyb20gXCIuL3JlbmRlclwiO1xuaW1wb3J0IFJhbmdlIGZyb20gXCIuL3JhbmdlXCI7XG5pbXBvcnQgRWRpdG9yTW9kZWwgZnJvbSBcIi4vbW9kZWxcIjtcbmltcG9ydCBEb2N1bWVudFBvc2l0aW9uLCB7IElQb3NpdGlvbiB9IGZyb20gXCIuL3Bvc2l0aW9uXCI7XG5pbXBvcnQgeyBQYXJ0LCBUeXBlIH0gZnJvbSBcIi4vcGFydHNcIjtcblxuZXhwb3J0IHR5cGUgQ2FyZXQgPSBSYW5nZSB8IERvY3VtZW50UG9zaXRpb247XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRTZWxlY3Rpb24oZWRpdG9yOiBIVE1MRGl2RWxlbWVudCwgbW9kZWw6IEVkaXRvck1vZGVsLCBzZWxlY3Rpb246IFJhbmdlIHwgSVBvc2l0aW9uKSB7XG4gICAgaWYgKHNlbGVjdGlvbiBpbnN0YW5jZW9mIFJhbmdlKSB7XG4gICAgICAgIHNldERvY3VtZW50UmFuZ2VTZWxlY3Rpb24oZWRpdG9yLCBtb2RlbCwgc2VsZWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzZXRDYXJldFBvc2l0aW9uKGVkaXRvciwgbW9kZWwsIHNlbGVjdGlvbik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXREb2N1bWVudFJhbmdlU2VsZWN0aW9uKGVkaXRvcjogSFRNTERpdkVsZW1lbnQsIG1vZGVsOiBFZGl0b3JNb2RlbCwgcmFuZ2U6IFJhbmdlKSB7XG4gICAgY29uc3Qgc2VsID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIGNvbnN0IHNlbGVjdGlvblJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICBjb25zdCBzdGFydCA9IGdldE5vZGVBbmRPZmZzZXRGb3JQb3NpdGlvbihlZGl0b3IsIG1vZGVsLCByYW5nZS5zdGFydCk7XG4gICAgc2VsZWN0aW9uUmFuZ2Uuc2V0U3RhcnQoc3RhcnQubm9kZSwgc3RhcnQub2Zmc2V0KTtcbiAgICBjb25zdCBlbmQgPSBnZXROb2RlQW5kT2Zmc2V0Rm9yUG9zaXRpb24oZWRpdG9yLCBtb2RlbCwgcmFuZ2UuZW5kKTtcbiAgICBzZWxlY3Rpb25SYW5nZS5zZXRFbmQoZW5kLm5vZGUsIGVuZC5vZmZzZXQpO1xuICAgIHNlbC5hZGRSYW5nZShzZWxlY3Rpb25SYW5nZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRDYXJldFBvc2l0aW9uKGVkaXRvcjogSFRNTERpdkVsZW1lbnQsIG1vZGVsOiBFZGl0b3JNb2RlbCwgY2FyZXRQb3NpdGlvbjogSVBvc2l0aW9uKSB7XG4gICAgY29uc3QgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIGNvbnN0IHsgbm9kZSwgb2Zmc2V0IH0gPSBnZXROb2RlQW5kT2Zmc2V0Rm9yUG9zaXRpb24oZWRpdG9yLCBtb2RlbCwgY2FyZXRQb3NpdGlvbik7XG4gICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgb2Zmc2V0KTtcbiAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcblxuICAgIGNvbnN0IHNlbCA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgIGlmIChzZWwucmFuZ2VDb3VudCA9PT0gMSkge1xuICAgICAgICBjb25zdCBleGlzdGluZ1JhbmdlID0gc2VsLmdldFJhbmdlQXQoMCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGV4aXN0aW5nUmFuZ2Uuc3RhcnRDb250YWluZXIgPT09IHJhbmdlLnN0YXJ0Q29udGFpbmVyICYmXG4gICAgICAgICAgICBleGlzdGluZ1JhbmdlLnN0YXJ0T2Zmc2V0ID09PSByYW5nZS5zdGFydE9mZnNldCAmJlxuICAgICAgICAgICAgZXhpc3RpbmdSYW5nZS5jb2xsYXBzZWQgPT09IHJhbmdlLmNvbGxhcHNlZFxuICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBzZWxlY3Rpb24gbWF0Y2hlcywgaXQncyBpbXBvcnRhbnQgdG8gbGVhdmUgaXQgYWxvbmUuXG4gICAgICAgICAgICAvLyBSZWNyZWF0aW5nIHRoZSBzZWxlY3Rpb24gc3RhdGUgaW4gYXQgbGVhc3QgQ2hyb21lIGNhbiBjYXVzZVxuICAgICAgICAgICAgLy8gc3RyYW5nZSBzaWRlIGVmZmVjdHMsIGxpa2UgdG91Y2ggYmFyIGZsaWNrZXJpbmcgb24gZXZlcnkga2V5LlxuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92ZWN0b3ItaW0vZWxlbWVudC13ZWIvaXNzdWVzLzkyOTlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgc2VsLmFkZFJhbmdlKHJhbmdlKTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZUFuZE9mZnNldEZvclBvc2l0aW9uKGVkaXRvcjogSFRNTERpdkVsZW1lbnQsIG1vZGVsOiBFZGl0b3JNb2RlbCwgcG9zaXRpb246IElQb3NpdGlvbikge1xuICAgIGNvbnN0IHsgb2Zmc2V0LCBsaW5lSW5kZXgsIG5vZGVJbmRleCB9ID0gZ2V0TGluZUFuZE5vZGVQb3NpdGlvbihtb2RlbCwgcG9zaXRpb24pO1xuICAgIGNvbnN0IGxpbmVOb2RlID0gZWRpdG9yLmNoaWxkTm9kZXNbbGluZUluZGV4XTtcblxuICAgIGxldCBmb2N1c05vZGU7XG4gICAgLy8gZW1wdHkgbGluZSB3aXRoIGp1c3QgYSA8YnI+XG4gICAgaWYgKG5vZGVJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgZm9jdXNOb2RlID0gbGluZU5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9jdXNOb2RlID0gbGluZU5vZGUuY2hpbGROb2Rlc1tub2RlSW5kZXhdO1xuICAgICAgICAvLyBtYWtlIHN1cmUgd2UgaGF2ZSBhIHRleHQgbm9kZVxuICAgICAgICBpZiAoZm9jdXNOb2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBmb2N1c05vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgZm9jdXNOb2RlID0gZm9jdXNOb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbm9kZTogZm9jdXNOb2RlLCBvZmZzZXQgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExpbmVBbmROb2RlUG9zaXRpb24obW9kZWw6IEVkaXRvck1vZGVsLCBjYXJldFBvc2l0aW9uOiBJUG9zaXRpb24pIHtcbiAgICBjb25zdCB7IHBhcnRzIH0gPSBtb2RlbDtcbiAgICBjb25zdCBwYXJ0SW5kZXggPSBjYXJldFBvc2l0aW9uLmluZGV4O1xuICAgIGNvbnN0IGxpbmVSZXN1bHQgPSBmaW5kTm9kZUluTGluZUZvclBhcnQocGFydHMsIHBhcnRJbmRleCk7XG4gICAgY29uc3QgeyBsaW5lSW5kZXggfSA9IGxpbmVSZXN1bHQ7XG4gICAgbGV0IHsgbm9kZUluZGV4IH0gPSBsaW5lUmVzdWx0O1xuICAgIGxldCB7IG9mZnNldCB9ID0gY2FyZXRQb3NpdGlvbjtcbiAgICAvLyB3ZSdyZSBhdCBhbiBlbXB0eSBsaW5lIGJldHdlZW4gYSBuZXdsaW5lIHBhcnRcbiAgICAvLyBhbmQgYW5vdGhlciBuZXdsaW5lIHBhcnQgb3IgZW5kL3N0YXJ0IG9mIHBhcnRzLlxuICAgIC8vIHNldCBvZmZzZXQgdG8gMCBzbyBpdCBnZXRzIHNldCB0byB0aGUgPGJyPiBpbnNpZGUgdGhlIGxpbmUgY29udGFpbmVyXG4gICAgaWYgKG5vZGVJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBtb3ZlIGNhcmV0IG91dCBvZiB1bmVkaXRhYmxlIHBhcnQgKGludG8gY2FyZXQgbm9kZSwgb3IgZW1wdHkgbGluZSBicikgaWYgbmVlZGVkXG4gICAgICAgICh7IG5vZGVJbmRleCwgb2Zmc2V0IH0gPSBtb3ZlT3V0T2ZVbmVkaXRhYmxlUGFydChwYXJ0cywgcGFydEluZGV4LCBub2RlSW5kZXgsIG9mZnNldCkpO1xuICAgIH1cbiAgICByZXR1cm4geyBsaW5lSW5kZXgsIG5vZGVJbmRleCwgb2Zmc2V0IH07XG59XG5cbmZ1bmN0aW9uIGZpbmROb2RlSW5MaW5lRm9yUGFydChwYXJ0czogUGFydFtdLCBwYXJ0SW5kZXg6IG51bWJlcikge1xuICAgIGxldCBsaW5lSW5kZXggPSAwO1xuICAgIGxldCBub2RlSW5kZXggPSAtMTtcblxuICAgIGxldCBwcmV2UGFydCA9IG51bGw7XG4gICAgLy8gZ28gdGhyb3VnaCB0byBwYXJ0cyB1cCB0aWxsIChhbmQgaW5jbHVkaW5nKSB0aGUgaW5kZXhcbiAgICAvLyB0byBmaW5kIG5ld2xpbmUgcGFydHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBwYXJ0SW5kZXg7ICsraSkge1xuICAgICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFR5cGUuTmV3bGluZSkge1xuICAgICAgICAgICAgbGluZUluZGV4ICs9IDE7XG4gICAgICAgICAgICBub2RlSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHByZXZQYXJ0ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGVJbmRleCArPSAxO1xuICAgICAgICAgICAgaWYgKG5lZWRzQ2FyZXROb2RlQmVmb3JlKHBhcnQsIHByZXZQYXJ0KSkge1xuICAgICAgICAgICAgICAgIG5vZGVJbmRleCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb25seSBqdW1wIG92ZXIgY2FyZXQgbm9kZSBpZiB3ZSdyZSBub3QgYXQgb3VyIGRlc3RpbmF0aW9uIG5vZGUgYWxyZWFkeSxcbiAgICAgICAgICAgIC8vIGFzIHdlJ2xsIGFzc3VtZSBpbiBtb3ZlT3V0T2ZVbmVkaXRhYmxlUGFydCB0aGF0IG5vZGVJbmRleFxuICAgICAgICAgICAgLy8gcmVmZXJzIHRvIHRoZSBub2RlICBjb3JyZXNwb25kaW5nIHRvIHRoZSBwYXJ0LFxuICAgICAgICAgICAgLy8gYW5kIG5vdCBhbiBhZGphY2VudCBjYXJldCBub2RlXG4gICAgICAgICAgICBpZiAoaSA8IHBhcnRJbmRleCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRQYXJ0ID0gcGFydHNbaSArIDFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzTGFzdE9mTGluZSA9ICFuZXh0UGFydCB8fCBuZXh0UGFydC50eXBlID09PSBUeXBlLk5ld2xpbmU7XG4gICAgICAgICAgICAgICAgaWYgKG5lZWRzQ2FyZXROb2RlQWZ0ZXIocGFydCwgaXNMYXN0T2ZMaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlSW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2UGFydCA9IHBhcnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBsaW5lSW5kZXgsIG5vZGVJbmRleCB9O1xufVxuXG5mdW5jdGlvbiBtb3ZlT3V0T2ZVbmVkaXRhYmxlUGFydChwYXJ0czogUGFydFtdLCBwYXJ0SW5kZXg6IG51bWJlciwgbm9kZUluZGV4OiBudW1iZXIsIG9mZnNldDogbnVtYmVyKSB7XG4gICAgLy8gbW92ZSBjYXJldCBiZWZvcmUgb3IgYWZ0ZXIgdW5lZGl0YWJsZSBwYXJ0XG4gICAgY29uc3QgcGFydCA9IHBhcnRzW3BhcnRJbmRleF07XG4gICAgaWYgKHBhcnQgJiYgIXBhcnQuY2FuRWRpdCkge1xuICAgICAgICBpZiAob2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICBub2RlSW5kZXggLT0gMTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZQYXJ0ID0gcGFydHNbcGFydEluZGV4IC0gMV07XG4gICAgICAgICAgICAvLyBpZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBhIGNhcmV0IG5vZGUsIGl0J3MgZW1wdHlcbiAgICAgICAgICAgIC8vIHNvIHRoZSBvZmZzZXQgY2FuIHN0YXkgYXQgMFxuICAgICAgICAgICAgLy8gb25seSB3aGVuIGl0J3Mgbm90LCB3ZSBuZWVkIHRvIHNldCB0aGUgb2Zmc2V0XG4gICAgICAgICAgICAvLyBhdCB0aGUgZW5kIG9mIHRoZSBub2RlXG4gICAgICAgICAgICBpZiAoIW5lZWRzQ2FyZXROb2RlQmVmb3JlKHBhcnQsIHByZXZQYXJ0KSkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHByZXZQYXJ0LnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZUluZGV4ICs9IDE7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG5vZGVJbmRleCwgb2Zmc2V0IH07XG59XG4iXX0=