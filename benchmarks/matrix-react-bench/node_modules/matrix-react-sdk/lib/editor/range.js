"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

/*
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
const whitespacePredicate = (index, offset, part) => {
  return part.text[offset].trim() === "";
};

class Range {
  constructor(model, positionA, positionB = positionA) {
    this.model = model;
    (0, _defineProperty2.default)(this, "_start", void 0);
    (0, _defineProperty2.default)(this, "_end", void 0);
    const bIsLarger = positionA.compare(positionB) < 0;
    this._start = bIsLarger ? positionA : positionB;
    this._end = bIsLarger ? positionB : positionA;
  }

  moveStartForwards(delta) {
    this._start = this._start.forwardsWhile(this.model, () => {
      delta -= 1;
      return delta >= 0;
    });
  }

  moveEndBackwards(delta) {
    this._end = this._end.backwardsWhile(this.model, () => {
      delta -= 1;
      return delta >= 0;
    });
  }

  trim() {
    this._start = this._start.forwardsWhile(this.model, whitespacePredicate);
    this._end = this._end.backwardsWhile(this.model, whitespacePredicate);
  }

  expandBackwardsWhile(predicate) {
    this._start = this._start.backwardsWhile(this.model, predicate);
  }

  get text() {
    let text = "";

    this._start.iteratePartsBetween(this._end, this.model, (part, startIdx, endIdx) => {
      const t = part.text.substring(startIdx, endIdx);
      text = text + t;
    });

    return text;
  }
  /**
   * Splits the model at the range boundaries and replaces with the given parts.
   * Should be run inside a `model.transform()` callback.
   * @param {Part[]} parts the parts to replace the range with
   * @return {Number} the net amount of characters added, can be negative.
   */


  replace(parts) {
    const newLength = parts.reduce((sum, part) => sum + part.text.length, 0);
    let oldLength = 0;

    this._start.iteratePartsBetween(this._end, this.model, (part, startIdx, endIdx) => {
      oldLength += endIdx - startIdx;
    });

    this.model.replaceRange(this._start, this._end, parts);
    return newLength - oldLength;
  }
  /**
   * Returns a copy of the (partial) parts within the range.
   * For partial parts, only the text is adjusted to the part that intersects with the range.
   */


  get parts() {
    const parts = [];

    this._start.iteratePartsBetween(this._end, this.model, (part, startIdx, endIdx) => {
      const serializedPart = part.serialize();
      serializedPart.text = part.text.substring(startIdx, endIdx);
      const newPart = this.model.partCreator.deserializePart(serializedPart);
      parts.push(newPart);
    });

    return parts;
  }

  get length() {
    let len = 0;

    this._start.iteratePartsBetween(this._end, this.model, (part, startIdx, endIdx) => {
      len += endIdx - startIdx;
    });

    return len;
  }

  get start() {
    return this._start;
  }

  get end() {
    return this._end;
  }

}

exports.default = Range;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9lZGl0b3IvcmFuZ2UudHMiXSwibmFtZXMiOlsid2hpdGVzcGFjZVByZWRpY2F0ZSIsImluZGV4Iiwib2Zmc2V0IiwicGFydCIsInRleHQiLCJ0cmltIiwiUmFuZ2UiLCJjb25zdHJ1Y3RvciIsIm1vZGVsIiwicG9zaXRpb25BIiwicG9zaXRpb25CIiwiYklzTGFyZ2VyIiwiY29tcGFyZSIsIl9zdGFydCIsIl9lbmQiLCJtb3ZlU3RhcnRGb3J3YXJkcyIsImRlbHRhIiwiZm9yd2FyZHNXaGlsZSIsIm1vdmVFbmRCYWNrd2FyZHMiLCJiYWNrd2FyZHNXaGlsZSIsImV4cGFuZEJhY2t3YXJkc1doaWxlIiwicHJlZGljYXRlIiwiaXRlcmF0ZVBhcnRzQmV0d2VlbiIsInN0YXJ0SWR4IiwiZW5kSWR4IiwidCIsInN1YnN0cmluZyIsInJlcGxhY2UiLCJwYXJ0cyIsIm5ld0xlbmd0aCIsInJlZHVjZSIsInN1bSIsImxlbmd0aCIsIm9sZExlbmd0aCIsInJlcGxhY2VSYW5nZSIsInNlcmlhbGl6ZWRQYXJ0Iiwic2VyaWFsaXplIiwibmV3UGFydCIsInBhcnRDcmVhdG9yIiwiZGVzZXJpYWxpemVQYXJ0IiwicHVzaCIsImxlbiIsInN0YXJ0IiwiZW5kIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BLE1BQU1BLG1CQUE4QixHQUFHLENBQUNDLEtBQUQsRUFBUUMsTUFBUixFQUFnQkMsSUFBaEIsS0FBeUI7QUFDNUQsU0FBT0EsSUFBSSxDQUFDQyxJQUFMLENBQVVGLE1BQVYsRUFBa0JHLElBQWxCLE9BQTZCLEVBQXBDO0FBQ0gsQ0FGRDs7QUFJZSxNQUFNQyxLQUFOLENBQVk7QUFJdkJDLEVBQUFBLFdBQVcsQ0FBaUJDLEtBQWpCLEVBQXFDQyxTQUFyQyxFQUFrRUMsU0FBUyxHQUFHRCxTQUE5RSxFQUF5RjtB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QUFMLENBQVlTLG1CQUFaLENBQWdDLEtBQUtSLElBQXJDLEVBQTJDLEtBQUtOLEtBQWhELEVBQXVELENBQUNMLElBQUQsRUFBT29CLFFBQVAsRUFBaUJDLE1BQWpCLEtBQTRCO0FBQy9FLFlBQU1XLGNBQWMsR0FBR2hDLElBQUksQ0FBQ2lDLFNBQUwsRUFBdkI7QUFDQUQsTUFBQUEsY0FBYyxDQUFDL0IsSUFBZixHQUFzQkQsSUFBSSxDQUFDQyxJQUFMLENBQVVzQixTQUFWLENBQW9CSCxRQUFwQixFQUE4QkMsTUFBOUIsQ0FBdEI7QUFDQSxZQUFNYSxPQUFPLEdBQUcsS0FBSzdCLEtBQUwsQ0FBVzhCLFdBQVgsQ0FBdUJDLGVBQXZCLENBQXVDSixjQUF2QyxDQUFoQjtBQUNBUCxNQUFBQSxLQUFLLENBQUNZLElBQU4sQ0FBV0gsT0FBWDtBQUNILEtBTEQ7O0FBTUEsV0FBT1QsS0FBUDtBQUNIOztBQUVnQixNQUFOSSxNQUFNLEdBQVc7QUFDeEIsUUFBSVMsR0FBRyxHQUFHLENBQVY7O0FBQ0EsU0FBSzVCLE1BQUwsQ0FBWVMsbUJBQVosQ0FBZ0MsS0FBS1IsSUFBckMsRUFBMkMsS0FBS04sS0FBaEQsRUFBdUQsQ0FBQ0wsSUFBRCxFQUFPb0IsUUFBUCxFQUFpQkMsTUFBakIsS0FBNEI7QUFDL0VpQixNQUFBQSxHQUFHLElBQUlqQixNQUFNLEdBQUdELFFBQWhCO0FBQ0gsS0FGRDs7QUFHQSxXQUFPa0IsR0FBUDtBQUNIOztBQUVlLE1BQUxDLEtBQUssR0FBcUI7QUFDakMsV0FBTyxLQUFLN0IsTUFBWjtBQUNIOztBQUVhLE1BQUg4QixHQUFHLEdBQXFCO0FBQy9CLFdBQU8sS0FBSzdCLElBQVo7QUFDSDs7QUF2RnNCIiwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE5IFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IEVkaXRvck1vZGVsIGZyb20gXCIuL21vZGVsXCI7XG5pbXBvcnQgRG9jdW1lbnRQb3NpdGlvbiwgeyBQcmVkaWNhdGUgfSBmcm9tIFwiLi9wb3NpdGlvblwiO1xuaW1wb3J0IHsgUGFydCB9IGZyb20gXCIuL3BhcnRzXCI7XG5cbmNvbnN0IHdoaXRlc3BhY2VQcmVkaWNhdGU6IFByZWRpY2F0ZSA9IChpbmRleCwgb2Zmc2V0LCBwYXJ0KSA9PiB7XG4gICAgcmV0dXJuIHBhcnQudGV4dFtvZmZzZXRdLnRyaW0oKSA9PT0gXCJcIjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhbmdlIHtcbiAgICBwcml2YXRlIF9zdGFydDogRG9jdW1lbnRQb3NpdGlvbjtcbiAgICBwcml2YXRlIF9lbmQ6IERvY3VtZW50UG9zaXRpb247XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgbW9kZWw6IEVkaXRvck1vZGVsLCBwb3NpdGlvbkE6IERvY3VtZW50UG9zaXRpb24sIHBvc2l0aW9uQiA9IHBvc2l0aW9uQSkge1xuICAgICAgICBjb25zdCBiSXNMYXJnZXIgPSBwb3NpdGlvbkEuY29tcGFyZShwb3NpdGlvbkIpIDwgMDtcbiAgICAgICAgdGhpcy5fc3RhcnQgPSBiSXNMYXJnZXIgPyBwb3NpdGlvbkEgOiBwb3NpdGlvbkI7XG4gICAgICAgIHRoaXMuX2VuZCA9IGJJc0xhcmdlciA/IHBvc2l0aW9uQiA6IHBvc2l0aW9uQTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbW92ZVN0YXJ0Rm9yd2FyZHMoZGVsdGE6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdGFydCA9IHRoaXMuX3N0YXJ0LmZvcndhcmRzV2hpbGUodGhpcy5tb2RlbCwgKCkgPT4ge1xuICAgICAgICAgICAgZGVsdGEgLT0gMTtcbiAgICAgICAgICAgIHJldHVybiBkZWx0YSA+PSAwO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbW92ZUVuZEJhY2t3YXJkcyhkZWx0YTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2VuZCA9IHRoaXMuX2VuZC5iYWNrd2FyZHNXaGlsZSh0aGlzLm1vZGVsLCAoKSA9PiB7XG4gICAgICAgICAgICBkZWx0YSAtPSAxO1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhID49IDA7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyB0cmltKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdGFydCA9IHRoaXMuX3N0YXJ0LmZvcndhcmRzV2hpbGUodGhpcy5tb2RlbCwgd2hpdGVzcGFjZVByZWRpY2F0ZSk7XG4gICAgICAgIHRoaXMuX2VuZCA9IHRoaXMuX2VuZC5iYWNrd2FyZHNXaGlsZSh0aGlzLm1vZGVsLCB3aGl0ZXNwYWNlUHJlZGljYXRlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZXhwYW5kQmFja3dhcmRzV2hpbGUocHJlZGljYXRlOiBQcmVkaWNhdGUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3RhcnQgPSB0aGlzLl9zdGFydC5iYWNrd2FyZHNXaGlsZSh0aGlzLm1vZGVsLCBwcmVkaWNhdGUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgdGV4dCgpOiBzdHJpbmcge1xuICAgICAgICBsZXQgdGV4dCA9IFwiXCI7XG4gICAgICAgIHRoaXMuX3N0YXJ0Lml0ZXJhdGVQYXJ0c0JldHdlZW4odGhpcy5fZW5kLCB0aGlzLm1vZGVsLCAocGFydCwgc3RhcnRJZHgsIGVuZElkeCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdCA9IHBhcnQudGV4dC5zdWJzdHJpbmcoc3RhcnRJZHgsIGVuZElkeCk7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dCArIHQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgdGhlIG1vZGVsIGF0IHRoZSByYW5nZSBib3VuZGFyaWVzIGFuZCByZXBsYWNlcyB3aXRoIHRoZSBnaXZlbiBwYXJ0cy5cbiAgICAgKiBTaG91bGQgYmUgcnVuIGluc2lkZSBhIGBtb2RlbC50cmFuc2Zvcm0oKWAgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtQYXJ0W119IHBhcnRzIHRoZSBwYXJ0cyB0byByZXBsYWNlIHRoZSByYW5nZSB3aXRoXG4gICAgICogQHJldHVybiB7TnVtYmVyfSB0aGUgbmV0IGFtb3VudCBvZiBjaGFyYWN0ZXJzIGFkZGVkLCBjYW4gYmUgbmVnYXRpdmUuXG4gICAgICovXG4gICAgcHVibGljIHJlcGxhY2UocGFydHM6IFBhcnRbXSk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IG5ld0xlbmd0aCA9IHBhcnRzLnJlZHVjZSgoc3VtLCBwYXJ0KSA9PiBzdW0gKyBwYXJ0LnRleHQubGVuZ3RoLCAwKTtcbiAgICAgICAgbGV0IG9sZExlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX3N0YXJ0Lml0ZXJhdGVQYXJ0c0JldHdlZW4odGhpcy5fZW5kLCB0aGlzLm1vZGVsLCAocGFydCwgc3RhcnRJZHgsIGVuZElkeCkgPT4ge1xuICAgICAgICAgICAgb2xkTGVuZ3RoICs9IGVuZElkeCAtIHN0YXJ0SWR4O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tb2RlbC5yZXBsYWNlUmFuZ2UodGhpcy5fc3RhcnQsIHRoaXMuX2VuZCwgcGFydHMpO1xuICAgICAgICByZXR1cm4gbmV3TGVuZ3RoIC0gb2xkTGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSAocGFydGlhbCkgcGFydHMgd2l0aGluIHRoZSByYW5nZS5cbiAgICAgKiBGb3IgcGFydGlhbCBwYXJ0cywgb25seSB0aGUgdGV4dCBpcyBhZGp1c3RlZCB0byB0aGUgcGFydCB0aGF0IGludGVyc2VjdHMgd2l0aCB0aGUgcmFuZ2UuXG4gICAgICovXG4gICAgcHVibGljIGdldCBwYXJ0cygpOiBQYXJ0W10ge1xuICAgICAgICBjb25zdCBwYXJ0czogUGFydFtdID0gW107XG4gICAgICAgIHRoaXMuX3N0YXJ0Lml0ZXJhdGVQYXJ0c0JldHdlZW4odGhpcy5fZW5kLCB0aGlzLm1vZGVsLCAocGFydCwgc3RhcnRJZHgsIGVuZElkeCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZFBhcnQgPSBwYXJ0LnNlcmlhbGl6ZSgpO1xuICAgICAgICAgICAgc2VyaWFsaXplZFBhcnQudGV4dCA9IHBhcnQudGV4dC5zdWJzdHJpbmcoc3RhcnRJZHgsIGVuZElkeCk7XG4gICAgICAgICAgICBjb25zdCBuZXdQYXJ0ID0gdGhpcy5tb2RlbC5wYXJ0Q3JlYXRvci5kZXNlcmlhbGl6ZVBhcnQoc2VyaWFsaXplZFBhcnQpO1xuICAgICAgICAgICAgcGFydHMucHVzaChuZXdQYXJ0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGxlbmd0aCgpOiBudW1iZXIge1xuICAgICAgICBsZXQgbGVuID0gMDtcbiAgICAgICAgdGhpcy5fc3RhcnQuaXRlcmF0ZVBhcnRzQmV0d2Vlbih0aGlzLl9lbmQsIHRoaXMubW9kZWwsIChwYXJ0LCBzdGFydElkeCwgZW5kSWR4KSA9PiB7XG4gICAgICAgICAgICBsZW4gKz0gZW5kSWR4IC0gc3RhcnRJZHg7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbGVuO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgc3RhcnQoKTogRG9jdW1lbnRQb3NpdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFydDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGVuZCgpOiBEb2N1bWVudFBvc2l0aW9uIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZDtcbiAgICB9XG59XG4iXX0=