"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pillifyLinks = pillifyLinks;
exports.unmountPills = unmountPills;

var _react = _interopRequireDefault(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _pushprocessor = require("matrix-js-sdk/src/pushprocessor");

var _MatrixClientPeg = require("../MatrixClientPeg");

var _SettingsStore = _interopRequireDefault(require("../settings/SettingsStore"));

var _Pill = _interopRequireDefault(require("../components/views/elements/Pill"));

var _Permalinks = require("./permalinks/Permalinks");

/*
Copyright 2019, 2020, 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/**
 * Recurses depth-first through a DOM tree, converting matrix.to links
 * into pills based on the context of a given room.  Returns a list of
 * the resulting React nodes so they can be unmounted rather than leaking.
 *
 * @param {Element[]} nodes - a list of sibling DOM nodes to traverse to try
 *   to turn into pills.
 * @param {MatrixEvent} mxEvent - the matrix event which the DOM nodes are
 *   part of representing.
 * @param {Element[]} pills: an accumulator of the DOM nodes which contain
 *   React components which have been mounted as part of this.
 *   The initial caller should pass in an empty array to seed the accumulator.
 */
function pillifyLinks(nodes, mxEvent, pills) {
  const room = _MatrixClientPeg.MatrixClientPeg.get().getRoom(mxEvent.getRoomId());

  const shouldShowPillAvatar = _SettingsStore.default.getValue("Pill.shouldShowPillAvatar");

  let node = nodes[0];

  while (node) {
    let pillified = false;

    if (node.tagName === "A" && node.getAttribute("href")) {
      const href = node.getAttribute("href");
      const parts = (0, _Permalinks.parseAppLocalLink)(href); // If the link is a (localised) matrix.to link, replace it with a pill
      // We don't want to pill event permalinks, so those are ignored.

      if (parts && !parts.eventId) {
        const pillContainer = document.createElement('span');

        const pill = /*#__PURE__*/_react.default.createElement(_Pill.default, {
          url: href,
          inMessage: true,
          room: room,
          shouldShowPillAvatar: shouldShowPillAvatar
        });

        _reactDom.default.render(pill, pillContainer);

        node.parentNode.replaceChild(pillContainer, node);
        pills.push(pillContainer); // Pills within pills aren't going to go well, so move on

        pillified = true; // update the current node with one that's now taken its place

        node = pillContainer;
      }
    } else if (node.nodeType === Node.TEXT_NODE && // as applying pills happens outside of react, make sure we're not doubly
    // applying @room pills here, as a rerender with the same content won't touch the DOM
    // to clear the pills from the last run of pillifyLinks
    !node.parentElement.classList.contains("mx_AtRoomPill")) {
      let currentTextNode = node;
      const roomNotifTextNodes = []; // Take a textNode and break it up to make all the instances of @room their
      // own textNode, adding those nodes to roomNotifTextNodes

      while (currentTextNode !== null) {
        const roomNotifPos = _Pill.default.roomNotifPos(currentTextNode.textContent);

        let nextTextNode = null;

        if (roomNotifPos > -1) {
          let roomTextNode = currentTextNode;
          if (roomNotifPos > 0) roomTextNode = roomTextNode.splitText(roomNotifPos);

          if (roomTextNode.textContent.length > _Pill.default.roomNotifLen()) {
            nextTextNode = roomTextNode.splitText(_Pill.default.roomNotifLen());
          }

          roomNotifTextNodes.push(roomTextNode);
        }

        currentTextNode = nextTextNode;
      }

      if (roomNotifTextNodes.length > 0) {
        const pushProcessor = new _pushprocessor.PushProcessor(_MatrixClientPeg.MatrixClientPeg.get());
        const atRoomRule = pushProcessor.getPushRuleById(".m.rule.roomnotif");

        if (atRoomRule && pushProcessor.ruleMatchesEvent(atRoomRule, mxEvent)) {
          // Now replace all those nodes with Pills
          for (const roomNotifTextNode of roomNotifTextNodes) {
            // Set the next node to be processed to the one after the node
            // we're adding now, since we've just inserted nodes into the structure
            // we're iterating over.
            // Note we've checked roomNotifTextNodes.length > 0 so we'll do this at least once
            node = roomNotifTextNode.nextSibling;
            const pillContainer = document.createElement('span');

            const pill = /*#__PURE__*/_react.default.createElement(_Pill.default, {
              type: _Pill.default.TYPE_AT_ROOM_MENTION,
              inMessage: true,
              room: room,
              shouldShowPillAvatar: shouldShowPillAvatar
            });

            _reactDom.default.render(pill, pillContainer);

            roomNotifTextNode.parentNode.replaceChild(pillContainer, roomNotifTextNode);
            pills.push(pillContainer);
          } // Nothing else to do for a text node (and we don't need to advance
          // the loop pointer because we did it above)


          continue;
        }
      }
    }

    if (node.childNodes && node.childNodes.length && !pillified) {
      pillifyLinks(node.childNodes, mxEvent, pills);
    }

    node = node.nextSibling;
  }
}
/**
 * Unmount all the pill containers from React created by pillifyLinks.
 *
 * It's critical to call this after pillifyLinks, otherwise
 * Pills will leak, leaking entire DOM trees via the event
 * emitter on BaseAvatar as per
 * https://github.com/vector-im/element-web/issues/12417
 *
 * @param {Element[]} pills - array of pill containers whose React
 *   components should be unmounted.
 */


function unmountPills(pills) {
  for (const pillContainer of pills) {
    _reactDom.default.unmountComponentAtNode(pillContainer);
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9waWxsaWZ5LnRzeCJdLCJuYW1lcyI6WyJwaWxsaWZ5TGlua3MiLCJub2RlcyIsIm14RXZlbnQiLCJwaWxscyIsInJvb20iLCJNYXRyaXhDbGllbnRQZWciLCJnZXQiLCJnZXRSb29tIiwiZ2V0Um9vbUlkIiwic2hvdWxkU2hvd1BpbGxBdmF0YXIiLCJTZXR0aW5nc1N0b3JlIiwiZ2V0VmFsdWUiLCJub2RlIiwicGlsbGlmaWVkIiwidGFnTmFtZSIsImdldEF0dHJpYnV0ZSIsImhyZWYiLCJwYXJ0cyIsImV2ZW50SWQiLCJwaWxsQ29udGFpbmVyIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwicGlsbCIsIlJlYWN0RE9NIiwicmVuZGVyIiwicGFyZW50Tm9kZSIsInJlcGxhY2VDaGlsZCIsInB1c2giLCJub2RlVHlwZSIsIk5vZGUiLCJURVhUX05PREUiLCJwYXJlbnRFbGVtZW50IiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCJjdXJyZW50VGV4dE5vZGUiLCJyb29tTm90aWZUZXh0Tm9kZXMiLCJyb29tTm90aWZQb3MiLCJQaWxsIiwidGV4dENvbnRlbnQiLCJuZXh0VGV4dE5vZGUiLCJyb29tVGV4dE5vZGUiLCJzcGxpdFRleHQiLCJsZW5ndGgiLCJyb29tTm90aWZMZW4iLCJwdXNoUHJvY2Vzc29yIiwiUHVzaFByb2Nlc3NvciIsImF0Um9vbVJ1bGUiLCJnZXRQdXNoUnVsZUJ5SWQiLCJydWxlTWF0Y2hlc0V2ZW50Iiwicm9vbU5vdGlmVGV4dE5vZGUiLCJuZXh0U2libGluZyIsIlRZUEVfQVRfUk9PTV9NRU5USU9OIiwiY2hpbGROb2RlcyIsInVubW91bnRQaWxscyIsInVubW91bnRDb21wb25lbnRBdE5vZGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFnQkE7O0FBQ0E7O0FBQ0E7O0FBR0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUEsWUFBWSxDQUFDWSxJQUFJLENBQUN3QyxVQUFOLEVBQXlDbEQsT0FBekMsRUFBa0RDLEtBQWxELENBQVo7QUFDSDs7QUFFRFMsSUFBQUEsSUFBSSxHQUFHQSxJQUFJLENBQUNzQyxXQUFaO0FBQ0g7QUFDSjtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNPLFNBQVNHLFlBQVQsQ0FBc0JsRCxLQUF0QixFQUF3QztBQUMzQyxPQUFLLE1BQU1nQixhQUFYLElBQTRCaEIsS0FBNUIsRUFBbUM7QUFDL0JvQixzQkFBUytCLHNCQUFULENBQWdDbkMsYUFBaEM7QUFDSDtBQUNKIiwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE5LCAyMDIwLCAyMDIxIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBQdXNoUHJvY2Vzc29yIH0gZnJvbSAnbWF0cml4LWpzLXNkay9zcmMvcHVzaHByb2Nlc3Nvcic7XG5pbXBvcnQgeyBNYXRyaXhFdmVudCB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9tb2RlbHMvZXZlbnRcIjtcblxuaW1wb3J0IHsgTWF0cml4Q2xpZW50UGVnIH0gZnJvbSAnLi4vTWF0cml4Q2xpZW50UGVnJztcbmltcG9ydCBTZXR0aW5nc1N0b3JlIGZyb20gXCIuLi9zZXR0aW5ncy9TZXR0aW5nc1N0b3JlXCI7XG5pbXBvcnQgUGlsbCBmcm9tIFwiLi4vY29tcG9uZW50cy92aWV3cy9lbGVtZW50cy9QaWxsXCI7XG5pbXBvcnQgeyBwYXJzZUFwcExvY2FsTGluayB9IGZyb20gXCIuL3Blcm1hbGlua3MvUGVybWFsaW5rc1wiO1xuXG4vKipcbiAqIFJlY3Vyc2VzIGRlcHRoLWZpcnN0IHRocm91Z2ggYSBET00gdHJlZSwgY29udmVydGluZyBtYXRyaXgudG8gbGlua3NcbiAqIGludG8gcGlsbHMgYmFzZWQgb24gdGhlIGNvbnRleHQgb2YgYSBnaXZlbiByb29tLiAgUmV0dXJucyBhIGxpc3Qgb2ZcbiAqIHRoZSByZXN1bHRpbmcgUmVhY3Qgbm9kZXMgc28gdGhleSBjYW4gYmUgdW5tb3VudGVkIHJhdGhlciB0aGFuIGxlYWtpbmcuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50W119IG5vZGVzIC0gYSBsaXN0IG9mIHNpYmxpbmcgRE9NIG5vZGVzIHRvIHRyYXZlcnNlIHRvIHRyeVxuICogICB0byB0dXJuIGludG8gcGlsbHMuXG4gKiBAcGFyYW0ge01hdHJpeEV2ZW50fSBteEV2ZW50IC0gdGhlIG1hdHJpeCBldmVudCB3aGljaCB0aGUgRE9NIG5vZGVzIGFyZVxuICogICBwYXJ0IG9mIHJlcHJlc2VudGluZy5cbiAqIEBwYXJhbSB7RWxlbWVudFtdfSBwaWxsczogYW4gYWNjdW11bGF0b3Igb2YgdGhlIERPTSBub2RlcyB3aGljaCBjb250YWluXG4gKiAgIFJlYWN0IGNvbXBvbmVudHMgd2hpY2ggaGF2ZSBiZWVuIG1vdW50ZWQgYXMgcGFydCBvZiB0aGlzLlxuICogICBUaGUgaW5pdGlhbCBjYWxsZXIgc2hvdWxkIHBhc3MgaW4gYW4gZW1wdHkgYXJyYXkgdG8gc2VlZCB0aGUgYWNjdW11bGF0b3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwaWxsaWZ5TGlua3Mobm9kZXM6IEFycmF5TGlrZTxFbGVtZW50PiwgbXhFdmVudDogTWF0cml4RXZlbnQsIHBpbGxzOiBFbGVtZW50W10pIHtcbiAgICBjb25zdCByb29tID0gTWF0cml4Q2xpZW50UGVnLmdldCgpLmdldFJvb20obXhFdmVudC5nZXRSb29tSWQoKSk7XG4gICAgY29uc3Qgc2hvdWxkU2hvd1BpbGxBdmF0YXIgPSBTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFwiUGlsbC5zaG91bGRTaG93UGlsbEF2YXRhclwiKTtcbiAgICBsZXQgbm9kZSA9IG5vZGVzWzBdO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGxldCBwaWxsaWZpZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAobm9kZS50YWdOYW1lID09PSBcIkFcIiAmJiBub2RlLmdldEF0dHJpYnV0ZShcImhyZWZcIikpIHtcbiAgICAgICAgICAgIGNvbnN0IGhyZWYgPSBub2RlLmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHBhcnNlQXBwTG9jYWxMaW5rKGhyZWYpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGxpbmsgaXMgYSAobG9jYWxpc2VkKSBtYXRyaXgudG8gbGluaywgcmVwbGFjZSBpdCB3aXRoIGEgcGlsbFxuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBwaWxsIGV2ZW50IHBlcm1hbGlua3MsIHNvIHRob3NlIGFyZSBpZ25vcmVkLlxuICAgICAgICAgICAgaWYgKHBhcnRzICYmICFwYXJ0cy5ldmVudElkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGlsbENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHBpbGwgPSA8UGlsbFxuICAgICAgICAgICAgICAgICAgICB1cmw9e2hyZWZ9XG4gICAgICAgICAgICAgICAgICAgIGluTWVzc2FnZT17dHJ1ZX1cbiAgICAgICAgICAgICAgICAgICAgcm9vbT17cm9vbX1cbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkU2hvd1BpbGxBdmF0YXI9e3Nob3VsZFNob3dQaWxsQXZhdGFyfVxuICAgICAgICAgICAgICAgIC8+O1xuXG4gICAgICAgICAgICAgICAgUmVhY3RET00ucmVuZGVyKHBpbGwsIHBpbGxDb250YWluZXIpO1xuICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQocGlsbENvbnRhaW5lciwgbm9kZSk7XG4gICAgICAgICAgICAgICAgcGlsbHMucHVzaChwaWxsQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAvLyBQaWxscyB3aXRoaW4gcGlsbHMgYXJlbid0IGdvaW5nIHRvIGdvIHdlbGwsIHNvIG1vdmUgb25cbiAgICAgICAgICAgICAgICBwaWxsaWZpZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBjdXJyZW50IG5vZGUgd2l0aCBvbmUgdGhhdCdzIG5vdyB0YWtlbiBpdHMgcGxhY2VcbiAgICAgICAgICAgICAgICBub2RlID0gcGlsbENvbnRhaW5lcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFICYmXG4gICAgICAgICAgICAvLyBhcyBhcHBseWluZyBwaWxscyBoYXBwZW5zIG91dHNpZGUgb2YgcmVhY3QsIG1ha2Ugc3VyZSB3ZSdyZSBub3QgZG91Ymx5XG4gICAgICAgICAgICAvLyBhcHBseWluZyBAcm9vbSBwaWxscyBoZXJlLCBhcyBhIHJlcmVuZGVyIHdpdGggdGhlIHNhbWUgY29udGVudCB3b24ndCB0b3VjaCB0aGUgRE9NXG4gICAgICAgICAgICAvLyB0byBjbGVhciB0aGUgcGlsbHMgZnJvbSB0aGUgbGFzdCBydW4gb2YgcGlsbGlmeUxpbmtzXG4gICAgICAgICAgICAhbm9kZS5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcIm14X0F0Um9vbVBpbGxcIilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFRleHROb2RlID0gbm9kZSBhcyBOb2RlIGFzIFRleHQ7XG4gICAgICAgICAgICBjb25zdCByb29tTm90aWZUZXh0Tm9kZXMgPSBbXTtcblxuICAgICAgICAgICAgLy8gVGFrZSBhIHRleHROb2RlIGFuZCBicmVhayBpdCB1cCB0byBtYWtlIGFsbCB0aGUgaW5zdGFuY2VzIG9mIEByb29tIHRoZWlyXG4gICAgICAgICAgICAvLyBvd24gdGV4dE5vZGUsIGFkZGluZyB0aG9zZSBub2RlcyB0byByb29tTm90aWZUZXh0Tm9kZXNcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50VGV4dE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByb29tTm90aWZQb3MgPSBQaWxsLnJvb21Ob3RpZlBvcyhjdXJyZW50VGV4dE5vZGUudGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0VGV4dE5vZGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChyb29tTm90aWZQb3MgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcm9vbVRleHROb2RlID0gY3VycmVudFRleHROb2RlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyb29tTm90aWZQb3MgPiAwKSByb29tVGV4dE5vZGUgPSByb29tVGV4dE5vZGUuc3BsaXRUZXh0KHJvb21Ob3RpZlBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb29tVGV4dE5vZGUudGV4dENvbnRlbnQubGVuZ3RoID4gUGlsbC5yb29tTm90aWZMZW4oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFRleHROb2RlID0gcm9vbVRleHROb2RlLnNwbGl0VGV4dChQaWxsLnJvb21Ob3RpZkxlbigpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByb29tTm90aWZUZXh0Tm9kZXMucHVzaChyb29tVGV4dE5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50VGV4dE5vZGUgPSBuZXh0VGV4dE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyb29tTm90aWZUZXh0Tm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHB1c2hQcm9jZXNzb3IgPSBuZXcgUHVzaFByb2Nlc3NvcihNYXRyaXhDbGllbnRQZWcuZ2V0KCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0Um9vbVJ1bGUgPSBwdXNoUHJvY2Vzc29yLmdldFB1c2hSdWxlQnlJZChcIi5tLnJ1bGUucm9vbW5vdGlmXCIpO1xuICAgICAgICAgICAgICAgIGlmIChhdFJvb21SdWxlICYmIHB1c2hQcm9jZXNzb3IucnVsZU1hdGNoZXNFdmVudChhdFJvb21SdWxlLCBteEV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3cgcmVwbGFjZSBhbGwgdGhvc2Ugbm9kZXMgd2l0aCBQaWxsc1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJvb21Ob3RpZlRleHROb2RlIG9mIHJvb21Ob3RpZlRleHROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBuZXh0IG5vZGUgdG8gYmUgcHJvY2Vzc2VkIHRvIHRoZSBvbmUgYWZ0ZXIgdGhlIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIGFkZGluZyBub3csIHNpbmNlIHdlJ3ZlIGp1c3QgaW5zZXJ0ZWQgbm9kZXMgaW50byB0aGUgc3RydWN0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSdyZSBpdGVyYXRpbmcgb3Zlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGUgd2UndmUgY2hlY2tlZCByb29tTm90aWZUZXh0Tm9kZXMubGVuZ3RoID4gMCBzbyB3ZSdsbCBkbyB0aGlzIGF0IGxlYXN0IG9uY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSByb29tTm90aWZUZXh0Tm9kZS5uZXh0U2libGluZztcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGlsbENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpbGwgPSA8UGlsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9e1BpbGwuVFlQRV9BVF9ST09NX01FTlRJT059XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5NZXNzYWdlPXt0cnVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb209e3Jvb219XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkU2hvd1BpbGxBdmF0YXI9e3Nob3VsZFNob3dQaWxsQXZhdGFyfVxuICAgICAgICAgICAgICAgICAgICAgICAgLz47XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0RE9NLnJlbmRlcihwaWxsLCBwaWxsQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb21Ob3RpZlRleHROb2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHBpbGxDb250YWluZXIsIHJvb21Ob3RpZlRleHROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpbGxzLnB1c2gocGlsbENvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyBlbHNlIHRvIGRvIGZvciBhIHRleHQgbm9kZSAoYW5kIHdlIGRvbid0IG5lZWQgdG8gYWR2YW5jZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbG9vcCBwb2ludGVyIGJlY2F1c2Ugd2UgZGlkIGl0IGFib3ZlKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZS5jaGlsZE5vZGVzICYmIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggJiYgIXBpbGxpZmllZCkge1xuICAgICAgICAgICAgcGlsbGlmeUxpbmtzKG5vZGUuY2hpbGROb2RlcyBhcyBOb2RlTGlzdE9mPEVsZW1lbnQ+LCBteEV2ZW50LCBwaWxscyk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZyBhcyBFbGVtZW50O1xuICAgIH1cbn1cblxuLyoqXG4gKiBVbm1vdW50IGFsbCB0aGUgcGlsbCBjb250YWluZXJzIGZyb20gUmVhY3QgY3JlYXRlZCBieSBwaWxsaWZ5TGlua3MuXG4gKlxuICogSXQncyBjcml0aWNhbCB0byBjYWxsIHRoaXMgYWZ0ZXIgcGlsbGlmeUxpbmtzLCBvdGhlcndpc2VcbiAqIFBpbGxzIHdpbGwgbGVhaywgbGVha2luZyBlbnRpcmUgRE9NIHRyZWVzIHZpYSB0aGUgZXZlbnRcbiAqIGVtaXR0ZXIgb24gQmFzZUF2YXRhciBhcyBwZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS92ZWN0b3ItaW0vZWxlbWVudC13ZWIvaXNzdWVzLzEyNDE3XG4gKlxuICogQHBhcmFtIHtFbGVtZW50W119IHBpbGxzIC0gYXJyYXkgb2YgcGlsbCBjb250YWluZXJzIHdob3NlIFJlYWN0XG4gKiAgIGNvbXBvbmVudHMgc2hvdWxkIGJlIHVubW91bnRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVubW91bnRQaWxscyhwaWxsczogRWxlbWVudFtdKSB7XG4gICAgZm9yIChjb25zdCBwaWxsQ29udGFpbmVyIG9mIHBpbGxzKSB7XG4gICAgICAgIFJlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUocGlsbENvbnRhaW5lcik7XG4gICAgfVxufVxuIl19