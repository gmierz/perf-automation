"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _MatrixClientPeg = require("../../MatrixClientPeg");

var _exportUtils = require("./exportUtils");

var _DecryptFile = require("../DecryptFile");

var _Media = require("../../customisations/Media");

var _DateUtils = require("../../DateUtils");

var _EventUtils = require("../EventUtils");

var _eventTimeline = require("matrix-js-sdk/src/models/event-timeline");

var _fileSaver = require("file-saver");

var _languageHandler = require("../../languageHandler");

var _SdkConfig = _interopRequireDefault(require("../../SdkConfig"));

var _logger = require("matrix-js-sdk/src/logger");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class Exporter {
  constructor(room, exportType, exportOptions, setProgressText) {
    this.room = room;
    this.exportType = exportType;
    this.exportOptions = exportOptions;
    this.setProgressText = setProgressText;
    (0, _defineProperty2.default)(this, "files", []);
    (0, _defineProperty2.default)(this, "client", void 0);
    (0, _defineProperty2.default)(this, "cancelled", false);

    if (exportOptions.maxSize < 1 * 1024 * 1024 || // Less than 1 MB
    exportOptions.maxSize > 2000 * 1024 * 1024 || // More than ~ 2 GB
    exportOptions.numberOfMessages > 10 ** 8) {
      throw new Error("Invalid export options");
    }

    this.client = _MatrixClientPeg.MatrixClientPeg.get();
    window.addEventListener("beforeunload", this.onBeforeUnload);
  }

  onBeforeUnload(e) {
    e.preventDefault();
    return e.returnValue = (0, _languageHandler._t)("Are you sure you want to exit during this export?");
  }

  updateProgress(progress, log = true, show = true) {
    if (log) _logger.logger.log(progress);
    if (show) this.setProgressText(progress);
  }

  addFile(filePath, blob) {
    const file = {
      name: filePath,
      blob
    };
    this.files.push(file);
  }

  async downloadZIP() {
    const brand = _SdkConfig.default.get().brand;

    const filenameWithoutExt = `${brand} - Chat Export - ${(0, _DateUtils.formatFullDateNoDay)(new Date())}`;
    const filename = `${filenameWithoutExt}.zip`;
    const {
      default: JSZip
    } = await Promise.resolve().then(() => _interopRequireWildcard(require('jszip')));
    const zip = new JSZip(); // Create a writable stream to the directory

    if (!this.cancelled) this.updateProgress("Generating a ZIP");else return this.cleanUp();

    for (const file of this.files) zip.file(filenameWithoutExt + "/" + file.name, file.blob);

    const content = await zip.generateAsync({
      type: "blob"
    });
    (0, _fileSaver.saveAs)(content, filename);
  }

  cleanUp() {
    _logger.logger.log("Cleaning up...");

    window.removeEventListener("beforeunload", this.onBeforeUnload);
    return "";
  }

  async cancelExport() {
    _logger.logger.log("Cancelling export...");

    this.cancelled = true;
  }

  downloadPlainText(fileName, text) {
    const content = new Blob([text], {
      type: "text"
    });
    (0, _fileSaver.saveAs)(content, fileName);
  }

  setEventMetadata(event) {
    const roomState = this.client.getRoom(this.room.roomId).currentState;
    event.sender = roomState.getSentinelMember(event.getSender());

    if (event.getType() === "m.room.member") {
      event.target = roomState.getSentinelMember(event.getStateKey());
    }

    return event;
  }

  getLimit() {
    let limit;

    switch (this.exportType) {
      case _exportUtils.ExportType.LastNMessages:
        limit = this.exportOptions.numberOfMessages;
        break;

      case _exportUtils.ExportType.Timeline:
        limit = 40;
        break;

      default:
        limit = 10 ** 8;
    }

    return limit;
  }

  async getRequiredEvents() {
    const eventMapper = this.client.getEventMapper();
    let prevToken = null;
    let limit = this.getLimit();
    const events = [];

    while (limit) {
      const eventsPerCrawl = Math.min(limit, 1000);
      const res = await this.client.createMessagesRequest(this.room.roomId, prevToken, eventsPerCrawl, _eventTimeline.Direction.Backward);

      if (this.cancelled) {
        this.cleanUp();
        return [];
      }

      if (res.chunk.length === 0) break;
      limit -= res.chunk.length;
      const matrixEvents = res.chunk.map(eventMapper);

      for (const mxEv of matrixEvents) {
        // if (this.exportOptions.startDate && mxEv.getTs() < this.exportOptions.startDate) {
        //     // Once the last message received is older than the start date, we break out of both the loops
        //     limit = 0;
        //     break;
        // }
        events.push(mxEv);
      }

      this.updateProgress("Fetched " + events.length + " events " + (this.exportType === _exportUtils.ExportType.LastNMessages ? `out of ${this.exportOptions.numberOfMessages}` : "so far"));
      prevToken = res.end;
    } // Reverse the events so that we preserve the order


    for (let i = 0; i < Math.floor(events.length / 2); i++) {
      [events[i], events[events.length - i - 1]] = [events[events.length - i - 1], events[i]];
    }

    const decryptionPromises = events.filter(event => event.isEncrypted()).map(event => {
      return this.client.decryptEventIfNeeded(event, {
        isRetry: true,
        emit: false
      });
    }); // Wait for all the events to get decrypted.

    await Promise.all(decryptionPromises);

    for (let i = 0; i < events.length; i++) this.setEventMetadata(events[i]);

    return events;
  }

  async getMediaBlob(event) {
    let blob;

    try {
      const isEncrypted = event.isEncrypted();
      const content = event.getContent();
      const shouldDecrypt = isEncrypted && content.hasOwnProperty("file") && event.getType() !== "m.sticker";

      if (shouldDecrypt) {
        blob = await (0, _DecryptFile.decryptFile)(content.file);
      } else {
        const media = (0, _Media.mediaFromContent)(content);
        const image = await fetch(media.srcHttp);
        blob = await image.blob();
      }
    } catch (err) {
      _logger.logger.log("Error decrypting media");
    }

    return blob;
  }

  splitFileName(file) {
    const lastDot = file.lastIndexOf('.');
    if (lastDot === -1) return [file, ""];
    const fileName = file.slice(0, lastDot);
    const ext = file.slice(lastDot + 1);
    return [fileName, '.' + ext];
  }

  getFilePath(event) {
    const mediaType = event.getContent().msgtype;
    let fileDirectory;

    switch (mediaType) {
      case "m.image":
        fileDirectory = "images";
        break;

      case "m.video":
        fileDirectory = "videos";
        break;

      case "m.audio":
        fileDirectory = "audio";
        break;

      default:
        fileDirectory = event.getType() === "m.sticker" ? "stickers" : "files";
    }

    const fileDate = (0, _DateUtils.formatFullDateNoDay)(new Date(event.getTs()));
    let [fileName, fileExt] = this.splitFileName(event.getContent().body);
    if (event.getType() === "m.sticker") fileExt = ".png";
    if ((0, _EventUtils.isVoiceMessage)(event)) fileExt = ".ogg";
    return fileDirectory + "/" + fileName + '-' + fileDate + fileExt;
  }

  isReply(event) {
    const isEncrypted = event.isEncrypted(); // If encrypted, in_reply_to lies in event.event.content

    const content = isEncrypted ? event.event.content : event.getContent();
    const relatesTo = content["m.relates_to"];
    return !!(relatesTo && relatesTo["m.in_reply_to"]);
  }

  isAttachment(mxEv) {
    const attachmentTypes = ["m.sticker", "m.image", "m.file", "m.video", "m.audio"];
    return mxEv.getType() === attachmentTypes[0] || attachmentTypes.includes(mxEv.getContent().msgtype);
  }

}

exports.default = Exporter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9leHBvcnRVdGlscy9FeHBvcnRlci50cyJdLCJuYW1lcyI6WyJFeHBvcnRlciIsImNvbnN0cnVjdG9yIiwicm9vbSIsImV4cG9ydFR5cGUiLCJleHBvcnRPcHRpb25zIiwic2V0UHJvZ3Jlc3NUZXh0IiwibWF4U2l6ZSIsIm51bWJlck9mTWVzc2FnZXMiLCJFcnJvciIsImNsaWVudCIsIk1hdHJpeENsaWVudFBlZyIsImdldCIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbkJlZm9yZVVubG9hZCIsImUiLCJwcmV2ZW50RGVmYXVsdCIsInJldHVyblZhbHVlIiwidXBkYXRlUHJvZ3Jlc3MiLCJwcm9ncmVzcyIsImxvZyIsInNob3ciLCJsb2dnZXIiLCJhZGRGaWxlIiwiZmlsZVBhdGgiLCJibG9iIiwiZmlsZSIsIm5hbWUiLCJmaWxlcyIsInB1c2giLCJkb3dubG9hZFpJUCIsImJyYW5kIiwiU2RrQ29uZmlnIiwiZmlsZW5hbWVXaXRob3V0RXh0IiwiRGF0ZSIsImZpbGVuYW1lIiwiZGVmYXVsdCIsIkpTWmlwIiwiemlwIiwiY2FuY2VsbGVkIiwiY2xlYW5VcCIsImNvbnRlbnQiLCJnZW5lcmF0ZUFzeW5jIiwidHlwZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjYW5jZWxFeHBvcnQiLCJkb3dubG9hZFBsYWluVGV4dCIsImZpbGVOYW1lIiwidGV4dCIsIkJsb2IiLCJzZXRFdmVudE1ldGFkYXRhIiwiZXZlbnQiLCJyb29tU3RhdGUiLCJnZXRSb29tIiwicm9vbUlkIiwiY3VycmVudFN0YXRlIiwic2VuZGVyIiwiZ2V0U2VudGluZWxNZW1iZXIiLCJnZXRTZW5kZXIiLCJnZXRUeXBlIiwidGFyZ2V0IiwiZ2V0U3RhdGVLZXkiLCJnZXRMaW1pdCIsImxpbWl0IiwiRXhwb3J0VHlwZSIsIkxhc3ROTWVzc2FnZXMiLCJUaW1lbGluZSIsImdldFJlcXVpcmVkRXZlbnRzIiwiZXZlbnRNYXBwZXIiLCJnZXRFdmVudE1hcHBlciIsInByZXZUb2tlbiIsImV2ZW50cyIsImV2ZW50c1BlckNyYXdsIiwiTWF0aCIsIm1pbiIsInJlcyIsImNyZWF0ZU1lc3NhZ2VzUmVxdWVzdCIsIkRpcmVjdGlvbiIsIkJhY2t3YXJkIiwiY2h1bmsiLCJsZW5ndGgiLCJtYXRyaXhFdmVudHMiLCJtYXAiLCJteEV2IiwiZW5kIiwiaSIsImZsb29yIiwiZGVjcnlwdGlvblByb21pc2VzIiwiZmlsdGVyIiwiaXNFbmNyeXB0ZWQiLCJkZWNyeXB0RXZlbnRJZk5lZWRlZCIsImlzUmV0cnkiLCJlbWl0IiwiUHJvbWlzZSIsImFsbCIsImdldE1lZGlhQmxvYiIsImdldENvbnRlbnQiLCJzaG91bGREZWNyeXB0IiwiaGFzT3duUHJvcGVydHkiLCJtZWRpYSIsImltYWdlIiwiZmV0Y2giLCJzcmNIdHRwIiwiZXJyIiwic3BsaXRGaWxlTmFtZSIsImxhc3REb3QiLCJsYXN0SW5kZXhPZiIsInNsaWNlIiwiZXh0IiwiZ2V0RmlsZVBhdGgiLCJtZWRpYVR5cGUiLCJtc2d0eXBlIiwiZmlsZURpcmVjdG9yeSIsImZpbGVEYXRlIiwiZ2V0VHMiLCJmaWxlRXh0IiwiYm9keSIsImlzUmVwbHkiLCJyZWxhdGVzVG8iLCJpc0F0dGFjaG1lbnQiLCJhdHRhY2htZW50VHlwZXMiLCJpbmNsdWRlcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFrQkE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBRUE7Ozs7OztBQU9lLE1BQWVBLFFBQWYsQ0FBd0I7QUFLekJDLEVBQUFBLFdBQVcsQ0FDUEMsSUFETyxFQUVQQyxVQUZPLEVBR1BDLGFBSE8sRUFJUEMsZUFKTyxFQUtuQjtBQUFBLFNBSllILElBSVosR0FKWUEsSUFJWjtBQUFBLFNBSFlDLFVBR1osR0FIWUEsVUFHWjtBQUFBLFNBRllDLGFBRVosR0FGWUEsYUFFWjtBQUFBLFNBRFlDLGVBQ1osR0FEWUEsZUFDWjtBQUFBLGlEQVQ0QixFQVM1QjtBQUFBO0FB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NkI7QUFDL0MsVUFBTXFDLGVBQWUsR0FBRyxDQUFDLFdBQUQsRUFBYyxTQUFkLEVBQXlCLFFBQXpCLEVBQW1DLFNBQW5DLEVBQThDLFNBQTlDLENBQXhCO0FBQ0EsV0FBT3JDLElBQUksQ0FBQ3hCLE9BQUwsT0FBbUI2RCxlQUFlLENBQUMsQ0FBRCxDQUFsQyxJQUF5Q0EsZUFBZSxDQUFDQyxRQUFoQixDQUF5QnRDLElBQUksQ0FBQ2EsVUFBTCxHQUFrQmUsT0FBM0MsQ0FBaEQ7QUFDSDs7QUFwT2tDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDIxIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IHsgTWF0cml4RXZlbnQgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvbW9kZWxzL2V2ZW50XCI7XG5pbXBvcnQgeyBSb29tIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL21vZGVscy9yb29tXCI7XG5pbXBvcnQgeyBNYXRyaXhDbGllbnRQZWcgfSBmcm9tIFwiLi4vLi4vTWF0cml4Q2xpZW50UGVnXCI7XG5pbXBvcnQgeyBJRXhwb3J0T3B0aW9ucywgRXhwb3J0VHlwZSB9IGZyb20gXCIuL2V4cG9ydFV0aWxzXCI7XG5pbXBvcnQgeyBkZWNyeXB0RmlsZSB9IGZyb20gXCIuLi9EZWNyeXB0RmlsZVwiO1xuaW1wb3J0IHsgbWVkaWFGcm9tQ29udGVudCB9IGZyb20gXCIuLi8uLi9jdXN0b21pc2F0aW9ucy9NZWRpYVwiO1xuaW1wb3J0IHsgZm9ybWF0RnVsbERhdGVOb0RheSB9IGZyb20gXCIuLi8uLi9EYXRlVXRpbHNcIjtcbmltcG9ydCB7IGlzVm9pY2VNZXNzYWdlIH0gZnJvbSBcIi4uL0V2ZW50VXRpbHNcIjtcbmltcG9ydCB7IE1hdHJpeENsaWVudCB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9jbGllbnRcIjtcbmltcG9ydCB7IERpcmVjdGlvbiB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9tb2RlbHMvZXZlbnQtdGltZWxpbmVcIjtcbmltcG9ydCB7IElNZWRpYUV2ZW50Q29udGVudCB9IGZyb20gXCIuLi8uLi9jdXN0b21pc2F0aW9ucy9tb2RlbHMvSU1lZGlhRXZlbnRDb250ZW50XCI7XG5pbXBvcnQgeyBzYXZlQXMgfSBmcm9tIFwiZmlsZS1zYXZlclwiO1xuaW1wb3J0IHsgX3QgfSBmcm9tIFwiLi4vLi4vbGFuZ3VhZ2VIYW5kbGVyXCI7XG5pbXBvcnQgU2RrQ29uZmlnIGZyb20gXCIuLi8uLi9TZGtDb25maWdcIjtcblxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL2xvZ2dlclwiO1xuXG50eXBlIEJsb2JGaWxlID0ge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBibG9iOiBCbG9iO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgRXhwb3J0ZXIge1xuICAgIHByb3RlY3RlZCBmaWxlczogQmxvYkZpbGVbXSA9IFtdO1xuICAgIHByb3RlY3RlZCBjbGllbnQ6IE1hdHJpeENsaWVudDtcbiAgICBwcm90ZWN0ZWQgY2FuY2VsbGVkID0gZmFsc2U7XG5cbiAgICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoXG4gICAgICAgIHByb3RlY3RlZCByb29tOiBSb29tLFxuICAgICAgICBwcm90ZWN0ZWQgZXhwb3J0VHlwZTogRXhwb3J0VHlwZSxcbiAgICAgICAgcHJvdGVjdGVkIGV4cG9ydE9wdGlvbnM6IElFeHBvcnRPcHRpb25zLFxuICAgICAgICBwcm90ZWN0ZWQgc2V0UHJvZ3Jlc3NUZXh0OiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxzdHJpbmc+PixcbiAgICApIHtcbiAgICAgICAgaWYgKGV4cG9ydE9wdGlvbnMubWF4U2l6ZSA8IDEgKiAxMDI0ICogMTAyNHx8IC8vIExlc3MgdGhhbiAxIE1CXG4gICAgICAgICAgICBleHBvcnRPcHRpb25zLm1heFNpemUgPiAyMDAwICogMTAyNCAqIDEwMjR8fCAvLyBNb3JlIHRoYW4gfiAyIEdCXG4gICAgICAgICAgICBleHBvcnRPcHRpb25zLm51bWJlck9mTWVzc2FnZXMgPiAxMCoqOFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZXhwb3J0IG9wdGlvbnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGllbnQgPSBNYXRyaXhDbGllbnRQZWcuZ2V0KCk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIHRoaXMub25CZWZvcmVVbmxvYWQpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBvbkJlZm9yZVVubG9hZChlOiBCZWZvcmVVbmxvYWRFdmVudCk6IHN0cmluZyB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIGUucmV0dXJuVmFsdWUgPSBfdChcIkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBleGl0IGR1cmluZyB0aGlzIGV4cG9ydD9cIik7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHVwZGF0ZVByb2dyZXNzKHByb2dyZXNzOiBzdHJpbmcsIGxvZyA9IHRydWUsIHNob3cgPSB0cnVlKTogdm9pZCB7XG4gICAgICAgIGlmIChsb2cpIGxvZ2dlci5sb2cocHJvZ3Jlc3MpO1xuICAgICAgICBpZiAoc2hvdykgdGhpcy5zZXRQcm9ncmVzc1RleHQocHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBhZGRGaWxlKGZpbGVQYXRoOiBzdHJpbmcsIGJsb2I6IEJsb2IpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZmlsZSA9IHtcbiAgICAgICAgICAgIG5hbWU6IGZpbGVQYXRoLFxuICAgICAgICAgICAgYmxvYixcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5maWxlcy5wdXNoKGZpbGUpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBhc3luYyBkb3dubG9hZFpJUCgpOiBQcm9taXNlPHN0cmluZyB8IHZvaWQ+IHtcbiAgICAgICAgY29uc3QgYnJhbmQgPSBTZGtDb25maWcuZ2V0KCkuYnJhbmQ7XG4gICAgICAgIGNvbnN0IGZpbGVuYW1lV2l0aG91dEV4dCA9IGAke2JyYW5kfSAtIENoYXQgRXhwb3J0IC0gJHtmb3JtYXRGdWxsRGF0ZU5vRGF5KG5ldyBEYXRlKCkpfWA7XG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gYCR7ZmlsZW5hbWVXaXRob3V0RXh0fS56aXBgO1xuICAgICAgICBjb25zdCB7IGRlZmF1bHQ6IEpTWmlwIH0gPSBhd2FpdCBpbXBvcnQoJ2pzemlwJyk7XG5cbiAgICAgICAgY29uc3QgemlwID0gbmV3IEpTWmlwKCk7XG4gICAgICAgIC8vIENyZWF0ZSBhIHdyaXRhYmxlIHN0cmVhbSB0byB0aGUgZGlyZWN0b3J5XG4gICAgICAgIGlmICghdGhpcy5jYW5jZWxsZWQpIHRoaXMudXBkYXRlUHJvZ3Jlc3MoXCJHZW5lcmF0aW5nIGEgWklQXCIpO1xuICAgICAgICBlbHNlIHJldHVybiB0aGlzLmNsZWFuVXAoKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgdGhpcy5maWxlcykgemlwLmZpbGUoZmlsZW5hbWVXaXRob3V0RXh0ICsgXCIvXCIgKyBmaWxlLm5hbWUsIGZpbGUuYmxvYik7XG5cbiAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHppcC5nZW5lcmF0ZUFzeW5jKHsgdHlwZTogXCJibG9iXCIgfSk7XG5cbiAgICAgICAgc2F2ZUFzKGNvbnRlbnQsIGZpbGVuYW1lKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgY2xlYW5VcCgpOiBzdHJpbmcge1xuICAgICAgICBsb2dnZXIubG9nKFwiQ2xlYW5pbmcgdXAuLi5cIik7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIHRoaXMub25CZWZvcmVVbmxvYWQpO1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgY2FuY2VsRXhwb3J0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBsb2dnZXIubG9nKFwiQ2FuY2VsbGluZyBleHBvcnQuLi5cIik7XG4gICAgICAgIHRoaXMuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZG93bmxvYWRQbGFpblRleHQoZmlsZU5hbWU6IHN0cmluZywgdGV4dDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBuZXcgQmxvYihbdGV4dF0sIHsgdHlwZTogXCJ0ZXh0XCIgfSk7XG4gICAgICAgIHNhdmVBcyhjb250ZW50LCBmaWxlTmFtZSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHNldEV2ZW50TWV0YWRhdGEoZXZlbnQ6IE1hdHJpeEV2ZW50KTogTWF0cml4RXZlbnQge1xuICAgICAgICBjb25zdCByb29tU3RhdGUgPSB0aGlzLmNsaWVudC5nZXRSb29tKHRoaXMucm9vbS5yb29tSWQpLmN1cnJlbnRTdGF0ZTtcbiAgICAgICAgZXZlbnQuc2VuZGVyID0gcm9vbVN0YXRlLmdldFNlbnRpbmVsTWVtYmVyKFxuICAgICAgICAgICAgZXZlbnQuZ2V0U2VuZGVyKCksXG4gICAgICAgICk7XG4gICAgICAgIGlmIChldmVudC5nZXRUeXBlKCkgPT09IFwibS5yb29tLm1lbWJlclwiKSB7XG4gICAgICAgICAgICBldmVudC50YXJnZXQgPSByb29tU3RhdGUuZ2V0U2VudGluZWxNZW1iZXIoXG4gICAgICAgICAgICAgICAgZXZlbnQuZ2V0U3RhdGVLZXkoKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRMaW1pdCgpOiBudW1iZXIge1xuICAgICAgICBsZXQgbGltaXQ6IG51bWJlcjtcbiAgICAgICAgc3dpdGNoICh0aGlzLmV4cG9ydFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgRXhwb3J0VHlwZS5MYXN0Tk1lc3NhZ2VzOlxuICAgICAgICAgICAgICAgIGxpbWl0ID0gdGhpcy5leHBvcnRPcHRpb25zLm51bWJlck9mTWVzc2FnZXM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEV4cG9ydFR5cGUuVGltZWxpbmU6XG4gICAgICAgICAgICAgICAgbGltaXQgPSA0MDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbGltaXQgPSAxMCoqODtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGltaXQ7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGFzeW5jIGdldFJlcXVpcmVkRXZlbnRzKCk6IFByb21pc2U8TWF0cml4RXZlbnRbXT4ge1xuICAgICAgICBjb25zdCBldmVudE1hcHBlciA9IHRoaXMuY2xpZW50LmdldEV2ZW50TWFwcGVyKCk7XG5cbiAgICAgICAgbGV0IHByZXZUb2tlbjogc3RyaW5nfG51bGwgPSBudWxsO1xuICAgICAgICBsZXQgbGltaXQgPSB0aGlzLmdldExpbWl0KCk7XG4gICAgICAgIGNvbnN0IGV2ZW50czogTWF0cml4RXZlbnRbXSA9IFtdO1xuXG4gICAgICAgIHdoaWxlIChsaW1pdCkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRzUGVyQ3Jhd2wgPSBNYXRoLm1pbihsaW1pdCwgMTAwMCk7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmNsaWVudC5jcmVhdGVNZXNzYWdlc1JlcXVlc3QoXG4gICAgICAgICAgICAgICAgdGhpcy5yb29tLnJvb21JZCxcbiAgICAgICAgICAgICAgICBwcmV2VG9rZW4sXG4gICAgICAgICAgICAgICAgZXZlbnRzUGVyQ3Jhd2wsXG4gICAgICAgICAgICAgICAgRGlyZWN0aW9uLkJhY2t3YXJkLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhblVwKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVzLmNodW5rLmxlbmd0aCA9PT0gMCkgYnJlYWs7XG5cbiAgICAgICAgICAgIGxpbWl0IC09IHJlcy5jaHVuay5sZW5ndGg7XG5cbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeEV2ZW50czogTWF0cml4RXZlbnRbXSA9IHJlcy5jaHVuay5tYXAoZXZlbnRNYXBwZXIpO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG14RXYgb2YgbWF0cml4RXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgKHRoaXMuZXhwb3J0T3B0aW9ucy5zdGFydERhdGUgJiYgbXhFdi5nZXRUcygpIDwgdGhpcy5leHBvcnRPcHRpb25zLnN0YXJ0RGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vICAgICAvLyBPbmNlIHRoZSBsYXN0IG1lc3NhZ2UgcmVjZWl2ZWQgaXMgb2xkZXIgdGhhbiB0aGUgc3RhcnQgZGF0ZSwgd2UgYnJlYWsgb3V0IG9mIGJvdGggdGhlIGxvb3BzXG4gICAgICAgICAgICAgICAgLy8gICAgIGxpbWl0ID0gMDtcbiAgICAgICAgICAgICAgICAvLyAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGV2ZW50cy5wdXNoKG14RXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVQcm9ncmVzcyhcbiAgICAgICAgICAgICAgICAoXCJGZXRjaGVkIFwiICsgZXZlbnRzLmxlbmd0aCArIFwiIGV2ZW50cyBcIikgKyAodGhpcy5leHBvcnRUeXBlID09PSBFeHBvcnRUeXBlLkxhc3ROTWVzc2FnZXNcbiAgICAgICAgICAgICAgICAgICAgPyBgb3V0IG9mICR7dGhpcy5leHBvcnRPcHRpb25zLm51bWJlck9mTWVzc2FnZXN9YFxuICAgICAgICAgICAgICAgICAgICA6IFwic28gZmFyXCIpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHByZXZUb2tlbiA9IHJlcy5lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV2ZXJzZSB0aGUgZXZlbnRzIHNvIHRoYXQgd2UgcHJlc2VydmUgdGhlIG9yZGVyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5mbG9vcihldmVudHMubGVuZ3RoLzIpOyBpKyspIHtcbiAgICAgICAgICAgIFtldmVudHNbaV0sIGV2ZW50c1tldmVudHMubGVuZ3RoIC0gaSAtIDFdXSA9IFtldmVudHNbZXZlbnRzLmxlbmd0aCAtIGkgLSAxXSwgZXZlbnRzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRlY3J5cHRpb25Qcm9taXNlcyA9IGV2ZW50c1xuICAgICAgICAgICAgLmZpbHRlcihldmVudCA9PiBldmVudC5pc0VuY3J5cHRlZCgpKVxuICAgICAgICAgICAgLm1hcChldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmRlY3J5cHRFdmVudElmTmVlZGVkKGV2ZW50LCB7XG4gICAgICAgICAgICAgICAgICAgIGlzUmV0cnk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGVtaXQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gV2FpdCBmb3IgYWxsIHRoZSBldmVudHMgdG8gZ2V0IGRlY3J5cHRlZC5cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoZGVjcnlwdGlvblByb21pc2VzKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykgdGhpcy5zZXRFdmVudE1ldGFkYXRhKGV2ZW50c1tpXSk7XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgYXN5bmMgZ2V0TWVkaWFCbG9iKGV2ZW50OiBNYXRyaXhFdmVudCk6IFByb21pc2U8QmxvYj4ge1xuICAgICAgICBsZXQgYmxvYjogQmxvYjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGlzRW5jcnlwdGVkID0gZXZlbnQuaXNFbmNyeXB0ZWQoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQ6IElNZWRpYUV2ZW50Q29udGVudCA9IGV2ZW50LmdldENvbnRlbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZERlY3J5cHQgPSBpc0VuY3J5cHRlZCAmJiBjb250ZW50Lmhhc093blByb3BlcnR5KFwiZmlsZVwiKSAmJiBldmVudC5nZXRUeXBlKCkgIT09IFwibS5zdGlja2VyXCI7XG4gICAgICAgICAgICBpZiAoc2hvdWxkRGVjcnlwdCkge1xuICAgICAgICAgICAgICAgIGJsb2IgPSBhd2FpdCBkZWNyeXB0RmlsZShjb250ZW50LmZpbGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZWRpYSA9IG1lZGlhRnJvbUNvbnRlbnQoY29udGVudCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSBhd2FpdCBmZXRjaChtZWRpYS5zcmNIdHRwKTtcbiAgICAgICAgICAgICAgICBibG9iID0gYXdhaXQgaW1hZ2UuYmxvYigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coXCJFcnJvciBkZWNyeXB0aW5nIG1lZGlhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9iO1xuICAgIH1cblxuICAgIHB1YmxpYyBzcGxpdEZpbGVOYW1lKGZpbGU6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICAgICAgY29uc3QgbGFzdERvdCA9IGZpbGUubGFzdEluZGV4T2YoJy4nKTtcbiAgICAgICAgaWYgKGxhc3REb3QgPT09IC0xKSByZXR1cm4gW2ZpbGUsIFwiXCJdO1xuICAgICAgICBjb25zdCBmaWxlTmFtZSA9IGZpbGUuc2xpY2UoMCwgbGFzdERvdCk7XG4gICAgICAgIGNvbnN0IGV4dCA9IGZpbGUuc2xpY2UobGFzdERvdCArIDEpO1xuICAgICAgICByZXR1cm4gW2ZpbGVOYW1lLCAnLicgKyBleHRdO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRGaWxlUGF0aChldmVudDogTWF0cml4RXZlbnQpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBtZWRpYVR5cGUgPSBldmVudC5nZXRDb250ZW50KCkubXNndHlwZTtcbiAgICAgICAgbGV0IGZpbGVEaXJlY3Rvcnk6IHN0cmluZztcbiAgICAgICAgc3dpdGNoIChtZWRpYVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJtLmltYWdlXCI6XG4gICAgICAgICAgICAgICAgZmlsZURpcmVjdG9yeSA9IFwiaW1hZ2VzXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibS52aWRlb1wiOlxuICAgICAgICAgICAgICAgIGZpbGVEaXJlY3RvcnkgPSBcInZpZGVvc1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm0uYXVkaW9cIjpcbiAgICAgICAgICAgICAgICBmaWxlRGlyZWN0b3J5ID0gXCJhdWRpb1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBmaWxlRGlyZWN0b3J5ID0gZXZlbnQuZ2V0VHlwZSgpID09PSBcIm0uc3RpY2tlclwiID8gXCJzdGlja2Vyc1wiIDogXCJmaWxlc1wiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbGVEYXRlID0gZm9ybWF0RnVsbERhdGVOb0RheShuZXcgRGF0ZShldmVudC5nZXRUcygpKSk7XG4gICAgICAgIGxldCBbZmlsZU5hbWUsIGZpbGVFeHRdID0gdGhpcy5zcGxpdEZpbGVOYW1lKGV2ZW50LmdldENvbnRlbnQoKS5ib2R5KTtcblxuICAgICAgICBpZiAoZXZlbnQuZ2V0VHlwZSgpID09PSBcIm0uc3RpY2tlclwiKSBmaWxlRXh0ID0gXCIucG5nXCI7XG4gICAgICAgIGlmIChpc1ZvaWNlTWVzc2FnZShldmVudCkpIGZpbGVFeHQgPSBcIi5vZ2dcIjtcblxuICAgICAgICByZXR1cm4gZmlsZURpcmVjdG9yeSArIFwiL1wiICsgZmlsZU5hbWUgKyAnLScgKyBmaWxlRGF0ZSArIGZpbGVFeHQ7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGlzUmVwbHkoZXZlbnQ6IE1hdHJpeEV2ZW50KTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGlzRW5jcnlwdGVkID0gZXZlbnQuaXNFbmNyeXB0ZWQoKTtcbiAgICAgICAgLy8gSWYgZW5jcnlwdGVkLCBpbl9yZXBseV90byBsaWVzIGluIGV2ZW50LmV2ZW50LmNvbnRlbnRcbiAgICAgICAgY29uc3QgY29udGVudCA9IGlzRW5jcnlwdGVkID8gZXZlbnQuZXZlbnQuY29udGVudCA6IGV2ZW50LmdldENvbnRlbnQoKTtcbiAgICAgICAgY29uc3QgcmVsYXRlc1RvID0gY29udGVudFtcIm0ucmVsYXRlc190b1wiXTtcbiAgICAgICAgcmV0dXJuICEhKHJlbGF0ZXNUbyAmJiByZWxhdGVzVG9bXCJtLmluX3JlcGx5X3RvXCJdKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgaXNBdHRhY2htZW50KG14RXY6IE1hdHJpeEV2ZW50KTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGF0dGFjaG1lbnRUeXBlcyA9IFtcIm0uc3RpY2tlclwiLCBcIm0uaW1hZ2VcIiwgXCJtLmZpbGVcIiwgXCJtLnZpZGVvXCIsIFwibS5hdWRpb1wiXTtcbiAgICAgICAgcmV0dXJuIG14RXYuZ2V0VHlwZSgpID09PSBhdHRhY2htZW50VHlwZXNbMF0gfHwgYXR0YWNobWVudFR5cGVzLmluY2x1ZGVzKG14RXYuZ2V0Q29udGVudCgpLm1zZ3R5cGUpO1xuICAgIH1cblxuICAgIGFic3RyYWN0IGV4cG9ydCgpOiBQcm9taXNlPHZvaWQ+O1xufVxuIl19