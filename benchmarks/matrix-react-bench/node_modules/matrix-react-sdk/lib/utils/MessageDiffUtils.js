"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.editBodyDiffToHtml = editBodyDiffToHtml;

var _react = _interopRequireDefault(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _diffMatchPatch = require("diff-match-patch");

var _diffDom = require("diff-dom");

var _HtmlUtils = require("../HtmlUtils");

var _logger = require("matrix-js-sdk/src/logger");

/*
Copyright 2019 - 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
const decodeEntities = function () {
  let textarea = null;
  return function (str) {
    if (!textarea) {
      textarea = document.createElement("textarea");
    }

    textarea.innerHTML = str;
    return textarea.value;
  };
}();

function textToHtml(text) {
  const container = document.createElement("div");
  container.textContent = text;
  return container.innerHTML;
}

function getSanitizedHtmlBody(content) {
  const opts = {
    stripReplyFallback: true,
    returnString: true
  };

  if (content.format === "org.matrix.custom.html") {
    return (0, _HtmlUtils.bodyToHtml)(content, null, opts);
  } else {
    // convert the string to something that can be safely
    // embedded in an html document, e.g. use html entities where needed
    // This is also needed so that DiffDOM wouldn't interpret something
    // as a tag when somebody types e.g. "</sarcasm>"
    // as opposed to bodyToHtml, here we also render
    // text messages with dangerouslySetInnerHTML, to unify
    // the code paths and because we need html to show differences
    return textToHtml((0, _HtmlUtils.bodyToHtml)(content, null, opts));
  }
}

function wrapInsertion(child) {
  const wrapper = document.createElement((0, _HtmlUtils.checkBlockNode)(child) ? "div" : "span");
  wrapper.className = "mx_EditHistoryMessage_insertion";
  wrapper.appendChild(child);
  return wrapper;
}

function wrapDeletion(child) {
  const wrapper = document.createElement((0, _HtmlUtils.checkBlockNode)(child) ? "div" : "span");
  wrapper.className = "mx_EditHistoryMessage_deletion";
  wrapper.appendChild(child);
  return wrapper;
}

function findRefNodes(root, route, isAddition = false) {
  let refNode = root;
  let refParentNode;
  const end = isAddition ? route.length - 1 : route.length;

  for (let i = 0; i < end; ++i) {
    refParentNode = refNode;
    refNode = refNode.childNodes[route[i]];
  }

  return {
    refNode,
    refParentNode
  };
}

function diffTreeToDOM(desc) {
  if (desc.nodeName === "#text") {
    return stringAsTextNode(desc.data);
  } else {
    const node = document.createElement(desc.nodeName);

    if (desc.attributes) {
      for (const [key, value] of Object.entries(desc.attributes)) {
        node.setAttribute(key, value);
      }
    }

    if (desc.childNodes) {
      for (const childDesc of desc.childNodes) {
        node.appendChild(diffTreeToDOM(childDesc));
      }
    }

    return node;
  }
}

function insertBefore(parent, nextSibling, child) {
  if (nextSibling) {
    parent.insertBefore(child, nextSibling);
  } else {
    parent.appendChild(child);
  }
}

function isRouteOfNextSibling(route1, route2) {
  // routes are arrays with indices,
  // to be interpreted as a path in the dom tree
  // ensure same parent
  for (let i = 0; i < route1.length - 1; ++i) {
    if (route1[i] !== route2[i]) {
      return false;
    }
  } // the route2 is only affected by the diff of route1
  // inserting an element if the index at the level of the
  // last element of route1 being larger
  // (e.g. coming behind route1 at that level)


  const lastD1Idx = route1.length - 1;
  return route2[lastD1Idx] >= route1[lastD1Idx];
}

function adjustRoutes(diff, remainingDiffs) {
  if (diff.action === "removeTextElement" || diff.action === "removeElement") {
    // as removed text is not removed from the html, but marked as deleted,
    // we need to readjust indices that assume the current node has been removed.
    const advance = 1;

    for (const rd of remainingDiffs) {
      if (isRouteOfNextSibling(diff.route, rd.route)) {
        rd.route[diff.route.length - 1] += advance;
      }
    }
  }
}

function stringAsTextNode(string) {
  return document.createTextNode(decodeEntities(string));
}

function renderDifferenceInDOM(originalRootNode, diff, diffMathPatch) {
  const {
    refNode,
    refParentNode
  } = findRefNodes(originalRootNode, diff.route);

  switch (diff.action) {
    case "replaceElement":
      {
        const container = document.createElement("span");
        const delNode = wrapDeletion(diffTreeToDOM(diff.oldValue));
        const insNode = wrapInsertion(diffTreeToDOM(diff.newValue));
        container.appendChild(delNode);
        container.appendChild(insNode);
        refNode.parentNode.replaceChild(container, refNode);
        break;
      }

    case "removeTextElement":
      {
        const delNode = wrapDeletion(stringAsTextNode(diff.value));
        refNode.parentNode.replaceChild(delNode, refNode);
        break;
      }

    case "removeElement":
      {
        const delNode = wrapDeletion(diffTreeToDOM(diff.element));
        refNode.parentNode.replaceChild(delNode, refNode);
        break;
      }

    case "modifyTextElement":
      {
        const textDiffs = diffMathPatch.diff_main(diff.oldValue, diff.newValue);
        diffMathPatch.diff_cleanupSemantic(textDiffs);
        const container = document.createElement("span");

        for (const [modifier, text] of textDiffs) {
          let textDiffNode = stringAsTextNode(text);

          if (modifier < 0) {
            textDiffNode = wrapDeletion(textDiffNode);
          } else if (modifier > 0) {
            textDiffNode = wrapInsertion(textDiffNode);
          }

          container.appendChild(textDiffNode);
        }

        refNode.parentNode.replaceChild(container, refNode);
        break;
      }

    case "addElement":
      {
        const insNode = wrapInsertion(diffTreeToDOM(diff.element));
        insertBefore(refParentNode, refNode, insNode);
        break;
      }

    case "addTextElement":
      {
        // XXX: sometimes diffDOM says insert a newline when there shouldn't be one
        // but we must insert the node anyway so that we don't break the route child IDs.
        // See https://github.com/fiduswriter/diffDOM/issues/100
        const insNode = wrapInsertion(stringAsTextNode(diff.value !== "\n" ? diff.value : ""));
        insertBefore(refParentNode, refNode, insNode);
        break;
      }
    // e.g. when changing a the href of a link,
    // show the link with old href as removed and with the new href as added

    case "removeAttribute":
    case "addAttribute":
    case "modifyAttribute":
      {
        const delNode = wrapDeletion(refNode.cloneNode(true));
        const updatedNode = refNode.cloneNode(true);

        if (diff.action === "addAttribute" || diff.action === "modifyAttribute") {
          updatedNode.setAttribute(diff.name, diff.newValue);
        } else {
          updatedNode.removeAttribute(diff.name);
        }

        const insNode = wrapInsertion(updatedNode);
        const container = document.createElement((0, _HtmlUtils.checkBlockNode)(refNode) ? "div" : "span");
        container.appendChild(delNode);
        container.appendChild(insNode);
        refNode.parentNode.replaceChild(container, refNode);
        break;
      }

    default:
      // Should not happen (modifyComment, ???)
      _logger.logger.warn("MessageDiffUtils::editBodyDiffToHtml: diff action not supported atm", diff);

  }
}

function routeIsEqual(r1, r2) {
  return r1.length === r2.length && !r1.some((e, i) => e !== r2[i]);
} // workaround for https://github.com/fiduswriter/diffDOM/issues/90


function filterCancelingOutDiffs(originalDiffActions) {
  const diffActions = originalDiffActions.slice();

  for (let i = 0; i < diffActions.length; ++i) {
    const diff = diffActions[i];

    if (diff.action === "removeTextElement") {
      const nextDiff = diffActions[i + 1];
      const cancelsOut = nextDiff && nextDiff.action === "addTextElement" && nextDiff.text === diff.text && routeIsEqual(nextDiff.route, diff.route);

      if (cancelsOut) {
        diffActions.splice(i, 2);
      }
    }
  }

  return diffActions;
}
/**
 * Renders a message with the changes made in an edit shown visually.
 * @param {object} originalContent the content for the base message
 * @param {object} editContent the content for the edit message
 * @return {object} a react element similar to what `bodyToHtml` returns
 */


function editBodyDiffToHtml(originalContent, editContent) {
  // wrap the body in a div, DiffDOM needs a root element
  const originalBody = `<div>${getSanitizedHtmlBody(originalContent)}</div>`;
  const editBody = `<div>${getSanitizedHtmlBody(editContent)}</div>`;
  const dd = new _diffDom.DiffDOM(); // diffActions is an array of objects with at least a `action` and `route`
  // property. `action` tells us what the diff object changes, and `route` where.
  // `route` is a path on the DOM tree expressed as an array of indices.

  const originaldiffActions = dd.diff(originalBody, editBody); // work around https://github.com/fiduswriter/diffDOM/issues/90

  const diffActions = filterCancelingOutDiffs(originaldiffActions); // for diffing text fragments

  const diffMathPatch = new _diffMatchPatch.diff_match_patch(); // parse the base html message as a DOM tree, to which we'll apply the differences found.
  // fish out the div in which we wrapped the messages above with children[0].

  const originalRootNode = new DOMParser().parseFromString(originalBody, "text/html").body.children[0];

  for (let i = 0; i < diffActions.length; ++i) {
    const diff = diffActions[i];
    renderDifferenceInDOM(originalRootNode, diff, diffMathPatch); // DiffDOM assumes in subsequent diffs route path that
    // the action was applied (e.g. that a removeElement action removed the element).
    // This is not the case for us. We render differences in the DOM tree, and don't apply them.
    // So we need to adjust the routes of the remaining diffs to account for this.

    adjustRoutes(diff, diffActions.slice(i + 1));
  } // take the html out of the modified DOM tree again


  const safeBody = originalRootNode.innerHTML;
  const className = (0, _classnames.default)({
    'mx_EventTile_body': true,
    'markdown-body': true
  });
  return /*#__PURE__*/_react.default.createElement("span", {
    key: "body",
    className: className,
    dangerouslySetInnerHTML: {
      __html: safeBody
    },
    dir: "auto"
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9NZXNzYWdlRGlmZlV0aWxzLnRzeCJdLCJuYW1lcyI6WyJkZWNvZGVFbnRpdGllcyIsInRleHRhcmVhIiwic3RyIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaW5uZXJIVE1MIiwidmFsdWUiLCJ0ZXh0VG9IdG1sIiwidGV4dCIsImNvbnRhaW5lciIsInRleHRDb250ZW50IiwiZ2V0U2FuaXRpemVkSHRtbEJvZHkiLCJjb250ZW50Iiwib3B0cyIsInN0cmlwUmVwbHlGYWxsYmFjayIsInJldHVyblN0cmluZyIsImZvcm1hdCIsIndyYXBJbnNlcnRpb24iLCJjaGlsZCIsIndyYXBwZXIiLCJjbGFzc05hbWUiLCJhcHBlbmRDaGlsZCIsIndyYXBEZWxldGlvbiIsImZpbmRSZWZOb2RlcyIsInJvb3QiLCJyb3V0ZSIsImlzQWRkaXRpb24iLCJyZWZOb2RlIiwicmVmUGFyZW50Tm9kZSIsImVuZCIsImxlbmd0aCIsImkiLCJjaGlsZE5vZGVzIiwiZGlmZlRyZWVUb0RPTSIsImRlc2MiLCJub2RlTmFtZSIsInN0cmluZ0FzVGV4dE5vZGUiLCJkYXRhIiwibm9kZSIsImF0dHJpYnV0ZXMiLCJrZXkiLCJPYmplY3QiLCJlbnRyaWVzIiwic2V0QXR0cmlidXRlIiwiY2hpbGREZXNjIiwiaW5zZXJ0QmVmb3JlIiwicGFyZW50IiwibmV4dFNpYmxpbmciLCJpc1JvdXRlT2ZOZXh0U2libGluZyIsInJvdXRlMSIsInJvdXRlMiIsImxhc3REMUlkeCIsImFkanVzdFJvdXRlcyIsImRpZmYiLCJyZW1haW5pbmdEaWZmcyIsImFjdGlvbiIsImFkdmFuY2UiLCJyZCIsInN0cmluZyIsImNyZWF0ZVRleHROb2RlIiwicmVuZGVyRGlmZmVyZW5jZUluRE9NIiwib3JpZ2luYWxSb290Tm9kZSIsImRpZmZNYXRoUGF0Y2giLCJkZWxOb2RlIiwib2xkVmFsdWUiLCJpbnNOb2RlIiwibmV3VmFsdWUiLCJwYXJlbnROb2RlIiwicmVwbGFjZUNoaWxkIiwiZWxlbWVudCIsInRleHREaWZmcyIsImRpZmZfbWFpbiIsImRpZmZfY2xlYW51cFNlbWFudGljIiwibW9kaWZpZXIiLCJ0ZXh0RGlmZk5vZGUiLCJjbG9uZU5vZGUiLCJ1cGRhdGVkTm9kZSIsIm5hbWUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJsb2dnZXIiLCJ3YXJuIiwicm91dGVJc0VxdWFsIiwicjEiLCJyMiIsInNvbWUiLCJlIiwiZmlsdGVyQ2FuY2VsaW5nT3V0RGlmZnMiLCJvcmlnaW5hbERpZmZBY3Rpb25zIiwiZGlmZkFjdGlvbnMiLCJzbGljZSIsIm5leHREaWZmIiwiY2FuY2Vsc091dCIsInNwbGljZSIsImVkaXRCb2R5RGlmZlRvSHRtbCIsIm9yaWdpbmFsQ29udGVudCIsImVkaXRDb250ZW50Iiwib3JpZ2luYWxCb2R5IiwiZWRpdEJvZHkiLCJkZCIsIkRpZmZET00iLCJvcmlnaW5hbGRpZmZBY3Rpb25zIiwiRGlmZk1hdGNoUGF0Y2giLCJET01QYXJzZXIiLCJwYXJzZUZyb21TdHJpbmciLCJib2R5IiwiY2hpbGRyZW4iLCJzYWZlQm9keSIsIl9faHRtbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBZ0JBOztBQUNBOztBQUNBOztBQUNBOztBQUdBOztBQUVBOztBQXhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFZQSxNQUFNQSxjQUFjLEdBQUksWUFBVztBQUMvQixNQUFJQyxRQUFRLEdBQUcsSUFBZjtBQUNBLFNBQU8sVUFBU0MsR0FBVCxFQUE4QjtBQUNqQyxRQUFJLENBQUNELFFBQUwsRUFBZTtBQUNYQSxNQUFBQSxRQUFRLEdBQUdFLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixVQUF2QixDQUFYO0FBQ0g7O0FBQ0RILElBQUFBLFFBQVEsQ0FBQ0ksU0FBVCxHQUFxQkgsR0FBckI7QUFDQSxXQUFPRCxRQUFRLENBQUNLLEtBQWhCO0FBQ0gsR0FORDtBQU9ILENBVHNCLEVBQXZCOztBQVdBLFNB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Q0FXNUY7O0FBQ0EsUUFBTXRDLGFBQWEsR0FBRyxJQUFJdUMsZ0NBQUosRUFBdEIsQ0FaNEYsQ0FhNUY7QUFDQTs7QUFDQSxRQUFNeEMsZ0JBQWdCLEdBQUcsSUFBSXlDLFNBQUosR0FBZ0JDLGVBQWhCLENBQWdDUCxZQUFoQyxFQUE4QyxXQUE5QyxFQUEyRFEsSUFBM0QsQ0FBZ0VDLFFBQWhFLENBQXlFLENBQXpFLENBQXpCOztBQUNBLE9BQUssSUFBSTFFLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd5RCxXQUFXLENBQUMxRCxNQUFoQyxFQUF3QyxFQUFFQyxDQUExQyxFQUE2QztBQUN6QyxVQUFNc0IsSUFBSSxHQUFHbUMsV0FBVyxDQUFDekQsQ0FBRCxDQUF4QjtBQUNBNkIsSUFBQUEscUJBQXFCLENBQUNDLGdCQUFELEVBQW1CUixJQUFuQixFQUF5QlMsYUFBekIsQ0FBckIsQ0FGeUMsQ0FHekM7QUFDQTtBQUNBO0FBQ0E7O0FBQ0FWLElBQUFBLFlBQVksQ0FBQ0MsSUFBRCxFQUFPbUMsV0FBVyxDQUFDQyxLQUFaLENBQWtCMUQsQ0FBQyxHQUFHLENBQXRCLENBQVAsQ0FBWjtBQUNILEdBeEIyRixDQXlCNUY7OztBQUNBLFFBQU0yRSxRQUFRLEdBQUc3QyxnQkFBZ0IsQ0FBQ3hELFNBQWxDO0FBQ0EsUUFBTWUsU0FBUyxHQUFHLHlCQUFXO0FBQ3pCLHlCQUFxQixJQURJO0FBRXpCLHFCQUFpQjtBQUZRLEdBQVgsQ0FBbEI7QUFJQSxzQkFBTztBQUFNLElBQUEsR0FBRyxFQUFDLE1BQVY7QUFBaUIsSUFBQSxTQUFTLEVBQUVBLFNBQTVCO0FBQXVDLElBQUEsdUJBQXVCLEVBQUU7QUFBRXVGLE1BQUFBLE1BQU0sRUFBRUQ7QUFBVixLQUFoRTtBQUFzRixJQUFBLEdBQUcsRUFBQztBQUExRixJQUFQO0FBQ0giLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMTkgLSAyMDIxIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IFJlYWN0LCB7IFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHsgZGlmZl9tYXRjaF9wYXRjaCBhcyBEaWZmTWF0Y2hQYXRjaCB9IGZyb20gJ2RpZmYtbWF0Y2gtcGF0Y2gnO1xuaW1wb3J0IHsgRGlmZkRPTSwgSURpZmYgfSBmcm9tIFwiZGlmZi1kb21cIjtcbmltcG9ydCB7IElDb250ZW50IH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL21vZGVscy9ldmVudFwiO1xuXG5pbXBvcnQgeyBib2R5VG9IdG1sLCBjaGVja0Jsb2NrTm9kZSwgSU9wdHNSZXR1cm5TdHJpbmcgfSBmcm9tIFwiLi4vSHRtbFV0aWxzXCI7XG5cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9sb2dnZXJcIjtcblxuY29uc3QgZGVjb2RlRW50aXRpZXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgbGV0IHRleHRhcmVhID0gbnVsbDtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBpZiAoIXRleHRhcmVhKSB7XG4gICAgICAgICAgICB0ZXh0YXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0YXJlYS5pbm5lckhUTUwgPSBzdHI7XG4gICAgICAgIHJldHVybiB0ZXh0YXJlYS52YWx1ZTtcbiAgICB9O1xufSkoKTtcblxuZnVuY3Rpb24gdGV4dFRvSHRtbCh0ZXh0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgY29udGFpbmVyLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTDtcbn1cblxuZnVuY3Rpb24gZ2V0U2FuaXRpemVkSHRtbEJvZHkoY29udGVudDogSUNvbnRlbnQpOiBzdHJpbmcge1xuICAgIGNvbnN0IG9wdHM6IElPcHRzUmV0dXJuU3RyaW5nID0ge1xuICAgICAgICBzdHJpcFJlcGx5RmFsbGJhY2s6IHRydWUsXG4gICAgICAgIHJldHVyblN0cmluZzogdHJ1ZSxcbiAgICB9O1xuICAgIGlmIChjb250ZW50LmZvcm1hdCA9PT0gXCJvcmcubWF0cml4LmN1c3RvbS5odG1sXCIpIHtcbiAgICAgICAgcmV0dXJuIGJvZHlUb0h0bWwoY29udGVudCwgbnVsbCwgb3B0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29udmVydCB0aGUgc3RyaW5nIHRvIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBzYWZlbHlcbiAgICAgICAgLy8gZW1iZWRkZWQgaW4gYW4gaHRtbCBkb2N1bWVudCwgZS5nLiB1c2UgaHRtbCBlbnRpdGllcyB3aGVyZSBuZWVkZWRcbiAgICAgICAgLy8gVGhpcyBpcyBhbHNvIG5lZWRlZCBzbyB0aGF0IERpZmZET00gd291bGRuJ3QgaW50ZXJwcmV0IHNvbWV0aGluZ1xuICAgICAgICAvLyBhcyBhIHRhZyB3aGVuIHNvbWVib2R5IHR5cGVzIGUuZy4gXCI8L3NhcmNhc20+XCJcblxuICAgICAgICAvLyBhcyBvcHBvc2VkIHRvIGJvZHlUb0h0bWwsIGhlcmUgd2UgYWxzbyByZW5kZXJcbiAgICAgICAgLy8gdGV4dCBtZXNzYWdlcyB3aXRoIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLCB0byB1bmlmeVxuICAgICAgICAvLyB0aGUgY29kZSBwYXRocyBhbmQgYmVjYXVzZSB3ZSBuZWVkIGh0bWwgdG8gc2hvdyBkaWZmZXJlbmNlc1xuICAgICAgICByZXR1cm4gdGV4dFRvSHRtbChib2R5VG9IdG1sKGNvbnRlbnQsIG51bGwsIG9wdHMpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHdyYXBJbnNlcnRpb24oY2hpbGQ6IE5vZGUpOiBIVE1MRWxlbWVudCB7XG4gICAgY29uc3Qgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoY2hlY2tCbG9ja05vZGUoY2hpbGQpID8gXCJkaXZcIiA6IFwic3BhblwiKTtcbiAgICB3cmFwcGVyLmNsYXNzTmFtZSA9IFwibXhfRWRpdEhpc3RvcnlNZXNzYWdlX2luc2VydGlvblwiO1xuICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIHJldHVybiB3cmFwcGVyO1xufVxuXG5mdW5jdGlvbiB3cmFwRGVsZXRpb24oY2hpbGQ6IE5vZGUpOiBIVE1MRWxlbWVudCB7XG4gICAgY29uc3Qgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoY2hlY2tCbG9ja05vZGUoY2hpbGQpID8gXCJkaXZcIiA6IFwic3BhblwiKTtcbiAgICB3cmFwcGVyLmNsYXNzTmFtZSA9IFwibXhfRWRpdEhpc3RvcnlNZXNzYWdlX2RlbGV0aW9uXCI7XG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgcmV0dXJuIHdyYXBwZXI7XG59XG5cbmZ1bmN0aW9uIGZpbmRSZWZOb2Rlcyhyb290OiBOb2RlLCByb3V0ZTogbnVtYmVyW10sIGlzQWRkaXRpb24gPSBmYWxzZSkge1xuICAgIGxldCByZWZOb2RlID0gcm9vdDtcbiAgICBsZXQgcmVmUGFyZW50Tm9kZTtcbiAgICBjb25zdCBlbmQgPSBpc0FkZGl0aW9uID8gcm91dGUubGVuZ3RoIC0gMSA6IHJvdXRlLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICAgIHJlZlBhcmVudE5vZGUgPSByZWZOb2RlO1xuICAgICAgICByZWZOb2RlID0gcmVmTm9kZS5jaGlsZE5vZGVzW3JvdXRlW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcmVmTm9kZSwgcmVmUGFyZW50Tm9kZSB9O1xufVxuXG5mdW5jdGlvbiBkaWZmVHJlZVRvRE9NKGRlc2MpIHtcbiAgICBpZiAoZGVzYy5ub2RlTmFtZSA9PT0gXCIjdGV4dFwiKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdBc1RleHROb2RlKGRlc2MuZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZGVzYy5ub2RlTmFtZSk7XG4gICAgICAgIGlmIChkZXNjLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGRlc2MuYXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzYy5jaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkRGVzYyBvZiBkZXNjLmNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGRpZmZUcmVlVG9ET00oY2hpbGREZXNjKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUocGFyZW50OiBOb2RlLCBuZXh0U2libGluZzogTm9kZSB8IG51bGwsIGNoaWxkOiBOb2RlKTogdm9pZCB7XG4gICAgaWYgKG5leHRTaWJsaW5nKSB7XG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIG5leHRTaWJsaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNSb3V0ZU9mTmV4dFNpYmxpbmcocm91dGUxOiBudW1iZXJbXSwgcm91dGUyOiBudW1iZXJbXSk6IGJvb2xlYW4ge1xuICAgIC8vIHJvdXRlcyBhcmUgYXJyYXlzIHdpdGggaW5kaWNlcyxcbiAgICAvLyB0byBiZSBpbnRlcnByZXRlZCBhcyBhIHBhdGggaW4gdGhlIGRvbSB0cmVlXG5cbiAgICAvLyBlbnN1cmUgc2FtZSBwYXJlbnRcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdXRlMS5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgaWYgKHJvdXRlMVtpXSAhPT0gcm91dGUyW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gdGhlIHJvdXRlMiBpcyBvbmx5IGFmZmVjdGVkIGJ5IHRoZSBkaWZmIG9mIHJvdXRlMVxuICAgIC8vIGluc2VydGluZyBhbiBlbGVtZW50IGlmIHRoZSBpbmRleCBhdCB0aGUgbGV2ZWwgb2YgdGhlXG4gICAgLy8gbGFzdCBlbGVtZW50IG9mIHJvdXRlMSBiZWluZyBsYXJnZXJcbiAgICAvLyAoZS5nLiBjb21pbmcgYmVoaW5kIHJvdXRlMSBhdCB0aGF0IGxldmVsKVxuICAgIGNvbnN0IGxhc3REMUlkeCA9IHJvdXRlMS5sZW5ndGggLSAxO1xuICAgIHJldHVybiByb3V0ZTJbbGFzdEQxSWR4XSA+PSByb3V0ZTFbbGFzdEQxSWR4XTtcbn1cblxuZnVuY3Rpb24gYWRqdXN0Um91dGVzKGRpZmY6IElEaWZmLCByZW1haW5pbmdEaWZmczogSURpZmZbXSk6IHZvaWQge1xuICAgIGlmIChkaWZmLmFjdGlvbiA9PT0gXCJyZW1vdmVUZXh0RWxlbWVudFwiIHx8IGRpZmYuYWN0aW9uID09PSBcInJlbW92ZUVsZW1lbnRcIikge1xuICAgICAgICAvLyBhcyByZW1vdmVkIHRleHQgaXMgbm90IHJlbW92ZWQgZnJvbSB0aGUgaHRtbCwgYnV0IG1hcmtlZCBhcyBkZWxldGVkLFxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlYWRqdXN0IGluZGljZXMgdGhhdCBhc3N1bWUgdGhlIGN1cnJlbnQgbm9kZSBoYXMgYmVlbiByZW1vdmVkLlxuICAgICAgICBjb25zdCBhZHZhbmNlID0gMTtcbiAgICAgICAgZm9yIChjb25zdCByZCBvZiByZW1haW5pbmdEaWZmcykge1xuICAgICAgICAgICAgaWYgKGlzUm91dGVPZk5leHRTaWJsaW5nKGRpZmYucm91dGUsIHJkLnJvdXRlKSkge1xuICAgICAgICAgICAgICAgIHJkLnJvdXRlW2RpZmYucm91dGUubGVuZ3RoIC0gMV0gKz0gYWR2YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gc3RyaW5nQXNUZXh0Tm9kZShzdHJpbmc6IHN0cmluZyk6IFRleHQge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkZWNvZGVFbnRpdGllcyhzdHJpbmcpKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyRGlmZmVyZW5jZUluRE9NKG9yaWdpbmFsUm9vdE5vZGU6IE5vZGUsIGRpZmY6IElEaWZmLCBkaWZmTWF0aFBhdGNoOiBEaWZmTWF0Y2hQYXRjaCk6IHZvaWQge1xuICAgIGNvbnN0IHsgcmVmTm9kZSwgcmVmUGFyZW50Tm9kZSB9ID0gZmluZFJlZk5vZGVzKG9yaWdpbmFsUm9vdE5vZGUsIGRpZmYucm91dGUpO1xuICAgIHN3aXRjaCAoZGlmZi5hY3Rpb24pIHtcbiAgICAgICAgY2FzZSBcInJlcGxhY2VFbGVtZW50XCI6IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgY29uc3QgZGVsTm9kZSA9IHdyYXBEZWxldGlvbihkaWZmVHJlZVRvRE9NKGRpZmYub2xkVmFsdWUpKTtcbiAgICAgICAgICAgIGNvbnN0IGluc05vZGUgPSB3cmFwSW5zZXJ0aW9uKGRpZmZUcmVlVG9ET00oZGlmZi5uZXdWYWx1ZSkpO1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGRlbE5vZGUpO1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGluc05vZGUpO1xuICAgICAgICAgICAgcmVmTm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChjb250YWluZXIsIHJlZk5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInJlbW92ZVRleHRFbGVtZW50XCI6IHtcbiAgICAgICAgICAgIGNvbnN0IGRlbE5vZGUgPSB3cmFwRGVsZXRpb24oc3RyaW5nQXNUZXh0Tm9kZShkaWZmLnZhbHVlKSk7XG4gICAgICAgICAgICByZWZOb2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGRlbE5vZGUsIHJlZk5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInJlbW92ZUVsZW1lbnRcIjoge1xuICAgICAgICAgICAgY29uc3QgZGVsTm9kZSA9IHdyYXBEZWxldGlvbihkaWZmVHJlZVRvRE9NKGRpZmYuZWxlbWVudCkpO1xuICAgICAgICAgICAgcmVmTm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChkZWxOb2RlLCByZWZOb2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJtb2RpZnlUZXh0RWxlbWVudFwiOiB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0RGlmZnMgPSBkaWZmTWF0aFBhdGNoLmRpZmZfbWFpbihkaWZmLm9sZFZhbHVlLCBkaWZmLm5ld1ZhbHVlKTtcbiAgICAgICAgICAgIGRpZmZNYXRoUGF0Y2guZGlmZl9jbGVhbnVwU2VtYW50aWModGV4dERpZmZzKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbW9kaWZpZXIsIHRleHRdIG9mIHRleHREaWZmcykge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0RGlmZk5vZGU6IE5vZGUgPSBzdHJpbmdBc1RleHROb2RlKHRleHQpO1xuICAgICAgICAgICAgICAgIGlmIChtb2RpZmllciA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dERpZmZOb2RlID0gd3JhcERlbGV0aW9uKHRleHREaWZmTm9kZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RpZmllciA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dERpZmZOb2RlID0gd3JhcEluc2VydGlvbih0ZXh0RGlmZk5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGV4dERpZmZOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZk5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoY29udGFpbmVyLCByZWZOb2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJhZGRFbGVtZW50XCI6IHtcbiAgICAgICAgICAgIGNvbnN0IGluc05vZGUgPSB3cmFwSW5zZXJ0aW9uKGRpZmZUcmVlVG9ET00oZGlmZi5lbGVtZW50KSk7XG4gICAgICAgICAgICBpbnNlcnRCZWZvcmUocmVmUGFyZW50Tm9kZSwgcmVmTm9kZSwgaW5zTm9kZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiYWRkVGV4dEVsZW1lbnRcIjoge1xuICAgICAgICAgICAgLy8gWFhYOiBzb21ldGltZXMgZGlmZkRPTSBzYXlzIGluc2VydCBhIG5ld2xpbmUgd2hlbiB0aGVyZSBzaG91bGRuJ3QgYmUgb25lXG4gICAgICAgICAgICAvLyBidXQgd2UgbXVzdCBpbnNlcnQgdGhlIG5vZGUgYW55d2F5IHNvIHRoYXQgd2UgZG9uJ3QgYnJlYWsgdGhlIHJvdXRlIGNoaWxkIElEcy5cbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmlkdXN3cml0ZXIvZGlmZkRPTS9pc3N1ZXMvMTAwXG4gICAgICAgICAgICBjb25zdCBpbnNOb2RlID0gd3JhcEluc2VydGlvbihzdHJpbmdBc1RleHROb2RlKGRpZmYudmFsdWUgIT09IFwiXFxuXCIgPyBkaWZmLnZhbHVlIDogXCJcIikpO1xuICAgICAgICAgICAgaW5zZXJ0QmVmb3JlKHJlZlBhcmVudE5vZGUsIHJlZk5vZGUsIGluc05vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZS5nLiB3aGVuIGNoYW5naW5nIGEgdGhlIGhyZWYgb2YgYSBsaW5rLFxuICAgICAgICAvLyBzaG93IHRoZSBsaW5rIHdpdGggb2xkIGhyZWYgYXMgcmVtb3ZlZCBhbmQgd2l0aCB0aGUgbmV3IGhyZWYgYXMgYWRkZWRcbiAgICAgICAgY2FzZSBcInJlbW92ZUF0dHJpYnV0ZVwiOlxuICAgICAgICBjYXNlIFwiYWRkQXR0cmlidXRlXCI6XG4gICAgICAgIGNhc2UgXCJtb2RpZnlBdHRyaWJ1dGVcIjoge1xuICAgICAgICAgICAgY29uc3QgZGVsTm9kZSA9IHdyYXBEZWxldGlvbihyZWZOb2RlLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkTm9kZSA9IHJlZk5vZGUuY2xvbmVOb2RlKHRydWUpIGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAgICAgaWYgKGRpZmYuYWN0aW9uID09PSBcImFkZEF0dHJpYnV0ZVwiIHx8IGRpZmYuYWN0aW9uID09PSBcIm1vZGlmeUF0dHJpYnV0ZVwiKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlZE5vZGUuc2V0QXR0cmlidXRlKGRpZmYubmFtZSwgZGlmZi5uZXdWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwZGF0ZWROb2RlLnJlbW92ZUF0dHJpYnV0ZShkaWZmLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5zTm9kZSA9IHdyYXBJbnNlcnRpb24odXBkYXRlZE5vZGUpO1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChjaGVja0Jsb2NrTm9kZShyZWZOb2RlKSA/IFwiZGl2XCIgOiBcInNwYW5cIik7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZGVsTm9kZSk7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaW5zTm9kZSk7XG4gICAgICAgICAgICByZWZOb2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGNvbnRhaW5lciwgcmVmTm9kZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gU2hvdWxkIG5vdCBoYXBwZW4gKG1vZGlmeUNvbW1lbnQsID8/PylcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiTWVzc2FnZURpZmZVdGlsczo6ZWRpdEJvZHlEaWZmVG9IdG1sOiBkaWZmIGFjdGlvbiBub3Qgc3VwcG9ydGVkIGF0bVwiLCBkaWZmKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJvdXRlSXNFcXVhbChyMTogbnVtYmVyW10sIHIyOiBudW1iZXJbXSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiByMS5sZW5ndGggPT09IHIyLmxlbmd0aCAmJiAhcjEuc29tZSgoZSwgaSkgPT4gZSAhPT0gcjJbaV0pO1xufVxuXG4vLyB3b3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vZmlkdXN3cml0ZXIvZGlmZkRPTS9pc3N1ZXMvOTBcbmZ1bmN0aW9uIGZpbHRlckNhbmNlbGluZ091dERpZmZzKG9yaWdpbmFsRGlmZkFjdGlvbnM6IElEaWZmW10pOiBJRGlmZltdIHtcbiAgICBjb25zdCBkaWZmQWN0aW9ucyA9IG9yaWdpbmFsRGlmZkFjdGlvbnMuc2xpY2UoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZkFjdGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgZGlmZiA9IGRpZmZBY3Rpb25zW2ldO1xuICAgICAgICBpZiAoZGlmZi5hY3Rpb24gPT09IFwicmVtb3ZlVGV4dEVsZW1lbnRcIikge1xuICAgICAgICAgICAgY29uc3QgbmV4dERpZmYgPSBkaWZmQWN0aW9uc1tpICsgMV07XG4gICAgICAgICAgICBjb25zdCBjYW5jZWxzT3V0ID0gbmV4dERpZmYgJiZcbiAgICAgICAgICAgICAgICBuZXh0RGlmZi5hY3Rpb24gPT09IFwiYWRkVGV4dEVsZW1lbnRcIiAmJlxuICAgICAgICAgICAgICAgIG5leHREaWZmLnRleHQgPT09IGRpZmYudGV4dCAmJlxuICAgICAgICAgICAgICAgIHJvdXRlSXNFcXVhbChuZXh0RGlmZi5yb3V0ZSwgZGlmZi5yb3V0ZSk7XG5cbiAgICAgICAgICAgIGlmIChjYW5jZWxzT3V0KSB7XG4gICAgICAgICAgICAgICAgZGlmZkFjdGlvbnMuc3BsaWNlKGksIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpZmZBY3Rpb25zO1xufVxuXG4vKipcbiAqIFJlbmRlcnMgYSBtZXNzYWdlIHdpdGggdGhlIGNoYW5nZXMgbWFkZSBpbiBhbiBlZGl0IHNob3duIHZpc3VhbGx5LlxuICogQHBhcmFtIHtvYmplY3R9IG9yaWdpbmFsQ29udGVudCB0aGUgY29udGVudCBmb3IgdGhlIGJhc2UgbWVzc2FnZVxuICogQHBhcmFtIHtvYmplY3R9IGVkaXRDb250ZW50IHRoZSBjb250ZW50IGZvciB0aGUgZWRpdCBtZXNzYWdlXG4gKiBAcmV0dXJuIHtvYmplY3R9IGEgcmVhY3QgZWxlbWVudCBzaW1pbGFyIHRvIHdoYXQgYGJvZHlUb0h0bWxgIHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVkaXRCb2R5RGlmZlRvSHRtbChvcmlnaW5hbENvbnRlbnQ6IElDb250ZW50LCBlZGl0Q29udGVudDogSUNvbnRlbnQpOiBSZWFjdE5vZGUge1xuICAgIC8vIHdyYXAgdGhlIGJvZHkgaW4gYSBkaXYsIERpZmZET00gbmVlZHMgYSByb290IGVsZW1lbnRcbiAgICBjb25zdCBvcmlnaW5hbEJvZHkgPSBgPGRpdj4ke2dldFNhbml0aXplZEh0bWxCb2R5KG9yaWdpbmFsQ29udGVudCl9PC9kaXY+YDtcbiAgICBjb25zdCBlZGl0Qm9keSA9IGA8ZGl2PiR7Z2V0U2FuaXRpemVkSHRtbEJvZHkoZWRpdENvbnRlbnQpfTwvZGl2PmA7XG4gICAgY29uc3QgZGQgPSBuZXcgRGlmZkRPTSgpO1xuICAgIC8vIGRpZmZBY3Rpb25zIGlzIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCBhdCBsZWFzdCBhIGBhY3Rpb25gIGFuZCBgcm91dGVgXG4gICAgLy8gcHJvcGVydHkuIGBhY3Rpb25gIHRlbGxzIHVzIHdoYXQgdGhlIGRpZmYgb2JqZWN0IGNoYW5nZXMsIGFuZCBgcm91dGVgIHdoZXJlLlxuICAgIC8vIGByb3V0ZWAgaXMgYSBwYXRoIG9uIHRoZSBET00gdHJlZSBleHByZXNzZWQgYXMgYW4gYXJyYXkgb2YgaW5kaWNlcy5cbiAgICBjb25zdCBvcmlnaW5hbGRpZmZBY3Rpb25zID0gZGQuZGlmZihvcmlnaW5hbEJvZHksIGVkaXRCb2R5KTtcbiAgICAvLyB3b3JrIGFyb3VuZCBodHRwczovL2dpdGh1Yi5jb20vZmlkdXN3cml0ZXIvZGlmZkRPTS9pc3N1ZXMvOTBcbiAgICBjb25zdCBkaWZmQWN0aW9ucyA9IGZpbHRlckNhbmNlbGluZ091dERpZmZzKG9yaWdpbmFsZGlmZkFjdGlvbnMpO1xuICAgIC8vIGZvciBkaWZmaW5nIHRleHQgZnJhZ21lbnRzXG4gICAgY29uc3QgZGlmZk1hdGhQYXRjaCA9IG5ldyBEaWZmTWF0Y2hQYXRjaCgpO1xuICAgIC8vIHBhcnNlIHRoZSBiYXNlIGh0bWwgbWVzc2FnZSBhcyBhIERPTSB0cmVlLCB0byB3aGljaCB3ZSdsbCBhcHBseSB0aGUgZGlmZmVyZW5jZXMgZm91bmQuXG4gICAgLy8gZmlzaCBvdXQgdGhlIGRpdiBpbiB3aGljaCB3ZSB3cmFwcGVkIHRoZSBtZXNzYWdlcyBhYm92ZSB3aXRoIGNoaWxkcmVuWzBdLlxuICAgIGNvbnN0IG9yaWdpbmFsUm9vdE5vZGUgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKG9yaWdpbmFsQm9keSwgXCJ0ZXh0L2h0bWxcIikuYm9keS5jaGlsZHJlblswXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZmZBY3Rpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGRpZmYgPSBkaWZmQWN0aW9uc1tpXTtcbiAgICAgICAgcmVuZGVyRGlmZmVyZW5jZUluRE9NKG9yaWdpbmFsUm9vdE5vZGUsIGRpZmYsIGRpZmZNYXRoUGF0Y2gpO1xuICAgICAgICAvLyBEaWZmRE9NIGFzc3VtZXMgaW4gc3Vic2VxdWVudCBkaWZmcyByb3V0ZSBwYXRoIHRoYXRcbiAgICAgICAgLy8gdGhlIGFjdGlvbiB3YXMgYXBwbGllZCAoZS5nLiB0aGF0IGEgcmVtb3ZlRWxlbWVudCBhY3Rpb24gcmVtb3ZlZCB0aGUgZWxlbWVudCkuXG4gICAgICAgIC8vIFRoaXMgaXMgbm90IHRoZSBjYXNlIGZvciB1cy4gV2UgcmVuZGVyIGRpZmZlcmVuY2VzIGluIHRoZSBET00gdHJlZSwgYW5kIGRvbid0IGFwcGx5IHRoZW0uXG4gICAgICAgIC8vIFNvIHdlIG5lZWQgdG8gYWRqdXN0IHRoZSByb3V0ZXMgb2YgdGhlIHJlbWFpbmluZyBkaWZmcyB0byBhY2NvdW50IGZvciB0aGlzLlxuICAgICAgICBhZGp1c3RSb3V0ZXMoZGlmZiwgZGlmZkFjdGlvbnMuc2xpY2UoaSArIDEpKTtcbiAgICB9XG4gICAgLy8gdGFrZSB0aGUgaHRtbCBvdXQgb2YgdGhlIG1vZGlmaWVkIERPTSB0cmVlIGFnYWluXG4gICAgY29uc3Qgc2FmZUJvZHkgPSBvcmlnaW5hbFJvb3ROb2RlLmlubmVySFRNTDtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBjbGFzc05hbWVzKHtcbiAgICAgICAgJ214X0V2ZW50VGlsZV9ib2R5JzogdHJ1ZSxcbiAgICAgICAgJ21hcmtkb3duLWJvZHknOiB0cnVlLFxuICAgIH0pO1xuICAgIHJldHVybiA8c3BhbiBrZXk9XCJib2R5XCIgY2xhc3NOYW1lPXtjbGFzc05hbWV9IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7IF9faHRtbDogc2FmZUJvZHkgfX0gZGlyPVwiYXV0b1wiIC8+O1xufVxuIl19