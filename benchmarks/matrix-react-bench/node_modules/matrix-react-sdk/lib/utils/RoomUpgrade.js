"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.awaitRoomDownSync = awaitRoomDownSync;
exports.upgradeRoom = upgradeRoom;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _event = require("matrix-js-sdk/src/@types/event");

var _RoomInvite = require("../RoomInvite");

var _Modal = _interopRequireDefault(require("../Modal"));

var _languageHandler = require("../languageHandler");

var _ErrorDialog = _interopRequireDefault(require("../components/views/dialogs/ErrorDialog"));

var _SpaceStore = _interopRequireDefault(require("../stores/spaces/SpaceStore"));

var _Spinner = _interopRequireDefault(require("../components/views/elements/Spinner"));

var _logger = require("matrix-js-sdk/src/logger");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

async function awaitRoomDownSync(cli, roomId) {
  const room = cli.getRoom(roomId);
  if (room) return room; // already have the room

  return new Promise(resolve => {
    // We have to wait for the js-sdk to give us the room back so
    // we can more effectively abuse the MultiInviter behaviour
    // which heavily relies on the Room object being available.
    const checkForRoomFn = room => {
      if (room.roomId !== roomId) return;
      resolve(room);
      cli.off("Room", checkForRoomFn);
    };

    cli.on("Room", checkForRoomFn);
  });
}

async function upgradeRoom(room, targetVersion, inviteUsers = false, handleError = true, updateSpaces = true, awaitRoom = false, progressCallback) {
  var _spinnerModal;

  const cli = room.client;
  let spinnerModal;

  if (!progressCallback) {
    spinnerModal = _Modal.default.createDialog(_Spinner.default, null, "mx_Dialog_spinner");
  }

  let toInvite = [];

  if (inviteUsers) {
    toInvite = [...room.getMembersWithMembership("join"), ...room.getMembersWithMembership("invite")].map(m => m.userId).filter(m => m !== cli.getUserId());
  }

  let parentsToRelink = [];

  if (updateSpaces) {
    parentsToRelink = Array.from(_SpaceStore.default.instance.getKnownParents(room.roomId)).map(roomId => cli.getRoom(roomId)).filter(parent => parent === null || parent === void 0 ? void 0 : parent.currentState.maySendStateEvent(_event.EventType.SpaceChild, cli.getUserId()));
  }

  const progress = {
    roomUpgraded: false,
    roomSynced: awaitRoom || inviteUsers ? false : undefined,
    inviteUsersProgress: inviteUsers ? 0 : undefined,
    inviteUsersTotal: toInvite.length,
    updateSpacesProgress: updateSpaces ? 0 : undefined,
    updateSpacesTotal: parentsToRelink.length
  };
  progressCallback === null || progressCallback === void 0 ? void 0 : progressCallback(progress);
  let newRoomId;

  try {
    ({
      replacement_room: newRoomId
    } = await cli.upgradeRoom(room.roomId, targetVersion));
  } catch (e) {
    if (!handleError) throw e;

    _logger.logger.error(e);

    _Modal.default.createTrackedDialog("Room Upgrade Error", "", _ErrorDialog.default, {
      title: (0, _languageHandler._t)('Error upgrading room'),
      description: (0, _languageHandler._t)('Double check that your server supports the room version chosen and try again.')
    });

    throw e;
  }

  progress.roomUpgraded = true;
  progressCallback === null || progressCallback === void 0 ? void 0 : progressCallback(progress);

  if (awaitRoom || inviteUsers) {
    await awaitRoomDownSync(room.client, newRoomId);
    progress.roomSynced = true;
    progressCallback === null || progressCallback === void 0 ? void 0 : progressCallback(progress);
  }

  if (toInvite.length > 0) {
    // Errors are handled internally to this function
    await (0, _RoomInvite.inviteUsersToRoom)(newRoomId, toInvite, () => {
      progress.inviteUsersProgress++;
      progressCallback === null || progressCallback === void 0 ? void 0 : progressCallback(progress);
    });
  }

  if (parentsToRelink.length > 0) {
    try {
      for (const parent of parentsToRelink) {
        const currentEv = parent.currentState.getStateEvents(_event.EventType.SpaceChild, room.roomId);
        await cli.sendStateEvent(parent.roomId, _event.EventType.SpaceChild, _objectSpread(_objectSpread({}, (currentEv === null || currentEv === void 0 ? void 0 : currentEv.getContent()) || {}), {}, {
          // copy existing attributes like suggested
          via: [cli.getDomain()]
        }), newRoomId);
        await cli.sendStateEvent(parent.roomId, _event.EventType.SpaceChild, {}, room.roomId);
        progress.updateSpacesProgress++;
        progressCallback === null || progressCallback === void 0 ? void 0 : progressCallback(progress);
      }
    } catch (e) {
      // These errors are not critical to the room upgrade itself
      _logger.logger.warn("Failed to update parent spaces during room upgrade", e);
    }
  }

  (_spinnerModal = spinnerModal) === null || _spinnerModal === void 0 ? void 0 : _spinnerModal.close();
  return newRoomId;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9Sb29tVXBncmFkZS50cyJdLCJuYW1lcyI6WyJhd2FpdFJvb21Eb3duU3luYyIsImNsaSIsInJvb21JZCIsInJvb20iLCJnZXRSb29tIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjaGVja0ZvclJvb21GbiIsIm9mZiIsIm9uIiwidXBncmFkZVJvb20iLCJ0YXJnZXRWZXJzaW9uIiwiaW52aXRlVXNlcnMiLCJoYW5kbGVFcnJvciIsInVwZGF0ZVNwYWNlcyIsImF3YWl0Um9vbSIsInByb2dyZXNzQ2FsbGJhY2siLCJjbGllbnQiLCJzcGlubmVyTW9kYWwiLCJNb2RhbCIsImNyZWF0ZURpYWxvZyIsIlNwaW5uZXIiLCJ0b0ludml0ZSIsImdldE1lbWJlcnNXaXRoTWVtYmVyc2hpcCIsIm1hcCIsIm0iLCJ1c2VySWQiLCJmaWx0ZXIiLCJnZXRVc2VySWQiLCJwYXJlbnRzVG9SZWxpbmsiLCJBcnJheSIsImZyb20iLCJTcGFjZVN0b3JlIiwiaW5zdGFuY2UiLCJnZXRLbm93blBhcmVudHMiLCJwYXJlbnQiLCJjdXJyZW50U3RhdGUiLCJtYXlTZW5kU3RhdGVFdmVudCIsIkV2ZW50VHlwZSIsIlNwYWNlQ2hpbGQiLCJwcm9ncmVzcyIsInJvb21VcGdyYWRlZCIsInJvb21TeW5jZWQiLCJ1bmRlZmluZWQiLCJpbnZpdGVVc2Vyc1Byb2dyZXNzIiwiaW52aXRlVXNlcnNUb3RhbCIsImxlbmd0aCIsInVwZGF0ZVNwYWNlc1Byb2dyZXNzIiwidXBkYXRlU3BhY2VzVG90YWwiLCJuZXdSb29tSWQiLCJyZXBsYWNlbWVudF9yb29tIiwiZSIsImxvZ2dlciIsImVycm9yIiwiY3JlYXRlVHJhY2tlZERpYWxvZyIsIkVycm9yRGlhbG9nIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsImN1cnJlbnRFdiIsImdldFN0YXRlRXZlbnRzIiwic2VuZFN0YXRlRXZlbnQiLCJnZXRDb250ZW50IiwidmlhIiwiZ2V0RG9tYWluIiwid2FybiIsImNsb3NlIl0sIm1h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Q0FBbEU7QUFDSDtBQUNKOztBQUVELG1CQUFBakMsWUFBWSxVQUFaLHNEQUFjK0MsS0FBZDtBQUNBLFNBQU9oQixTQUFQO0FBQ0giLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMjEgVGhlIE1hdHJpeC5vcmcgRm91bmRhdGlvbiBDLkkuQy5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgeyBSb29tIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL21vZGVscy9yb29tXCI7XG5pbXBvcnQgeyBFdmVudFR5cGUgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvQHR5cGVzL2V2ZW50XCI7XG5cbmltcG9ydCB7IGludml0ZVVzZXJzVG9Sb29tIH0gZnJvbSBcIi4uL1Jvb21JbnZpdGVcIjtcbmltcG9ydCBNb2RhbCwgeyBJSGFuZGxlIH0gZnJvbSBcIi4uL01vZGFsXCI7XG5pbXBvcnQgeyBfdCB9IGZyb20gXCIuLi9sYW5ndWFnZUhhbmRsZXJcIjtcbmltcG9ydCBFcnJvckRpYWxvZyBmcm9tIFwiLi4vY29tcG9uZW50cy92aWV3cy9kaWFsb2dzL0Vycm9yRGlhbG9nXCI7XG5pbXBvcnQgU3BhY2VTdG9yZSBmcm9tIFwiLi4vc3RvcmVzL3NwYWNlcy9TcGFjZVN0b3JlXCI7XG5pbXBvcnQgU3Bpbm5lciBmcm9tIFwiLi4vY29tcG9uZW50cy92aWV3cy9lbGVtZW50cy9TcGlubmVyXCI7XG5cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9sb2dnZXJcIjtcbmltcG9ydCB7IE1hdHJpeENsaWVudCB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9jbGllbnRcIjtcblxuaW50ZXJmYWNlIElQcm9ncmVzcyB7XG4gICAgcm9vbVVwZ3JhZGVkOiBib29sZWFuO1xuICAgIHJvb21TeW5jZWQ/OiBib29sZWFuO1xuICAgIGludml0ZVVzZXJzUHJvZ3Jlc3M/OiBudW1iZXI7XG4gICAgaW52aXRlVXNlcnNUb3RhbDogbnVtYmVyO1xuICAgIHVwZGF0ZVNwYWNlc1Byb2dyZXNzPzogbnVtYmVyO1xuICAgIHVwZGF0ZVNwYWNlc1RvdGFsOiBudW1iZXI7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhd2FpdFJvb21Eb3duU3luYyhjbGk6IE1hdHJpeENsaWVudCwgcm9vbUlkOiBzdHJpbmcpOiBQcm9taXNlPFJvb20+IHtcbiAgICBjb25zdCByb29tID0gY2xpLmdldFJvb20ocm9vbUlkKTtcbiAgICBpZiAocm9vbSkgcmV0dXJuIHJvb207IC8vIGFscmVhZHkgaGF2ZSB0aGUgcm9vbVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPFJvb20+KHJlc29sdmUgPT4ge1xuICAgICAgICAvLyBXZSBoYXZlIHRvIHdhaXQgZm9yIHRoZSBqcy1zZGsgdG8gZ2l2ZSB1cyB0aGUgcm9vbSBiYWNrIHNvXG4gICAgICAgIC8vIHdlIGNhbiBtb3JlIGVmZmVjdGl2ZWx5IGFidXNlIHRoZSBNdWx0aUludml0ZXIgYmVoYXZpb3VyXG4gICAgICAgIC8vIHdoaWNoIGhlYXZpbHkgcmVsaWVzIG9uIHRoZSBSb29tIG9iamVjdCBiZWluZyBhdmFpbGFibGUuXG4gICAgICAgIGNvbnN0IGNoZWNrRm9yUm9vbUZuID0gKHJvb206IFJvb20pID0+IHtcbiAgICAgICAgICAgIGlmIChyb29tLnJvb21JZCAhPT0gcm9vbUlkKSByZXR1cm47XG4gICAgICAgICAgICByZXNvbHZlKHJvb20pO1xuICAgICAgICAgICAgY2xpLm9mZihcIlJvb21cIiwgY2hlY2tGb3JSb29tRm4pO1xuICAgICAgICB9O1xuICAgICAgICBjbGkub24oXCJSb29tXCIsIGNoZWNrRm9yUm9vbUZuKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZ3JhZGVSb29tKFxuICAgIHJvb206IFJvb20sXG4gICAgdGFyZ2V0VmVyc2lvbjogc3RyaW5nLFxuICAgIGludml0ZVVzZXJzID0gZmFsc2UsXG4gICAgaGFuZGxlRXJyb3IgPSB0cnVlLFxuICAgIHVwZGF0ZVNwYWNlcyA9IHRydWUsXG4gICAgYXdhaXRSb29tID0gZmFsc2UsXG4gICAgcHJvZ3Jlc3NDYWxsYmFjaz86IChwcm9ncmVzczogSVByb2dyZXNzKSA9PiB2b2lkLFxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCBjbGkgPSByb29tLmNsaWVudDtcbiAgICBsZXQgc3Bpbm5lck1vZGFsOiBJSGFuZGxlPGFueT47XG4gICAgaWYgKCFwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgIHNwaW5uZXJNb2RhbCA9IE1vZGFsLmNyZWF0ZURpYWxvZyhTcGlubmVyLCBudWxsLCBcIm14X0RpYWxvZ19zcGlubmVyXCIpO1xuICAgIH1cblxuICAgIGxldCB0b0ludml0ZTogc3RyaW5nW10gPSBbXTtcbiAgICBpZiAoaW52aXRlVXNlcnMpIHtcbiAgICAgICAgdG9JbnZpdGUgPSBbXG4gICAgICAgICAgICAuLi5yb29tLmdldE1lbWJlcnNXaXRoTWVtYmVyc2hpcChcImpvaW5cIiksXG4gICAgICAgICAgICAuLi5yb29tLmdldE1lbWJlcnNXaXRoTWVtYmVyc2hpcChcImludml0ZVwiKSxcbiAgICAgICAgXS5tYXAobSA9PiBtLnVzZXJJZCkuZmlsdGVyKG0gPT4gbSAhPT0gY2xpLmdldFVzZXJJZCgpKTtcbiAgICB9XG5cbiAgICBsZXQgcGFyZW50c1RvUmVsaW5rOiBSb29tW10gPSBbXTtcbiAgICBpZiAodXBkYXRlU3BhY2VzKSB7XG4gICAgICAgIHBhcmVudHNUb1JlbGluayA9IEFycmF5LmZyb20oU3BhY2VTdG9yZS5pbnN0YW5jZS5nZXRLbm93blBhcmVudHMocm9vbS5yb29tSWQpKVxuICAgICAgICAgICAgLm1hcChyb29tSWQgPT4gY2xpLmdldFJvb20ocm9vbUlkKSlcbiAgICAgICAgICAgIC5maWx0ZXIocGFyZW50ID0+IHBhcmVudD8uY3VycmVudFN0YXRlLm1heVNlbmRTdGF0ZUV2ZW50KEV2ZW50VHlwZS5TcGFjZUNoaWxkLCBjbGkuZ2V0VXNlcklkKCkpKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9ncmVzczogSVByb2dyZXNzID0ge1xuICAgICAgICByb29tVXBncmFkZWQ6IGZhbHNlLFxuICAgICAgICByb29tU3luY2VkOiAoYXdhaXRSb29tIHx8IGludml0ZVVzZXJzKSA/IGZhbHNlIDogdW5kZWZpbmVkLFxuICAgICAgICBpbnZpdGVVc2Vyc1Byb2dyZXNzOiBpbnZpdGVVc2VycyA/IDAgOiB1bmRlZmluZWQsXG4gICAgICAgIGludml0ZVVzZXJzVG90YWw6IHRvSW52aXRlLmxlbmd0aCxcbiAgICAgICAgdXBkYXRlU3BhY2VzUHJvZ3Jlc3M6IHVwZGF0ZVNwYWNlcyA/IDAgOiB1bmRlZmluZWQsXG4gICAgICAgIHVwZGF0ZVNwYWNlc1RvdGFsOiBwYXJlbnRzVG9SZWxpbmsubGVuZ3RoLFxuICAgIH07XG4gICAgcHJvZ3Jlc3NDYWxsYmFjaz8uKHByb2dyZXNzKTtcblxuICAgIGxldCBuZXdSb29tSWQ6IHN0cmluZztcbiAgICB0cnkge1xuICAgICAgICAoeyByZXBsYWNlbWVudF9yb29tOiBuZXdSb29tSWQgfSA9IGF3YWl0IGNsaS51cGdyYWRlUm9vbShyb29tLnJvb21JZCwgdGFyZ2V0VmVyc2lvbikpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKCFoYW5kbGVFcnJvcikgdGhyb3cgZTtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGUpO1xuXG4gICAgICAgIE1vZGFsLmNyZWF0ZVRyYWNrZWREaWFsb2coXCJSb29tIFVwZ3JhZGUgRXJyb3JcIiwgXCJcIiwgRXJyb3JEaWFsb2csIHtcbiAgICAgICAgICAgIHRpdGxlOiBfdCgnRXJyb3IgdXBncmFkaW5nIHJvb20nKSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBfdCgnRG91YmxlIGNoZWNrIHRoYXQgeW91ciBzZXJ2ZXIgc3VwcG9ydHMgdGhlIHJvb20gdmVyc2lvbiBjaG9zZW4gYW5kIHRyeSBhZ2Fpbi4nKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgcHJvZ3Jlc3Mucm9vbVVwZ3JhZGVkID0gdHJ1ZTtcbiAgICBwcm9ncmVzc0NhbGxiYWNrPy4ocHJvZ3Jlc3MpO1xuXG4gICAgaWYgKGF3YWl0Um9vbSB8fCBpbnZpdGVVc2Vycykge1xuICAgICAgICBhd2FpdCBhd2FpdFJvb21Eb3duU3luYyhyb29tLmNsaWVudCwgbmV3Um9vbUlkKTtcbiAgICAgICAgcHJvZ3Jlc3Mucm9vbVN5bmNlZCA9IHRydWU7XG4gICAgICAgIHByb2dyZXNzQ2FsbGJhY2s/Lihwcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKHRvSW52aXRlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gRXJyb3JzIGFyZSBoYW5kbGVkIGludGVybmFsbHkgdG8gdGhpcyBmdW5jdGlvblxuICAgICAgICBhd2FpdCBpbnZpdGVVc2Vyc1RvUm9vbShuZXdSb29tSWQsIHRvSW52aXRlLCAoKSA9PiB7XG4gICAgICAgICAgICBwcm9ncmVzcy5pbnZpdGVVc2Vyc1Byb2dyZXNzKys7XG4gICAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrPy4ocHJvZ3Jlc3MpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50c1RvUmVsaW5rLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFyZW50IG9mIHBhcmVudHNUb1JlbGluaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRFdiA9IHBhcmVudC5jdXJyZW50U3RhdGUuZ2V0U3RhdGVFdmVudHMoRXZlbnRUeXBlLlNwYWNlQ2hpbGQsIHJvb20ucm9vbUlkKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBjbGkuc2VuZFN0YXRlRXZlbnQocGFyZW50LnJvb21JZCwgRXZlbnRUeXBlLlNwYWNlQ2hpbGQsIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uKGN1cnJlbnRFdj8uZ2V0Q29udGVudCgpIHx8IHt9KSwgLy8gY29weSBleGlzdGluZyBhdHRyaWJ1dGVzIGxpa2Ugc3VnZ2VzdGVkXG4gICAgICAgICAgICAgICAgICAgIHZpYTogW2NsaS5nZXREb21haW4oKV0sXG4gICAgICAgICAgICAgICAgfSwgbmV3Um9vbUlkKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBjbGkuc2VuZFN0YXRlRXZlbnQocGFyZW50LnJvb21JZCwgRXZlbnRUeXBlLlNwYWNlQ2hpbGQsIHt9LCByb29tLnJvb21JZCk7XG5cbiAgICAgICAgICAgICAgICBwcm9ncmVzcy51cGRhdGVTcGFjZXNQcm9ncmVzcysrO1xuICAgICAgICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2s/Lihwcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFRoZXNlIGVycm9ycyBhcmUgbm90IGNyaXRpY2FsIHRvIHRoZSByb29tIHVwZ3JhZGUgaXRzZWxmXG4gICAgICAgICAgICBsb2dnZXIud2FybihcIkZhaWxlZCB0byB1cGRhdGUgcGFyZW50IHNwYWNlcyBkdXJpbmcgcm9vbSB1cGdyYWRlXCIsIGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3Bpbm5lck1vZGFsPy5jbG9zZSgpO1xuICAgIHJldHVybiBuZXdSb29tSWQ7XG59XG4iXX0=