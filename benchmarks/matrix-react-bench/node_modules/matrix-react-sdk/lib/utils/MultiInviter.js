"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.InviteState = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _httpApi = require("matrix-js-sdk/src/http-api");

var _utils = require("matrix-js-sdk/src/utils");

var _MatrixClientPeg = require("../MatrixClientPeg");

var _UserAddress = require("../UserAddress");

var _GroupStore = _interopRequireDefault(require("../stores/GroupStore"));

var _languageHandler = require("../languageHandler");

var _Modal = _interopRequireDefault(require("../Modal"));

var _SettingsStore = _interopRequireDefault(require("../settings/SettingsStore"));

var _AskInviteAnywayDialog = _interopRequireDefault(require("../components/views/dialogs/AskInviteAnywayDialog"));

var _logger = require("matrix-js-sdk/src/logger");

/*
Copyright 2016 - 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
let InviteState;
exports.InviteState = InviteState;

(function (InviteState) {
  InviteState["Invited"] = "invited";
  InviteState["Error"] = "error";
})(InviteState || (exports.InviteState = InviteState = {}));

const UNKNOWN_PROFILE_ERRORS = ['M_NOT_FOUND', 'M_USER_NOT_FOUND', 'M_PROFILE_UNDISCLOSED', 'M_PROFILE_NOT_FOUND'];
const USER_ALREADY_JOINED = "IO.ELEMENT.ALREADY_JOINED";
const USER_ALREADY_INVITED = "IO.ELEMENT.ALREADY_INVITED";
/**
 * Invites multiple addresses to a room or group, handling rate limiting from the server
 */

class MultiInviter {
  // State of each address (invited or error)
  // { address: {errorText, errcode} }

  /**
   * @param {string} targetId The ID of the room or group to invite to
   * @param {function} progressCallback optional callback, fired after each invite.
   */
  constructor(targetId, progressCallback) {
    this.progressCallback = progressCallback;
    (0, _defineProperty2.default)(this, "roomId", void 0);
    (0, _defineProperty2.default)(this, "groupId", void 0);
    (0, _defineProperty2.default)(this, "canceled", false);
    (0, _defineProperty2.default)(this, "addresses", []);
    (0, _defineProperty2.default)(this, "busy", false);
    (0, _defineProperty2.default)(this, "_fatal", false);
    (0, _defineProperty2.default)(this, "completionStates", {});
    (0, _defineProperty2.default)(this, "errors", {});
    (0, _defineProperty2.default)(this, "deferred", null);
    (0, _defineProperty2.default)(this, "reason", null);

    if (targetId[0] === '+') {
      this.roomId = null;
      this.groupId = targetId;
    } else {
      this.roomId = targetId;
      this.groupId = null;
    }
  }

  get fatal() {
    return this._fatal;
  }
  /**
   * Invite users to this room. This may only be called once per
   * instance of the class.
   *
   * @param {array} addresses Array of addresses to invite
   * @param {string} reason Reason for inviting (optional)
   * @returns {Promise} Resolved when all invitations in the queue are complete
   */


  invite(addresses, reason) {
    if (this.addresses.length > 0) {
      throw new Error("Already inviting/invited");
    }

    this.addresses.push(...addresses);
    this.reason = reason;

    for (const addr of this.addresses) {
      if ((0, _UserAddress.getAddressType)(addr) === null) {
        this.completionStates[addr] = InviteState.Error;
        this.errors[addr] = {
          errcode: 'M_INVALID',
          errorText: (0, _languageHandler._t)('Unrecognised address')
        };
      }
    }

    this.deferred = (0, _utils.defer)();
    this.inviteMore(0);
    return this.deferred.promise;
  }
  /**
   * Stops inviting. Causes promises returned by invite() to be rejected.
   */


  cancel() {
    if (!this.busy) return;
    this.canceled = true;
    this.deferred.reject(new Error('canceled'));
  }

  getCompletionState(addr) {
    return this.completionStates[addr];
  }

  getErrorText(addr) {
    return this.errors[addr] ? this.errors[addr].errorText : null;
  }

  async inviteToRoom(roomId, addr, ignoreProfile = false) {
    const addrType = (0, _UserAddress.getAddressType)(addr);

    if (addrType === _UserAddress.AddressType.Email) {
      return _MatrixClientPeg.MatrixClientPeg.get().inviteByEmail(roomId, addr);
    } else if (addrType === _UserAddress.AddressType.MatrixUserId) {
      const room = _MatrixClientPeg.MatrixClientPeg.get().getRoom(roomId);

      if (!room) throw new Error("Room not found");
      const member = room.getMember(addr);

      if ((member === null || member === void 0 ? void 0 : member.membership) === "join") {
        throw new _httpApi.MatrixError({
          errcode: USER_ALREADY_JOINED,
          error: "Member already joined"
        });
      } else if ((member === null || member === void 0 ? void 0 : member.membership) === "invite") {
        throw new _httpApi.MatrixError({
          errcode: USER_ALREADY_INVITED,
          error: "Member already invited"
        });
      }

      if (!ignoreProfile && _SettingsStore.default.getValue("promptBeforeInviteUnknownUsers", this.roomId)) {
        const profile = await _MatrixClientPeg.MatrixClientPeg.get().getProfileInfo(addr);

        if (!profile) {
          // noinspection ExceptionCaughtLocallyJS
          throw new Error("User has no profile");
        }
      }

      return _MatrixClientPeg.MatrixClientPeg.get().invite(roomId, addr, undefined, this.reason);
    } else {
      throw new Error('Unsupported address');
    }
  }

  doInvite(address, ignoreProfile = false) {
    return new Promise((resolve, reject) => {
      _logger.logger.log(`Inviting ${address}`);

      let doInvite;

      if (this.groupId !== null) {
        doInvite = _GroupStore.default.inviteUserToGroup(this.groupId, address);
      } else {
        doInvite = this.inviteToRoom(this.roomId, address, ignoreProfile);
      }

      doInvite.then(() => {
        var _this$progressCallbac;

        if (this.canceled) {
          return;
        }

        this.completionStates[address] = InviteState.Invited;
        delete this.errors[address];
        resolve();
        (_this$progressCallbac = this.progressCallback) === null || _this$progressCallbac === void 0 ? void 0 : _this$progressCallbac.call(this);
      }).catch(err => {
        if (this.canceled) {
          return;
        }

        _logger.logger.error(err);

        let errorText;
        let fatal = false;

        switch (err.errcode) {
          case "M_FORBIDDEN":
            errorText = (0, _languageHandler._t)('You do not have permission to invite people to this room.');
            fatal = true;
            break;

          case USER_ALREADY_INVITED:
            errorText = (0, _languageHandler._t)("User %(userId)s is already invited to the room", {
              userId: address
            });
            break;

          case USER_ALREADY_JOINED:
            errorText = (0, _languageHandler._t)("User %(userId)s is already in the room", {
              userId: address
            });
            break;

          case "M_LIMIT_EXCEEDED":
            // we're being throttled so wait a bit & try again
            setTimeout(() => {
              this.doInvite(address, ignoreProfile).then(resolve, reject);
            }, 5000);
            return;

          case "M_NOT_FOUND":
          case "M_USER_NOT_FOUND":
            errorText = (0, _languageHandler._t)("User %(user_id)s does not exist", {
              user_id: address
            });
            break;

          case "M_PROFILE_UNDISCLOSED":
            errorText = (0, _languageHandler._t)("User %(user_id)s may or may not exist", {
              user_id: address
            });
            break;

          case "M_PROFILE_NOT_FOUND":
            if (!ignoreProfile) {
              // Invite without the profile check
              _logger.logger.warn(`User ${address} does not have a profile - inviting anyways automatically`);

              this.doInvite(address, true).then(resolve, reject);
              return;
            }

            break;

          case "M_BAD_STATE":
            errorText = (0, _languageHandler._t)("The user must be unbanned before they can be invited.");
            break;

          case "M_UNSUPPORTED_ROOM_VERSION":
            errorText = (0, _languageHandler._t)("The user's homeserver does not support the version of the room.");
            break;
        }

        if (!errorText) {
          errorText = (0, _languageHandler._t)('Unknown server error');
        }

        this.completionStates[address] = InviteState.Error;
        this.errors[address] = {
          errorText,
          errcode: err.errcode
        };
        this.busy = !fatal;
        this._fatal = fatal;

        if (fatal) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }

  inviteMore(nextIndex, ignoreProfile = false) {
    if (this.canceled) {
      return;
    }

    if (nextIndex === this.addresses.length) {
      this.busy = false;

      if (Object.keys(this.errors).length > 0 && !this.groupId) {
        // There were problems inviting some people - see if we can invite them
        // without caring if they exist or not.
        const unknownProfileUsers = Object.keys(this.errors).filter(a => UNKNOWN_PROFILE_ERRORS.includes(this.errors[a].errcode));

        if (unknownProfileUsers.length > 0) {
          const inviteUnknowns = () => {
            const promises = unknownProfileUsers.map(u => this.doInvite(u, true));
            Promise.all(promises).then(() => this.deferred.resolve(this.completionStates));
          };

          if (!_SettingsStore.default.getValue("promptBeforeInviteUnknownUsers", this.roomId)) {
            inviteUnknowns();
            return;
          }

          _logger.logger.log("Showing failed to invite dialog...");

          _Modal.default.createTrackedDialog('Failed to invite', '', _AskInviteAnywayDialog.default, {
            unknownProfileUsers: unknownProfileUsers.map(u => ({
              userId: u,
              errorText: this.errors[u].errorText
            })),
            onInviteAnyways: () => inviteUnknowns(),
            onGiveUp: () => {
              // Fake all the completion states because we already warned the user
              for (const addr of unknownProfileUsers) {
                this.completionStates[addr] = InviteState.Invited;
              }

              this.deferred.resolve(this.completionStates);
            }
          });

          return;
        }
      }

      this.deferred.resolve(this.completionStates);
      return;
    }

    const addr = this.addresses[nextIndex]; // don't try to invite it if it's an invalid address
    // (it will already be marked as an error though,
    // so no need to do so again)

    if ((0, _UserAddress.getAddressType)(addr) === null) {
      this.inviteMore(nextIndex + 1);
      return;
    } // don't re-invite (there's no way in the UI to do this, but
    // for sanity's sake)


    if (this.completionStates[addr] === InviteState.Invited) {
      this.inviteMore(nextIndex + 1);
      return;
    }

    this.doInvite(addr, ignoreProfile).then(() => {
      this.inviteMore(nextIndex + 1, ignoreProfile);
    }).catch(() => this.deferred.resolve(this.completionStates));
  }

}

exports.default = MultiInviter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9NdWx0aUludml0ZXIudHMiXSwibmFtZXMiOlsiSW52aXRlU3RhdGUiLCJVTktOT1dOX1BST0ZJTEVfRVJST1JTIiwiVVNFUl9BTFJFQURZX0pPSU5FRCIsIlVTRVJfQUxSRUFEWV9JTlZJVEVEIiwiTXVsdGlJbnZpdGVyIiwiY29uc3RydWN0b3IiLCJ0YXJnZXRJZCIsInByb2dyZXNzQ2FsbGJhY2siLCJyb29tSWQiLCJncm91cElkIiwiZmF0YWwiLCJfZmF0YWwiLCJpbnZpdGUiLCJhZGRyZXNzZXMiLCJyZWFzb24iLCJsZW5ndGgiLCJFcnJvciIsInB1c2giLCJhZGRyIiwiY29tcGxldGlvblN0YXRlcyIsImVycm9ycyIsImVycmNvZGUiLCJlcnJvclRleHQiLCJkZWZlcnJlZCIsImludml0ZU1vcmUiLCJwcm9taXNlIiwiY2FuY2VsIiwiYnVzeSIsImNhbmNlbGVkIiwicmVqZWN0IiwiZ2V0Q29tcGxldGlvblN0YXRlIiwiZ2V0RXJyb3JUZXh0IiwiaW52aXRlVG9Sb29tIiwiaWdub3JlUHJvZmlsZSIsImFkZHJUeXBlIiwiQWRkcmVzc1R5cGUiLCJFbWFpbCIsIk1hdHJpeENsaWVudFBlZyIsImdldCIsImludml0ZUJ5RW1haWwiLCJNYXRyaXhVc2VySWQiLCJyb29tIiwiZ2V0Um9vbSIsIm1lbWJlciIsImdldE1lbWJlciIsIm1lbWJlcnNoaXAiLCJNYXRyaXhFcnJvciIsImVycm9yIiwiU2V0dGluZ3NTdG9yZSIsImdldFZhbHVlIiwicHJvZmlsZSIsImdldFByb2ZpbGVJbmZvIiwidW5kZWZpbmVkIiwiZG9JbnZpdGUiLCJhZGRyZXNzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJsb2dnZXIiLCJsb2ciLCJHcm91cFN0b3JlIiwiaW52aXRlVXNlclRvR3JvdXAiLCJ0aGVuIiwiSW52aXRlZCIsImNhdGNoIiwiZXJyIiwidXNlcklkIiwic2V0VGltZW91dCIsInVzZXJfaWQiLCJ3YXJuIiwibmV4dEluZGV4IiwiT2JqZWN0Iiwia2V5cyIsInVua25vd25Qcm9maWxlVXNlcnMiLCJmaWx0ZXIiLCJhIiwiaW5jbHVkZXMiLCJpbnZpdGVVbmtub3ducyIsInByb21pc2VzIiwibWFwIiwidSIsImFsbCIsIk1vZGFsIiwiY3JlYXRlVHJhY2tlZERpYWxvZyIsIkFza0ludml0ZUFueXdheURpYWxvZyIsIm9uSW52aXRlQW55d2F5cyIsIm9uR2l2ZVVwIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWdCQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUEzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0lBZVlBLFc7OztXQUFBQSxXO0FBQUFBLEVBQUFBLFc7QUFBQUEsRUFBQUEsVztHQUFBQSxXLDJCQUFBQSxXOztBQVVaLE1BQU1DLHNCQUFzQixHQUFHLENBQUMsYUFBRCxFQUFnQixrQkFBaEIsRUFBb0MsdUJBQXBDLEVBQTZELHFCQUE3RCxDQUEvQjtBQUlBLE1BQU1DLG1CQUFtQixHQUFHLDJCQUE1QjtBQUNBLE1BQU1DLG9CQUFvQixHQUFHLDRCQUE3QjtBQUVBO0FBQ0E7QUFDQTs7QUFDZSxNQUFNQyxZQUFOLENBQW1CO0FBUW1CO0FBQ0o7O0FBSTdDO0FBQ0o7QUFDQTtBQUNBO0FBQ0lDLEVBQUFBLFdBQVcsQ0FBQ0MsUUFBRCxFQUFvQ0MsZ0JBQXBDLEVBQW1FO0FBQUEsU0FBL0JBLGdCQUErQixHQUEvQkEsZ0JBQStCO0FBQUE7QUFBQTtBQUFBLG9EQWIzRCxLQWEyRDtBQUFBLHFEQVpoRCxFQVlnRDtBQUFBLGdEQVgvRCxLQVcrRDtBQUFBLGtEQVY3RCxLQVU2RDtBQUFBLDREQVRqQyxFQVNpQztBQUFBLGtEQVJyQyxFQVFxQztBQUFBLG9EQVA5QixJQU84QjtBQUFBLGtEQU5yRCxJQU1xRDs7QUFDMUUsUUFBSUQsUUFBUSxDQUFDLENBQUQsQ0FBUixLQUFnQixHQUFwQixFQUF5QjtBQUNyQixXQUFLRSxNQUFMLEdBQWMsSUFBZDtBQUNBLFdBQUtDLE9BQUwsR0FBZUgsUUFBZjtBQUNILEtBSEQsTUFHTztBQUNILFdBQUtFLE1BQUwsR0FBY0YsUUFBZDtBQUNBLFdBQUtHLE9BQUwsR0FBZSxJQUFmO0FBQ0g7QUFDSjs7QUFFZSxNQUFMQyxLQUFLLEdBQUc7QUFDZixXQUFPLEtBQUtDLE1BQVo7QUFDSDtBQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNXQyxFQUFBQSxNQUFNLENBQUNDLFNBQUQsRUFBWUMsTUFBWixFQUF3RDtBQUNqRSxRQUFJLEtBQUtELFNBQUwsQ0FBZUUsTUFBZixHQUF3QixDQUE1QixFQUErQjtBQUMzQixZQUFNLElBQUlDLEtBQUosQ0FBVSwwQkFBVixDQUFOO0FBQ0g7O0FBQ0QsU0FBS0gsU0FBTCxDQUFlSSxJQUFmLENBQW9CLEdBQUdKLFNBQXZCO0FBQ0EsU0FBS0MsTUFBTCxHQUFjQSxNQUFkOztBQUVBLFNBQUssTUFBTUksSUFBWCxJQUFtQixLQUFLTCxTQUF4QixFQUFtQztBQUMvQixVQUFJLGlDQUFlSyxJQUFmLE1BQXlCLElBQTdCLEVBQW1DO0FBQy9CLGFBQUtDLGdCQUFMLENBQXNCRCxJQUF0QixJQUE4QmxCLFdBQVcsQ0FBQ2dCLEtBQTFDO0FBQ0EsYUFBS0ksTUFBTCxDQUFZRixJQUFaLElBQW9CO0FBQ2hCRyxVQUFBQSxPQUFPLEVBQUUsV0FETztBQUVoQkMsVUFBQUEsU0FBUyxFQUFFLHlCQUFHLHNCQUFIO0FBRkssU0FBcEI7QUFJSDtBQUNKOztBQUNELFNBQUtDLFFBQUwsR0FBZ0IsbUJBQWhCO0FBQ0EsU0FBS0MsVUFBTCxDQUFnQixDQUFoQjtBQUVBLFdBQU8sS0FBS0QsUUFBTCxDQUFjRSxPQUFyQjtBQUNIO0FBRUQ7QUFDSjtBQUNBOzs7QUFDV0MsRUFBQUEsTUFBTSxHQUFTO0FBQ2xCLFFBQUksQ0FBQyxLQUFLQyxJQUFWLEVBQWdCO0FBRWhCLFNBQUtDLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxTQUFLTCxRQUFMLENBQWNNLE1BQWQsQ0FBcUIsSUFBSWIsS0FBSixDQUFVLFVBQVYsQ0FBckI7QUFDSDs7QUFFTWMsRUFBQUEsa0JBQWtCLENBQUNaLElBQUQsRUFBNEI7QUFDakQsV0FBTyxLQUFLQyxnQkFBTCxDQUFzQkQsSUFBdEIsQ0FBUDtBQUNIOztBQUVNYSxFQUFBQSxZQUFZLENBQUNiLElBQUQsRUFBdUI7QUFDdEMsV0FBTyxLQUFLRSxNQUFMLENBQVlGLElBQVosSUFBb0IsS0FBS0UsTUFBTCxDQUFZRixJQUFaLEVBQWtCSSxTQUF0QyxHQUFrRCxJQUF6RDtBQUNIOztBQUV5QixRQUFaVSxZQUFZLENBQUN4QixNQUFELEVBQWlCVSxJQUFqQixFQUErQmUsYUFBYSxHQUFHLEtBQS9DLEVBQW1FO0FBQ3pGLFVBQU1DLFFBQVEsR0FBRyxpQ0FBZWhCLElBQWYsQ0FBakI7O0FBRUEsUUFBSWdCLFFBQVEsS0FBS0MseUJBQVlDLEtBQTdCLEVBQW9DO0FBQ2hDLGFBQU9DLGlDQUFnQkMsR0FBaEIsR0FBc0JDLGFBQXRCLENBQW9DL0IsTUFBcEMsRUFBNENVLElBQTVDLENBQVA7QUFDSCxLQUZELE1BRU8sSUFBSWdCLFFBQVEsS0FBS0MseUJBQVlLLFlBQTdCLEVBQTJDO0FBQzlDLFlBQU1DLElBQUksR0FBR0osaUNBQWdCQyxHQUFoQixHQUFzQkksT0FBdEIsQ0FBOEJsQyxNQUE5QixDQUFiOztBQUNBLFVBQUksQ0FBQ2lDLElBQUwsRUFBVyxNQUFNLElBQUl6QixLQUFKLENBQVUsZ0JBQVYsQ0FBTjtBQUVYLFlBQU0yQixNQUFNLEdBQUdGLElBQUksQ0FBQ0csU0FBTCxDQUFlMUIsSUFBZixDQUFmOztBQUNBLFVBQUksQ0FBQXlCLE1BQU0sU0FBTixJQUFBQSxNQUFNLFdBQU4sWUFBQUEsTUFBTSxDQUFFRSxVQUFSLE1BQXVCLE1BQTNCLEVBQW1DO0FBQy9CLGNBQU0sSUFBSUMsb0JBQUosQ0FBZ0I7QUFDbEJ6QixVQUFBQSxPQUFPLEVBQUVuQixtQkFEUztBQUVsQjZDLFVBQUFBLEtBQUssRUFBRTtBQUZXLFNBQWhCLENBQU47QUFJSCxPQUxELE1BS08sSUFBSSxDQUFBSixNQUFNLFNBQU4sSUFBQUEsTUFBTSxXQUFOLFlBQUFBLE1BQU0sQ0FBRUUsVUFBUixNQUF1QixRQUEzQixFQUFxQztBQUN4QyxjQUFNLElBQUlDLG9CQUFKLENBQWdCO0FBQ2xCekIsVUFBQUEsT0FBTyxFQUFFbEIsb0JBRFM7QUFFbEI0QyxVQUFBQSxLQUFLLEVBQUU7QUFGVyxTQUFoQixDQUFOO0FBSUg7O0FBRUQsVUFBSSxDQUFDZCxhQUFELElBQWtCZSx1QkFBY0MsUUFBZCxDQUF1QixnQ0FBdkIsRUFBeUQsS0FBS3pDLE1BQTlELENBQXRCLEVBQTZGO0FBQ3pGLGNBQU0wQyxPQUFPLEdBQUcsTUFBTWIsaUNBQWdCQyxHQUFoQixHQUFzQmEsY0FBdEIsQ0FBcUNqQyxJQUFyQyxDQUF0Qjs7QUFDQSxZQUFJLENBQUNnQyxPQUFMLEVBQWM7QUFDVjtBQUNBLGdCQUFNLElBQUlsQyxLQUFKLENBQVUscUJBQVYsQ0FBTjtBQUNIO0FBQ0o7O0FBRUQsYUFBT3FCLGlDQUFnQkMsR0FBaEIsR0FBc0IxQixNQUF0QixDQUE2QkosTUFBN0IsRUFBcUNVLElBQXJDLEVBQTJDa0MsU0FBM0MsRUFBc0QsS0FBS3RDLE1BQTNELENBQVA7QUFDSCxLQTFCTSxNQTBCQTtBQUNILFlBQU0sSUFBSUUsS0FBSixDQUFVLHFCQUFWLENBQU47QUFDSDtBQUNKOztBQUVPcUMsRUFBQUEsUUFBUSxDQUFDQyxPQUFELEVBQWtCckIsYUFBYSxHQUFHLEtBQWxDLEVBQXdEO0FBQ3BFLFdBQU8sSUFBSXNCLE9BQUosQ0FBa0IsQ0FBQ0MsT0FBRCxFQUFVM0IsTUFBVixLQUFxQjtBQUMxQzRCLHFCQUFPQyxHQUFQLENBQVksWUFBV0osT0FBUSxFQUEvQjs7QUFFQSxVQUFJRCxRQUFKOztBQUNBLFVBQUksS0FBSzVDLE9BQUwsS0FBaUIsSUFBckIsRUFBMkI7QUFDdkI0QyxRQUFBQSxRQUFRLEdBQUdNLG9CQUFXQyxpQkFBWCxDQUE2QixLQUFLbkQsT0FBbEMsRUFBMkM2QyxPQUEzQyxDQUFYO0FBQ0gsT0FGRCxNQUVPO0FBQ0hELFFBQUFBLFFBQVEsR0FBRyxLQUFLckIsWUFBTCxDQUFrQixLQUFLeEIsTUFBdkIsRUFBK0I4QyxPQUEvQixFQUF3Q3JCLGFBQXhDLENBQVg7QUFDSDs7QUFFRG9CLE1BQUFBLFFBQVEsQ0FBQ1EsSUFBVCxDQUFjLE1BQU07QUFBQTs7QUFDaEIsWUFBSSxLQUFLakMsUUFBVCxFQUFtQjtBQUNmO0FBQ0g7O0FBRUQsYUFBS1QsZ0JBQUwsQ0FBc0JtQyxPQUF0QixJQUFpQ3RELFdBQVcsQ0FBQzhELE9BQTdDO0FBQ0EsZUFBTyxLQUFLMUMsTUFBTCxDQUFZa0MsT0FBWixDQUFQO0FBRUFFLFFBQUFBLE9BQU87QUFDUCxzQ0FBS2pELGdCQUFMO0FBQ0gsT0FWRCxFQVVHd0QsS0FWSCxDQVVVQyxHQUFELElBQVM7QUFDZCxZQUFJLEtBQUtwQyxRQUFULEVBQW1CO0FBQ2Y7QUFDSDs7QUFFRDZCLHVCQUFPVixLQUFQLENBQWFpQixHQUFiOztBQUVBLFlBQUkxQyxTQUFKO0FBQ0EsWUFBSVosS0FBSyxHQUFHLEtBQVo7O0FBQ0EsZ0JBQVFzRCxHQUFHLENBQUMzQyxPQUFaO0FBQ0ksZUFBSyxhQUFMO0FBQ0lDLFlBQUFBLFNBQVMsR0FBRyx5QkFBRywyREFBSCxDQUFaO0FBQ0FaLFlBQUFBLEtBQUssR0FBRyxJQUFSO0FBQ0E7O0FBQ0osZUFBS1Asb0JBQUw7QUFDSW1CLFlBQUFBLFNBQVMsR0FBRyx5QkFBRyxnREFBSCxFQUFxRDtBQUFFMkMsY0FBQUEsTUFBTSxFQUFFWDtBQUFWLGFBQXJELENBQVo7QUFDQTs7QUFDSixlQUFLcEQsbUJBQUw7QUFDSW9CLFlBQUFBLFNBQVMsR0FBRyx5QkFBRyx3Q0FBSCxFQUE2QztBQUFFMkMsY0FBQUEsTUFBTSxFQUFFWDtBQUFWLGFBQTdDLENBQVo7QUFDQTs7QUFDSixlQUFLLGtCQUFMO0FBQ0k7QUFDQVksWUFBQUEsVUFBVSxDQUFDLE1BQU07QUFDYixtQkFBS2IsUUFBTCxDQUFjQyxPQUFkLEVBQXVCckIsYUFBdkIsRUFBc0M0QixJQUF0QyxDQUEyQ0wsT0FBM0MsRUFBb0QzQixNQUFwRDtBQUNILGFBRlMsRUFFUCxJQUZPLENBQVY7QUFHQTs7QUFDSixlQUFLLGFBQUw7QUFDQSxlQUFLLGtCQUFMO0FBQ0lQLFlBQUFBLFNBQVMsR0FBRyx5QkFBRyxpQ0FBSCxFQUFzQztBQUFFNkMsY0FBQUEsT0FBTyxFQUFFYjtBQUFYLGFBQXRDLENBQVo7QUFDQTs7QUFDSixlQUFLLHVCQUFMO0FBQ0loQyxZQUFBQSxTQUFTLEdBQUcseUJBQUcsdUNBQUgsRUFBNEM7QUFBRTZDLGNBQUFBLE9BQU8sRUFBRWI7QUFBWCxhQUE1QyxDQUFaO0FBQ0E7O0FBQ0osZUFBSyxxQkFBTDtBQUNJLGdCQUFJLENBQUNyQixhQUFMLEVBQW9CO0FBQ2hCO0FBQ0F3Qiw2QkFBT1csSUFBUCxDQUFhLFFBQU9kLE9BQVEsMkRBQTVCOztBQUNBLG1CQUFLRCxRQUFMLENBQWNDLE9BQWQsRUFBdUIsSUFBdkIsRUFBNkJPLElBQTdCLENBQWtDTCxPQUFsQyxFQUEyQzNCLE1BQTNDO0FBQ0E7QUFDSDs7QUFDRDs7QUFDSixlQUFLLGFBQUw7QUFDSVAsWUFBQUEsU0FBUyxHQUFHLHlCQUFHLHVEQUFILENBQVo7QUFDQTs7QUFDSixlQUFLLDRCQUFMO0FBQ0lBLFlBQUFBLFNBQVMsR0FBRyx5QkFBRyxpRUFBSCxDQUFaO0FBQ0E7QUFyQ1I7O0FBd0NBLFlBQUksQ0FBQ0EsU0FBTCxFQUFnQjtBQUNaQSxVQUFBQSxTQUFTLEdBQUcseUJBQUcsc0JBQUgsQ0FBWjtBQUNIOztBQUVELGFBQUtILGdCQUFMLENBQXNCbUMsT0FBdEIsSUFBaUN0RCxXQUFXLENBQUNnQixLQUE3QztBQUNBLGFBQUtJLE1BQUwsQ0FBWWtDLE9BQVosSUFBdUI7QUFBRWhDLFVBQUFBLFNBQUY7QUFBYUQsVUFBQUEsT0FBTyxFQUFFMkMsR0FBRyxDQUFDM0M7QUFBMUIsU0FBdkI7QUFFQSxhQUFLTSxJQUFMLEdBQVksQ0FBQ2pCLEtBQWI7QUFDQSxhQUFLQyxNQUFMLEdBQWNELEtBQWQ7O0FBRUEsWUFBSUEsS0FBSixFQUFXO0FBQ1BtQixVQUFBQSxNQUFNLENBQUNtQyxHQUFELENBQU47QUFDSCxTQUZELE1BRU87QUFDSFIsVUFBQUEsT0FBTztBQUNWO0FBQ0osT0ExRUQ7QUEyRUgsS0FyRk0sQ0FBUDtBQXNGSDs7QUFFT2hDLEVBQUFBLFVBQVUsQ0FBQzZDLFNBQUQsRUFBb0JwQyxhQUFhLEdBQUcsS0FBcEMsRUFBaUQ7QUFDL0QsUUFBSSxLQUFLTCxRQUFULEVBQW1CO0FBQ2Y7QUFDSDs7QUFFRCxRQUFJeUMsU0FBUyxLQUFLLEtBQUt4RCxTQUFMLENBQWVFLE1BQWpDLEVBQXlDO0FBQ3JDLFdBQUtZLElBQUwsR0FBWSxLQUFaOztBQUNBLFVBQUkyQyxNQUFNLENBQUNDLElBQVAsQ0FBWSxLQUFLbkQsTUFBakIsRUFBeUJMLE1BQXpCLEdBQWtDLENBQWxDLElBQXVDLENBQUMsS0FBS04sT0FBakQsRUFBMEQ7QUFDdEQ7QUFDQTtBQUNBLGNBQU0rRCxtQkFBbUIsR0FBR0YsTUFBTSxDQUFDQyxJQUFQLENBQVksS0FBS25ELE1BQWpCLEVBQ3ZCcUQsTUFEdUIsQ0FDaEJDLENBQUMsSUFBSXpFLHNCQUFzQixDQUFDMEUsUUFBdkIsQ0FBZ0MsS0FBS3ZELE1BQUwsQ0FBWXNELENBQVosRUFBZXJELE9BQS9DLENBRFcsQ0FBNUI7O0FBR0EsWUFBSW1ELG1CQUFtQixDQUFDekQsTUFBcEIsR0FBNkIsQ0FBakMsRUFBb0M7QUFDaEMsZ0JBQU02RCxjQUFjLEdBQUcsTUFBTTtBQUN6QixrQkFBTUMsUUFBUSxHQUFHTCxtQkFBbUIsQ0FBQ00sR0FBcEIsQ0FBd0JDLENBQUMsSUFBSSxLQUFLMUIsUUFBTCxDQUFjMEIsQ0FBZCxFQUFpQixJQUFqQixDQUE3QixDQUFqQjtBQUNBeEIsWUFBQUEsT0FBTyxDQUFDeUIsR0FBUixDQUFZSCxRQUFaLEVBQXNCaEIsSUFBdEIsQ0FBMkIsTUFBTSxLQUFLdEMsUUFBTCxDQUFjaUMsT0FBZCxDQUFzQixLQUFLckMsZ0JBQTNCLENBQWpDO0FBQ0gsV0FIRDs7QUFLQSxjQUFJLENBQUM2Qix1QkFBY0MsUUFBZCxDQUF1QixnQ0FBdkIsRUFBeUQsS0FBS3pDLE1BQTlELENBQUwsRUFBNEU7QUFDeEVvRSxZQUFBQSxjQUFjO0FBQ2Q7QUFDSDs7QUFFRG5CLHlCQUFPQyxHQUFQLENBQVcsb0NBQVg7O0FBQ0F1Qix5QkFBTUMsbUJBQU4sQ0FBMEIsa0JBQTFCLEVBQThDLEVBQTlDLEVBQWtEQyw4QkFBbEQsRUFBeUU7QUFDckVYLFlBQUFBLG1CQUFtQixFQUFFQSxtQkFBbUIsQ0FBQ00sR0FBcEIsQ0FBd0JDLENBQUMsS0FBSztBQUMvQ2QsY0FBQUEsTUFBTSxFQUFFYyxDQUR1QztBQUUvQ3pELGNBQUFBLFNBQVMsRUFBRSxLQUFLRixNQUFMLENBQVkyRCxDQUFaLEVBQWV6RDtBQUZxQixhQUFMLENBQXpCLENBRGdEO0FBS3JFOEQsWUFBQUEsZUFBZSxFQUFFLE1BQU1SLGNBQWMsRUFMZ0M7QUFNckVTLFlBQUFBLFFBQVEsRUFBRSxNQUFNO0FBQ1o7QUFDQSxtQkFBSyxNQUFNbkUsSUFBWCxJQUFtQnNELG1CQUFuQixFQUF3QztBQUNwQyxxQkFBS3JELGdCQUFMLENBQXNCRCxJQUF0QixJQUE4QmxCLFdBQVcsQ0FBQzhELE9BQTFDO0FBQ0g7O0FBQ0QsbUJBQUt2QyxRQUFMLENBQWNpQyxPQUFkLENBQXNCLEtBQUtyQyxnQkFBM0I7QUFDSDtBQVpvRSxXQUF6RTs7QUFjQTtBQUNIO0FBQ0o7O0FBQ0QsV0FBS0ksUUFBTCxDQUFjaUMsT0FBZCxDQUFzQixLQUFLckMsZ0JBQTNCO0FBQ0E7QUFDSDs7QUFFRCxVQUFNRCxJQUFJLEdBQUcsS0FBS0wsU0FBTCxDQUFld0QsU0FBZixDQUFiLENBOUMrRCxDQWdEL0Q7QUFDQTtBQUNBOztBQUNBLFFBQUksaUNBQWVuRCxJQUFmLE1BQXlCLElBQTdCLEVBQW1DO0FBQy9CLFdBQUtNLFVBQUwsQ0FBZ0I2QyxTQUFTLEdBQUcsQ0FBNUI7QUFDQTtBQUNILEtBdEQ4RCxDQXdEL0Q7QUFDQTs7O0FBQ0EsUUFBSSxLQUFLbEQsZ0JBQUwsQ0FBc0JELElBQXRCLE1BQWdDbEIsV0FBVyxDQUFDOEQsT0FBaEQsRUFBeUQ7QUFDckQsV0FBS3RDLFVBQUwsQ0FBZ0I2QyxTQUFTLEdBQUcsQ0FBNUI7QUFDQTtBQUNIOztBQUVELFNBQUtoQixRQUFMLENBQWNuQyxJQUFkLEVBQW9CZSxhQUFwQixFQUFtQzRCLElBQW5DLENBQXdDLE1BQU07QUFDMUMsV0FBS3JDLFVBQUwsQ0FBZ0I2QyxTQUFTLEdBQUcsQ0FBNUIsRUFBK0JwQyxhQUEvQjtBQUNILEtBRkQsRUFFRzhCLEtBRkgsQ0FFUyxNQUFNLEtBQUt4QyxRQUFMLENBQWNpQyxPQUFkLENBQXNCLEtBQUtyQyxnQkFBM0IsQ0FGZjtBQUdIOztBQTlRNkIiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMTYgLSAyMDIxIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IHsgTWF0cml4RXJyb3IgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvaHR0cC1hcGlcIjtcbmltcG9ydCB7IGRlZmVyLCBJRGVmZXJyZWQgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvdXRpbHNcIjtcblxuaW1wb3J0IHsgTWF0cml4Q2xpZW50UGVnIH0gZnJvbSAnLi4vTWF0cml4Q2xpZW50UGVnJztcbmltcG9ydCB7IEFkZHJlc3NUeXBlLCBnZXRBZGRyZXNzVHlwZSB9IGZyb20gJy4uL1VzZXJBZGRyZXNzJztcbmltcG9ydCBHcm91cFN0b3JlIGZyb20gJy4uL3N0b3Jlcy9Hcm91cFN0b3JlJztcbmltcG9ydCB7IF90IH0gZnJvbSBcIi4uL2xhbmd1YWdlSGFuZGxlclwiO1xuaW1wb3J0IE1vZGFsIGZyb20gXCIuLi9Nb2RhbFwiO1xuaW1wb3J0IFNldHRpbmdzU3RvcmUgZnJvbSBcIi4uL3NldHRpbmdzL1NldHRpbmdzU3RvcmVcIjtcbmltcG9ydCBBc2tJbnZpdGVBbnl3YXlEaWFsb2cgZnJvbSBcIi4uL2NvbXBvbmVudHMvdmlld3MvZGlhbG9ncy9Bc2tJbnZpdGVBbnl3YXlEaWFsb2dcIjtcblxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL2xvZ2dlclwiO1xuXG5leHBvcnQgZW51bSBJbnZpdGVTdGF0ZSB7XG4gICAgSW52aXRlZCA9IFwiaW52aXRlZFwiLFxuICAgIEVycm9yID0gXCJlcnJvclwiLFxufVxuXG5pbnRlcmZhY2UgSUVycm9yIHtcbiAgICBlcnJvclRleHQ6IHN0cmluZztcbiAgICBlcnJjb2RlOiBzdHJpbmc7XG59XG5cbmNvbnN0IFVOS05PV05fUFJPRklMRV9FUlJPUlMgPSBbJ01fTk9UX0ZPVU5EJywgJ01fVVNFUl9OT1RfRk9VTkQnLCAnTV9QUk9GSUxFX1VORElTQ0xPU0VEJywgJ01fUFJPRklMRV9OT1RfRk9VTkQnXTtcblxuZXhwb3J0IHR5cGUgQ29tcGxldGlvblN0YXRlcyA9IFJlY29yZDxzdHJpbmcsIEludml0ZVN0YXRlPjtcblxuY29uc3QgVVNFUl9BTFJFQURZX0pPSU5FRCA9IFwiSU8uRUxFTUVOVC5BTFJFQURZX0pPSU5FRFwiO1xuY29uc3QgVVNFUl9BTFJFQURZX0lOVklURUQgPSBcIklPLkVMRU1FTlQuQUxSRUFEWV9JTlZJVEVEXCI7XG5cbi8qKlxuICogSW52aXRlcyBtdWx0aXBsZSBhZGRyZXNzZXMgdG8gYSByb29tIG9yIGdyb3VwLCBoYW5kbGluZyByYXRlIGxpbWl0aW5nIGZyb20gdGhlIHNlcnZlclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNdWx0aUludml0ZXIge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgcm9vbUlkPzogc3RyaW5nO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgZ3JvdXBJZD86IHN0cmluZztcblxuICAgIHByaXZhdGUgY2FuY2VsZWQgPSBmYWxzZTtcbiAgICBwcml2YXRlIGFkZHJlc3Nlczogc3RyaW5nW10gPSBbXTtcbiAgICBwcml2YXRlIGJ1c3kgPSBmYWxzZTtcbiAgICBwcml2YXRlIF9mYXRhbCA9IGZhbHNlO1xuICAgIHByaXZhdGUgY29tcGxldGlvblN0YXRlczogQ29tcGxldGlvblN0YXRlcyA9IHt9OyAvLyBTdGF0ZSBvZiBlYWNoIGFkZHJlc3MgKGludml0ZWQgb3IgZXJyb3IpXG4gICAgcHJpdmF0ZSBlcnJvcnM6IFJlY29yZDxzdHJpbmcsIElFcnJvcj4gPSB7fTsgLy8geyBhZGRyZXNzOiB7ZXJyb3JUZXh0LCBlcnJjb2RlfSB9XG4gICAgcHJpdmF0ZSBkZWZlcnJlZDogSURlZmVycmVkPENvbXBsZXRpb25TdGF0ZXM+ID0gbnVsbDtcbiAgICBwcml2YXRlIHJlYXNvbjogc3RyaW5nID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRJZCBUaGUgSUQgb2YgdGhlIHJvb20gb3IgZ3JvdXAgdG8gaW52aXRlIHRvXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gcHJvZ3Jlc3NDYWxsYmFjayBvcHRpb25hbCBjYWxsYmFjaywgZmlyZWQgYWZ0ZXIgZWFjaCBpbnZpdGUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFyZ2V0SWQ6IHN0cmluZywgcHJpdmF0ZSByZWFkb25seSBwcm9ncmVzc0NhbGxiYWNrPzogKCkgPT4gdm9pZCkge1xuICAgICAgICBpZiAodGFyZ2V0SWRbMF0gPT09ICcrJykge1xuICAgICAgICAgICAgdGhpcy5yb29tSWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5ncm91cElkID0gdGFyZ2V0SWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJvb21JZCA9IHRhcmdldElkO1xuICAgICAgICAgICAgdGhpcy5ncm91cElkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgZmF0YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mYXRhbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZpdGUgdXNlcnMgdG8gdGhpcyByb29tLiBUaGlzIG1heSBvbmx5IGJlIGNhbGxlZCBvbmNlIHBlclxuICAgICAqIGluc3RhbmNlIG9mIHRoZSBjbGFzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGFkZHJlc3NlcyBBcnJheSBvZiBhZGRyZXNzZXMgdG8gaW52aXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiBSZWFzb24gZm9yIGludml0aW5nIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiBhbGwgaW52aXRhdGlvbnMgaW4gdGhlIHF1ZXVlIGFyZSBjb21wbGV0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBpbnZpdGUoYWRkcmVzc2VzLCByZWFzb24/OiBzdHJpbmcpOiBQcm9taXNlPENvbXBsZXRpb25TdGF0ZXM+IHtcbiAgICAgICAgaWYgKHRoaXMuYWRkcmVzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgaW52aXRpbmcvaW52aXRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZHJlc3Nlcy5wdXNoKC4uLmFkZHJlc3Nlcyk7XG4gICAgICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuXG4gICAgICAgIGZvciAoY29uc3QgYWRkciBvZiB0aGlzLmFkZHJlc3Nlcykge1xuICAgICAgICAgICAgaWYgKGdldEFkZHJlc3NUeXBlKGFkZHIpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0aW9uU3RhdGVzW2FkZHJdID0gSW52aXRlU3RhdGUuRXJyb3I7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnNbYWRkcl0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGVycmNvZGU6ICdNX0lOVkFMSUQnLFxuICAgICAgICAgICAgICAgICAgICBlcnJvclRleHQ6IF90KCdVbnJlY29nbmlzZWQgYWRkcmVzcycpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWZlcnJlZCA9IGRlZmVyPENvbXBsZXRpb25TdGF0ZXM+KCk7XG4gICAgICAgIHRoaXMuaW52aXRlTW9yZSgwKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5kZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3BzIGludml0aW5nLiBDYXVzZXMgcHJvbWlzZXMgcmV0dXJuZWQgYnkgaW52aXRlKCkgdG8gYmUgcmVqZWN0ZWQuXG4gICAgICovXG4gICAgcHVibGljIGNhbmNlbCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1c3kpIHJldHVybjtcblxuICAgICAgICB0aGlzLmNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kZWZlcnJlZC5yZWplY3QobmV3IEVycm9yKCdjYW5jZWxlZCcpKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0Q29tcGxldGlvblN0YXRlKGFkZHI6IHN0cmluZyk6IEludml0ZVN0YXRlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGlvblN0YXRlc1thZGRyXTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0RXJyb3JUZXh0KGFkZHI6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yc1thZGRyXSA/IHRoaXMuZXJyb3JzW2FkZHJdLmVycm9yVGV4dCA6IG51bGw7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBpbnZpdGVUb1Jvb20ocm9vbUlkOiBzdHJpbmcsIGFkZHI6IHN0cmluZywgaWdub3JlUHJvZmlsZSA9IGZhbHNlKTogUHJvbWlzZTx7fT4ge1xuICAgICAgICBjb25zdCBhZGRyVHlwZSA9IGdldEFkZHJlc3NUeXBlKGFkZHIpO1xuXG4gICAgICAgIGlmIChhZGRyVHlwZSA9PT0gQWRkcmVzc1R5cGUuRW1haWwpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRyaXhDbGllbnRQZWcuZ2V0KCkuaW52aXRlQnlFbWFpbChyb29tSWQsIGFkZHIpO1xuICAgICAgICB9IGVsc2UgaWYgKGFkZHJUeXBlID09PSBBZGRyZXNzVHlwZS5NYXRyaXhVc2VySWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb20gPSBNYXRyaXhDbGllbnRQZWcuZ2V0KCkuZ2V0Um9vbShyb29tSWQpO1xuICAgICAgICAgICAgaWYgKCFyb29tKSB0aHJvdyBuZXcgRXJyb3IoXCJSb29tIG5vdCBmb3VuZFwiKTtcblxuICAgICAgICAgICAgY29uc3QgbWVtYmVyID0gcm9vbS5nZXRNZW1iZXIoYWRkcik7XG4gICAgICAgICAgICBpZiAobWVtYmVyPy5tZW1iZXJzaGlwID09PSBcImpvaW5cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBNYXRyaXhFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGVycmNvZGU6IFVTRVJfQUxSRUFEWV9KT0lORUQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBcIk1lbWJlciBhbHJlYWR5IGpvaW5lZFwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtZW1iZXI/Lm1lbWJlcnNoaXAgPT09IFwiaW52aXRlXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWF0cml4RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBlcnJjb2RlOiBVU0VSX0FMUkVBRFlfSU5WSVRFRCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IFwiTWVtYmVyIGFscmVhZHkgaW52aXRlZFwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlnbm9yZVByb2ZpbGUgJiYgU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZShcInByb21wdEJlZm9yZUludml0ZVVua25vd25Vc2Vyc1wiLCB0aGlzLnJvb21JZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9maWxlID0gYXdhaXQgTWF0cml4Q2xpZW50UGVnLmdldCgpLmdldFByb2ZpbGVJbmZvKGFkZHIpO1xuICAgICAgICAgICAgICAgIGlmICghcHJvZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBub2luc3BlY3Rpb24gRXhjZXB0aW9uQ2F1Z2h0TG9jYWxseUpTXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVzZXIgaGFzIG5vIHByb2ZpbGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gTWF0cml4Q2xpZW50UGVnLmdldCgpLmludml0ZShyb29tSWQsIGFkZHIsIHVuZGVmaW5lZCwgdGhpcy5yZWFzb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBhZGRyZXNzJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGRvSW52aXRlKGFkZHJlc3M6IHN0cmluZywgaWdub3JlUHJvZmlsZSA9IGZhbHNlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGBJbnZpdGluZyAke2FkZHJlc3N9YCk7XG5cbiAgICAgICAgICAgIGxldCBkb0ludml0ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyb3VwSWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkb0ludml0ZSA9IEdyb3VwU3RvcmUuaW52aXRlVXNlclRvR3JvdXAodGhpcy5ncm91cElkLCBhZGRyZXNzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9JbnZpdGUgPSB0aGlzLmludml0ZVRvUm9vbSh0aGlzLnJvb21JZCwgYWRkcmVzcywgaWdub3JlUHJvZmlsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvSW52aXRlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRpb25TdGF0ZXNbYWRkcmVzc10gPSBJbnZpdGVTdGF0ZS5JbnZpdGVkO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmVycm9yc1thZGRyZXNzXTtcblxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2dyZXNzQ2FsbGJhY2s/LigpO1xuICAgICAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoZXJyKTtcblxuICAgICAgICAgICAgICAgIGxldCBlcnJvclRleHQ7XG4gICAgICAgICAgICAgICAgbGV0IGZhdGFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChlcnIuZXJyY29kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTV9GT1JCSURERU5cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yVGV4dCA9IF90KCdZb3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byBpbnZpdGUgcGVvcGxlIHRvIHRoaXMgcm9vbS4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFVTRVJfQUxSRUFEWV9JTlZJVEVEOlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JUZXh0ID0gX3QoXCJVc2VyICUodXNlcklkKXMgaXMgYWxyZWFkeSBpbnZpdGVkIHRvIHRoZSByb29tXCIsIHsgdXNlcklkOiBhZGRyZXNzIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVVNFUl9BTFJFQURZX0pPSU5FRDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yVGV4dCA9IF90KFwiVXNlciAlKHVzZXJJZClzIGlzIGFscmVhZHkgaW4gdGhlIHJvb21cIiwgeyB1c2VySWQ6IGFkZHJlc3MgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk1fTElNSVRfRVhDRUVERURcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIGJlaW5nIHRocm90dGxlZCBzbyB3YWl0IGEgYml0ICYgdHJ5IGFnYWluXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvSW52aXRlKGFkZHJlc3MsIGlnbm9yZVByb2ZpbGUpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDUwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTV9OT1RfRk9VTkRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk1fVVNFUl9OT1RfRk9VTkRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yVGV4dCA9IF90KFwiVXNlciAlKHVzZXJfaWQpcyBkb2VzIG5vdCBleGlzdFwiLCB7IHVzZXJfaWQ6IGFkZHJlc3MgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk1fUFJPRklMRV9VTkRJU0NMT1NFRFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JUZXh0ID0gX3QoXCJVc2VyICUodXNlcl9pZClzIG1heSBvciBtYXkgbm90IGV4aXN0XCIsIHsgdXNlcl9pZDogYWRkcmVzcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTV9QUk9GSUxFX05PVF9GT1VORFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpZ25vcmVQcm9maWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52aXRlIHdpdGhvdXQgdGhlIHByb2ZpbGUgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgVXNlciAke2FkZHJlc3N9IGRvZXMgbm90IGhhdmUgYSBwcm9maWxlIC0gaW52aXRpbmcgYW55d2F5cyBhdXRvbWF0aWNhbGx5YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb0ludml0ZShhZGRyZXNzLCB0cnVlKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJNX0JBRF9TVEFURVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JUZXh0ID0gX3QoXCJUaGUgdXNlciBtdXN0IGJlIHVuYmFubmVkIGJlZm9yZSB0aGV5IGNhbiBiZSBpbnZpdGVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTV9VTlNVUFBPUlRFRF9ST09NX1ZFUlNJT05cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yVGV4dCA9IF90KFwiVGhlIHVzZXIncyBob21lc2VydmVyIGRvZXMgbm90IHN1cHBvcnQgdGhlIHZlcnNpb24gb2YgdGhlIHJvb20uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvclRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JUZXh0ID0gX3QoJ1Vua25vd24gc2VydmVyIGVycm9yJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0aW9uU3RhdGVzW2FkZHJlc3NdID0gSW52aXRlU3RhdGUuRXJyb3I7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnNbYWRkcmVzc10gPSB7IGVycm9yVGV4dCwgZXJyY29kZTogZXJyLmVycmNvZGUgfTtcblxuICAgICAgICAgICAgICAgIHRoaXMuYnVzeSA9ICFmYXRhbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9mYXRhbCA9IGZhdGFsO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZhdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbnZpdGVNb3JlKG5leHRJbmRleDogbnVtYmVyLCBpZ25vcmVQcm9maWxlID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0SW5kZXggPT09IHRoaXMuYWRkcmVzc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5idXN5ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5lcnJvcnMpLmxlbmd0aCA+IDAgJiYgIXRoaXMuZ3JvdXBJZCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlIHdlcmUgcHJvYmxlbXMgaW52aXRpbmcgc29tZSBwZW9wbGUgLSBzZWUgaWYgd2UgY2FuIGludml0ZSB0aGVtXG4gICAgICAgICAgICAgICAgLy8gd2l0aG91dCBjYXJpbmcgaWYgdGhleSBleGlzdCBvciBub3QuXG4gICAgICAgICAgICAgICAgY29uc3QgdW5rbm93blByb2ZpbGVVc2VycyA9IE9iamVjdC5rZXlzKHRoaXMuZXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGEgPT4gVU5LTk9XTl9QUk9GSUxFX0VSUk9SUy5pbmNsdWRlcyh0aGlzLmVycm9yc1thXS5lcnJjb2RlKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodW5rbm93blByb2ZpbGVVc2Vycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGludml0ZVVua25vd25zID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSB1bmtub3duUHJvZmlsZVVzZXJzLm1hcCh1ID0+IHRoaXMuZG9JbnZpdGUodSwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCkgPT4gdGhpcy5kZWZlcnJlZC5yZXNvbHZlKHRoaXMuY29tcGxldGlvblN0YXRlcykpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZShcInByb21wdEJlZm9yZUludml0ZVVua25vd25Vc2Vyc1wiLCB0aGlzLnJvb21JZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludml0ZVVua25vd25zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFwiU2hvd2luZyBmYWlsZWQgdG8gaW52aXRlIGRpYWxvZy4uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgTW9kYWwuY3JlYXRlVHJhY2tlZERpYWxvZygnRmFpbGVkIHRvIGludml0ZScsICcnLCBBc2tJbnZpdGVBbnl3YXlEaWFsb2csIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVua25vd25Qcm9maWxlVXNlcnM6IHVua25vd25Qcm9maWxlVXNlcnMubWFwKHUgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VySWQ6IHUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JUZXh0OiB0aGlzLmVycm9yc1t1XS5lcnJvclRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkludml0ZUFueXdheXM6ICgpID0+IGludml0ZVVua25vd25zKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkdpdmVVcDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZha2UgYWxsIHRoZSBjb21wbGV0aW9uIHN0YXRlcyBiZWNhdXNlIHdlIGFscmVhZHkgd2FybmVkIHRoZSB1c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBhZGRyIG9mIHVua25vd25Qcm9maWxlVXNlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0aW9uU3RhdGVzW2FkZHJdID0gSW52aXRlU3RhdGUuSW52aXRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5yZXNvbHZlKHRoaXMuY29tcGxldGlvblN0YXRlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQucmVzb2x2ZSh0aGlzLmNvbXBsZXRpb25TdGF0ZXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYWRkciA9IHRoaXMuYWRkcmVzc2VzW25leHRJbmRleF07XG5cbiAgICAgICAgLy8gZG9uJ3QgdHJ5IHRvIGludml0ZSBpdCBpZiBpdCdzIGFuIGludmFsaWQgYWRkcmVzc1xuICAgICAgICAvLyAoaXQgd2lsbCBhbHJlYWR5IGJlIG1hcmtlZCBhcyBhbiBlcnJvciB0aG91Z2gsXG4gICAgICAgIC8vIHNvIG5vIG5lZWQgdG8gZG8gc28gYWdhaW4pXG4gICAgICAgIGlmIChnZXRBZGRyZXNzVHlwZShhZGRyKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pbnZpdGVNb3JlKG5leHRJbmRleCArIDEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG9uJ3QgcmUtaW52aXRlICh0aGVyZSdzIG5vIHdheSBpbiB0aGUgVUkgdG8gZG8gdGhpcywgYnV0XG4gICAgICAgIC8vIGZvciBzYW5pdHkncyBzYWtlKVxuICAgICAgICBpZiAodGhpcy5jb21wbGV0aW9uU3RhdGVzW2FkZHJdID09PSBJbnZpdGVTdGF0ZS5JbnZpdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmludml0ZU1vcmUobmV4dEluZGV4ICsgMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRvSW52aXRlKGFkZHIsIGlnbm9yZVByb2ZpbGUpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pbnZpdGVNb3JlKG5leHRJbmRleCArIDEsIGlnbm9yZVByb2ZpbGUpO1xuICAgICAgICB9KS5jYXRjaCgoKSA9PiB0aGlzLmRlZmVycmVkLnJlc29sdmUodGhpcy5jb21wbGV0aW9uU3RhdGVzKSk7XG4gICAgfVxufVxuIl19