"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.midPointsBetweenStrings = midPointsBetweenStrings;
exports.reorderLexicographically = void 0;

var _utils = require("matrix-js-sdk/src/utils");

var _arrays = require("./arrays");

/*
Copyright 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
function midPointsBetweenStrings(a, b, count, maxLen, alphabet = _utils.DEFAULT_ALPHABET) {
  const padN = Math.min(Math.max(a.length, b.length), maxLen);
  const padA = (0, _utils.alphabetPad)(a, padN, alphabet);
  const padB = (0, _utils.alphabetPad)(b, padN, alphabet);
  const baseA = (0, _utils.stringToBase)(padA, alphabet);
  const baseB = (0, _utils.stringToBase)(padB, alphabet);

  if (baseB - baseA - BigInt(1) < count) {
    if (padN < maxLen) {
      // this recurses once at most due to the new limit of n+1
      return midPointsBetweenStrings((0, _utils.alphabetPad)(padA, padN + 1, alphabet), (0, _utils.alphabetPad)(padB, padN + 1, alphabet), count, padN + 1, alphabet);
    }

    return [];
  }

  const step = (baseB - baseA) / BigInt(count + 1);
  const start = BigInt(baseA + step);
  return Array(count).fill(undefined).map((_, i) => (0, _utils.baseToString)(start + BigInt(i) * step, alphabet));
}

const reorderLexicographically = (orders, fromIndex, toIndex, maxLen = 50) => {
  var _newOrder, _newOrder2, _newOrder5, _newOrder6;

  // sanity check inputs
  if (fromIndex < 0 || toIndex < 0 || fromIndex > orders.length || toIndex > orders.length || fromIndex === toIndex) {
    return [];
  } // zip orders with their indices to simplify later index wrangling


  const ordersWithIndices = orders.map((order, index) => ({
    index,
    order
  })); // apply the fundamental order update to the zipped array

  const newOrder = (0, _arrays.moveElement)(ordersWithIndices, fromIndex, toIndex); // check if we have to fill undefined orders to complete placement

  const orderToLeftUndefined = ((_newOrder = newOrder[toIndex - 1]) === null || _newOrder === void 0 ? void 0 : _newOrder.order) === undefined;
  let leftBoundIdx = toIndex;
  let rightBoundIdx = toIndex;
  let canMoveLeft = true;
  const nextBase = ((_newOrder2 = newOrder[toIndex + 1]) === null || _newOrder2 === void 0 ? void 0 : _newOrder2.order) !== undefined ? (0, _utils.stringToBase)(newOrder[toIndex + 1].order) : BigInt(Number.MAX_VALUE); // check how far left we would have to mutate to fit in that direction

  for (let i = toIndex - 1, j = 1; i >= 0; i--, j++) {
    var _newOrder$i;

    if (((_newOrder$i = newOrder[i]) === null || _newOrder$i === void 0 ? void 0 : _newOrder$i.order) !== undefined && nextBase - (0, _utils.stringToBase)(newOrder[i].order) > j) break;
    leftBoundIdx = i;
  } // verify the left move would be sufficient


  const firstOrderBase = newOrder[0].order === undefined ? undefined : (0, _utils.stringToBase)(newOrder[0].order);
  const bigToIndex = BigInt(toIndex);

  if (leftBoundIdx === 0 && firstOrderBase !== undefined && nextBase - firstOrderBase <= bigToIndex && firstOrderBase <= bigToIndex) {
    canMoveLeft = false;
  }

  const canDisplaceRight = !orderToLeftUndefined;
  let canMoveRight = canDisplaceRight;

  if (canDisplaceRight) {
    var _newOrder3, _newOrder4;

    const prevBase = ((_newOrder3 = newOrder[toIndex - 1]) === null || _newOrder3 === void 0 ? void 0 : _newOrder3.order) !== undefined ? (0, _utils.stringToBase)((_newOrder4 = newOrder[toIndex - 1]) === null || _newOrder4 === void 0 ? void 0 : _newOrder4.order) : BigInt(Number.MIN_VALUE); // check how far right we would have to mutate to fit in that direction

    for (let i = toIndex + 1, j = 1; i < newOrder.length; i++, j++) {
      var _newOrder$i2;

      if (((_newOrder$i2 = newOrder[i]) === null || _newOrder$i2 === void 0 ? void 0 : _newOrder$i2.order) === undefined || (0, _utils.stringToBase)(newOrder[i].order) - prevBase > j) break;
      rightBoundIdx = i;
    } // verify the right move would be sufficient


    if (rightBoundIdx === newOrder.length - 1 && (newOrder[rightBoundIdx] ? (0, _utils.stringToBase)(newOrder[rightBoundIdx].order) : BigInt(Number.MAX_VALUE)) - prevBase <= rightBoundIdx - toIndex) {
      canMoveRight = false;
    }
  } // pick the cheaper direction


  const leftDiff = canMoveLeft ? toIndex - leftBoundIdx : Number.MAX_SAFE_INTEGER;
  const rightDiff = canMoveRight ? rightBoundIdx - toIndex : Number.MAX_SAFE_INTEGER;

  if (orderToLeftUndefined || leftDiff < rightDiff) {
    rightBoundIdx = toIndex;
  } else {
    leftBoundIdx = toIndex;
  }

  const prevOrder = ((_newOrder5 = newOrder[leftBoundIdx - 1]) === null || _newOrder5 === void 0 ? void 0 : _newOrder5.order) ?? "";

  const nextOrder = ((_newOrder6 = newOrder[rightBoundIdx + 1]) === null || _newOrder6 === void 0 ? void 0 : _newOrder6.order) ?? _utils.DEFAULT_ALPHABET.charAt(_utils.DEFAULT_ALPHABET.length - 1).repeat(prevOrder.length || 1);

  const changes = midPointsBetweenStrings(prevOrder, nextOrder, 1 + rightBoundIdx - leftBoundIdx, maxLen);
  return changes.map((order, i) => ({
    index: newOrder[leftBoundIdx + i].index,
    order
  }));
};

exports.reorderLexicographically = reorderLexicographically;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9zdHJpbmdPcmRlckZpZWxkLnRzIl0sIm5hbWVzIjpbIm1pZFBvaW50c0JldHdlZW5TdHJpbmdzIiwiYSIsImIiLCJjb3VudCIsIm1heExlbiIsImFscGhhYmV0IiwiREVGQVVMVF9BTFBIQUJFVCIsInBhZE4iLCJNYXRoIiwibWluIiwibWF4IiwibGVuZ3RoIiwicGFkQSIsInBhZEIiLCJiYXNlQSIsImJhc2VCIiwiQmlnSW50Iiwic3RlcCIsInN0YXJ0IiwiQXJyYXkiLCJmaWxsIiwidW5kZWZpbmVkIiwibWFwIiwiXyIsImkiLCJyZW9yZGVyTGV4aWNvZ3JhcGhpY2FsbHkiLCJvcmRlcnMiLCJmcm9tSW5kZXgiLCJ0b0luZGV4Iiwib3JkZXJzV2l0aEluZGljZXMiLCJvcmRlciIsImluZGV4IiwibmV3T3JkZXIiLCJvcmRlclRvTGVmdFVuZGVmaW5lZCIsImxlZnRCb3VuZElkeCIsInJpZ2h0Qm91bmRJZHgiLCJjYW5Nb3ZlTGVmdCIsIm5leHRCYXNlIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwiaiIsImZpcnN0T3JkZXJCYXNlIiwiYmlnVG9JbmRleCIsImNhbkRpc3BsYWNlUmlnaHQiLCJjYW5Nb3ZlUmlnaHQiLCJwcmV2QmFzZSIsIk1JTl9WQUxVRSIsImxlZnREaWZmIiwiTUFYX1NBRkVfSU5URUdFUiIsInJpZ2h0RGlmZiIsInByZXZPcmRlciIsIm5leHRPcmRlciIsImNoYXJBdCIsInJlcGVhdCIsImNoYW5nZXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBZ0JBOztBQUVBOztBQWxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNTyxTQUFTQSx1QkFBVCxDQUNIQyxDQURHLEVBRUhDLENBRkcsRUFHSEMsS0FIRyxFQUlIQyxNQUpHLEVBS0hDLFFBQVEsR0FBR0MsdUJBTFIsRUFNSztBQUNSLFFBQU1DLElBQUksR0FBR0MsSUFBSSxD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RDtBQUM5Q2QsSUFBQUEsYUFBYSxHQUFHUCxPQUFoQjtBQUNILEdBRkQsTUFFTztBQUNITSxJQUFBQSxZQUFZLEdBQUdOLE9BQWY7QUFDSDs7QUFFRCxRQUFNc0IsU0FBUyxHQUFHLGVBQUFsQixRQUFRLENBQUNFLFlBQVksR0FBRyxDQUFoQixDQUFSLDBEQUE0QkosS0FBNUIsS0FBcUMsRUFBdkQ7O0FBQ0EsUUFBTXFCLFNBQVMsR0FBRyxlQUFBbkIsUUFBUSxDQUFDRyxhQUFhLEdBQUcsQ0FBakIsQ0FBUiwwREFBNkJMLEtBQTdCLEtBQ1h4Qix3QkFBaUI4QyxNQUFqQixDQUF3QjlDLHdCQUFpQkssTUFBakIsR0FBMEIsQ0FBbEQsRUFBcUQwQyxNQUFyRCxDQUE0REgsU0FBUyxDQUFDdkMsTUFBVixJQUFvQixDQUFoRixDQURQOztBQUdBLFFBQU0yQyxPQUFPLEdBQUd0RCx1QkFBdUIsQ0FBQ2tELFNBQUQsRUFBWUMsU0FBWixFQUF1QixJQUFJaEIsYUFBSixHQUFvQkQsWUFBM0MsRUFBeUQ5QixNQUF6RCxDQUF2QztBQUVBLFNBQU9rRCxPQUFPLENBQUNoQyxHQUFSLENBQVksQ0FBQ1EsS0FBRCxFQUFRTixDQUFSLE1BQWU7QUFDOUJPLElBQUFBLEtBQUssRUFBRUMsUUFBUSxDQUFDRSxZQUFZLEdBQUdWLENBQWhCLENBQVIsQ0FBMkJPLEtBREo7QUFFOUJELElBQUFBO0FBRjhCLEdBQWYsQ0FBWixDQUFQO0FBSUgsQ0ExRk0iLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMjEgVGhlIE1hdHJpeC5vcmcgRm91bmRhdGlvbiBDLkkuQy5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgeyBhbHBoYWJldFBhZCwgYmFzZVRvU3RyaW5nLCBzdHJpbmdUb0Jhc2UsIERFRkFVTFRfQUxQSEFCRVQgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvdXRpbHNcIjtcblxuaW1wb3J0IHsgbW92ZUVsZW1lbnQgfSBmcm9tIFwiLi9hcnJheXNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG1pZFBvaW50c0JldHdlZW5TdHJpbmdzKFxuICAgIGE6IHN0cmluZyxcbiAgICBiOiBzdHJpbmcsXG4gICAgY291bnQ6IG51bWJlcixcbiAgICBtYXhMZW46IG51bWJlcixcbiAgICBhbHBoYWJldCA9IERFRkFVTFRfQUxQSEFCRVQsXG4pOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgcGFkTiA9IE1hdGgubWluKE1hdGgubWF4KGEubGVuZ3RoLCBiLmxlbmd0aCksIG1heExlbik7XG4gICAgY29uc3QgcGFkQSA9IGFscGhhYmV0UGFkKGEsIHBhZE4sIGFscGhhYmV0KTtcbiAgICBjb25zdCBwYWRCID0gYWxwaGFiZXRQYWQoYiwgcGFkTiwgYWxwaGFiZXQpO1xuICAgIGNvbnN0IGJhc2VBID0gc3RyaW5nVG9CYXNlKHBhZEEsIGFscGhhYmV0KTtcbiAgICBjb25zdCBiYXNlQiA9IHN0cmluZ1RvQmFzZShwYWRCLCBhbHBoYWJldCk7XG5cbiAgICBpZiAoYmFzZUIgLSBiYXNlQSAtIEJpZ0ludCgxKSA8IGNvdW50KSB7XG4gICAgICAgIGlmIChwYWROIDwgbWF4TGVuKSB7XG4gICAgICAgICAgICAvLyB0aGlzIHJlY3Vyc2VzIG9uY2UgYXQgbW9zdCBkdWUgdG8gdGhlIG5ldyBsaW1pdCBvZiBuKzFcbiAgICAgICAgICAgIHJldHVybiBtaWRQb2ludHNCZXR3ZWVuU3RyaW5ncyhcbiAgICAgICAgICAgICAgICBhbHBoYWJldFBhZChwYWRBLCBwYWROICsgMSwgYWxwaGFiZXQpLFxuICAgICAgICAgICAgICAgIGFscGhhYmV0UGFkKHBhZEIsIHBhZE4gKyAxLCBhbHBoYWJldCksXG4gICAgICAgICAgICAgICAgY291bnQsXG4gICAgICAgICAgICAgICAgcGFkTiArIDEsXG4gICAgICAgICAgICAgICAgYWxwaGFiZXQsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGVwID0gKGJhc2VCIC0gYmFzZUEpIC8gQmlnSW50KGNvdW50ICsgMSk7XG4gICAgY29uc3Qgc3RhcnQgPSBCaWdJbnQoYmFzZUEgKyBzdGVwKTtcbiAgICByZXR1cm4gQXJyYXkoY291bnQpLmZpbGwodW5kZWZpbmVkKS5tYXAoKF8sIGkpID0+IGJhc2VUb1N0cmluZyhzdGFydCArIChCaWdJbnQoaSkgKiBzdGVwKSwgYWxwaGFiZXQpKTtcbn1cblxuaW50ZXJmYWNlIElFbnRyeSB7XG4gICAgaW5kZXg6IG51bWJlcjtcbiAgICBvcmRlcjogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgcmVvcmRlckxleGljb2dyYXBoaWNhbGx5ID0gKFxuICAgIG9yZGVyczogQXJyYXk8c3RyaW5nIHwgdW5kZWZpbmVkPixcbiAgICBmcm9tSW5kZXg6IG51bWJlcixcbiAgICB0b0luZGV4OiBudW1iZXIsXG4gICAgbWF4TGVuID0gNTAsXG4pOiBJRW50cnlbXSA9PiB7XG4gICAgLy8gc2FuaXR5IGNoZWNrIGlucHV0c1xuICAgIGlmIChcbiAgICAgICAgZnJvbUluZGV4IDwgMCB8fCB0b0luZGV4IDwgMCB8fFxuICAgICAgICBmcm9tSW5kZXggPiBvcmRlcnMubGVuZ3RoIHx8IHRvSW5kZXggPiBvcmRlcnMubGVuZ3RoIHx8XG4gICAgICAgIGZyb21JbmRleCA9PT0gdG9JbmRleFxuICAgICkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLy8gemlwIG9yZGVycyB3aXRoIHRoZWlyIGluZGljZXMgdG8gc2ltcGxpZnkgbGF0ZXIgaW5kZXggd3JhbmdsaW5nXG4gICAgY29uc3Qgb3JkZXJzV2l0aEluZGljZXM6IElFbnRyeVtdID0gb3JkZXJzLm1hcCgob3JkZXIsIGluZGV4KSA9PiAoeyBpbmRleCwgb3JkZXIgfSkpO1xuICAgIC8vIGFwcGx5IHRoZSBmdW5kYW1lbnRhbCBvcmRlciB1cGRhdGUgdG8gdGhlIHppcHBlZCBhcnJheVxuICAgIGNvbnN0IG5ld09yZGVyID0gbW92ZUVsZW1lbnQob3JkZXJzV2l0aEluZGljZXMsIGZyb21JbmRleCwgdG9JbmRleCk7XG5cbiAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIHRvIGZpbGwgdW5kZWZpbmVkIG9yZGVycyB0byBjb21wbGV0ZSBwbGFjZW1lbnRcbiAgICBjb25zdCBvcmRlclRvTGVmdFVuZGVmaW5lZCA9IG5ld09yZGVyW3RvSW5kZXggLSAxXT8ub3JkZXIgPT09IHVuZGVmaW5lZDtcblxuICAgIGxldCBsZWZ0Qm91bmRJZHggPSB0b0luZGV4O1xuICAgIGxldCByaWdodEJvdW5kSWR4ID0gdG9JbmRleDtcblxuICAgIGxldCBjYW5Nb3ZlTGVmdCA9IHRydWU7XG4gICAgY29uc3QgbmV4dEJhc2UgPSBuZXdPcmRlclt0b0luZGV4ICsgMV0/Lm9yZGVyICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBzdHJpbmdUb0Jhc2UobmV3T3JkZXJbdG9JbmRleCArIDFdLm9yZGVyKVxuICAgICAgICA6IEJpZ0ludChOdW1iZXIuTUFYX1ZBTFVFKTtcblxuICAgIC8vIGNoZWNrIGhvdyBmYXIgbGVmdCB3ZSB3b3VsZCBoYXZlIHRvIG11dGF0ZSB0byBmaXQgaW4gdGhhdCBkaXJlY3Rpb25cbiAgICBmb3IgKGxldCBpID0gdG9JbmRleCAtIDEsIGogPSAxOyBpID49IDA7IGktLSwgaisrKSB7XG4gICAgICAgIGlmIChuZXdPcmRlcltpXT8ub3JkZXIgIT09IHVuZGVmaW5lZCAmJiBuZXh0QmFzZSAtIHN0cmluZ1RvQmFzZShuZXdPcmRlcltpXS5vcmRlcikgPiBqKSBicmVhaztcbiAgICAgICAgbGVmdEJvdW5kSWR4ID0gaTtcbiAgICB9XG5cbiAgICAvLyB2ZXJpZnkgdGhlIGxlZnQgbW92ZSB3b3VsZCBiZSBzdWZmaWNpZW50XG4gICAgY29uc3QgZmlyc3RPcmRlckJhc2UgPSBuZXdPcmRlclswXS5vcmRlciA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc3RyaW5nVG9CYXNlKG5ld09yZGVyWzBdLm9yZGVyKTtcbiAgICBjb25zdCBiaWdUb0luZGV4ID0gQmlnSW50KHRvSW5kZXgpO1xuICAgIGlmIChsZWZ0Qm91bmRJZHggPT09IDAgJiZcbiAgICAgICAgZmlyc3RPcmRlckJhc2UgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBuZXh0QmFzZSAtIGZpcnN0T3JkZXJCYXNlIDw9IGJpZ1RvSW5kZXggJiZcbiAgICAgICAgZmlyc3RPcmRlckJhc2UgPD0gYmlnVG9JbmRleFxuICAgICkge1xuICAgICAgICBjYW5Nb3ZlTGVmdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbkRpc3BsYWNlUmlnaHQgPSAhb3JkZXJUb0xlZnRVbmRlZmluZWQ7XG4gICAgbGV0IGNhbk1vdmVSaWdodCA9IGNhbkRpc3BsYWNlUmlnaHQ7XG4gICAgaWYgKGNhbkRpc3BsYWNlUmlnaHQpIHtcbiAgICAgICAgY29uc3QgcHJldkJhc2UgPSBuZXdPcmRlclt0b0luZGV4IC0gMV0/Lm9yZGVyICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gc3RyaW5nVG9CYXNlKG5ld09yZGVyW3RvSW5kZXggLSAxXT8ub3JkZXIpXG4gICAgICAgICAgICA6IEJpZ0ludChOdW1iZXIuTUlOX1ZBTFVFKTtcblxuICAgICAgICAvLyBjaGVjayBob3cgZmFyIHJpZ2h0IHdlIHdvdWxkIGhhdmUgdG8gbXV0YXRlIHRvIGZpdCBpbiB0aGF0IGRpcmVjdGlvblxuICAgICAgICBmb3IgKGxldCBpID0gdG9JbmRleCArIDEsIGogPSAxOyBpIDwgbmV3T3JkZXIubGVuZ3RoOyBpKyssIGorKykge1xuICAgICAgICAgICAgaWYgKG5ld09yZGVyW2ldPy5vcmRlciA9PT0gdW5kZWZpbmVkIHx8IHN0cmluZ1RvQmFzZShuZXdPcmRlcltpXS5vcmRlcikgLSBwcmV2QmFzZSA+IGopIGJyZWFrO1xuICAgICAgICAgICAgcmlnaHRCb3VuZElkeCA9IGk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB2ZXJpZnkgdGhlIHJpZ2h0IG1vdmUgd291bGQgYmUgc3VmZmljaWVudFxuICAgICAgICBpZiAocmlnaHRCb3VuZElkeCA9PT0gbmV3T3JkZXIubGVuZ3RoIC0gMSAmJlxuICAgICAgICAgICAgKG5ld09yZGVyW3JpZ2h0Qm91bmRJZHhdXG4gICAgICAgICAgICAgICAgPyBzdHJpbmdUb0Jhc2UobmV3T3JkZXJbcmlnaHRCb3VuZElkeF0ub3JkZXIpXG4gICAgICAgICAgICAgICAgOiBCaWdJbnQoTnVtYmVyLk1BWF9WQUxVRSkpIC0gcHJldkJhc2UgPD0gKHJpZ2h0Qm91bmRJZHggLSB0b0luZGV4KVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNhbk1vdmVSaWdodCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcGljayB0aGUgY2hlYXBlciBkaXJlY3Rpb25cbiAgICBjb25zdCBsZWZ0RGlmZiA9IGNhbk1vdmVMZWZ0ID8gdG9JbmRleCAtIGxlZnRCb3VuZElkeCA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgIGNvbnN0IHJpZ2h0RGlmZiA9IGNhbk1vdmVSaWdodCA/IHJpZ2h0Qm91bmRJZHggLSB0b0luZGV4IDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgaWYgKG9yZGVyVG9MZWZ0VW5kZWZpbmVkIHx8IGxlZnREaWZmIDwgcmlnaHREaWZmKSB7XG4gICAgICAgIHJpZ2h0Qm91bmRJZHggPSB0b0luZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlZnRCb3VuZElkeCA9IHRvSW5kZXg7XG4gICAgfVxuXG4gICAgY29uc3QgcHJldk9yZGVyID0gbmV3T3JkZXJbbGVmdEJvdW5kSWR4IC0gMV0/Lm9yZGVyID8/IFwiXCI7XG4gICAgY29uc3QgbmV4dE9yZGVyID0gbmV3T3JkZXJbcmlnaHRCb3VuZElkeCArIDFdPy5vcmRlclxuICAgICAgICA/PyBERUZBVUxUX0FMUEhBQkVULmNoYXJBdChERUZBVUxUX0FMUEhBQkVULmxlbmd0aCAtIDEpLnJlcGVhdChwcmV2T3JkZXIubGVuZ3RoIHx8IDEpO1xuXG4gICAgY29uc3QgY2hhbmdlcyA9IG1pZFBvaW50c0JldHdlZW5TdHJpbmdzKHByZXZPcmRlciwgbmV4dE9yZGVyLCAxICsgcmlnaHRCb3VuZElkeCAtIGxlZnRCb3VuZElkeCwgbWF4TGVuKTtcblxuICAgIHJldHVybiBjaGFuZ2VzLm1hcCgob3JkZXIsIGkpID0+ICh7XG4gICAgICAgIGluZGV4OiBuZXdPcmRlcltsZWZ0Qm91bmRJZHggKyBpXS5pbmRleCxcbiAgICAgICAgb3JkZXIsXG4gICAgfSkpO1xufTtcbiJdfQ==