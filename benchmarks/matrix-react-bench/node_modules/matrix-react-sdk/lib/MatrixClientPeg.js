"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MatrixClientPeg = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _matrix = require("matrix-js-sdk/src/matrix");

var _memory = require("matrix-js-sdk/src/store/memory");

var utils = _interopRequireWildcard(require("matrix-js-sdk/src/utils"));

var _eventTimeline = require("matrix-js-sdk/src/models/event-timeline");

var _eventTimelineSet = require("matrix-js-sdk/src/models/event-timeline-set");

var sdk = _interopRequireWildcard(require("./index"));

var _createMatrixClient = _interopRequireDefault(require("./utils/createMatrixClient"));

var _SettingsStore = _interopRequireDefault(require("./settings/SettingsStore"));

var _MatrixActionCreators = _interopRequireDefault(require("./actions/MatrixActionCreators"));

var _Modal = _interopRequireDefault(require("./Modal"));

var _crypto = require("matrix-js-sdk/src/crypto");

var _MatrixClientBackedSettingsHandler = _interopRequireDefault(require("./settings/handlers/MatrixClientBackedSettingsHandler"));

var StorageManager = _interopRequireWildcard(require("./utils/StorageManager"));

var _IdentityAuthClient = _interopRequireDefault(require("./IdentityAuthClient"));

var _SecurityManager = require("./SecurityManager");

var _QRCode = require("matrix-js-sdk/src/crypto/verification/QRCode");

var _Security = _interopRequireDefault(require("./customisations/Security"));

var _logger = require("matrix-js-sdk/src/logger");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
Copyright 2015, 2016 OpenMarket Ltd
Copyright 2017 Vector Creations Ltd.
Copyright 2017, 2018, 2019 New Vector Ltd
Copyright 2019, 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/**
 * Wrapper object for handling the js-sdk Matrix Client object in the react-sdk
 * Handles the creation/initialisation of client objects.
 * This module provides a singleton instance of this class so the 'current'
 * Matrix Client object is available easily.
 */
class MatrixClientPegClass {
  // These are the default options used when when the
  // client is started in 'start'. These can be altered
  // at any time up to after the 'will_start_client'
  // event is finished processing.
  // the credentials used to init the current client object.
  // used if we tear it down & recreate it with a different store
  constructor() {
    (0, _defineProperty2.default)(this, "opts", {
      initialSyncLimit: 20
    });
    (0, _defineProperty2.default)(this, "matrixClient", null);
    (0, _defineProperty2.default)(this, "justRegisteredUserId", void 0);
    (0, _defineProperty2.default)(this, "currentClientCreds", void 0);
  }

  get() {
    return this.matrixClient;
  }

  unset() {
    this.matrixClient = null;

    _MatrixActionCreators.default.stop();
  }

  setJustRegisteredUserId(uid) {
    this.justRegisteredUserId = uid;

    if (uid) {
      window.localStorage.setItem("mx_registration_time", String(new Date().getTime()));
    }
  }

  currentUserIsJustRegistered() {
    return this.matrixClient && this.matrixClient.credentials.userId === this.justRegisteredUserId;
  }

  userRegisteredWithinLastHours(hours) {
    try {
      const date = new Date(window.localStorage.getItem("mx_registration_time"));
      return (new Date().getTime() - date.getTime()) / 36e5 <= hours;
    } catch (e) {
      return false;
    }
  }

  replaceUsingCreds(creds) {
    this.currentClientCreds = creds;
    this.createClient(creds);
  }

  async assign() {
    for (const dbType of ['indexeddb', 'memory']) {
      try {
        const promise = this.matrixClient.store.startup();

        _logger.logger.log("MatrixClientPeg: waiting for MatrixClient store to initialise");

        await promise;
        break;
      } catch (err) {
        if (dbType === 'indexeddb') {
          _logger.logger.error('Error starting matrixclient store - falling back to memory store', err);

          this.matrixClient.store = new _memory.MemoryStore({
            localStorage: localStorage
          });
        } else {
          _logger.logger.error('Failed to start memory store!', err);

          throw err;
        }
      }
    }

    StorageManager.trackStores(this.matrixClient); // try to initialise e2e on the new client

    try {
      // check that we have a version of the js-sdk which includes initCrypto
      if (!_SettingsStore.default.getValue("lowBandwidth") && this.matrixClient.initCrypto) {
        await this.matrixClient.initCrypto();
        this.matrixClient.setCryptoTrustCrossSignedDevices(!_SettingsStore.default.getValue('e2ee.manuallyVerifyAllSessions'));
        await (0, _SecurityManager.tryToUnlockSecretStorageWithDehydrationKey)(this.matrixClient);
        StorageManager.setCryptoInitialised(true);
      }
    } catch (e) {
      if (e && e.name === 'InvalidCryptoStoreError') {
        // The js-sdk found a crypto DB too new for it to use
        // FIXME: Using an import will result in test failures
        const CryptoStoreTooNewDialog = sdk.getComponent("views.dialogs.CryptoStoreTooNewDialog");

        _Modal.default.createDialog(CryptoStoreTooNewDialog);
      } // this can happen for a number of reasons, the most likely being
      // that the olm library was missing. It's not fatal.


      _logger.logger.warn("Unable to initialise e2e", e);
    }

    const opts = utils.deepCopy(this.opts); // the react sdk doesn't work without this, so don't allow

    opts.pendingEventOrdering = _matrix.PendingEventOrdering.Detached;
    opts.lazyLoadMembers = true;
    opts.clientWellKnownPollPeriod = 2 * 60 * 60; // 2 hours

    opts.experimentalThreadSupport = _SettingsStore.default.getValue("feature_thread"); // Connect the matrix client to the dispatcher and setting handlers

    _MatrixActionCreators.default.start(this.matrixClient);

    _MatrixClientBackedSettingsHandler.default.matrixClient = this.matrixClient;
    return opts;
  }

  async start() {
    const opts = await this.assign();

    _logger.logger.log(`MatrixClientPeg: really starting MatrixClient`);

    await this.get().startClient(opts);

    _logger.logger.log(`MatrixClientPeg: MatrixClient started`);
  }

  getCredentials() {
    return {
      homeserverUrl: this.matrixClient.baseUrl,
      identityServerUrl: this.matrixClient.idBaseUrl,
      userId: this.matrixClient.credentials.userId,
      deviceId: this.matrixClient.getDeviceId(),
      accessToken: this.matrixClient.getAccessToken(),
      guest: this.matrixClient.isGuest()
    };
  }

  getHomeserverName() {
    const matches = /^@[^:]+:(.+)$/.exec(this.matrixClient.credentials.userId);

    if (matches === null || matches.length < 1) {
      throw new Error("Failed to derive homeserver name from user ID!");
    }

    return matches[1];
  }

  createClient(creds) {
    const opts = {
      baseUrl: creds.homeserverUrl,
      idBaseUrl: creds.identityServerUrl,
      accessToken: creds.accessToken,
      userId: creds.userId,
      deviceId: creds.deviceId,
      pickleKey: creds.pickleKey,
      timelineSupport: true,
      forceTURN: !_SettingsStore.default.getValue('webRtcAllowPeerToPeer'),
      fallbackICEServerAllowed: !!_SettingsStore.default.getValue('fallbackICEServerAllowed'),
      // Gather up to 20 ICE candidates when a call arrives: this should be more than we'd
      // ever normally need, so effectively this should make all the gathering happen when
      // the call arrives.
      iceCandidatePoolSize: 20,
      verificationMethods: [_crypto.verificationMethods.SAS, _QRCode.SHOW_QR_CODE_METHOD, _crypto.verificationMethods.RECIPROCATE_QR_CODE],
      unstableClientRelationAggregation: true,
      identityServer: new _IdentityAuthClient.default(),
      cryptoCallbacks: {}
    }; // These are always installed regardless of the labs flag so that
    // cross-signing features can toggle on without reloading and also be
    // accessed immediately after login.

    Object.assign(opts.cryptoCallbacks, _SecurityManager.crossSigningCallbacks);

    if (_Security.default.getDehydrationKey) {
      opts.cryptoCallbacks.getDehydrationKey = _Security.default.getDehydrationKey;
    }

    this.matrixClient = (0, _createMatrixClient.default)(opts); // we're going to add eventlisteners for each matrix event tile, so the
    // potential number of event listeners is quite high.

    this.matrixClient.setMaxListeners(500);
    this.matrixClient.setGuest(Boolean(creds.guest));
    const notifTimelineSet = new _eventTimelineSet.EventTimelineSet(null, {
      timelineSupport: true,
      pendingEvents: false
    }); // XXX: what is our initial pagination token?! it somehow needs to be synchronised with /sync.

    notifTimelineSet.getLiveTimeline().setPaginationToken("", _eventTimeline.EventTimeline.BACKWARDS);
    this.matrixClient.setNotifTimelineSet(notifTimelineSet);
  }

}

if (!window.mxMatrixClientPeg) {
  window.mxMatrixClientPeg = new MatrixClientPegClass();
}

const MatrixClientPeg = window.mxMatrixClientPeg;
exports.MatrixClientPeg = MatrixClientPeg;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9NYXRyaXhDbGllbnRQZWcudHMiXSwibmFtZXMiOlsiTWF0cml4Q2xpZW50UGVnQ2xhc3MiLCJjb25zdHJ1Y3RvciIsImluaXRpYWxTeW5jTGltaXQiLCJnZXQiLCJtYXRyaXhDbGllbnQiLCJ1bnNldCIsIk1hdHJpeEFjdGlvbkNyZWF0b3JzIiwic3RvcCIsInNldEp1c3RSZWdpc3RlcmVkVXNlcklkIiwidWlkIiwianVzdFJlZ2lzdGVyZWRVc2VySWQiLCJ3aW5kb3ciLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiU3RyaW5nIiwiRGF0ZSIsImdldFRpbWUiLCJjdXJyZW50VXNlcklzSnVzdFJlZ2lzdGVyZWQiLCJjcmVkZW50aWFscyIsInVzZXJJZCIsInVzZXJSZWdpc3RlcmVkV2l0aGluTGFzdEhvdXJzIiwiaG91cnMiLCJkYXRlIiwiZ2V0SXRlbSIsImUiLCJyZXBsYWNlVXNpbmdDcmVkcyIsImNyZWRzIiwiY3VycmVudENsaWVudENyZWRzIiwiY3JlYXRlQ2xpZW50IiwiYXNzaWduIiwiZGJUeXBlIiwicHJvbWlzZSIsInN0b3JlIiwic3RhcnR1cCIsImxvZ2dlciIsImxvZyIsImVyciIsImVycm9yIiwiTWVtb3J5U3RvcmUiLCJTdG9yYWdlTWFuYWdlciIsInRyYWNrU3RvcmVzIiwiU2V0dGluZ3NTdG9yZSIsImdldFZhbHVlIiwiaW5pdENyeXB0byIsInNldENyeXB0b1RydXN0Q3Jvc3NTaWduZWREZXZpY2VzIiwic2V0Q3J5cHRvSW5pdGlhbGlzZWQiLCJuYW1lIiwiQ3J5cHRvU3RvcmVUb29OZXdEaWFsb2ciLCJzZGsiLCJnZXRDb21wb25lbnQiLCJNb2RhbCIsImNyZWF0ZURpYWxvZyIsIndhcm4iLCJvcHRzIiwidXRpbHMiLCJkZWVwQ29weSIsInBlbmRpbmdFdmVudE9yZGVyaW5nIiwiUGVuZGluZ0V2ZW50T3JkZXJpbmciLCJEZXRhY2hlZCIsImxhenlMb2FkTWVtYmVycyIsImNsaWVudFdlbGxLbm93blBvbGxQZXJpb2QiLCJleHBlcmltZW50YWxUaHJlYWRTdXBwb3J0Iiwic3RhcnQiLCJNYXRyaXhDbGllbnRCYWNrZWRTZXR0aW5nc0hhbmRsZXIiLCJzdGFydENsaWVudCIsImdldENyZWRlbnRpYWxzIiwiaG9tZXNlcnZlclVybCIsImJhc2VVcmwiLCJpZGVudGl0eVNlcnZlclVybCIsImlkQmFzZVVybCIsImRldmljZUlkIiwiZ2V0RGV2aWNlSWQiLCJhY2Nlc3NUb2tlbiIsImdldEFjY2Vzc1Rva2VuIiwiZ3Vlc3QiLCJpc0d1ZXN0IiwiZ2V0SG9tZXNlcnZlck5hbWUiLCJtYXRjaGVzIiwiZXhlYyIsImxlbmd0aCIsIkVycm9yIiwicGlja2xlS2V5IiwidGltZWxpbmVTdXBwb3J0IiwiZm9yY2VUVVJOIiwiZmFsbGJhY2tJQ0VTZXJ2ZXJBbGxvd2VkIiwiaWNlQ2FuZGlkYXRlUG9vbFNpemUiLCJ2ZXJpZmljYXRpb25NZXRob2RzIiwiU0FTIiwiU0hPV19RUl9DT0RFX01FVEhPRCIsIlJFQ0lQUk9DQVRFX1FSX0NPREUiLCJ1bnN0YWJsZUNsaWVudFJlbGF0aW9uQWdncmVnYXRpb24iLCJpZGVudGl0eVNlcnZlciIsIklkZW50aXR5QXV0aENsaWVudCIsImNyeXB0b0NhbGxiYWNrcyIsIk9iamVjdCIsImNyb3NzU2lnbmluZ0NhbGxiYWNrcyIsIlNlY3VyaXR5Q3VzdG9taXNhdGlvbnMiLCJnZXREZWh5ZHJhdGlvbktleSIsInNldE1heExpc3RlbmVycyIsInNldEd1ZXN0IiwiQm9vbGVhbiIsIm5vdGlmVGltZWxpbmVTZXQiLCJFdmVudFRpbWVsaW5lU2V0IiwicGVuZGluZ0V2ZW50cyIsImdldExpdmVUaW1lbGluZSIsInNldFBhZ2luYXRpb25Ub2tlbiIsIkV2ZW50VGltZWxpbmUiLCJCQUNLV0FSRFMiLCJzZXROb3RpZlRpbWVsaW5lU2V0IiwibXhNYXRyaXhDbGllbnRQZWciLCJNYXRyaXhDbGllbnRQZWciXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBbUJBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztB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RCxJQUFuQixDQUFwQixDQWxDa0QsQ0FvQ2xEO0FBQ0E7O0FBQ0EsU0FBS2pELFlBQUwsQ0FBa0I4RixlQUFsQixDQUFrQyxHQUFsQztBQUVBLFNBQUs5RixZQUFMLENBQWtCK0YsUUFBbEIsQ0FBMkJDLE9BQU8sQ0FBQzFFLEtBQUssQ0FBQ2dELEtBQVAsQ0FBbEM7QUFFQSxVQUFNMkIsZ0JBQWdCLEdBQUcsSUFBSUMsa0NBQUosQ0FBcUIsSUFBckIsRUFBMkI7QUFDaERwQixNQUFBQSxlQUFlLEVBQUUsSUFEK0I7QUFFaERxQixNQUFBQSxhQUFhLEVBQUU7QUFGaUMsS0FBM0IsQ0FBekIsQ0ExQ2tELENBOENsRDs7QUFDQUYsSUFBQUEsZ0JBQWdCLENBQUNHLGVBQWpCLEdBQW1DQyxrQkFBbkMsQ0FBc0QsRUFBdEQsRUFBMERDLDZCQUFjQyxTQUF4RTtBQUNBLFNBQUt2RyxZQUFMLENBQWtCd0csbUJBQWxCLENBQXNDUCxnQkFBdEM7QUFDSDs7QUFqTWtEOztBQW9NdkQsSUFBSSxDQUFDMUYsTUFBTSxDQUFDa0csaUJBQVosRUFBK0I7QUFDM0JsRyxFQUFBQSxNQUFNLENBQUNrRyxpQkFBUCxHQUEyQixJQUFJN0csb0JBQUosRUFBM0I7QUFDSDs7QUFFTSxNQUFNOEcsZUFBZSxHQUFHbkcsTUFBTSxDQUFDa0csaUJBQS9CIiwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE1LCAyMDE2IE9wZW5NYXJrZXQgTHRkXG5Db3B5cmlnaHQgMjAxNyBWZWN0b3IgQ3JlYXRpb25zIEx0ZC5cbkNvcHlyaWdodCAyMDE3LCAyMDE4LCAyMDE5IE5ldyBWZWN0b3IgTHRkXG5Db3B5cmlnaHQgMjAxOSwgMjAyMCBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB7IElDcmVhdGVDbGllbnRPcHRzLCBQZW5kaW5nRXZlbnRPcmRlcmluZyB9IGZyb20gJ21hdHJpeC1qcy1zZGsvc3JjL21hdHJpeCc7XG5pbXBvcnQgeyBJU3RhcnRDbGllbnRPcHRzLCBNYXRyaXhDbGllbnQgfSBmcm9tICdtYXRyaXgtanMtc2RrL3NyYy9jbGllbnQnO1xuaW1wb3J0IHsgTWVtb3J5U3RvcmUgfSBmcm9tICdtYXRyaXgtanMtc2RrL3NyYy9zdG9yZS9tZW1vcnknO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnbWF0cml4LWpzLXNkay9zcmMvdXRpbHMnO1xuaW1wb3J0IHsgRXZlbnRUaW1lbGluZSB9IGZyb20gJ21hdHJpeC1qcy1zZGsvc3JjL21vZGVscy9ldmVudC10aW1lbGluZSc7XG5pbXBvcnQgeyBFdmVudFRpbWVsaW5lU2V0IH0gZnJvbSAnbWF0cml4LWpzLXNkay9zcmMvbW9kZWxzL2V2ZW50LXRpbWVsaW5lLXNldCc7XG5pbXBvcnQgKiBhcyBzZGsgZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgY3JlYXRlTWF0cml4Q2xpZW50IGZyb20gJy4vdXRpbHMvY3JlYXRlTWF0cml4Q2xpZW50JztcbmltcG9ydCBTZXR0aW5nc1N0b3JlIGZyb20gJy4vc2V0dGluZ3MvU2V0dGluZ3NTdG9yZSc7XG5pbXBvcnQgTWF0cml4QWN0aW9uQ3JlYXRvcnMgZnJvbSAnLi9hY3Rpb25zL01hdHJpeEFjdGlvbkNyZWF0b3JzJztcbmltcG9ydCBNb2RhbCBmcm9tICcuL01vZGFsJztcbmltcG9ydCB7IHZlcmlmaWNhdGlvbk1ldGhvZHMgfSBmcm9tICdtYXRyaXgtanMtc2RrL3NyYy9jcnlwdG8nO1xuaW1wb3J0IE1hdHJpeENsaWVudEJhY2tlZFNldHRpbmdzSGFuZGxlciBmcm9tIFwiLi9zZXR0aW5ncy9oYW5kbGVycy9NYXRyaXhDbGllbnRCYWNrZWRTZXR0aW5nc0hhbmRsZXJcIjtcbmltcG9ydCAqIGFzIFN0b3JhZ2VNYW5hZ2VyIGZyb20gJy4vdXRpbHMvU3RvcmFnZU1hbmFnZXInO1xuaW1wb3J0IElkZW50aXR5QXV0aENsaWVudCBmcm9tICcuL0lkZW50aXR5QXV0aENsaWVudCc7XG5pbXBvcnQgeyBjcm9zc1NpZ25pbmdDYWxsYmFja3MsIHRyeVRvVW5sb2NrU2VjcmV0U3RvcmFnZVdpdGhEZWh5ZHJhdGlvbktleSB9IGZyb20gJy4vU2VjdXJpdHlNYW5hZ2VyJztcbmltcG9ydCB7IFNIT1dfUVJfQ09ERV9NRVRIT0QgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvY3J5cHRvL3ZlcmlmaWNhdGlvbi9RUkNvZGVcIjtcbmltcG9ydCBTZWN1cml0eUN1c3RvbWlzYXRpb25zIGZyb20gXCIuL2N1c3RvbWlzYXRpb25zL1NlY3VyaXR5XCI7XG5cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9sb2dnZXJcIjtcblxuZXhwb3J0IGludGVyZmFjZSBJTWF0cml4Q2xpZW50Q3JlZHMge1xuICAgIGhvbWVzZXJ2ZXJVcmw6IHN0cmluZztcbiAgICBpZGVudGl0eVNlcnZlclVybDogc3RyaW5nO1xuICAgIHVzZXJJZDogc3RyaW5nO1xuICAgIGRldmljZUlkPzogc3RyaW5nO1xuICAgIGFjY2Vzc1Rva2VuOiBzdHJpbmc7XG4gICAgZ3Vlc3Q/OiBib29sZWFuO1xuICAgIHBpY2tsZUtleT86IHN0cmluZztcbiAgICBmcmVzaExvZ2luPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJTWF0cml4Q2xpZW50UGVnIHtcbiAgICBvcHRzOiBJU3RhcnRDbGllbnRPcHRzO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBzZXJ2ZXIgbmFtZSBvZiB0aGUgdXNlcidzIGhvbWVzZXJ2ZXJcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgdW5hYmxlIHRvIGRlZHVjZSB0aGUgaG9tZXNlcnZlciBuYW1lXG4gICAgICogKGVnLiBpZiB0aGUgdXNlciBpcyBub3QgbG9nZ2VkIGluKVxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGhvbWVzZXJ2ZXIgbmFtZSwgaWYgcHJlc2VudC5cbiAgICAgKi9cbiAgICBnZXRIb21lc2VydmVyTmFtZSgpOiBzdHJpbmc7XG5cbiAgICBnZXQoKTogTWF0cml4Q2xpZW50O1xuICAgIHVuc2V0KCk6IHZvaWQ7XG4gICAgYXNzaWduKCk6IFByb21pc2U8YW55PjtcbiAgICBzdGFydCgpOiBQcm9taXNlPGFueT47XG5cbiAgICBnZXRDcmVkZW50aWFscygpOiBJTWF0cml4Q2xpZW50Q3JlZHM7XG5cbiAgICAvKipcbiAgICAgKiBJZiB3ZSd2ZSByZWdpc3RlcmVkIGEgdXNlciBJRCB3ZSBzZXQgdGhpcyB0byB0aGUgSUQgb2YgdGhlXG4gICAgICogdXNlciB3ZSd2ZSBqdXN0IHJlZ2lzdGVyZWQuIElmIHRoZXkgdGhlbiBnbyAmIGxvZyBpbiwgd2VcbiAgICAgKiBjYW4gc2VuZCB0aGVtIHRvIHRoZSB3ZWxjb21lIHVzZXIgKG9idmlvdXNseSB0aGlzIGRvZXNuJ3RcbiAgICAgKiBndWFyZW50ZWUgdGhleSdsbCBnZXQgYSBjaGF0IHdpdGggdGhlIHdlbGNvbWUgdXNlcikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdWlkIFRoZSB1c2VyIElEIG9mIHRoZSB1c2VyIHdlJ3ZlIGp1c3QgcmVnaXN0ZXJlZFxuICAgICAqL1xuICAgIHNldEp1c3RSZWdpc3RlcmVkVXNlcklkKHVpZDogc3RyaW5nKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCB1c2VyIGhhcyBqdXN0IGJlZW4gcmVnaXN0ZXJlZCBieSB0aGlzXG4gICAgICogY2xpZW50IGFzIGRldGVybWluZWQgYnkgc2V0SnVzdFJlZ2lzdGVyZWRVc2VySWQoKVxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2x9IFRydWUgaWYgdXNlciBoYXMganVzdCBiZWVuIHJlZ2lzdGVyZWRcbiAgICAgKi9cbiAgICBjdXJyZW50VXNlcklzSnVzdFJlZ2lzdGVyZWQoKTogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBjdXJyZW50IHVzZXIgaGFzIGJlZW4gcmVnaXN0ZXJlZCBieSB0aGlzIGRldmljZSB0aGVuIHRoaXNcbiAgICAgKiByZXR1cm5zIGEgYm9vbGVhbiBvZiB3aGV0aGVyIGl0IHdhcyB3aXRoaW4gdGhlIGxhc3QgTiBob3VycyBnaXZlbi5cbiAgICAgKi9cbiAgICB1c2VyUmVnaXN0ZXJlZFdpdGhpbkxhc3RIb3Vycyhob3VyczogbnVtYmVyKTogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2UgdGhpcyBNYXRyaXhDbGllbnRQZWcncyBjbGllbnQgd2l0aCBhIGNsaWVudCBpbnN0YW5jZSB0aGF0IGhhc1xuICAgICAqIGhvbWVzZXJ2ZXIgLyBpZGVudGl0eSBzZXJ2ZXIgVVJMcyBhbmQgYWN0aXZlIGNyZWRlbnRpYWxzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lNYXRyaXhDbGllbnRDcmVkc30gY3JlZHMgVGhlIG5ldyBjcmVkZW50aWFscyB0byB1c2UuXG4gICAgICovXG4gICAgcmVwbGFjZVVzaW5nQ3JlZHMoY3JlZHM6IElNYXRyaXhDbGllbnRDcmVkcyk6IHZvaWQ7XG59XG5cbi8qKlxuICogV3JhcHBlciBvYmplY3QgZm9yIGhhbmRsaW5nIHRoZSBqcy1zZGsgTWF0cml4IENsaWVudCBvYmplY3QgaW4gdGhlIHJlYWN0LXNka1xuICogSGFuZGxlcyB0aGUgY3JlYXRpb24vaW5pdGlhbGlzYXRpb24gb2YgY2xpZW50IG9iamVjdHMuXG4gKiBUaGlzIG1vZHVsZSBwcm92aWRlcyBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIHNvIHRoZSAnY3VycmVudCdcbiAqIE1hdHJpeCBDbGllbnQgb2JqZWN0IGlzIGF2YWlsYWJsZSBlYXNpbHkuXG4gKi9cbmNsYXNzIE1hdHJpeENsaWVudFBlZ0NsYXNzIGltcGxlbWVudHMgSU1hdHJpeENsaWVudFBlZyB7XG4gICAgLy8gVGhlc2UgYXJlIHRoZSBkZWZhdWx0IG9wdGlvbnMgdXNlZCB3aGVuIHdoZW4gdGhlXG4gICAgLy8gY2xpZW50IGlzIHN0YXJ0ZWQgaW4gJ3N0YXJ0Jy4gVGhlc2UgY2FuIGJlIGFsdGVyZWRcbiAgICAvLyBhdCBhbnkgdGltZSB1cCB0byBhZnRlciB0aGUgJ3dpbGxfc3RhcnRfY2xpZW50J1xuICAgIC8vIGV2ZW50IGlzIGZpbmlzaGVkIHByb2Nlc3NpbmcuXG4gICAgcHVibGljIG9wdHM6IElTdGFydENsaWVudE9wdHMgPSB7XG4gICAgICAgIGluaXRpYWxTeW5jTGltaXQ6IDIwLFxuICAgIH07XG5cbiAgICBwcml2YXRlIG1hdHJpeENsaWVudDogTWF0cml4Q2xpZW50ID0gbnVsbDtcbiAgICBwcml2YXRlIGp1c3RSZWdpc3RlcmVkVXNlcklkOiBzdHJpbmc7XG5cbiAgICAvLyB0aGUgY3JlZGVudGlhbHMgdXNlZCB0byBpbml0IHRoZSBjdXJyZW50IGNsaWVudCBvYmplY3QuXG4gICAgLy8gdXNlZCBpZiB3ZSB0ZWFyIGl0IGRvd24gJiByZWNyZWF0ZSBpdCB3aXRoIGEgZGlmZmVyZW50IHN0b3JlXG4gICAgcHJpdmF0ZSBjdXJyZW50Q2xpZW50Q3JlZHM6IElNYXRyaXhDbGllbnRDcmVkcztcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQoKTogTWF0cml4Q2xpZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4Q2xpZW50O1xuICAgIH1cblxuICAgIHB1YmxpYyB1bnNldCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tYXRyaXhDbGllbnQgPSBudWxsO1xuXG4gICAgICAgIE1hdHJpeEFjdGlvbkNyZWF0b3JzLnN0b3AoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0SnVzdFJlZ2lzdGVyZWRVc2VySWQodWlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5qdXN0UmVnaXN0ZXJlZFVzZXJJZCA9IHVpZDtcbiAgICAgICAgaWYgKHVpZCkge1xuICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKFwibXhfcmVnaXN0cmF0aW9uX3RpbWVcIiwgU3RyaW5nKG5ldyBEYXRlKCkuZ2V0VGltZSgpKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgY3VycmVudFVzZXJJc0p1c3RSZWdpc3RlcmVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5tYXRyaXhDbGllbnQgJiZcbiAgICAgICAgICAgIHRoaXMubWF0cml4Q2xpZW50LmNyZWRlbnRpYWxzLnVzZXJJZCA9PT0gdGhpcy5qdXN0UmVnaXN0ZXJlZFVzZXJJZFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHB1YmxpYyB1c2VyUmVnaXN0ZXJlZFdpdGhpbkxhc3RIb3Vycyhob3VyczogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUod2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKFwibXhfcmVnaXN0cmF0aW9uX3RpbWVcIikpO1xuICAgICAgICAgICAgcmV0dXJuICgobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBkYXRlLmdldFRpbWUoKSkgLyAzNmU1KSA8PSBob3VycztcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIHJlcGxhY2VVc2luZ0NyZWRzKGNyZWRzOiBJTWF0cml4Q2xpZW50Q3JlZHMpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2xpZW50Q3JlZHMgPSBjcmVkcztcbiAgICAgICAgdGhpcy5jcmVhdGVDbGllbnQoY3JlZHMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBhc3NpZ24oKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgZm9yIChjb25zdCBkYlR5cGUgb2YgWydpbmRleGVkZGInLCAnbWVtb3J5J10pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubWF0cml4Q2xpZW50LnN0b3JlLnN0YXJ0dXAoKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFwiTWF0cml4Q2xpZW50UGVnOiB3YWl0aW5nIGZvciBNYXRyaXhDbGllbnQgc3RvcmUgdG8gaW5pdGlhbGlzZVwiKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRiVHlwZSA9PT0gJ2luZGV4ZWRkYicpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBzdGFydGluZyBtYXRyaXhjbGllbnQgc3RvcmUgLSBmYWxsaW5nIGJhY2sgdG8gbWVtb3J5IHN0b3JlJywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRyaXhDbGllbnQuc3RvcmUgPSBuZXcgTWVtb3J5U3RvcmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlOiBsb2NhbFN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIHN0YXJ0IG1lbW9yeSBzdG9yZSEnLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgU3RvcmFnZU1hbmFnZXIudHJhY2tTdG9yZXModGhpcy5tYXRyaXhDbGllbnQpO1xuXG4gICAgICAgIC8vIHRyeSB0byBpbml0aWFsaXNlIGUyZSBvbiB0aGUgbmV3IGNsaWVudFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gY2hlY2sgdGhhdCB3ZSBoYXZlIGEgdmVyc2lvbiBvZiB0aGUganMtc2RrIHdoaWNoIGluY2x1ZGVzIGluaXRDcnlwdG9cbiAgICAgICAgICAgIGlmICghU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZShcImxvd0JhbmR3aWR0aFwiKSAmJiB0aGlzLm1hdHJpeENsaWVudC5pbml0Q3J5cHRvKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5tYXRyaXhDbGllbnQuaW5pdENyeXB0bygpO1xuICAgICAgICAgICAgICAgIHRoaXMubWF0cml4Q2xpZW50LnNldENyeXB0b1RydXN0Q3Jvc3NTaWduZWREZXZpY2VzKFxuICAgICAgICAgICAgICAgICAgICAhU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZSgnZTJlZS5tYW51YWxseVZlcmlmeUFsbFNlc3Npb25zJyksXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0cnlUb1VubG9ja1NlY3JldFN0b3JhZ2VXaXRoRGVoeWRyYXRpb25LZXkodGhpcy5tYXRyaXhDbGllbnQpO1xuICAgICAgICAgICAgICAgIFN0b3JhZ2VNYW5hZ2VyLnNldENyeXB0b0luaXRpYWxpc2VkKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSAmJiBlLm5hbWUgPT09ICdJbnZhbGlkQ3J5cHRvU3RvcmVFcnJvcicpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUganMtc2RrIGZvdW5kIGEgY3J5cHRvIERCIHRvbyBuZXcgZm9yIGl0IHRvIHVzZVxuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBVc2luZyBhbiBpbXBvcnQgd2lsbCByZXN1bHQgaW4gdGVzdCBmYWlsdXJlc1xuICAgICAgICAgICAgICAgIGNvbnN0IENyeXB0b1N0b3JlVG9vTmV3RGlhbG9nID1cbiAgICAgICAgICAgICAgICAgICAgc2RrLmdldENvbXBvbmVudChcInZpZXdzLmRpYWxvZ3MuQ3J5cHRvU3RvcmVUb29OZXdEaWFsb2dcIik7XG4gICAgICAgICAgICAgICAgTW9kYWwuY3JlYXRlRGlhbG9nKENyeXB0b1N0b3JlVG9vTmV3RGlhbG9nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoaXMgY2FuIGhhcHBlbiBmb3IgYSBudW1iZXIgb2YgcmVhc29ucywgdGhlIG1vc3QgbGlrZWx5IGJlaW5nXG4gICAgICAgICAgICAvLyB0aGF0IHRoZSBvbG0gbGlicmFyeSB3YXMgbWlzc2luZy4gSXQncyBub3QgZmF0YWwuXG4gICAgICAgICAgICBsb2dnZXIud2FybihcIlVuYWJsZSB0byBpbml0aWFsaXNlIGUyZVwiLCBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9wdHMgPSB1dGlscy5kZWVwQ29weSh0aGlzLm9wdHMpO1xuICAgICAgICAvLyB0aGUgcmVhY3Qgc2RrIGRvZXNuJ3Qgd29yayB3aXRob3V0IHRoaXMsIHNvIGRvbid0IGFsbG93XG4gICAgICAgIG9wdHMucGVuZGluZ0V2ZW50T3JkZXJpbmcgPSBQZW5kaW5nRXZlbnRPcmRlcmluZy5EZXRhY2hlZDtcbiAgICAgICAgb3B0cy5sYXp5TG9hZE1lbWJlcnMgPSB0cnVlO1xuICAgICAgICBvcHRzLmNsaWVudFdlbGxLbm93blBvbGxQZXJpb2QgPSAyICogNjAgKiA2MDsgLy8gMiBob3Vyc1xuICAgICAgICBvcHRzLmV4cGVyaW1lbnRhbFRocmVhZFN1cHBvcnQgPSBTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFwiZmVhdHVyZV90aHJlYWRcIik7XG5cbiAgICAgICAgLy8gQ29ubmVjdCB0aGUgbWF0cml4IGNsaWVudCB0byB0aGUgZGlzcGF0Y2hlciBhbmQgc2V0dGluZyBoYW5kbGVyc1xuICAgICAgICBNYXRyaXhBY3Rpb25DcmVhdG9ycy5zdGFydCh0aGlzLm1hdHJpeENsaWVudCk7XG4gICAgICAgIE1hdHJpeENsaWVudEJhY2tlZFNldHRpbmdzSGFuZGxlci5tYXRyaXhDbGllbnQgPSB0aGlzLm1hdHJpeENsaWVudDtcblxuICAgICAgICByZXR1cm4gb3B0cztcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgc3RhcnQoKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IGF3YWl0IHRoaXMuYXNzaWduKCk7XG5cbiAgICAgICAgbG9nZ2VyLmxvZyhgTWF0cml4Q2xpZW50UGVnOiByZWFsbHkgc3RhcnRpbmcgTWF0cml4Q2xpZW50YCk7XG4gICAgICAgIGF3YWl0IHRoaXMuZ2V0KCkuc3RhcnRDbGllbnQob3B0cyk7XG4gICAgICAgIGxvZ2dlci5sb2coYE1hdHJpeENsaWVudFBlZzogTWF0cml4Q2xpZW50IHN0YXJ0ZWRgKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0Q3JlZGVudGlhbHMoKTogSU1hdHJpeENsaWVudENyZWRzIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhvbWVzZXJ2ZXJVcmw6IHRoaXMubWF0cml4Q2xpZW50LmJhc2VVcmwsXG4gICAgICAgICAgICBpZGVudGl0eVNlcnZlclVybDogdGhpcy5tYXRyaXhDbGllbnQuaWRCYXNlVXJsLFxuICAgICAgICAgICAgdXNlcklkOiB0aGlzLm1hdHJpeENsaWVudC5jcmVkZW50aWFscy51c2VySWQsXG4gICAgICAgICAgICBkZXZpY2VJZDogdGhpcy5tYXRyaXhDbGllbnQuZ2V0RGV2aWNlSWQoKSxcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiB0aGlzLm1hdHJpeENsaWVudC5nZXRBY2Nlc3NUb2tlbigpLFxuICAgICAgICAgICAgZ3Vlc3Q6IHRoaXMubWF0cml4Q2xpZW50LmlzR3Vlc3QoKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0SG9tZXNlcnZlck5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IC9eQFteOl0rOiguKykkLy5leGVjKHRoaXMubWF0cml4Q2xpZW50LmNyZWRlbnRpYWxzLnVzZXJJZCk7XG4gICAgICAgIGlmIChtYXRjaGVzID09PSBudWxsIHx8IG1hdGNoZXMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGRlcml2ZSBob21lc2VydmVyIG5hbWUgZnJvbSB1c2VyIElEIVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0Y2hlc1sxXTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNyZWF0ZUNsaWVudChjcmVkczogSU1hdHJpeENsaWVudENyZWRzKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG9wdHM6IElDcmVhdGVDbGllbnRPcHRzID0ge1xuICAgICAgICAgICAgYmFzZVVybDogY3JlZHMuaG9tZXNlcnZlclVybCxcbiAgICAgICAgICAgIGlkQmFzZVVybDogY3JlZHMuaWRlbnRpdHlTZXJ2ZXJVcmwsXG4gICAgICAgICAgICBhY2Nlc3NUb2tlbjogY3JlZHMuYWNjZXNzVG9rZW4sXG4gICAgICAgICAgICB1c2VySWQ6IGNyZWRzLnVzZXJJZCxcbiAgICAgICAgICAgIGRldmljZUlkOiBjcmVkcy5kZXZpY2VJZCxcbiAgICAgICAgICAgIHBpY2tsZUtleTogY3JlZHMucGlja2xlS2V5LFxuICAgICAgICAgICAgdGltZWxpbmVTdXBwb3J0OiB0cnVlLFxuICAgICAgICAgICAgZm9yY2VUVVJOOiAhU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZSgnd2ViUnRjQWxsb3dQZWVyVG9QZWVyJyksXG4gICAgICAgICAgICBmYWxsYmFja0lDRVNlcnZlckFsbG93ZWQ6ICEhU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZSgnZmFsbGJhY2tJQ0VTZXJ2ZXJBbGxvd2VkJyksXG4gICAgICAgICAgICAvLyBHYXRoZXIgdXAgdG8gMjAgSUNFIGNhbmRpZGF0ZXMgd2hlbiBhIGNhbGwgYXJyaXZlczogdGhpcyBzaG91bGQgYmUgbW9yZSB0aGFuIHdlJ2RcbiAgICAgICAgICAgIC8vIGV2ZXIgbm9ybWFsbHkgbmVlZCwgc28gZWZmZWN0aXZlbHkgdGhpcyBzaG91bGQgbWFrZSBhbGwgdGhlIGdhdGhlcmluZyBoYXBwZW4gd2hlblxuICAgICAgICAgICAgLy8gdGhlIGNhbGwgYXJyaXZlcy5cbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZVBvb2xTaXplOiAyMCxcbiAgICAgICAgICAgIHZlcmlmaWNhdGlvbk1ldGhvZHM6IFtcbiAgICAgICAgICAgICAgICB2ZXJpZmljYXRpb25NZXRob2RzLlNBUyxcbiAgICAgICAgICAgICAgICBTSE9XX1FSX0NPREVfTUVUSE9ELFxuICAgICAgICAgICAgICAgIHZlcmlmaWNhdGlvbk1ldGhvZHMuUkVDSVBST0NBVEVfUVJfQ09ERSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB1bnN0YWJsZUNsaWVudFJlbGF0aW9uQWdncmVnYXRpb246IHRydWUsXG4gICAgICAgICAgICBpZGVudGl0eVNlcnZlcjogbmV3IElkZW50aXR5QXV0aENsaWVudCgpLFxuICAgICAgICAgICAgY3J5cHRvQ2FsbGJhY2tzOiB7fSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUaGVzZSBhcmUgYWx3YXlzIGluc3RhbGxlZCByZWdhcmRsZXNzIG9mIHRoZSBsYWJzIGZsYWcgc28gdGhhdFxuICAgICAgICAvLyBjcm9zcy1zaWduaW5nIGZlYXR1cmVzIGNhbiB0b2dnbGUgb24gd2l0aG91dCByZWxvYWRpbmcgYW5kIGFsc28gYmVcbiAgICAgICAgLy8gYWNjZXNzZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgbG9naW4uXG4gICAgICAgIE9iamVjdC5hc3NpZ24ob3B0cy5jcnlwdG9DYWxsYmFja3MsIGNyb3NzU2lnbmluZ0NhbGxiYWNrcyk7XG4gICAgICAgIGlmIChTZWN1cml0eUN1c3RvbWlzYXRpb25zLmdldERlaHlkcmF0aW9uS2V5KSB7XG4gICAgICAgICAgICBvcHRzLmNyeXB0b0NhbGxiYWNrcy5nZXREZWh5ZHJhdGlvbktleSA9XG4gICAgICAgICAgICAgICAgU2VjdXJpdHlDdXN0b21pc2F0aW9ucy5nZXREZWh5ZHJhdGlvbktleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWF0cml4Q2xpZW50ID0gY3JlYXRlTWF0cml4Q2xpZW50KG9wdHMpO1xuXG4gICAgICAgIC8vIHdlJ3JlIGdvaW5nIHRvIGFkZCBldmVudGxpc3RlbmVycyBmb3IgZWFjaCBtYXRyaXggZXZlbnQgdGlsZSwgc28gdGhlXG4gICAgICAgIC8vIHBvdGVudGlhbCBudW1iZXIgb2YgZXZlbnQgbGlzdGVuZXJzIGlzIHF1aXRlIGhpZ2guXG4gICAgICAgIHRoaXMubWF0cml4Q2xpZW50LnNldE1heExpc3RlbmVycyg1MDApO1xuXG4gICAgICAgIHRoaXMubWF0cml4Q2xpZW50LnNldEd1ZXN0KEJvb2xlYW4oY3JlZHMuZ3Vlc3QpKTtcblxuICAgICAgICBjb25zdCBub3RpZlRpbWVsaW5lU2V0ID0gbmV3IEV2ZW50VGltZWxpbmVTZXQobnVsbCwge1xuICAgICAgICAgICAgdGltZWxpbmVTdXBwb3J0OiB0cnVlLFxuICAgICAgICAgICAgcGVuZGluZ0V2ZW50czogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBYWFg6IHdoYXQgaXMgb3VyIGluaXRpYWwgcGFnaW5hdGlvbiB0b2tlbj8hIGl0IHNvbWVob3cgbmVlZHMgdG8gYmUgc3luY2hyb25pc2VkIHdpdGggL3N5bmMuXG4gICAgICAgIG5vdGlmVGltZWxpbmVTZXQuZ2V0TGl2ZVRpbWVsaW5lKCkuc2V0UGFnaW5hdGlvblRva2VuKFwiXCIsIEV2ZW50VGltZWxpbmUuQkFDS1dBUkRTKTtcbiAgICAgICAgdGhpcy5tYXRyaXhDbGllbnQuc2V0Tm90aWZUaW1lbGluZVNldChub3RpZlRpbWVsaW5lU2V0KTtcbiAgICB9XG59XG5cbmlmICghd2luZG93Lm14TWF0cml4Q2xpZW50UGVnKSB7XG4gICAgd2luZG93Lm14TWF0cml4Q2xpZW50UGVnID0gbmV3IE1hdHJpeENsaWVudFBlZ0NsYXNzKCk7XG59XG5cbmV4cG9ydCBjb25zdCBNYXRyaXhDbGllbnRQZWcgPSB3aW5kb3cubXhNYXRyaXhDbGllbnRQZWc7XG4iXX0=