"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DecryptionFailureTracker = exports.DecryptionFailure = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/*
Copyright 2018 - 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
class DecryptionFailure {
  constructor(failedEventId, errorCode) {
    this.failedEventId = failedEventId;
    this.errorCode = errorCode;
    (0, _defineProperty2.default)(this, "ts", void 0);
    this.ts = Date.now();
  }

}

exports.DecryptionFailure = DecryptionFailure;

class DecryptionFailureTracker {
  // Array of items of type DecryptionFailure. Every `CHECK_INTERVAL_MS`, this list
  // is checked for failures that happened > `GRACE_PERIOD_MS` ago. Those that did
  // are accumulated in `failureCounts`.
  // A histogram of the number of failures that will be tracked at the next tracking
  // interval, split by failure error code.
  // Event IDs of failures that were tracked previously
  // Set to an interval ID when `start` is called
  // Spread the load on `Analytics` by tracking at a low frequency, `TRACK_INTERVAL_MS`.
  // Call `checkFailures` every `CHECK_INTERVAL_MS`.
  // Give events a chance to be decrypted by waiting `GRACE_PERIOD_MS` before counting
  // the failure in `failureCounts`.

  /**
   * Create a new DecryptionFailureTracker.
   *
   * Call `eventDecrypted(event, err)` on this instance when an event is decrypted.
   *
   * Call `start()` to start the tracker, and `stop()` to stop tracking.
   *
   * @param {function} fn The tracking function, which will be called when failures
   * are tracked. The function should have a signature `(count, trackedErrorCode) => {...}`,
   * where `count` is the number of failures and `errorCode` matches the `.code` of
   * provided DecryptionError errors (by default, unless `errorCodeMapFn` is specified.
   * @param {function?} errorCodeMapFn The function used to map error codes to the
   * trackedErrorCode. If not provided, the `.code` of errors will be used.
   */
  constructor(fn, errorCodeMapFn) {
    this.fn = fn;
    this.errorCodeMapFn = errorCodeMapFn;
    (0, _defineProperty2.default)(this, "failures", []);
    (0, _defineProperty2.default)(this, "failureCounts", {// [errorCode]: 42
    });
    (0, _defineProperty2.default)(this, "trackedEventHashMap", {// [eventId]: true
    });
    (0, _defineProperty2.default)(this, "checkInterval", null);
    (0, _defineProperty2.default)(this, "trackInterval", null);

    if (!fn || typeof fn !== 'function') {
      throw new Error('DecryptionFailureTracker requires tracking function');
    }

    if (errorCodeMapFn && typeof errorCodeMapFn !== 'function') {
      throw new Error('DecryptionFailureTracker second constructor argument should be a function');
    }
  } // loadTrackedEventHashMap() {
  //     this.trackedEventHashMap = JSON.parse(localStorage.getItem('mx-decryption-failure-event-id-hashes')) || {};
  // }
  // saveTrackedEventHashMap() {
  //     localStorage.setItem('mx-decryption-failure-event-id-hashes', JSON.stringify(this.trackedEventHashMap));
  // }


  eventDecrypted(e, err) {
    if (err) {
      this.addDecryptionFailure(new DecryptionFailure(e.getId(), err.code));
    } else {
      // Could be an event in the failures, remove it
      this.removeDecryptionFailuresForEvent(e);
    }
  }

  addDecryptionFailure(failure) {
    this.failures.push(failure);
  }

  removeDecryptionFailuresForEvent(e) {
    this.failures = this.failures.filter(f => f.failedEventId !== e.getId());
  }
  /**
   * Start checking for and tracking failures.
   */


  start() {
    this.checkInterval = setInterval(() => this.checkFailures(Date.now()), DecryptionFailureTracker.CHECK_INTERVAL_MS);
    this.trackInterval = setInterval(() => this.trackFailures(), DecryptionFailureTracker.TRACK_INTERVAL_MS);
  }
  /**
   * Clear state and stop checking for and tracking failures.
   */


  stop() {
    clearInterval(this.checkInterval);
    clearInterval(this.trackInterval);
    this.failures = [];
    this.failureCounts = {};
  }
  /**
   * Mark failures that occurred before nowTs - GRACE_PERIOD_MS as failures that should be
   * tracked. Only mark one failure per event ID.
   * @param {number} nowTs the timestamp that represents the time now.
   */


  checkFailures(nowTs) {
    const failuresGivenGrace = [];
    const failuresNotReady = [];

    while (this.failures.length > 0) {
      const f = this.failures.shift();

      if (nowTs > f.ts + DecryptionFailureTracker.GRACE_PERIOD_MS) {
        failuresGivenGrace.push(f);
      } else {
        failuresNotReady.push(f);
      }
    }

    this.failures = failuresNotReady; // Only track one failure per event

    const dedupedFailuresMap = failuresGivenGrace.reduce((map, failure) => {
      if (!this.trackedEventHashMap[failure.failedEventId]) {
        return map.set(failure.failedEventId, failure);
      } else {
        return map;
      }
    }, // Use a map to preseve key ordering
    new Map());
    const trackedEventIds = [...dedupedFailuresMap.keys()];
    this.trackedEventHashMap = trackedEventIds.reduce((result, eventId) => _objectSpread(_objectSpread({}, result), {}, {
      [eventId]: true
    }), this.trackedEventHashMap); // Commented out for now for expediency, we need to consider unbound nature of storing
    // this in localStorage
    // this.saveTrackedEventHashMap();

    const dedupedFailures = dedupedFailuresMap.values();
    this.aggregateFailures(dedupedFailures);
  }

  aggregateFailures(failures) {
    for (const failure of failures) {
      const errorCode = failure.errorCode;
      this.failureCounts[errorCode] = (this.failureCounts[errorCode] || 0) + 1;
    }
  }
  /**
   * If there are failures that should be tracked, call the given trackDecryptionFailure
   * function with the number of failures that should be tracked.
   */


  trackFailures() {
    for (const errorCode of Object.keys(this.failureCounts)) {
      if (this.failureCounts[errorCode] > 0) {
        const trackedErrorCode = this.errorCodeMapFn ? this.errorCodeMapFn(errorCode) : errorCode;
        this.fn(this.failureCounts[errorCode], trackedErrorCode);
        this.failureCounts[errorCode] = 0;
      }
    }
  }

}

exports.DecryptionFailureTracker = DecryptionFailureTracker;
(0, _defineProperty2.default)(DecryptionFailureTracker, "TRACK_INTERVAL_MS", 60000);
(0, _defineProperty2.default)(DecryptionFailureTracker, "CHECK_INTERVAL_MS", 5000);
(0, _defineProperty2.default)(DecryptionFailureTracker, "GRACE_PERIOD_MS", 60000);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9EZWNyeXB0aW9uRmFpbHVyZVRyYWNrZXIudHMiXSwibmFtZXMiOlsiRGVjcnlwdGlvbkZhaWx1cmUiLCJjb25zdHJ1Y3RvciIsImZhaWxlZEV2ZW50SWQiLCJlcnJvckNvZGUiLCJ0cyIsIkRhdGUiLCJub3ciLCJEZWNyeXB0aW9uRmFpbHVyZVRyYWNrZXIiLCJmbiIsImVycm9yQ29kZU1hcEZuIiwiRXJyb3IiLCJldmVudERlY3J5cHRlZCIsImUiLCJlcnIiLCJhZGREZWNyeXB0aW9uRmFpbHVyZSIsImdldElkIiwiY29kZSIsInJlbW92ZURlY3J5cHRpb25GYWlsdXJlc0ZvckV2ZW50IiwiZmFpbHVyZSIsImZhaWx1cmVzIiwicHVzaCIsImZpbHRlciIsImYiLCJzdGFydCIsImNoZWNrSW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNoZWNrRmFpbHVyZXMiLCJDSEVDS19JTlRFUlZBTF9NUyIsInRyYWNrSW50ZXJ2YWwiLCJ0cmFja0ZhaWx1cmVzIiwiVFJBQ0tfSU5URVJWQUxfTVMiLCJzdG9wIiwiY2xlYXJJbnRlcnZhbCIsImZhaWx1cmVDb3VudHMiLCJub3dUcyIsImZhaWx1cmVzR2l2ZW5HcmFjZSIsImZhaWx1cmVzTm90UmVhZHkiLCJsZW5ndGgiLCJzaGlmdCIsIkdSQUNFX1BFUklPRF9NUyIsImRlZHVwZWRGYWlsdXJlc01hcCIsInJlZHVjZSIsIm1hcCIsInRyYWNrZWRFdmVudEhhc2hNYXAiLCJzZXQiLCJNYXAiLCJ0cmFja2VkRXZlbnRJZHMiLCJrZXlzIiwicmVzdWx0IiwiZXZlbnRJZCIsImRlZHVwZWRGYWlsdXJlcyIsInZhbHVlcyIsImFnZ3JlZ2F0ZUZhaWx1cmVzIiwiT2JqZWN0IiwidHJhY2tlZEVycm9yQ29kZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS08sTUFBTUEs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ZUFBZSxHQUFHVixrQkFBa0IsQ0FBQ1csTUFBbkIsRUFBeEI7QUFFQSxTQUFLQyxpQkFBTCxDQUF1QkYsZUFBdkI7QUFDSDs7QUFFT0UsRUFBQUEsaUJBQWlCLENBQUNqQyxRQUFELEVBQXNDO0FBQzNELFNBQUssTUFBTUQsT0FBWCxJQUFzQkMsUUFBdEIsRUFBZ0M7QUFDNUIsWUFBTWhCLFNBQVMsR0FBR2UsT0FBTyxDQUFDZixTQUExQjtBQUNBLFdBQUs4QixhQUFMLENBQW1COUIsU0FBbkIsSUFBZ0MsQ0FBQyxLQUFLOEIsYUFBTCxDQUFtQjlCLFNBQW5CLEtBQWlDLENBQWxDLElBQXVDLENBQXZFO0FBQ0g7QUFDSjtBQUVEO0FBQ0o7QUFDQTtBQUNBOzs7QUFDVzBCLEVBQUFBLGFBQWEsR0FBUztBQUN6QixTQUFLLE1BQU0xQixTQUFYLElBQXdCa0QsTUFBTSxDQUFDTixJQUFQLENBQVksS0FBS2QsYUFBakIsQ0FBeEIsRUFBeUQ7QUFDckQsVUFBSSxLQUFLQSxhQUFMLENBQW1COUIsU0FBbkIsSUFBZ0MsQ0FBcEMsRUFBdUM7QUFDbkMsY0FBTW1ELGdCQUFnQixHQUFHLEtBQUs3QyxjQUFMLEdBQXNCLEtBQUtBLGNBQUwsQ0FBb0JOLFNBQXBCLENBQXRCLEdBQXVEQSxTQUFoRjtBQUVBLGFBQUtLLEVBQUwsQ0FBUSxLQUFLeUIsYUFBTCxDQUFtQjlCLFNBQW5CLENBQVIsRUFBdUNtRCxnQkFBdkM7QUFDQSxhQUFLckIsYUFBTCxDQUFtQjlCLFNBQW5CLElBQWdDLENBQWhDO0FBQ0g7QUFDSjtBQUNKOztBQTdLaUM7Ozs4QkFBekJJLHdCLHVCQXNCa0IsSzs4QkF0QmxCQSx3Qix1QkF5QmtCLEk7OEJBekJsQkEsd0IscUJBNkJnQixLIiwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE4IC0gMjAyMSBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB7IE1hdHJpeEVycm9yIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL2h0dHAtYXBpXCI7XG5pbXBvcnQgeyBNYXRyaXhFdmVudCB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9tb2RlbHMvZXZlbnRcIjtcblxuZXhwb3J0IGNsYXNzIERlY3J5cHRpb25GYWlsdXJlIHtcbiAgICBwdWJsaWMgcmVhZG9ubHkgdHM6IG51bWJlcjtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBmYWlsZWRFdmVudElkOiBzdHJpbmcsIHB1YmxpYyByZWFkb25seSBlcnJvckNvZGU6IHN0cmluZykge1xuICAgICAgICB0aGlzLnRzID0gRGF0ZS5ub3coKTtcbiAgICB9XG59XG5cbnR5cGUgVHJhY2tpbmdGbiA9IChjb3VudDogbnVtYmVyLCB0cmFja2VkRXJyQ29kZTogc3RyaW5nKSA9PiB2b2lkO1xudHlwZSBFcnJDb2RlTWFwRm4gPSAoZXJyY29kZTogc3RyaW5nKSA9PiBzdHJpbmc7XG5cbmV4cG9ydCBjbGFzcyBEZWNyeXB0aW9uRmFpbHVyZVRyYWNrZXIge1xuICAgIC8vIEFycmF5IG9mIGl0ZW1zIG9mIHR5cGUgRGVjcnlwdGlvbkZhaWx1cmUuIEV2ZXJ5IGBDSEVDS19JTlRFUlZBTF9NU2AsIHRoaXMgbGlzdFxuICAgIC8vIGlzIGNoZWNrZWQgZm9yIGZhaWx1cmVzIHRoYXQgaGFwcGVuZWQgPiBgR1JBQ0VfUEVSSU9EX01TYCBhZ28uIFRob3NlIHRoYXQgZGlkXG4gICAgLy8gYXJlIGFjY3VtdWxhdGVkIGluIGBmYWlsdXJlQ291bnRzYC5cbiAgICBwdWJsaWMgZmFpbHVyZXM6IERlY3J5cHRpb25GYWlsdXJlW10gPSBbXTtcblxuICAgIC8vIEEgaGlzdG9ncmFtIG9mIHRoZSBudW1iZXIgb2YgZmFpbHVyZXMgdGhhdCB3aWxsIGJlIHRyYWNrZWQgYXQgdGhlIG5leHQgdHJhY2tpbmdcbiAgICAvLyBpbnRlcnZhbCwgc3BsaXQgYnkgZmFpbHVyZSBlcnJvciBjb2RlLlxuICAgIHB1YmxpYyBmYWlsdXJlQ291bnRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge1xuICAgICAgICAvLyBbZXJyb3JDb2RlXTogNDJcbiAgICB9O1xuXG4gICAgLy8gRXZlbnQgSURzIG9mIGZhaWx1cmVzIHRoYXQgd2VyZSB0cmFja2VkIHByZXZpb3VzbHlcbiAgICBwdWJsaWMgdHJhY2tlZEV2ZW50SGFzaE1hcDogUmVjb3JkPHN0cmluZywgYm9vbGVhbj4gPSB7XG4gICAgICAgIC8vIFtldmVudElkXTogdHJ1ZVxuICAgIH07XG5cbiAgICAvLyBTZXQgdG8gYW4gaW50ZXJ2YWwgSUQgd2hlbiBgc3RhcnRgIGlzIGNhbGxlZFxuICAgIHB1YmxpYyBjaGVja0ludGVydmFsOiBudW1iZXIgPSBudWxsO1xuICAgIHB1YmxpYyB0cmFja0ludGVydmFsOiBudW1iZXIgPSBudWxsO1xuXG4gICAgLy8gU3ByZWFkIHRoZSBsb2FkIG9uIGBBbmFseXRpY3NgIGJ5IHRyYWNraW5nIGF0IGEgbG93IGZyZXF1ZW5jeSwgYFRSQUNLX0lOVEVSVkFMX01TYC5cbiAgICBzdGF0aWMgVFJBQ0tfSU5URVJWQUxfTVMgPSA2MDAwMDtcblxuICAgIC8vIENhbGwgYGNoZWNrRmFpbHVyZXNgIGV2ZXJ5IGBDSEVDS19JTlRFUlZBTF9NU2AuXG4gICAgc3RhdGljIENIRUNLX0lOVEVSVkFMX01TID0gNTAwMDtcblxuICAgIC8vIEdpdmUgZXZlbnRzIGEgY2hhbmNlIHRvIGJlIGRlY3J5cHRlZCBieSB3YWl0aW5nIGBHUkFDRV9QRVJJT0RfTVNgIGJlZm9yZSBjb3VudGluZ1xuICAgIC8vIHRoZSBmYWlsdXJlIGluIGBmYWlsdXJlQ291bnRzYC5cbiAgICBzdGF0aWMgR1JBQ0VfUEVSSU9EX01TID0gNjAwMDA7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgRGVjcnlwdGlvbkZhaWx1cmVUcmFja2VyLlxuICAgICAqXG4gICAgICogQ2FsbCBgZXZlbnREZWNyeXB0ZWQoZXZlbnQsIGVycilgIG9uIHRoaXMgaW5zdGFuY2Ugd2hlbiBhbiBldmVudCBpcyBkZWNyeXB0ZWQuXG4gICAgICpcbiAgICAgKiBDYWxsIGBzdGFydCgpYCB0byBzdGFydCB0aGUgdHJhY2tlciwgYW5kIGBzdG9wKClgIHRvIHN0b3AgdHJhY2tpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBUaGUgdHJhY2tpbmcgZnVuY3Rpb24sIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdoZW4gZmFpbHVyZXNcbiAgICAgKiBhcmUgdHJhY2tlZC4gVGhlIGZ1bmN0aW9uIHNob3VsZCBoYXZlIGEgc2lnbmF0dXJlIGAoY291bnQsIHRyYWNrZWRFcnJvckNvZGUpID0+IHsuLi59YCxcbiAgICAgKiB3aGVyZSBgY291bnRgIGlzIHRoZSBudW1iZXIgb2YgZmFpbHVyZXMgYW5kIGBlcnJvckNvZGVgIG1hdGNoZXMgdGhlIGAuY29kZWAgb2ZcbiAgICAgKiBwcm92aWRlZCBEZWNyeXB0aW9uRXJyb3IgZXJyb3JzIChieSBkZWZhdWx0LCB1bmxlc3MgYGVycm9yQ29kZU1hcEZuYCBpcyBzcGVjaWZpZWQuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbj99IGVycm9yQ29kZU1hcEZuIFRoZSBmdW5jdGlvbiB1c2VkIHRvIG1hcCBlcnJvciBjb2RlcyB0byB0aGVcbiAgICAgKiB0cmFja2VkRXJyb3JDb2RlLiBJZiBub3QgcHJvdmlkZWQsIHRoZSBgLmNvZGVgIG9mIGVycm9ycyB3aWxsIGJlIHVzZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBmbjogVHJhY2tpbmdGbiwgcHJpdmF0ZSByZWFkb25seSBlcnJvckNvZGVNYXBGbj86IEVyckNvZGVNYXBGbikge1xuICAgICAgICBpZiAoIWZuIHx8IHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNyeXB0aW9uRmFpbHVyZVRyYWNrZXIgcmVxdWlyZXMgdHJhY2tpbmcgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvckNvZGVNYXBGbiAmJiB0eXBlb2YgZXJyb3JDb2RlTWFwRm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjcnlwdGlvbkZhaWx1cmVUcmFja2VyIHNlY29uZCBjb25zdHJ1Y3RvciBhcmd1bWVudCBzaG91bGQgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gbG9hZFRyYWNrZWRFdmVudEhhc2hNYXAoKSB7XG4gICAgLy8gICAgIHRoaXMudHJhY2tlZEV2ZW50SGFzaE1hcCA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ214LWRlY3J5cHRpb24tZmFpbHVyZS1ldmVudC1pZC1oYXNoZXMnKSkgfHwge307XG4gICAgLy8gfVxuXG4gICAgLy8gc2F2ZVRyYWNrZWRFdmVudEhhc2hNYXAoKSB7XG4gICAgLy8gICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdteC1kZWNyeXB0aW9uLWZhaWx1cmUtZXZlbnQtaWQtaGFzaGVzJywgSlNPTi5zdHJpbmdpZnkodGhpcy50cmFja2VkRXZlbnRIYXNoTWFwKSk7XG4gICAgLy8gfVxuXG4gICAgcHVibGljIGV2ZW50RGVjcnlwdGVkKGU6IE1hdHJpeEV2ZW50LCBlcnI6IE1hdHJpeEVycm9yIHwgRXJyb3IpOiB2b2lkIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhpcy5hZGREZWNyeXB0aW9uRmFpbHVyZShuZXcgRGVjcnlwdGlvbkZhaWx1cmUoZS5nZXRJZCgpLCBlcnIuY29kZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ291bGQgYmUgYW4gZXZlbnQgaW4gdGhlIGZhaWx1cmVzLCByZW1vdmUgaXRcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRGVjcnlwdGlvbkZhaWx1cmVzRm9yRXZlbnQoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgYWRkRGVjcnlwdGlvbkZhaWx1cmUoZmFpbHVyZTogRGVjcnlwdGlvbkZhaWx1cmUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5mYWlsdXJlcy5wdXNoKGZhaWx1cmUpO1xuICAgIH1cblxuICAgIHB1YmxpYyByZW1vdmVEZWNyeXB0aW9uRmFpbHVyZXNGb3JFdmVudChlOiBNYXRyaXhFdmVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLmZhaWx1cmVzID0gdGhpcy5mYWlsdXJlcy5maWx0ZXIoKGYpID0+IGYuZmFpbGVkRXZlbnRJZCAhPT0gZS5nZXRJZCgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBjaGVja2luZyBmb3IgYW5kIHRyYWNraW5nIGZhaWx1cmVzLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGFydCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jaGVja0ludGVydmFsID0gc2V0SW50ZXJ2YWwoXG4gICAgICAgICAgICAoKSA9PiB0aGlzLmNoZWNrRmFpbHVyZXMoRGF0ZS5ub3coKSksXG4gICAgICAgICAgICBEZWNyeXB0aW9uRmFpbHVyZVRyYWNrZXIuQ0hFQ0tfSU5URVJWQUxfTVMsXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy50cmFja0ludGVydmFsID0gc2V0SW50ZXJ2YWwoXG4gICAgICAgICAgICAoKSA9PiB0aGlzLnRyYWNrRmFpbHVyZXMoKSxcbiAgICAgICAgICAgIERlY3J5cHRpb25GYWlsdXJlVHJhY2tlci5UUkFDS19JTlRFUlZBTF9NUyxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBzdGF0ZSBhbmQgc3RvcCBjaGVja2luZyBmb3IgYW5kIHRyYWNraW5nIGZhaWx1cmVzLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdG9wKCk6IHZvaWQge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuY2hlY2tJbnRlcnZhbCk7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50cmFja0ludGVydmFsKTtcblxuICAgICAgICB0aGlzLmZhaWx1cmVzID0gW107XG4gICAgICAgIHRoaXMuZmFpbHVyZUNvdW50cyA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcmsgZmFpbHVyZXMgdGhhdCBvY2N1cnJlZCBiZWZvcmUgbm93VHMgLSBHUkFDRV9QRVJJT0RfTVMgYXMgZmFpbHVyZXMgdGhhdCBzaG91bGQgYmVcbiAgICAgKiB0cmFja2VkLiBPbmx5IG1hcmsgb25lIGZhaWx1cmUgcGVyIGV2ZW50IElELlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBub3dUcyB0aGUgdGltZXN0YW1wIHRoYXQgcmVwcmVzZW50cyB0aGUgdGltZSBub3cuXG4gICAgICovXG4gICAgcHVibGljIGNoZWNrRmFpbHVyZXMobm93VHM6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBjb25zdCBmYWlsdXJlc0dpdmVuR3JhY2UgPSBbXTtcbiAgICAgICAgY29uc3QgZmFpbHVyZXNOb3RSZWFkeSA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5mYWlsdXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5mYWlsdXJlcy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKG5vd1RzID4gZi50cyArIERlY3J5cHRpb25GYWlsdXJlVHJhY2tlci5HUkFDRV9QRVJJT0RfTVMpIHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlc0dpdmVuR3JhY2UucHVzaChmKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmFpbHVyZXNOb3RSZWFkeS5wdXNoKGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmFpbHVyZXMgPSBmYWlsdXJlc05vdFJlYWR5O1xuXG4gICAgICAgIC8vIE9ubHkgdHJhY2sgb25lIGZhaWx1cmUgcGVyIGV2ZW50XG4gICAgICAgIGNvbnN0IGRlZHVwZWRGYWlsdXJlc01hcCA9IGZhaWx1cmVzR2l2ZW5HcmFjZS5yZWR1Y2UoXG4gICAgICAgICAgICAobWFwLCBmYWlsdXJlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRyYWNrZWRFdmVudEhhc2hNYXBbZmFpbHVyZS5mYWlsZWRFdmVudElkXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFwLnNldChmYWlsdXJlLmZhaWxlZEV2ZW50SWQsIGZhaWx1cmUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIFVzZSBhIG1hcCB0byBwcmVzZXZlIGtleSBvcmRlcmluZ1xuICAgICAgICAgICAgbmV3IE1hcCgpLFxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHRyYWNrZWRFdmVudElkcyA9IFsuLi5kZWR1cGVkRmFpbHVyZXNNYXAua2V5cygpXTtcblxuICAgICAgICB0aGlzLnRyYWNrZWRFdmVudEhhc2hNYXAgPSB0cmFja2VkRXZlbnRJZHMucmVkdWNlKFxuICAgICAgICAgICAgKHJlc3VsdCwgZXZlbnRJZCkgPT4gKHsgLi4ucmVzdWx0LCBbZXZlbnRJZF06IHRydWUgfSksXG4gICAgICAgICAgICB0aGlzLnRyYWNrZWRFdmVudEhhc2hNYXAsXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQ29tbWVudGVkIG91dCBmb3Igbm93IGZvciBleHBlZGllbmN5LCB3ZSBuZWVkIHRvIGNvbnNpZGVyIHVuYm91bmQgbmF0dXJlIG9mIHN0b3JpbmdcbiAgICAgICAgLy8gdGhpcyBpbiBsb2NhbFN0b3JhZ2VcbiAgICAgICAgLy8gdGhpcy5zYXZlVHJhY2tlZEV2ZW50SGFzaE1hcCgpO1xuXG4gICAgICAgIGNvbnN0IGRlZHVwZWRGYWlsdXJlcyA9IGRlZHVwZWRGYWlsdXJlc01hcC52YWx1ZXMoKTtcblxuICAgICAgICB0aGlzLmFnZ3JlZ2F0ZUZhaWx1cmVzKGRlZHVwZWRGYWlsdXJlcyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhZ2dyZWdhdGVGYWlsdXJlcyhmYWlsdXJlczogRGVjcnlwdGlvbkZhaWx1cmVbXSk6IHZvaWQge1xuICAgICAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2YgZmFpbHVyZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IGZhaWx1cmUuZXJyb3JDb2RlO1xuICAgICAgICAgICAgdGhpcy5mYWlsdXJlQ291bnRzW2Vycm9yQ29kZV0gPSAodGhpcy5mYWlsdXJlQ291bnRzW2Vycm9yQ29kZV0gfHwgMCkgKyAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgdGhlcmUgYXJlIGZhaWx1cmVzIHRoYXQgc2hvdWxkIGJlIHRyYWNrZWQsIGNhbGwgdGhlIGdpdmVuIHRyYWNrRGVjcnlwdGlvbkZhaWx1cmVcbiAgICAgKiBmdW5jdGlvbiB3aXRoIHRoZSBudW1iZXIgb2YgZmFpbHVyZXMgdGhhdCBzaG91bGQgYmUgdHJhY2tlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgdHJhY2tGYWlsdXJlcygpOiB2b2lkIHtcbiAgICAgICAgZm9yIChjb25zdCBlcnJvckNvZGUgb2YgT2JqZWN0LmtleXModGhpcy5mYWlsdXJlQ291bnRzKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmFpbHVyZUNvdW50c1tlcnJvckNvZGVdID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrZWRFcnJvckNvZGUgPSB0aGlzLmVycm9yQ29kZU1hcEZuID8gdGhpcy5lcnJvckNvZGVNYXBGbihlcnJvckNvZGUpIDogZXJyb3JDb2RlO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5mbih0aGlzLmZhaWx1cmVDb3VudHNbZXJyb3JDb2RlXSwgdHJhY2tlZEVycm9yQ29kZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsdXJlQ291bnRzW2Vycm9yQ29kZV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIl19