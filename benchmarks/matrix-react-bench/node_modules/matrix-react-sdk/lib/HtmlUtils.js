"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PERMITTED_URL_SCHEMES = void 0;
exports.bodyToHtml = bodyToHtml;
exports.checkBlockNode = checkBlockNode;
exports.getHtmlText = getHtmlText;
exports.isUrlPermitted = isUrlPermitted;
exports.linkifyAndSanitizeHtml = linkifyAndSanitizeHtml;
exports.linkifyElement = linkifyElement;
exports.linkifyString = linkifyString;
exports.processHtmlForSending = processHtmlForSending;
exports.sanitizedHtmlNode = sanitizedHtmlNode;
exports.unicodeToShortcode = unicodeToShortcode;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _sanitizeHtml = _interopRequireDefault(require("sanitize-html"));

var _cheerio = _interopRequireDefault(require("cheerio"));

var linkify = _interopRequireWildcard(require("linkifyjs"));

var _element = _interopRequireDefault(require("linkifyjs/element"));

var _string = _interopRequireDefault(require("linkifyjs/string"));

var _classnames = _interopRequireDefault(require("classnames"));

var _emojibaseRegex = _interopRequireDefault(require("emojibase-regex"));

var _katex = _interopRequireDefault(require("katex"));

var _htmlEntities = require("html-entities");

var _linkifyMatrix = _interopRequireDefault(require("./linkify-matrix"));

var _SettingsStore = _interopRequireDefault(require("./settings/SettingsStore"));

var _Permalinks = require("./utils/permalinks/Permalinks");

var _emoji = require("./emoji");

var _ReplyChain = _interopRequireDefault(require("./components/views/elements/ReplyChain"));

var _Media = require("./customisations/Media");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

(0, _linkifyMatrix.default)(linkify); // Anything outside the basic multilingual plane will be a surrogate pair

const SURROGATE_PAIR_PATTERN = /([\ud800-\udbff])([\udc00-\udfff])/; // And there a bunch more symbol characters that emojibase has within the
// BMP, so this includes the ranges from 'letterlike symbols' to
// 'miscellaneous symbols and arrows' which should catch all of them
// (with plenty of false positives, but that's OK)

const SYMBOL_PATTERN = /([\u2100-\u2bff])/; // Regex pattern for Zero-Width joiner unicode characters

const ZWJ_REGEX = new RegExp("\u200D|\u2003", "g"); // Regex pattern for whitespace characters

const WHITESPACE_REGEX = new RegExp("\\s", "g");
const BIGEMOJI_REGEX = new RegExp(`^(${_emojibaseRegex.default.source})+$`, 'i');
const COLOR_REGEX = /^#[0-9a-fA-F]{6}$/;
const PERMITTED_URL_SCHEMES = ["bitcoin", "ftp", "geo", "http", "https", "im", "irc", "ircs", "magnet", "mailto", "matrix", "mms", "news", "nntp", "openpgp4fpr", "sip", "sftp", "sms", "smsto", "ssh", "tel", "urn", "webcal", "wtai", "xmpp"];
exports.PERMITTED_URL_SCHEMES = PERMITTED_URL_SCHEMES;
const MEDIA_API_MXC_REGEX = /\/_matrix\/media\/r0\/(?:download|thumbnail)\/(.+?)\/(.+?)(?:[?/]|$)/;
/*
 * Return true if the given string contains emoji
 * Uses a much, much simpler regex than emojibase's so will give false
 * positives, but useful for fast-path testing strings to see if they
 * need emojification.
 * unicodeToImage uses this function.
 */

function mightContainEmoji(str) {
  return SURROGATE_PAIR_PATTERN.test(str) || SYMBOL_PATTERN.test(str);
}
/**
 * Returns the shortcode for an emoji character.
 *
 * @param {String} char The emoji character
 * @return {String} The shortcode (such as :thumbup:)
 */


function unicodeToShortcode(char) {
  var _getEmojiFromUnicode;

  const shortcodes = (_getEmojiFromUnicode = (0, _emoji.getEmojiFromUnicode)(char)) === null || _getEmojiFromUnicode === void 0 ? void 0 : _getEmojiFromUnicode.shortcodes;
  return shortcodes !== null && shortcodes !== void 0 && shortcodes.length ? `:${shortcodes[0]}:` : '';
}

function processHtmlForSending(html) {
  const contentDiv = document.createElement('div');
  contentDiv.innerHTML = html;

  if (contentDiv.children.length === 0) {
    return contentDiv.innerHTML;
  }

  let contentHTML = "";

  for (let i = 0; i < contentDiv.children.length; i++) {
    const element = contentDiv.children[i];

    if (element.tagName.toLowerCase() === 'p') {
      contentHTML += element.innerHTML; // Don't add a <br /> for the last <p>

      if (i !== contentDiv.children.length - 1) {
        contentHTML += '<br />';
      }
    } else {
      const temp = document.createElement('div');
      temp.appendChild(element.cloneNode(true));
      contentHTML += temp.innerHTML;
    }
  }

  return contentHTML;
}
/*
 * Given an untrusted HTML string, return a React node with an sanitized version
 * of that HTML.
 */


function sanitizedHtmlNode(insaneHtml) {
  const saneHtml = (0, _sanitizeHtml.default)(insaneHtml, sanitizeHtmlParams);
  return /*#__PURE__*/_react.default.createElement("div", {
    dangerouslySetInnerHTML: {
      __html: saneHtml
    },
    dir: "auto"
  });
}

function getHtmlText(insaneHtml) {
  return (0, _sanitizeHtml.default)(insaneHtml, {
    allowedTags: [],
    allowedAttributes: {},
    selfClosing: [],
    allowedSchemes: [],
    disallowedTagsMode: 'discard'
  });
}
/**
 * Tests if a URL from an untrusted source may be safely put into the DOM
 * The biggest threat here is javascript: URIs.
 * Note that the HTML sanitiser library has its own internal logic for
 * doing this, to which we pass the same list of schemes. This is used in
 * other places we need to sanitise URLs.
 * @return true if permitted, otherwise false
 */


function isUrlPermitted(inputUrl) {
  try {
    // URL parser protocol includes the trailing colon
    return PERMITTED_URL_SCHEMES.includes(new URL(inputUrl).protocol.slice(0, -1));
  } catch (e) {
    return false;
  }
}

const transformTags = {
  // custom to matrix
  // add blank targets to all hyperlinks except vector URLs
  'a': function (tagName, attribs) {
    if (attribs.href) {
      attribs.target = '_blank'; // by default

      const transformed = (0, _Permalinks.tryTransformPermalinkToLocalHref)(attribs.href);

      if (transformed !== attribs.href || attribs.href.match(_linkifyMatrix.default.ELEMENT_URL_PATTERN)) {
        attribs.href = transformed;
        delete attribs.target;
      }
    }

    attribs.rel = 'noreferrer noopener'; // https://mathiasbynens.github.io/rel-noopener/

    return {
      tagName,
      attribs
    };
  },
  'img': function (tagName, attribs) {
    let src = attribs.src; // Strip out imgs that aren't `mxc` here instead of using allowedSchemesByTag
    // because transformTags is used _before_ we filter by allowedSchemesByTag and
    // we don't want to allow images with `https?` `src`s.
    // We also drop inline images (as if they were not present at all) when the "show
    // images" preference is disabled. Future work might expose some UI to reveal them
    // like standalone image events have.

    if (!src || !_SettingsStore.default.getValue("showImages")) {
      return {
        tagName,
        attribs: {}
      };
    }

    if (!src.startsWith("mxc://")) {
      const match = MEDIA_API_MXC_REGEX.exec(src);

      if (match) {
        src = `mxc://${match[1]}/${match[2]}`;
      }
    }

    if (!src.startsWith("mxc://")) {
      return {
        tagName,
        attribs: {}
      };
    }

    const width = Number(attribs.width) || 800;
    const height = Number(attribs.height) || 600;
    attribs.src = (0, _Media.mediaFromMxc)(src).getThumbnailOfSourceHttp(width, height);
    return {
      tagName,
      attribs
    };
  },
  'code': function (tagName, attribs) {
    if (typeof attribs.class !== 'undefined') {
      // Filter out all classes other than ones starting with language- for syntax highlighting.
      const classes = attribs.class.split(/\s/).filter(function (cl) {
        return cl.startsWith('language-') && !cl.startsWith('language-_');
      });
      attribs.class = classes.join(' ');
    }

    return {
      tagName,
      attribs
    };
  },
  '*': function (tagName, attribs) {
    // Delete any style previously assigned, style is an allowedTag for font and span
    // because attributes are stripped after transforming
    delete attribs.style; // Sanitise and transform data-mx-color and data-mx-bg-color to their CSS
    // equivalents

    const customCSSMapper = {
      'data-mx-color': 'color',
      'data-mx-bg-color': 'background-color' // $customAttributeKey: $cssAttributeKey

    };
    let style = "";
    Object.keys(customCSSMapper).forEach(customAttributeKey => {
      const cssAttributeKey = customCSSMapper[customAttributeKey];
      const customAttributeValue = attribs[customAttributeKey];

      if (customAttributeValue && typeof customAttributeValue === 'string' && COLOR_REGEX.test(customAttributeValue)) {
        style += cssAttributeKey + ":" + customAttributeValue + ";";
        delete attribs[customAttributeKey];
      }
    });

    if (style) {
      attribs.style = style;
    }

    return {
      tagName,
      attribs
    };
  }
};
const sanitizeHtmlParams = {
  allowedTags: ['font', // custom to matrix for IRC-style font coloring
  'del', // for markdown
  'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'p', 'a', 'ul', 'ol', 'sup', 'sub', 'nl', 'li', 'b', 'i', 'u', 'strong', 'em', 'strike', 'code', 'hr', 'br', 'div', 'table', 'thead', 'caption', 'tbody', 'tr', 'th', 'td', 'pre', 'span', 'img', 'details', 'summary'],
  allowedAttributes: {
    // custom ones first:
    font: ['color', 'data-mx-bg-color', 'data-mx-color', 'style'],
    // custom to matrix
    span: ['data-mx-maths', 'data-mx-bg-color', 'data-mx-color', 'data-mx-spoiler', 'style'],
    // custom to matrix
    div: ['data-mx-maths'],
    a: ['href', 'name', 'target', 'rel'],
    // remote target: custom to matrix
    img: ['src', 'width', 'height', 'alt', 'title'],
    ol: ['start'],
    code: ['class'] // We don't actually allow all classes, we filter them in transformTags

  },
  // Lots of these won't come up by default because we don't allow them
  selfClosing: ['img', 'br', 'hr', 'area', 'base', 'basefont', 'input', 'link', 'meta'],
  // URL schemes we permit
  allowedSchemes: PERMITTED_URL_SCHEMES,
  allowProtocolRelative: false,
  transformTags,
  // 50 levels deep "should be enough for anyone"
  nestingLimit: 50
}; // this is the same as the above except with less rewriting

const composerSanitizeHtmlParams = _objectSpread(_objectSpread({}, sanitizeHtmlParams), {}, {
  transformTags: {
    'code': transformTags['code'],
    '*': transformTags['*']
  }
});

class BaseHighlighter {
  constructor(highlightClass, highlightLink) {
    this.highlightClass = highlightClass;
    this.highlightLink = highlightLink;
  }
  /**
   * apply the highlights to a section of text
   *
   * @param {string} safeSnippet The snippet of text to apply the highlights
   *     to.
   * @param {string[]} safeHighlights A list of substrings to highlight,
   *     sorted by descending length.
   *
   * returns a list of results (strings for HtmlHighligher, react nodes for
   * TextHighlighter).
   */


  applyHighlights(safeSnippet, safeHighlights) {
    let lastOffset = 0;
    let offset;
    let nodes = [];
    const safeHighlight = safeHighlights[0];

    while ((offset = safeSnippet.toLowerCase().indexOf(safeHighlight.toLowerCase(), lastOffset)) >= 0) {
      // handle preamble
      if (offset > lastOffset) {
        const subSnippet = safeSnippet.substring(lastOffset, offset);
        nodes = nodes.concat(this.applySubHighlights(subSnippet, safeHighlights));
      } // do highlight. use the original string rather than safeHighlight
      // to preserve the original casing.


      const endOffset = offset + safeHighlight.length;
      nodes.push(this.processSnippet(safeSnippet.substring(offset, endOffset), true));
      lastOffset = endOffset;
    } // handle postamble


    if (lastOffset !== safeSnippet.length) {
      const subSnippet = safeSnippet.substring(lastOffset, undefined);
      nodes = nodes.concat(this.applySubHighlights(subSnippet, safeHighlights));
    }

    return nodes;
  }

  applySubHighlights(safeSnippet, safeHighlights) {
    if (safeHighlights[1]) {
      // recurse into this range to check for the next set of highlight matches
      return this.applyHighlights(safeSnippet, safeHighlights.slice(1));
    } else {
      // no more highlights to be found, just return the unhighlighted string
      return [this.processSnippet(safeSnippet, false)];
    }
  }

}

class HtmlHighlighter extends BaseHighlighter {
  /* highlight the given snippet if required
   *
   * snippet: content of the span; must have been sanitised
   * highlight: true to highlight as a search match
   *
   * returns an HTML string
   */
  processSnippet(snippet, highlight) {
    if (!highlight) {
      // nothing required here
      return snippet;
    }

    let span = `<span class="${this.highlightClass}">${snippet}</span>`;

    if (this.highlightLink) {
      span = `<a href="${encodeURI(this.highlightLink)}">${span}</a>`;
    }

    return span;
  }

}

function bodyToHtml(content, highlights, opts = {}) {
  const isHtmlMessage = content.format === "org.matrix.custom.html" && content.formatted_body;
  let bodyHasEmoji = false;
  let sanitizeParams = sanitizeHtmlParams;

  if (opts.forComposerQuote) {
    sanitizeParams = composerSanitizeHtmlParams;
  }

  let strippedBody;
  let safeBody;
  let isDisplayedWithHtml; // XXX: We sanitize the HTML whilst also highlighting its text nodes, to avoid accidentally trying
  // to highlight HTML tags themselves.  However, this does mean that we don't highlight textnodes which
  // are interrupted by HTML tags (not that we did before) - e.g. foo<span/>bar won't get highlighted
  // by an attempt to search for 'foobar'.  Then again, the search query probably wouldn't work either

  try {
    if (highlights && highlights.length > 0) {
      const highlighter = new HtmlHighlighter("mx_EventTile_searchHighlight", opts.highlightLink);
      const safeHighlights = highlights // sanitizeHtml can hang if an unclosed HTML tag is thrown at it
      // A search for `<foo` will make the browser crash
      // an alternative would be to escape HTML special characters
      // but that would bring no additional benefit as the highlighter
      // does not work with those special chars
      .filter(highlight => !highlight.includes("<")).map(highlight => (0, _sanitizeHtml.default)(highlight, sanitizeParams)); // XXX: hacky bodge to temporarily apply a textFilter to the sanitizeParams structure.

      sanitizeParams.textFilter = function (safeText) {
        return highlighter.applyHighlights(safeText, safeHighlights).join('');
      };
    }

    let formattedBody = typeof content.formatted_body === 'string' ? content.formatted_body : null;
    const plainBody = typeof content.body === 'string' ? content.body : "";
    if (opts.stripReplyFallback && formattedBody) formattedBody = _ReplyChain.default.stripHTMLReply(formattedBody);
    strippedBody = opts.stripReplyFallback ? _ReplyChain.default.stripPlainReply(plainBody) : plainBody;
    bodyHasEmoji = mightContainEmoji(isHtmlMessage ? formattedBody : plainBody); // Only generate safeBody if the message was sent as org.matrix.custom.html

    if (isHtmlMessage) {
      isDisplayedWithHtml = true;
      safeBody = (0, _sanitizeHtml.default)(formattedBody, sanitizeParams);

      if (_SettingsStore.default.getValue("feature_latex_maths")) {
        const phtml = _cheerio.default.load(safeBody, {
          // @ts-ignore: The `_useHtmlParser2` internal option is the
          // simplest way to both parse and render using `htmlparser2`.
          _useHtmlParser2: true,
          decodeEntities: false
        }); // @ts-ignore - The types for `replaceWith` wrongly expect
        // Cheerio instance to be returned.


        phtml('div, span[data-mx-maths!=""]').replaceWith(function (i, e) {
          return _katex.default.renderToString(_htmlEntities.AllHtmlEntities.decode(phtml(e).attr('data-mx-maths')), {
            throwOnError: false,
            // @ts-ignore - `e` can be an Element, not just a Node
            displayMode: e.name == 'div',
            output: "htmlAndMathml"
          });
        });
        safeBody = phtml.html();
      }
    }
  } finally {
    delete sanitizeParams.textFilter;
  }

  const contentBody = isDisplayedWithHtml ? safeBody : strippedBody;

  if (opts.returnString) {
    return contentBody;
  }

  let emojiBody = false;

  if (!opts.disableBigEmoji && bodyHasEmoji) {
    let contentBodyTrimmed = contentBody !== undefined ? contentBody.trim() : ''; // Ignore spaces in body text. Emojis with spaces in between should
    // still be counted as purely emoji messages.

    contentBodyTrimmed = contentBodyTrimmed.replace(WHITESPACE_REGEX, ''); // Remove zero width joiner characters from emoji messages. This ensures
    // that emojis that are made up of multiple unicode characters are still
    // presented as large.

    contentBodyTrimmed = contentBodyTrimmed.replace(ZWJ_REGEX, '');
    const match = BIGEMOJI_REGEX.exec(contentBodyTrimmed);
    emojiBody = match && match[0] && match[0].length === contentBodyTrimmed.length && ( // Prevent user pills expanding for users with only emoji in
    // their username. Permalinks (links in pills) can be any URL
    // now, so we just check for an HTTP-looking thing.
    strippedBody === safeBody || // replies have the html fallbacks, account for that here
    content.formatted_body === undefined || !content.formatted_body.includes("http:") && !content.formatted_body.includes("https:"));
  }

  const className = (0, _classnames.default)({
    'mx_EventTile_body': true,
    'mx_EventTile_bigEmoji': emojiBody,
    'markdown-body': isHtmlMessage && !emojiBody
  });
  return isDisplayedWithHtml ? /*#__PURE__*/_react.default.createElement("span", {
    key: "body",
    ref: opts.ref,
    className: className,
    dangerouslySetInnerHTML: {
      __html: safeBody
    },
    dir: "auto"
  }) : /*#__PURE__*/_react.default.createElement("span", {
    key: "body",
    ref: opts.ref,
    className: className,
    dir: "auto"
  }, strippedBody);
}
/**
 * Linkifies the given string. This is a wrapper around 'linkifyjs/string'.
 *
 * @param {string} str string to linkify
 * @param {object} [options] Options for linkifyString. Default: linkifyMatrix.options
 * @returns {string} Linkified string
 */


function linkifyString(str, options = _linkifyMatrix.default.options) {
  return (0, _string.default)(str, options);
}
/**
 * Linkifies the given DOM element. This is a wrapper around 'linkifyjs/element'.
 *
 * @param {object} element DOM element to linkify
 * @param {object} [options] Options for linkifyElement. Default: linkifyMatrix.options
 * @returns {object}
 */


function linkifyElement(element, options = _linkifyMatrix.default.options) {
  return (0, _element.default)(element, options);
}
/**
 * Linkify the given string and sanitize the HTML afterwards.
 *
 * @param {string} dirtyHtml The HTML string to sanitize and linkify
 * @param {object} [options] Options for linkifyString. Default: linkifyMatrix.options
 * @returns {string}
 */


function linkifyAndSanitizeHtml(dirtyHtml, options = _linkifyMatrix.default.options) {
  return (0, _sanitizeHtml.default)(linkifyString(dirtyHtml, options), sanitizeHtmlParams);
}
/**
 * Returns if a node is a block element or not.
 * Only takes html nodes into account that are allowed in matrix messages.
 *
 * @param {Node} node
 * @returns {bool}
 */


function checkBlockNode(node) {
  switch (node.nodeName) {
    case "H1":
    case "H2":
    case "H3":
    case "H4":
    case "H5":
    case "H6":
    case "PRE":
    case "BLOCKQUOTE":
    case "P":
    case "UL":
    case "OL":
    case "LI":
    case "HR":
    case "TABLE":
    case "THEAD":
    case "TBODY":
    case "TR":
    case "TH":
    case "TD":
      return true;

    case "DIV":
      // don't treat math nodes as block nodes for deserializing
      return !node.hasAttribute("data-mx-maths");

    default:
      return false;
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9IdG1sVXRpbHMudHN4Il0sIm5hbWVzIjpbImxpbmtpZnkiLCJTVVJST0dBVEVfUEFJUl9QQVRURVJOIiwiU1lNQk9MX1BBVFRFUk4iLCJaV0pfUkVHRVgiLCJSZWdFeHAiLCJXSElURVNQQUNFX1JFR0VYIiwiQklHRU1PSklfUkVHRVgiLCJFTU9KSUJBU0VfUkVHRVgiLCJzb3VyY2UiLCJDT0xPUl9SRUdFWCIsIlBFUk1JVFRFRF9VUkxfU0NIRU1FUyIsIk1FRElBX0FQSV9NWENfUkVHRVgiLCJtaWdodENvbnRhaW5FbW9qaSIsInN0ciIsInRlc3QiLCJ1bmljb2RlVG9TaG9ydGNvZGUiLCJjaGFyIiwic2hvcnRjb2RlcyIsImxlbmd0aCIsInByb2Nlc3NIdG1sRm9yU2VuZGluZyIsImh0bWwiLCJjb250ZW50RGl2IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaW5uZXJIVE1MIiwiY2hpbGRyZW4iLCJjb250ZW50SFRNTCIsImkiLCJlbGVtZW50IiwidGFnTmFtZSIsInRvTG93ZXJDYXNlIiwidGVtcCIsImFwcGVuZENoaWxkIiwiY2xvbmVOb2RlIiwic2FuaXRpemVkSHRtbE5vZGUiLCJpbnNhbmVIdG1sIiwic2FuZUh0bWwiLCJzYW5pdGl6ZUh0bWxQYXJhbXMiLCJfX2h0bWwiLCJnZXRIdG1sVGV4dCIsImFsbG93ZWRUYWdzIiwiYWxsb3dlZEF0dHJpYnV0ZXMiLCJzZWxmQ2xvc2luZyIsImFsbG93ZWRTY2hlbWVzIiwiZGlzYWxsb3dlZFRhZ3NNb2RlIiwiaXNVcmxQZXJtaXR0ZWQiLCJpbnB1dFVybCIsImluY2x1ZGVzIiwiVVJMIiwicHJvdG9jb2wiLCJzbGljZSIsImUiLCJ0cmFuc2Zvcm1UYWdzIiwiYXR0cmlicyIsImhyZWYiLCJ0YXJnZXQiLCJ0cmFuc2Zvcm1lZCIsIm1hdGNoIiwibGlua2lmeU1hdHJpeCIsIkVMRU1FTlRfVVJMX1BBVFRFUk4iLCJyZWwiLCJzcmMiLCJTZXR0aW5nc1N0b3JlIiwiZ2V0VmFsdWUiLCJzdGFydHNXaXRoIiwiZXhlYyIsIndpZHRoIiwiTnVtYmVyIiwiaGVpZ2h0IiwiZ2V0VGh1bWJuYWlsT2ZTb3VyY2VIdHRwIiwiY2xhc3MiLCJjbGFzc2VzIiwic3BsaXQiLCJmaWx0ZXIiLCJjbCIsImpvaW4iLCJzdHlsZSIsImN1c3RvbUNTU01hcHBlciIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwiY3VzdG9tQXR0cmlidXRlS2V5IiwiY3NzQXR0cmlidXRlS2V5IiwiY3VzdG9tQXR0cmlidXRlVmFsdWUiLCJmb250Iiwic3BhbiIsImRpdiIsImEiLCJpbWciLCJvbCIsImNvZGUiLCJhbGxvd1Byb3RvY29sUmVsYXRpdmUiLCJuZXN0aW5nTGltaXQiLCJjb21wb3NlclNhbml0aXplSHRtbFBhcmFtcyIsIkJhc2VIaWdobGlnaHRlciIsImNvbnN0cnVjdG9yIiwiaGlnaGxpZ2h0Q2xhc3MiLCJoaWdobGlnaHRMaW5rIiwiYXBwbHlIaWdobGlnaHRzIiwic2FmZVNuaXBwZXQiLCJzYWZlSGlnaGxpZ2h0cyIsImxhc3RPZmZzZXQiLCJvZmZzZXQiLCJub2RlcyIsInNhZmVIaWdobGlnaHQiLCJpbmRleE9mIiwic3ViU25pcHBldCIsInN1YnN0cmluZyIsImNvbmNhdCIsImFwcGx5U3ViSGlnaGxpZ2h0cyIsImVuZE9mZnNldCIsInB1c2giLCJwcm9jZXNzU25pcHBldCIsInVuZGVmaW5lZCIsIkh0bWxIaWdobGlnaHRlciIsInNuaXBwZXQiLCJoaWdobGlnaHQiLCJlbmNvZGVVUkkiLCJib2R5VG9IdG1sIiwiY29udGVudCIsImhpZ2hsaWdodHMiLCJvcHRzIiwiaXNIdG1sTWVzc2FnZSIsImZvcm1hdCIsImZvcm1hdHRlZF9ib2R5IiwiYm9keUhhc0Vtb2ppIiwic2FuaXRpemVQYXJhbXMiLCJmb3JDb21wb3NlclF1b3RlIiwic3RyaXBwZWRCb2R5Iiwic2FmZUJvZHkiLCJpc0Rpc3BsYXllZFdpdGhIdG1sIiwiaGlnaGxpZ2h0ZXIiLCJtYXAiLCJ0ZXh0RmlsdGVyIiwic2FmZVRleHQiLCJmb3JtYXR0ZWRCb2R5IiwicGxhaW5Cb2R5IiwiYm9keSIsInN0cmlwUmVwbHlGYWxsYmFjayIsIlJlcGx5Q2hhaW4iLCJzdHJpcEhUTUxSZXBseSIsInN0cmlwUGxhaW5SZXBseSIsInBodG1sIiwiY2hlZXJpbyIsImxvYWQiLCJfdXNlSHRtbFBhcnNlcjIiLCJkZWNvZGVFbnRpdGllcyIsInJlcGxhY2VXaXRoIiwia2F0ZXgiLCJyZW5kZXJUb1N0cmluZyIsIkFsbEh0bWxFbnRpdGllcyIsImRlY29kZSIsImF0dHIiLCJ0aHJvd09uRXJyb3IiLCJkaXNwbGF5TW9kZSIsIm5hbWUiLCJvdXRwdXQiLCJjb250ZW50Qm9keSIsInJldHVyblN0cmluZyIsImVtb2ppQm9keSIsImRpc2FibGVCaWdFbW9qaSIsImNvbnRlbnRCb2R5VHJpbW1lZCIsInRyaW0iLCJyZXBsYWNlIiwiY2xhc3NOYW1lIiwicmVmIiwibGlua2lmeVN0cmluZyIsIm9wdGlvbnMiLCJsaW5raWZ5RWxlbWVudCIsImxpbmtpZnlBbmRTYW5pdGl6ZUh0bWwiLCJkaXJ0eUh0bWwiLCJjaGVja0Jsb2NrTm9kZSIsIm5vZGUiLCJub2RlTmFtZSIsImhhc0F0dHJpYnV0ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUlBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7O0FBRUEsNEJBQWNBLE9BQWQsRSxDQUVBOztBQUNBLE1BQU1DLHNCQUFzQixHQUFHLG9DQUEvQixDLENBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsTUFBTUMsY0FBYyxHQUFHLG1CQUF2QixDLENBRUE7O0FBQ0EsTUFBTUMsU0FBUyxHQUFHLElBQUlDLE1BQUosQ0FBVyxlQUFYLEVBQTRCLEdBQTVCLENBQWxCLEMsQ0FFQTs7QUFDQSxNQUFNQyxnQkFBZ0IsR0FBRyxJQUFJRCxNQUFKLENBQVcsS0FBWCxFQUFrQixHQUFsQixD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QUVELElBQUQsQ0FBc0JFLFlBQXRCLENBQW1DLGVBQW5DLENBQVI7O0FBQ0o7QUFDSSxhQUFPLEtBQVA7QUF6QlI7QUEyQkgiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMTUsIDIwMTYgT3Blbk1hcmtldCBMdGRcbkNvcHlyaWdodCAyMDE3LCAyMDE4IE5ldyBWZWN0b3IgTHRkXG5Db3B5cmlnaHQgMjAxOSBNaWNoYWVsIFRlbGF0eW5za2kgPDd0M2NoZ3V5QGdtYWlsLmNvbT5cbkNvcHlyaWdodCAyMDE5IFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IFJlYWN0LCB7IFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBzYW5pdGl6ZUh0bWwgZnJvbSAnc2FuaXRpemUtaHRtbCc7XG5pbXBvcnQgY2hlZXJpbyBmcm9tICdjaGVlcmlvJztcbmltcG9ydCAqIGFzIGxpbmtpZnkgZnJvbSAnbGlua2lmeWpzJztcbmltcG9ydCBfbGlua2lmeUVsZW1lbnQgZnJvbSAnbGlua2lmeWpzL2VsZW1lbnQnO1xuaW1wb3J0IF9saW5raWZ5U3RyaW5nIGZyb20gJ2xpbmtpZnlqcy9zdHJpbmcnO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgRU1PSklCQVNFX1JFR0VYIGZyb20gJ2Vtb2ppYmFzZS1yZWdleCc7XG5pbXBvcnQga2F0ZXggZnJvbSAna2F0ZXgnO1xuaW1wb3J0IHsgQWxsSHRtbEVudGl0aWVzIH0gZnJvbSAnaHRtbC1lbnRpdGllcyc7XG5pbXBvcnQgeyBJQ29udGVudCB9IGZyb20gJ21hdHJpeC1qcy1zZGsvc3JjL21vZGVscy9ldmVudCc7XG5cbmltcG9ydCB7IElFeHRlbmRlZFNhbml0aXplT3B0aW9ucyB9IGZyb20gJy4vQHR5cGVzL3Nhbml0aXplLWh0bWwnO1xuaW1wb3J0IGxpbmtpZnlNYXRyaXggZnJvbSAnLi9saW5raWZ5LW1hdHJpeCc7XG5pbXBvcnQgU2V0dGluZ3NTdG9yZSBmcm9tICcuL3NldHRpbmdzL1NldHRpbmdzU3RvcmUnO1xuaW1wb3J0IHsgdHJ5VHJhbnNmb3JtUGVybWFsaW5rVG9Mb2NhbEhyZWYgfSBmcm9tIFwiLi91dGlscy9wZXJtYWxpbmtzL1Blcm1hbGlua3NcIjtcbmltcG9ydCB7IGdldEVtb2ppRnJvbVVuaWNvZGUgfSBmcm9tIFwiLi9lbW9qaVwiO1xuaW1wb3J0IFJlcGx5Q2hhaW4gZnJvbSBcIi4vY29tcG9uZW50cy92aWV3cy9lbGVtZW50cy9SZXBseUNoYWluXCI7XG5pbXBvcnQgeyBtZWRpYUZyb21NeGMgfSBmcm9tIFwiLi9jdXN0b21pc2F0aW9ucy9NZWRpYVwiO1xuXG5saW5raWZ5TWF0cml4KGxpbmtpZnkpO1xuXG4vLyBBbnl0aGluZyBvdXRzaWRlIHRoZSBiYXNpYyBtdWx0aWxpbmd1YWwgcGxhbmUgd2lsbCBiZSBhIHN1cnJvZ2F0ZSBwYWlyXG5jb25zdCBTVVJST0dBVEVfUEFJUl9QQVRURVJOID0gLyhbXFx1ZDgwMC1cXHVkYmZmXSkoW1xcdWRjMDAtXFx1ZGZmZl0pLztcbi8vIEFuZCB0aGVyZSBhIGJ1bmNoIG1vcmUgc3ltYm9sIGNoYXJhY3RlcnMgdGhhdCBlbW9qaWJhc2UgaGFzIHdpdGhpbiB0aGVcbi8vIEJNUCwgc28gdGhpcyBpbmNsdWRlcyB0aGUgcmFuZ2VzIGZyb20gJ2xldHRlcmxpa2Ugc3ltYm9scycgdG9cbi8vICdtaXNjZWxsYW5lb3VzIHN5bWJvbHMgYW5kIGFycm93cycgd2hpY2ggc2hvdWxkIGNhdGNoIGFsbCBvZiB0aGVtXG4vLyAod2l0aCBwbGVudHkgb2YgZmFsc2UgcG9zaXRpdmVzLCBidXQgdGhhdCdzIE9LKVxuY29uc3QgU1lNQk9MX1BBVFRFUk4gPSAvKFtcXHUyMTAwLVxcdTJiZmZdKS87XG5cbi8vIFJlZ2V4IHBhdHRlcm4gZm9yIFplcm8tV2lkdGggam9pbmVyIHVuaWNvZGUgY2hhcmFjdGVyc1xuY29uc3QgWldKX1JFR0VYID0gbmV3IFJlZ0V4cChcIlxcdTIwMER8XFx1MjAwM1wiLCBcImdcIik7XG5cbi8vIFJlZ2V4IHBhdHRlcm4gZm9yIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuY29uc3QgV0hJVEVTUEFDRV9SRUdFWCA9IG5ldyBSZWdFeHAoXCJcXFxcc1wiLCBcImdcIik7XG5cbmNvbnN0IEJJR0VNT0pJX1JFR0VYID0gbmV3IFJlZ0V4cChgXigke0VNT0pJQkFTRV9SRUdFWC5zb3VyY2V9KSskYCwgJ2knKTtcblxuY29uc3QgQ09MT1JfUkVHRVggPSAvXiNbMC05YS1mQS1GXXs2fSQvO1xuXG5leHBvcnQgY29uc3QgUEVSTUlUVEVEX1VSTF9TQ0hFTUVTID0gW1xuICAgIFwiYml0Y29pblwiLFxuICAgIFwiZnRwXCIsXG4gICAgXCJnZW9cIixcbiAgICBcImh0dHBcIixcbiAgICBcImh0dHBzXCIsXG4gICAgXCJpbVwiLFxuICAgIFwiaXJjXCIsXG4gICAgXCJpcmNzXCIsXG4gICAgXCJtYWduZXRcIixcbiAgICBcIm1haWx0b1wiLFxuICAgIFwibWF0cml4XCIsXG4gICAgXCJtbXNcIixcbiAgICBcIm5ld3NcIixcbiAgICBcIm5udHBcIixcbiAgICBcIm9wZW5wZ3A0ZnByXCIsXG4gICAgXCJzaXBcIixcbiAgICBcInNmdHBcIixcbiAgICBcInNtc1wiLFxuICAgIFwic21zdG9cIixcbiAgICBcInNzaFwiLFxuICAgIFwidGVsXCIsXG4gICAgXCJ1cm5cIixcbiAgICBcIndlYmNhbFwiLFxuICAgIFwid3RhaVwiLFxuICAgIFwieG1wcFwiLFxuXTtcblxuY29uc3QgTUVESUFfQVBJX01YQ19SRUdFWCA9IC9cXC9fbWF0cml4XFwvbWVkaWFcXC9yMFxcLyg/OmRvd25sb2FkfHRodW1ibmFpbClcXC8oLis/KVxcLyguKz8pKD86Wz8vXXwkKS87XG5cbi8qXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGNvbnRhaW5zIGVtb2ppXG4gKiBVc2VzIGEgbXVjaCwgbXVjaCBzaW1wbGVyIHJlZ2V4IHRoYW4gZW1vamliYXNlJ3Mgc28gd2lsbCBnaXZlIGZhbHNlXG4gKiBwb3NpdGl2ZXMsIGJ1dCB1c2VmdWwgZm9yIGZhc3QtcGF0aCB0ZXN0aW5nIHN0cmluZ3MgdG8gc2VlIGlmIHRoZXlcbiAqIG5lZWQgZW1vamlmaWNhdGlvbi5cbiAqIHVuaWNvZGVUb0ltYWdlIHVzZXMgdGhpcyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWlnaHRDb250YWluRW1vamkoc3RyOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gU1VSUk9HQVRFX1BBSVJfUEFUVEVSTi50ZXN0KHN0cikgfHwgU1lNQk9MX1BBVFRFUk4udGVzdChzdHIpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNob3J0Y29kZSBmb3IgYW4gZW1vamkgY2hhcmFjdGVyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjaGFyIFRoZSBlbW9qaSBjaGFyYWN0ZXJcbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHNob3J0Y29kZSAoc3VjaCBhcyA6dGh1bWJ1cDopXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmljb2RlVG9TaG9ydGNvZGUoY2hhcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBzaG9ydGNvZGVzID0gZ2V0RW1vamlGcm9tVW5pY29kZShjaGFyKT8uc2hvcnRjb2RlcztcbiAgICByZXR1cm4gc2hvcnRjb2Rlcz8ubGVuZ3RoID8gYDoke3Nob3J0Y29kZXNbMF19OmAgOiAnJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NIdG1sRm9yU2VuZGluZyhodG1sOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGNvbnRlbnREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250ZW50RGl2LmlubmVySFRNTCA9IGh0bWw7XG5cbiAgICBpZiAoY29udGVudERpdi5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnREaXYuaW5uZXJIVE1MO1xuICAgIH1cblxuICAgIGxldCBjb250ZW50SFRNTCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZW50RGl2LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBjb250ZW50RGl2LmNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdwJykge1xuICAgICAgICAgICAgY29udGVudEhUTUwgKz0gZWxlbWVudC5pbm5lckhUTUw7XG4gICAgICAgICAgICAvLyBEb24ndCBhZGQgYSA8YnIgLz4gZm9yIHRoZSBsYXN0IDxwPlxuICAgICAgICAgICAgaWYgKGkgIT09IGNvbnRlbnREaXYuY2hpbGRyZW4ubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRIVE1MICs9ICc8YnIgLz4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdGVtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGVtcC5hcHBlbmRDaGlsZChlbGVtZW50LmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgICAgICBjb250ZW50SFRNTCArPSB0ZW1wLmlubmVySFRNTDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb250ZW50SFRNTDtcbn1cblxuLypcbiAqIEdpdmVuIGFuIHVudHJ1c3RlZCBIVE1MIHN0cmluZywgcmV0dXJuIGEgUmVhY3Qgbm9kZSB3aXRoIGFuIHNhbml0aXplZCB2ZXJzaW9uXG4gKiBvZiB0aGF0IEhUTUwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGl6ZWRIdG1sTm9kZShpbnNhbmVIdG1sOiBzdHJpbmcpOiBSZWFjdE5vZGUge1xuICAgIGNvbnN0IHNhbmVIdG1sID0gc2FuaXRpemVIdG1sKGluc2FuZUh0bWwsIHNhbml0aXplSHRtbFBhcmFtcyk7XG5cbiAgICByZXR1cm4gPGRpdiBkYW5nZXJvdXNseVNldElubmVySFRNTD17eyBfX2h0bWw6IHNhbmVIdG1sIH19IGRpcj1cImF1dG9cIiAvPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEh0bWxUZXh0KGluc2FuZUh0bWw6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHNhbml0aXplSHRtbChpbnNhbmVIdG1sLCB7XG4gICAgICAgIGFsbG93ZWRUYWdzOiBbXSxcbiAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICBzZWxmQ2xvc2luZzogW10sXG4gICAgICAgIGFsbG93ZWRTY2hlbWVzOiBbXSxcbiAgICAgICAgZGlzYWxsb3dlZFRhZ3NNb2RlOiAnZGlzY2FyZCcsXG4gICAgfSk7XG59XG5cbi8qKlxuICogVGVzdHMgaWYgYSBVUkwgZnJvbSBhbiB1bnRydXN0ZWQgc291cmNlIG1heSBiZSBzYWZlbHkgcHV0IGludG8gdGhlIERPTVxuICogVGhlIGJpZ2dlc3QgdGhyZWF0IGhlcmUgaXMgamF2YXNjcmlwdDogVVJJcy5cbiAqIE5vdGUgdGhhdCB0aGUgSFRNTCBzYW5pdGlzZXIgbGlicmFyeSBoYXMgaXRzIG93biBpbnRlcm5hbCBsb2dpYyBmb3JcbiAqIGRvaW5nIHRoaXMsIHRvIHdoaWNoIHdlIHBhc3MgdGhlIHNhbWUgbGlzdCBvZiBzY2hlbWVzLiBUaGlzIGlzIHVzZWQgaW5cbiAqIG90aGVyIHBsYWNlcyB3ZSBuZWVkIHRvIHNhbml0aXNlIFVSTHMuXG4gKiBAcmV0dXJuIHRydWUgaWYgcGVybWl0dGVkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVXJsUGVybWl0dGVkKGlucHV0VXJsOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBVUkwgcGFyc2VyIHByb3RvY29sIGluY2x1ZGVzIHRoZSB0cmFpbGluZyBjb2xvblxuICAgICAgICByZXR1cm4gUEVSTUlUVEVEX1VSTF9TQ0hFTUVTLmluY2x1ZGVzKG5ldyBVUkwoaW5wdXRVcmwpLnByb3RvY29sLnNsaWNlKDAsIC0xKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5jb25zdCB0cmFuc2Zvcm1UYWdzOiBJRXh0ZW5kZWRTYW5pdGl6ZU9wdGlvbnNbXCJ0cmFuc2Zvcm1UYWdzXCJdID0geyAvLyBjdXN0b20gdG8gbWF0cml4XG4gICAgLy8gYWRkIGJsYW5rIHRhcmdldHMgdG8gYWxsIGh5cGVybGlua3MgZXhjZXB0IHZlY3RvciBVUkxzXG4gICAgJ2EnOiBmdW5jdGlvbih0YWdOYW1lOiBzdHJpbmcsIGF0dHJpYnM6IHNhbml0aXplSHRtbC5BdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmIChhdHRyaWJzLmhyZWYpIHtcbiAgICAgICAgICAgIGF0dHJpYnMudGFyZ2V0ID0gJ19ibGFuayc7IC8vIGJ5IGRlZmF1bHRcblxuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSB0cnlUcmFuc2Zvcm1QZXJtYWxpbmtUb0xvY2FsSHJlZihhdHRyaWJzLmhyZWYpO1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybWVkICE9PSBhdHRyaWJzLmhyZWYgfHwgYXR0cmlicy5ocmVmLm1hdGNoKGxpbmtpZnlNYXRyaXguRUxFTUVOVF9VUkxfUEFUVEVSTikpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJzLmhyZWYgPSB0cmFuc2Zvcm1lZDtcbiAgICAgICAgICAgICAgICBkZWxldGUgYXR0cmlicy50YXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXR0cmlicy5yZWwgPSAnbm9yZWZlcnJlciBub29wZW5lcic7IC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5naXRodWIuaW8vcmVsLW5vb3BlbmVyL1xuICAgICAgICByZXR1cm4geyB0YWdOYW1lLCBhdHRyaWJzIH07XG4gICAgfSxcbiAgICAnaW1nJzogZnVuY3Rpb24odGFnTmFtZTogc3RyaW5nLCBhdHRyaWJzOiBzYW5pdGl6ZUh0bWwuQXR0cmlidXRlcykge1xuICAgICAgICBsZXQgc3JjID0gYXR0cmlicy5zcmM7XG4gICAgICAgIC8vIFN0cmlwIG91dCBpbWdzIHRoYXQgYXJlbid0IGBteGNgIGhlcmUgaW5zdGVhZCBvZiB1c2luZyBhbGxvd2VkU2NoZW1lc0J5VGFnXG4gICAgICAgIC8vIGJlY2F1c2UgdHJhbnNmb3JtVGFncyBpcyB1c2VkIF9iZWZvcmVfIHdlIGZpbHRlciBieSBhbGxvd2VkU2NoZW1lc0J5VGFnIGFuZFxuICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIGFsbG93IGltYWdlcyB3aXRoIGBodHRwcz9gIGBzcmNgcy5cbiAgICAgICAgLy8gV2UgYWxzbyBkcm9wIGlubGluZSBpbWFnZXMgKGFzIGlmIHRoZXkgd2VyZSBub3QgcHJlc2VudCBhdCBhbGwpIHdoZW4gdGhlIFwic2hvd1xuICAgICAgICAvLyBpbWFnZXNcIiBwcmVmZXJlbmNlIGlzIGRpc2FibGVkLiBGdXR1cmUgd29yayBtaWdodCBleHBvc2Ugc29tZSBVSSB0byByZXZlYWwgdGhlbVxuICAgICAgICAvLyBsaWtlIHN0YW5kYWxvbmUgaW1hZ2UgZXZlbnRzIGhhdmUuXG4gICAgICAgIGlmICghc3JjIHx8ICFTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFwic2hvd0ltYWdlc1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdGFnTmFtZSwgYXR0cmliczoge30gfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc3JjLnN0YXJ0c1dpdGgoXCJteGM6Ly9cIikpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gTUVESUFfQVBJX01YQ19SRUdFWC5leGVjKHNyYyk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBgbXhjOi8vJHttYXRjaFsxXX0vJHttYXRjaFsyXX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzcmMuc3RhcnRzV2l0aChcIm14YzovL1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdGFnTmFtZSwgYXR0cmliczoge30gfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHdpZHRoID0gTnVtYmVyKGF0dHJpYnMud2lkdGgpIHx8IDgwMDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gTnVtYmVyKGF0dHJpYnMuaGVpZ2h0KSB8fCA2MDA7XG4gICAgICAgIGF0dHJpYnMuc3JjID0gbWVkaWFGcm9tTXhjKHNyYykuZ2V0VGh1bWJuYWlsT2ZTb3VyY2VIdHRwKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICByZXR1cm4geyB0YWdOYW1lLCBhdHRyaWJzIH07XG4gICAgfSxcbiAgICAnY29kZSc6IGZ1bmN0aW9uKHRhZ05hbWU6IHN0cmluZywgYXR0cmliczogc2FuaXRpemVIdG1sLkF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyaWJzLmNsYXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gRmlsdGVyIG91dCBhbGwgY2xhc3NlcyBvdGhlciB0aGFuIG9uZXMgc3RhcnRpbmcgd2l0aCBsYW5ndWFnZS0gZm9yIHN5bnRheCBoaWdobGlnaHRpbmcuXG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzID0gYXR0cmlicy5jbGFzcy5zcGxpdCgvXFxzLykuZmlsdGVyKGZ1bmN0aW9uKGNsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsLnN0YXJ0c1dpdGgoJ2xhbmd1YWdlLScpICYmICFjbC5zdGFydHNXaXRoKCdsYW5ndWFnZS1fJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF0dHJpYnMuY2xhc3MgPSBjbGFzc2VzLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0YWdOYW1lLCBhdHRyaWJzIH07XG4gICAgfSxcbiAgICAnKic6IGZ1bmN0aW9uKHRhZ05hbWU6IHN0cmluZywgYXR0cmliczogc2FuaXRpemVIdG1sLkF0dHJpYnV0ZXMpIHtcbiAgICAgICAgLy8gRGVsZXRlIGFueSBzdHlsZSBwcmV2aW91c2x5IGFzc2lnbmVkLCBzdHlsZSBpcyBhbiBhbGxvd2VkVGFnIGZvciBmb250IGFuZCBzcGFuXG4gICAgICAgIC8vIGJlY2F1c2UgYXR0cmlidXRlcyBhcmUgc3RyaXBwZWQgYWZ0ZXIgdHJhbnNmb3JtaW5nXG4gICAgICAgIGRlbGV0ZSBhdHRyaWJzLnN0eWxlO1xuXG4gICAgICAgIC8vIFNhbml0aXNlIGFuZCB0cmFuc2Zvcm0gZGF0YS1teC1jb2xvciBhbmQgZGF0YS1teC1iZy1jb2xvciB0byB0aGVpciBDU1NcbiAgICAgICAgLy8gZXF1aXZhbGVudHNcbiAgICAgICAgY29uc3QgY3VzdG9tQ1NTTWFwcGVyID0ge1xuICAgICAgICAgICAgJ2RhdGEtbXgtY29sb3InOiAnY29sb3InLFxuICAgICAgICAgICAgJ2RhdGEtbXgtYmctY29sb3InOiAnYmFja2dyb3VuZC1jb2xvcicsXG4gICAgICAgICAgICAvLyAkY3VzdG9tQXR0cmlidXRlS2V5OiAkY3NzQXR0cmlidXRlS2V5XG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IHN0eWxlID0gXCJcIjtcbiAgICAgICAgT2JqZWN0LmtleXMoY3VzdG9tQ1NTTWFwcGVyKS5mb3JFYWNoKChjdXN0b21BdHRyaWJ1dGVLZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNzc0F0dHJpYnV0ZUtleSA9IGN1c3RvbUNTU01hcHBlcltjdXN0b21BdHRyaWJ1dGVLZXldO1xuICAgICAgICAgICAgY29uc3QgY3VzdG9tQXR0cmlidXRlVmFsdWUgPSBhdHRyaWJzW2N1c3RvbUF0dHJpYnV0ZUtleV07XG4gICAgICAgICAgICBpZiAoY3VzdG9tQXR0cmlidXRlVmFsdWUgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgY3VzdG9tQXR0cmlidXRlVmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgQ09MT1JfUkVHRVgudGVzdChjdXN0b21BdHRyaWJ1dGVWYWx1ZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHN0eWxlICs9IGNzc0F0dHJpYnV0ZUtleSArIFwiOlwiICsgY3VzdG9tQXR0cmlidXRlVmFsdWUgKyBcIjtcIjtcbiAgICAgICAgICAgICAgICBkZWxldGUgYXR0cmlic1tjdXN0b21BdHRyaWJ1dGVLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgICAgIGF0dHJpYnMuc3R5bGUgPSBzdHlsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHRhZ05hbWUsIGF0dHJpYnMgfTtcbiAgICB9LFxufTtcblxuY29uc3Qgc2FuaXRpemVIdG1sUGFyYW1zOiBJRXh0ZW5kZWRTYW5pdGl6ZU9wdGlvbnMgPSB7XG4gICAgYWxsb3dlZFRhZ3M6IFtcbiAgICAgICAgJ2ZvbnQnLCAvLyBjdXN0b20gdG8gbWF0cml4IGZvciBJUkMtc3R5bGUgZm9udCBjb2xvcmluZ1xuICAgICAgICAnZGVsJywgLy8gZm9yIG1hcmtkb3duXG4gICAgICAgICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdibG9ja3F1b3RlJywgJ3AnLCAnYScsICd1bCcsICdvbCcsICdzdXAnLCAnc3ViJyxcbiAgICAgICAgJ25sJywgJ2xpJywgJ2InLCAnaScsICd1JywgJ3N0cm9uZycsICdlbScsICdzdHJpa2UnLCAnY29kZScsICdocicsICdicicsICdkaXYnLFxuICAgICAgICAndGFibGUnLCAndGhlYWQnLCAnY2FwdGlvbicsICd0Ym9keScsICd0cicsICd0aCcsICd0ZCcsICdwcmUnLCAnc3BhbicsICdpbWcnLFxuICAgICAgICAnZGV0YWlscycsICdzdW1tYXJ5JyxcbiAgICBdLFxuICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiB7XG4gICAgICAgIC8vIGN1c3RvbSBvbmVzIGZpcnN0OlxuICAgICAgICBmb250OiBbJ2NvbG9yJywgJ2RhdGEtbXgtYmctY29sb3InLCAnZGF0YS1teC1jb2xvcicsICdzdHlsZSddLCAvLyBjdXN0b20gdG8gbWF0cml4XG4gICAgICAgIHNwYW46IFsnZGF0YS1teC1tYXRocycsICdkYXRhLW14LWJnLWNvbG9yJywgJ2RhdGEtbXgtY29sb3InLCAnZGF0YS1teC1zcG9pbGVyJywgJ3N0eWxlJ10sIC8vIGN1c3RvbSB0byBtYXRyaXhcbiAgICAgICAgZGl2OiBbJ2RhdGEtbXgtbWF0aHMnXSxcbiAgICAgICAgYTogWydocmVmJywgJ25hbWUnLCAndGFyZ2V0JywgJ3JlbCddLCAvLyByZW1vdGUgdGFyZ2V0OiBjdXN0b20gdG8gbWF0cml4XG4gICAgICAgIGltZzogWydzcmMnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ2FsdCcsICd0aXRsZSddLFxuICAgICAgICBvbDogWydzdGFydCddLFxuICAgICAgICBjb2RlOiBbJ2NsYXNzJ10sIC8vIFdlIGRvbid0IGFjdHVhbGx5IGFsbG93IGFsbCBjbGFzc2VzLCB3ZSBmaWx0ZXIgdGhlbSBpbiB0cmFuc2Zvcm1UYWdzXG4gICAgfSxcbiAgICAvLyBMb3RzIG9mIHRoZXNlIHdvbid0IGNvbWUgdXAgYnkgZGVmYXVsdCBiZWNhdXNlIHdlIGRvbid0IGFsbG93IHRoZW1cbiAgICBzZWxmQ2xvc2luZzogWydpbWcnLCAnYnInLCAnaHInLCAnYXJlYScsICdiYXNlJywgJ2Jhc2Vmb250JywgJ2lucHV0JywgJ2xpbmsnLCAnbWV0YSddLFxuICAgIC8vIFVSTCBzY2hlbWVzIHdlIHBlcm1pdFxuICAgIGFsbG93ZWRTY2hlbWVzOiBQRVJNSVRURURfVVJMX1NDSEVNRVMsXG4gICAgYWxsb3dQcm90b2NvbFJlbGF0aXZlOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1UYWdzLFxuICAgIC8vIDUwIGxldmVscyBkZWVwIFwic2hvdWxkIGJlIGVub3VnaCBmb3IgYW55b25lXCJcbiAgICBuZXN0aW5nTGltaXQ6IDUwLFxufTtcblxuLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgYWJvdmUgZXhjZXB0IHdpdGggbGVzcyByZXdyaXRpbmdcbmNvbnN0IGNvbXBvc2VyU2FuaXRpemVIdG1sUGFyYW1zOiBJRXh0ZW5kZWRTYW5pdGl6ZU9wdGlvbnMgPSB7XG4gICAgLi4uc2FuaXRpemVIdG1sUGFyYW1zLFxuICAgIHRyYW5zZm9ybVRhZ3M6IHtcbiAgICAgICAgJ2NvZGUnOiB0cmFuc2Zvcm1UYWdzWydjb2RlJ10sXG4gICAgICAgICcqJzogdHJhbnNmb3JtVGFnc1snKiddLFxuICAgIH0sXG59O1xuXG5hYnN0cmFjdCBjbGFzcyBCYXNlSGlnaGxpZ2h0ZXI8VCBleHRlbmRzIFJlYWN0LlJlYWN0Tm9kZT4ge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBoaWdobGlnaHRDbGFzczogc3RyaW5nLCBwdWJsaWMgaGlnaGxpZ2h0TGluazogc3RyaW5nKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYXBwbHkgdGhlIGhpZ2hsaWdodHMgdG8gYSBzZWN0aW9uIG9mIHRleHRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzYWZlU25pcHBldCBUaGUgc25pcHBldCBvZiB0ZXh0IHRvIGFwcGx5IHRoZSBoaWdobGlnaHRzXG4gICAgICogICAgIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHNhZmVIaWdobGlnaHRzIEEgbGlzdCBvZiBzdWJzdHJpbmdzIHRvIGhpZ2hsaWdodCxcbiAgICAgKiAgICAgc29ydGVkIGJ5IGRlc2NlbmRpbmcgbGVuZ3RoLlxuICAgICAqXG4gICAgICogcmV0dXJucyBhIGxpc3Qgb2YgcmVzdWx0cyAoc3RyaW5ncyBmb3IgSHRtbEhpZ2hsaWdoZXIsIHJlYWN0IG5vZGVzIGZvclxuICAgICAqIFRleHRIaWdobGlnaHRlcikuXG4gICAgICovXG4gICAgcHVibGljIGFwcGx5SGlnaGxpZ2h0cyhzYWZlU25pcHBldDogc3RyaW5nLCBzYWZlSGlnaGxpZ2h0czogc3RyaW5nW10pOiBUW10ge1xuICAgICAgICBsZXQgbGFzdE9mZnNldCA9IDA7XG4gICAgICAgIGxldCBvZmZzZXQ7XG4gICAgICAgIGxldCBub2RlczogVFtdID0gW107XG5cbiAgICAgICAgY29uc3Qgc2FmZUhpZ2hsaWdodCA9IHNhZmVIaWdobGlnaHRzWzBdO1xuICAgICAgICB3aGlsZSAoKG9mZnNldCA9IHNhZmVTbmlwcGV0LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzYWZlSGlnaGxpZ2h0LnRvTG93ZXJDYXNlKCksIGxhc3RPZmZzZXQpKSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgcHJlYW1ibGVcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPiBsYXN0T2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViU25pcHBldCA9IHNhZmVTbmlwcGV0LnN1YnN0cmluZyhsYXN0T2Zmc2V0LCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIG5vZGVzID0gbm9kZXMuY29uY2F0KHRoaXMuYXBwbHlTdWJIaWdobGlnaHRzKHN1YlNuaXBwZXQsIHNhZmVIaWdobGlnaHRzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRvIGhpZ2hsaWdodC4gdXNlIHRoZSBvcmlnaW5hbCBzdHJpbmcgcmF0aGVyIHRoYW4gc2FmZUhpZ2hsaWdodFxuICAgICAgICAgICAgLy8gdG8gcHJlc2VydmUgdGhlIG9yaWdpbmFsIGNhc2luZy5cbiAgICAgICAgICAgIGNvbnN0IGVuZE9mZnNldCA9IG9mZnNldCArIHNhZmVIaWdobGlnaHQubGVuZ3RoO1xuICAgICAgICAgICAgbm9kZXMucHVzaCh0aGlzLnByb2Nlc3NTbmlwcGV0KHNhZmVTbmlwcGV0LnN1YnN0cmluZyhvZmZzZXQsIGVuZE9mZnNldCksIHRydWUpKTtcblxuICAgICAgICAgICAgbGFzdE9mZnNldCA9IGVuZE9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSBwb3N0YW1ibGVcbiAgICAgICAgaWYgKGxhc3RPZmZzZXQgIT09IHNhZmVTbmlwcGV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViU25pcHBldCA9IHNhZmVTbmlwcGV0LnN1YnN0cmluZyhsYXN0T2Zmc2V0LCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgbm9kZXMgPSBub2Rlcy5jb25jYXQodGhpcy5hcHBseVN1YkhpZ2hsaWdodHMoc3ViU25pcHBldCwgc2FmZUhpZ2hsaWdodHMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhcHBseVN1YkhpZ2hsaWdodHMoc2FmZVNuaXBwZXQ6IHN0cmluZywgc2FmZUhpZ2hsaWdodHM6IHN0cmluZ1tdKTogVFtdIHtcbiAgICAgICAgaWYgKHNhZmVIaWdobGlnaHRzWzFdKSB7XG4gICAgICAgICAgICAvLyByZWN1cnNlIGludG8gdGhpcyByYW5nZSB0byBjaGVjayBmb3IgdGhlIG5leHQgc2V0IG9mIGhpZ2hsaWdodCBtYXRjaGVzXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBseUhpZ2hsaWdodHMoc2FmZVNuaXBwZXQsIHNhZmVIaWdobGlnaHRzLnNsaWNlKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vIG1vcmUgaGlnaGxpZ2h0cyB0byBiZSBmb3VuZCwganVzdCByZXR1cm4gdGhlIHVuaGlnaGxpZ2h0ZWQgc3RyaW5nXG4gICAgICAgICAgICByZXR1cm4gW3RoaXMucHJvY2Vzc1NuaXBwZXQoc2FmZVNuaXBwZXQsIGZhbHNlKV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgcHJvY2Vzc1NuaXBwZXQoc25pcHBldDogc3RyaW5nLCBoaWdobGlnaHQ6IGJvb2xlYW4pOiBUO1xufVxuXG5jbGFzcyBIdG1sSGlnaGxpZ2h0ZXIgZXh0ZW5kcyBCYXNlSGlnaGxpZ2h0ZXI8c3RyaW5nPiB7XG4gICAgLyogaGlnaGxpZ2h0IHRoZSBnaXZlbiBzbmlwcGV0IGlmIHJlcXVpcmVkXG4gICAgICpcbiAgICAgKiBzbmlwcGV0OiBjb250ZW50IG9mIHRoZSBzcGFuOyBtdXN0IGhhdmUgYmVlbiBzYW5pdGlzZWRcbiAgICAgKiBoaWdobGlnaHQ6IHRydWUgdG8gaGlnaGxpZ2h0IGFzIGEgc2VhcmNoIG1hdGNoXG4gICAgICpcbiAgICAgKiByZXR1cm5zIGFuIEhUTUwgc3RyaW5nXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHByb2Nlc3NTbmlwcGV0KHNuaXBwZXQ6IHN0cmluZywgaGlnaGxpZ2h0OiBib29sZWFuKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKCFoaWdobGlnaHQpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgcmVxdWlyZWQgaGVyZVxuICAgICAgICAgICAgcmV0dXJuIHNuaXBwZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3BhbiA9IGA8c3BhbiBjbGFzcz1cIiR7dGhpcy5oaWdobGlnaHRDbGFzc31cIj4ke3NuaXBwZXR9PC9zcGFuPmA7XG5cbiAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0TGluaykge1xuICAgICAgICAgICAgc3BhbiA9IGA8YSBocmVmPVwiJHtlbmNvZGVVUkkodGhpcy5oaWdobGlnaHRMaW5rKX1cIj4ke3NwYW59PC9hPmA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxufVxuXG5pbnRlcmZhY2UgSU9wdHMge1xuICAgIGhpZ2hsaWdodExpbms/OiBzdHJpbmc7XG4gICAgZGlzYWJsZUJpZ0Vtb2ppPzogYm9vbGVhbjtcbiAgICBzdHJpcFJlcGx5RmFsbGJhY2s/OiBib29sZWFuO1xuICAgIHJldHVyblN0cmluZz86IGJvb2xlYW47XG4gICAgZm9yQ29tcG9zZXJRdW90ZT86IGJvb2xlYW47XG4gICAgcmVmPzogUmVhY3QuUmVmPEhUTUxTcGFuRWxlbWVudD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSU9wdHNSZXR1cm5Ob2RlIGV4dGVuZHMgSU9wdHMge1xuICAgIHJldHVyblN0cmluZzogZmFsc2UgfCB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSU9wdHNSZXR1cm5TdHJpbmcgZXh0ZW5kcyBJT3B0cyB7XG4gICAgcmV0dXJuU3RyaW5nOiB0cnVlO1xufVxuXG4vKiB0dXJuIGEgbWF0cml4IGV2ZW50IGJvZHkgaW50byBodG1sXG4gKlxuICogY29udGVudDogJ2NvbnRlbnQnIG9mIHRoZSBNYXRyaXhFdmVudFxuICpcbiAqIGhpZ2hsaWdodHM6IG9wdGlvbmFsIGxpc3Qgb2Ygd29yZHMgdG8gaGlnaGxpZ2h0LCBvcmRlcmVkIGJ5IGxvbmdlc3Qgd29yZCBmaXJzdFxuICpcbiAqIG9wdHMuaGlnaGxpZ2h0TGluazogb3B0aW9uYWwgaHJlZiB0byBhZGQgdG8gaGlnaGxpZ2h0ZWQgd29yZHNcbiAqIG9wdHMuZGlzYWJsZUJpZ0Vtb2ppOiBvcHRpb25hbCBhcmd1bWVudCB0byBkaXNhYmxlIHRoZSBiaWcgZW1vamkgY2xhc3MuXG4gKiBvcHRzLnN0cmlwUmVwbHlGYWxsYmFjazogb3B0aW9uYWwgYXJndW1lbnQgc3BlY2lmeWluZyB0aGUgZXZlbnQgaXMgYSByZXBseSBhbmQgc28gZmFsbGJhY2sgbmVlZHMgcmVtb3ZpbmdcbiAqIG9wdHMucmV0dXJuU3RyaW5nOiByZXR1cm4gYW4gSFRNTCBzdHJpbmcgcmF0aGVyIHRoYW4gSlNYIGVsZW1lbnRzXG4gKiBvcHRzLmZvckNvbXBvc2VyUXVvdGU6IG9wdGlvbmFsIHBhcmFtIHRvIGxlc3NlbiB0aGUgdXJsIHJld3JpdGluZyBkb25lIGJ5IHNhbml0aXphdGlvbiwgZm9yIHF1b3RpbmcgaW50byBjb21wb3NlclxuICogb3B0cy5yZWY6IFJlYWN0IHJlZiB0byBhdHRhY2ggdG8gYW55IFJlYWN0IGNvbXBvbmVudHMgcmV0dXJuZWQgKG5vdCBjb21wYXRpYmxlIHdpdGggb3B0cy5yZXR1cm5TdHJpbmcpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBib2R5VG9IdG1sKGNvbnRlbnQ6IElDb250ZW50LCBoaWdobGlnaHRzOiBzdHJpbmdbXSwgb3B0czogSU9wdHNSZXR1cm5TdHJpbmcpOiBzdHJpbmc7XG5leHBvcnQgZnVuY3Rpb24gYm9keVRvSHRtbChjb250ZW50OiBJQ29udGVudCwgaGlnaGxpZ2h0czogc3RyaW5nW10sIG9wdHM6IElPcHRzUmV0dXJuTm9kZSk6IFJlYWN0Tm9kZTtcbmV4cG9ydCBmdW5jdGlvbiBib2R5VG9IdG1sKGNvbnRlbnQ6IElDb250ZW50LCBoaWdobGlnaHRzOiBzdHJpbmdbXSwgb3B0czogSU9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGlzSHRtbE1lc3NhZ2UgPSBjb250ZW50LmZvcm1hdCA9PT0gXCJvcmcubWF0cml4LmN1c3RvbS5odG1sXCIgJiYgY29udGVudC5mb3JtYXR0ZWRfYm9keTtcbiAgICBsZXQgYm9keUhhc0Vtb2ppID0gZmFsc2U7XG5cbiAgICBsZXQgc2FuaXRpemVQYXJhbXMgPSBzYW5pdGl6ZUh0bWxQYXJhbXM7XG4gICAgaWYgKG9wdHMuZm9yQ29tcG9zZXJRdW90ZSkge1xuICAgICAgICBzYW5pdGl6ZVBhcmFtcyA9IGNvbXBvc2VyU2FuaXRpemVIdG1sUGFyYW1zO1xuICAgIH1cblxuICAgIGxldCBzdHJpcHBlZEJvZHk6IHN0cmluZztcbiAgICBsZXQgc2FmZUJvZHk6IHN0cmluZztcbiAgICBsZXQgaXNEaXNwbGF5ZWRXaXRoSHRtbDogYm9vbGVhbjtcbiAgICAvLyBYWFg6IFdlIHNhbml0aXplIHRoZSBIVE1MIHdoaWxzdCBhbHNvIGhpZ2hsaWdodGluZyBpdHMgdGV4dCBub2RlcywgdG8gYXZvaWQgYWNjaWRlbnRhbGx5IHRyeWluZ1xuICAgIC8vIHRvIGhpZ2hsaWdodCBIVE1MIHRhZ3MgdGhlbXNlbHZlcy4gIEhvd2V2ZXIsIHRoaXMgZG9lcyBtZWFuIHRoYXQgd2UgZG9uJ3QgaGlnaGxpZ2h0IHRleHRub2RlcyB3aGljaFxuICAgIC8vIGFyZSBpbnRlcnJ1cHRlZCBieSBIVE1MIHRhZ3MgKG5vdCB0aGF0IHdlIGRpZCBiZWZvcmUpIC0gZS5nLiBmb288c3Bhbi8+YmFyIHdvbid0IGdldCBoaWdobGlnaHRlZFxuICAgIC8vIGJ5IGFuIGF0dGVtcHQgdG8gc2VhcmNoIGZvciAnZm9vYmFyJy4gIFRoZW4gYWdhaW4sIHRoZSBzZWFyY2ggcXVlcnkgcHJvYmFibHkgd291bGRuJ3Qgd29yayBlaXRoZXJcbiAgICB0cnkge1xuICAgICAgICBpZiAoaGlnaGxpZ2h0cyAmJiBoaWdobGlnaHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGhpZ2hsaWdodGVyID0gbmV3IEh0bWxIaWdobGlnaHRlcihcIm14X0V2ZW50VGlsZV9zZWFyY2hIaWdobGlnaHRcIiwgb3B0cy5oaWdobGlnaHRMaW5rKTtcbiAgICAgICAgICAgIGNvbnN0IHNhZmVIaWdobGlnaHRzID0gaGlnaGxpZ2h0c1xuICAgICAgICAgICAgICAgIC8vIHNhbml0aXplSHRtbCBjYW4gaGFuZyBpZiBhbiB1bmNsb3NlZCBIVE1MIHRhZyBpcyB0aHJvd24gYXQgaXRcbiAgICAgICAgICAgICAgICAvLyBBIHNlYXJjaCBmb3IgYDxmb29gIHdpbGwgbWFrZSB0aGUgYnJvd3NlciBjcmFzaFxuICAgICAgICAgICAgICAgIC8vIGFuIGFsdGVybmF0aXZlIHdvdWxkIGJlIHRvIGVzY2FwZSBIVE1MIHNwZWNpYWwgY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgIC8vIGJ1dCB0aGF0IHdvdWxkIGJyaW5nIG5vIGFkZGl0aW9uYWwgYmVuZWZpdCBhcyB0aGUgaGlnaGxpZ2h0ZXJcbiAgICAgICAgICAgICAgICAvLyBkb2VzIG5vdCB3b3JrIHdpdGggdGhvc2Ugc3BlY2lhbCBjaGFyc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGhpZ2hsaWdodDogc3RyaW5nKTogYm9vbGVhbiA9PiAhaGlnaGxpZ2h0LmluY2x1ZGVzKFwiPFwiKSlcbiAgICAgICAgICAgICAgICAubWFwKChoaWdobGlnaHQ6IHN0cmluZyk6IHN0cmluZyA9PiBzYW5pdGl6ZUh0bWwoaGlnaGxpZ2h0LCBzYW5pdGl6ZVBhcmFtcykpO1xuICAgICAgICAgICAgLy8gWFhYOiBoYWNreSBib2RnZSB0byB0ZW1wb3JhcmlseSBhcHBseSBhIHRleHRGaWx0ZXIgdG8gdGhlIHNhbml0aXplUGFyYW1zIHN0cnVjdHVyZS5cbiAgICAgICAgICAgIHNhbml0aXplUGFyYW1zLnRleHRGaWx0ZXIgPSBmdW5jdGlvbihzYWZlVGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoaWdobGlnaHRlci5hcHBseUhpZ2hsaWdodHMoc2FmZVRleHQsIHNhZmVIaWdobGlnaHRzKS5qb2luKCcnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZm9ybWF0dGVkQm9keSA9IHR5cGVvZiBjb250ZW50LmZvcm1hdHRlZF9ib2R5ID09PSAnc3RyaW5nJyA/IGNvbnRlbnQuZm9ybWF0dGVkX2JvZHkgOiBudWxsO1xuICAgICAgICBjb25zdCBwbGFpbkJvZHkgPSB0eXBlb2YgY29udGVudC5ib2R5ID09PSAnc3RyaW5nJyA/IGNvbnRlbnQuYm9keSA6IFwiXCI7XG5cbiAgICAgICAgaWYgKG9wdHMuc3RyaXBSZXBseUZhbGxiYWNrICYmIGZvcm1hdHRlZEJvZHkpIGZvcm1hdHRlZEJvZHkgPSBSZXBseUNoYWluLnN0cmlwSFRNTFJlcGx5KGZvcm1hdHRlZEJvZHkpO1xuICAgICAgICBzdHJpcHBlZEJvZHkgPSBvcHRzLnN0cmlwUmVwbHlGYWxsYmFjayA/IFJlcGx5Q2hhaW4uc3RyaXBQbGFpblJlcGx5KHBsYWluQm9keSkgOiBwbGFpbkJvZHk7XG5cbiAgICAgICAgYm9keUhhc0Vtb2ppID0gbWlnaHRDb250YWluRW1vamkoaXNIdG1sTWVzc2FnZSA/IGZvcm1hdHRlZEJvZHkgOiBwbGFpbkJvZHkpO1xuXG4gICAgICAgIC8vIE9ubHkgZ2VuZXJhdGUgc2FmZUJvZHkgaWYgdGhlIG1lc3NhZ2Ugd2FzIHNlbnQgYXMgb3JnLm1hdHJpeC5jdXN0b20uaHRtbFxuICAgICAgICBpZiAoaXNIdG1sTWVzc2FnZSkge1xuICAgICAgICAgICAgaXNEaXNwbGF5ZWRXaXRoSHRtbCA9IHRydWU7XG4gICAgICAgICAgICBzYWZlQm9keSA9IHNhbml0aXplSHRtbChmb3JtYXR0ZWRCb2R5LCBzYW5pdGl6ZVBhcmFtcyk7XG5cbiAgICAgICAgICAgIGlmIChTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFwiZmVhdHVyZV9sYXRleF9tYXRoc1wiKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBodG1sID0gY2hlZXJpby5sb2FkKHNhZmVCb2R5LCB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmU6IFRoZSBgX3VzZUh0bWxQYXJzZXIyYCBpbnRlcm5hbCBvcHRpb24gaXMgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbXBsZXN0IHdheSB0byBib3RoIHBhcnNlIGFuZCByZW5kZXIgdXNpbmcgYGh0bWxwYXJzZXIyYC5cbiAgICAgICAgICAgICAgICAgICAgX3VzZUh0bWxQYXJzZXIyOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkZWNvZGVFbnRpdGllczogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIFRoZSB0eXBlcyBmb3IgYHJlcGxhY2VXaXRoYCB3cm9uZ2x5IGV4cGVjdFxuICAgICAgICAgICAgICAgIC8vIENoZWVyaW8gaW5zdGFuY2UgdG8gYmUgcmV0dXJuZWQuXG4gICAgICAgICAgICAgICAgcGh0bWwoJ2Rpdiwgc3BhbltkYXRhLW14LW1hdGhzIT1cIlwiXScpLnJlcGxhY2VXaXRoKGZ1bmN0aW9uKGksIGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGthdGV4LnJlbmRlclRvU3RyaW5nKFxuICAgICAgICAgICAgICAgICAgICAgICAgQWxsSHRtbEVudGl0aWVzLmRlY29kZShwaHRtbChlKS5hdHRyKCdkYXRhLW14LW1hdGhzJykpLFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93T25FcnJvcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIGBlYCBjYW4gYmUgYW4gRWxlbWVudCwgbm90IGp1c3QgYSBOb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU1vZGU6IGUubmFtZSA9PSAnZGl2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IFwiaHRtbEFuZE1hdGhtbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2FmZUJvZHkgPSBwaHRtbC5odG1sKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgICBkZWxldGUgc2FuaXRpemVQYXJhbXMudGV4dEZpbHRlcjtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZW50Qm9keSA9IGlzRGlzcGxheWVkV2l0aEh0bWwgPyBzYWZlQm9keSA6IHN0cmlwcGVkQm9keTtcbiAgICBpZiAob3B0cy5yZXR1cm5TdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnRCb2R5O1xuICAgIH1cblxuICAgIGxldCBlbW9qaUJvZHkgPSBmYWxzZTtcbiAgICBpZiAoIW9wdHMuZGlzYWJsZUJpZ0Vtb2ppICYmIGJvZHlIYXNFbW9qaSkge1xuICAgICAgICBsZXQgY29udGVudEJvZHlUcmltbWVkID0gY29udGVudEJvZHkgIT09IHVuZGVmaW5lZCA/IGNvbnRlbnRCb2R5LnRyaW0oKSA6ICcnO1xuXG4gICAgICAgIC8vIElnbm9yZSBzcGFjZXMgaW4gYm9keSB0ZXh0LiBFbW9qaXMgd2l0aCBzcGFjZXMgaW4gYmV0d2VlbiBzaG91bGRcbiAgICAgICAgLy8gc3RpbGwgYmUgY291bnRlZCBhcyBwdXJlbHkgZW1vamkgbWVzc2FnZXMuXG4gICAgICAgIGNvbnRlbnRCb2R5VHJpbW1lZCA9IGNvbnRlbnRCb2R5VHJpbW1lZC5yZXBsYWNlKFdISVRFU1BBQ0VfUkVHRVgsICcnKTtcblxuICAgICAgICAvLyBSZW1vdmUgemVybyB3aWR0aCBqb2luZXIgY2hhcmFjdGVycyBmcm9tIGVtb2ppIG1lc3NhZ2VzLiBUaGlzIGVuc3VyZXNcbiAgICAgICAgLy8gdGhhdCBlbW9qaXMgdGhhdCBhcmUgbWFkZSB1cCBvZiBtdWx0aXBsZSB1bmljb2RlIGNoYXJhY3RlcnMgYXJlIHN0aWxsXG4gICAgICAgIC8vIHByZXNlbnRlZCBhcyBsYXJnZS5cbiAgICAgICAgY29udGVudEJvZHlUcmltbWVkID0gY29udGVudEJvZHlUcmltbWVkLnJlcGxhY2UoWldKX1JFR0VYLCAnJyk7XG5cbiAgICAgICAgY29uc3QgbWF0Y2ggPSBCSUdFTU9KSV9SRUdFWC5leGVjKGNvbnRlbnRCb2R5VHJpbW1lZCk7XG4gICAgICAgIGVtb2ppQm9keSA9IG1hdGNoICYmIG1hdGNoWzBdICYmIG1hdGNoWzBdLmxlbmd0aCA9PT0gY29udGVudEJvZHlUcmltbWVkLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IHVzZXIgcGlsbHMgZXhwYW5kaW5nIGZvciB1c2VycyB3aXRoIG9ubHkgZW1vamkgaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlaXIgdXNlcm5hbWUuIFBlcm1hbGlua3MgKGxpbmtzIGluIHBpbGxzKSBjYW4gYmUgYW55IFVSTFxuICAgICAgICAgICAgICAgICAgICAvLyBub3csIHNvIHdlIGp1c3QgY2hlY2sgZm9yIGFuIEhUVFAtbG9va2luZyB0aGluZy5cbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaXBwZWRCb2R5ID09PSBzYWZlQm9keSB8fCAvLyByZXBsaWVzIGhhdmUgdGhlIGh0bWwgZmFsbGJhY2tzLCBhY2NvdW50IGZvciB0aGF0IGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuZm9ybWF0dGVkX2JvZHkgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKCFjb250ZW50LmZvcm1hdHRlZF9ib2R5LmluY2x1ZGVzKFwiaHR0cDpcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFjb250ZW50LmZvcm1hdHRlZF9ib2R5LmluY2x1ZGVzKFwiaHR0cHM6XCIpKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGNsYXNzTmFtZSA9IGNsYXNzTmFtZXMoe1xuICAgICAgICAnbXhfRXZlbnRUaWxlX2JvZHknOiB0cnVlLFxuICAgICAgICAnbXhfRXZlbnRUaWxlX2JpZ0Vtb2ppJzogZW1vamlCb2R5LFxuICAgICAgICAnbWFya2Rvd24tYm9keSc6IGlzSHRtbE1lc3NhZ2UgJiYgIWVtb2ppQm9keSxcbiAgICB9KTtcblxuICAgIHJldHVybiBpc0Rpc3BsYXllZFdpdGhIdG1sID9cbiAgICAgICAgPHNwYW5cbiAgICAgICAgICAgIGtleT1cImJvZHlcIlxuICAgICAgICAgICAgcmVmPXtvcHRzLnJlZn1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3sgX19odG1sOiBzYWZlQm9keSB9fVxuICAgICAgICAgICAgZGlyPVwiYXV0b1wiXG4gICAgICAgIC8+IDogPHNwYW4ga2V5PVwiYm9keVwiIHJlZj17b3B0cy5yZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBkaXI9XCJhdXRvXCI+eyBzdHJpcHBlZEJvZHkgfTwvc3Bhbj47XG59XG5cbi8qKlxuICogTGlua2lmaWVzIHRoZSBnaXZlbiBzdHJpbmcuIFRoaXMgaXMgYSB3cmFwcGVyIGFyb3VuZCAnbGlua2lmeWpzL3N0cmluZycuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBzdHJpbmcgdG8gbGlua2lmeVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIGZvciBsaW5raWZ5U3RyaW5nLiBEZWZhdWx0OiBsaW5raWZ5TWF0cml4Lm9wdGlvbnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IExpbmtpZmllZCBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmtpZnlTdHJpbmcoc3RyOiBzdHJpbmcsIG9wdGlvbnMgPSBsaW5raWZ5TWF0cml4Lm9wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiBfbGlua2lmeVN0cmluZyhzdHIsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIExpbmtpZmllcyB0aGUgZ2l2ZW4gRE9NIGVsZW1lbnQuIFRoaXMgaXMgYSB3cmFwcGVyIGFyb3VuZCAnbGlua2lmeWpzL2VsZW1lbnQnLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IERPTSBlbGVtZW50IHRvIGxpbmtpZnlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBmb3IgbGlua2lmeUVsZW1lbnQuIERlZmF1bHQ6IGxpbmtpZnlNYXRyaXgub3B0aW9uc1xuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmtpZnlFbGVtZW50KGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBvcHRpb25zID0gbGlua2lmeU1hdHJpeC5vcHRpb25zKTogSFRNTEVsZW1lbnQge1xuICAgIHJldHVybiBfbGlua2lmeUVsZW1lbnQoZWxlbWVudCwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogTGlua2lmeSB0aGUgZ2l2ZW4gc3RyaW5nIGFuZCBzYW5pdGl6ZSB0aGUgSFRNTCBhZnRlcndhcmRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXJ0eUh0bWwgVGhlIEhUTUwgc3RyaW5nIHRvIHNhbml0aXplIGFuZCBsaW5raWZ5XG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgZm9yIGxpbmtpZnlTdHJpbmcuIERlZmF1bHQ6IGxpbmtpZnlNYXRyaXgub3B0aW9uc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmtpZnlBbmRTYW5pdGl6ZUh0bWwoZGlydHlIdG1sOiBzdHJpbmcsIG9wdGlvbnMgPSBsaW5raWZ5TWF0cml4Lm9wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiBzYW5pdGl6ZUh0bWwobGlua2lmeVN0cmluZyhkaXJ0eUh0bWwsIG9wdGlvbnMpLCBzYW5pdGl6ZUh0bWxQYXJhbXMpO1xufVxuXG4vKipcbiAqIFJldHVybnMgaWYgYSBub2RlIGlzIGEgYmxvY2sgZWxlbWVudCBvciBub3QuXG4gKiBPbmx5IHRha2VzIGh0bWwgbm9kZXMgaW50byBhY2NvdW50IHRoYXQgYXJlIGFsbG93ZWQgaW4gbWF0cml4IG1lc3NhZ2VzLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybnMge2Jvb2x9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0Jsb2NrTm9kZShub2RlOiBOb2RlKTogYm9vbGVhbiB7XG4gICAgc3dpdGNoIChub2RlLm5vZGVOYW1lKSB7XG4gICAgICAgIGNhc2UgXCJIMVwiOlxuICAgICAgICBjYXNlIFwiSDJcIjpcbiAgICAgICAgY2FzZSBcIkgzXCI6XG4gICAgICAgIGNhc2UgXCJINFwiOlxuICAgICAgICBjYXNlIFwiSDVcIjpcbiAgICAgICAgY2FzZSBcIkg2XCI6XG4gICAgICAgIGNhc2UgXCJQUkVcIjpcbiAgICAgICAgY2FzZSBcIkJMT0NLUVVPVEVcIjpcbiAgICAgICAgY2FzZSBcIlBcIjpcbiAgICAgICAgY2FzZSBcIlVMXCI6XG4gICAgICAgIGNhc2UgXCJPTFwiOlxuICAgICAgICBjYXNlIFwiTElcIjpcbiAgICAgICAgY2FzZSBcIkhSXCI6XG4gICAgICAgIGNhc2UgXCJUQUJMRVwiOlxuICAgICAgICBjYXNlIFwiVEhFQURcIjpcbiAgICAgICAgY2FzZSBcIlRCT0RZXCI6XG4gICAgICAgIGNhc2UgXCJUUlwiOlxuICAgICAgICBjYXNlIFwiVEhcIjpcbiAgICAgICAgY2FzZSBcIlREXCI6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSBcIkRJVlwiOlxuICAgICAgICAgICAgLy8gZG9uJ3QgdHJlYXQgbWF0aCBub2RlcyBhcyBibG9jayBub2RlcyBmb3IgZGVzZXJpYWxpemluZ1xuICAgICAgICAgICAgcmV0dXJuICEobm9kZSBhcyBIVE1MRWxlbWVudCkuaGFzQXR0cmlidXRlKFwiZGF0YS1teC1tYXRoc1wiKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4iXX0=