"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WidgetVariableCustomisations = void 0;

/*
 * Copyright 2021 The Matrix.org Foundation C.I.C.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Populate this class with the details of your customisations when copying it.

/**
 * Provides a partial set of the variables needed to render any widget. If
 * variables are missing or not provided then they will be filled with the
 * application-determined defaults.
 *
 * This will not be called until after isReady() resolves.
 * @returns {Partial<Omit<ITemplateParams, "widgetRoomId">>} The variables.
 */
function provideVariables() {
  return {};
}
/**
 * Resolves to whether or not the customisation point is ready for variables
 * to be provided. This will block widgets being rendered.
 * @returns {Promise<boolean>} Resolves when ready.
 */


async function isReady() {
  return; // default no waiting
} // This interface summarises all available customisation points and also marks
// them all as optional. This allows customisers to only define and export the
// customisations they need while still maintaining type safety.


// A real customisation module will define and export one or more of the
// customisation points that make up the interface above.
const WidgetVariableCustomisations = {};
exports.WidgetVariableCustomisations = WidgetVariableCustomisations;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jdXN0b21pc2F0aW9ucy9XaWRnZXRWYXJpYWJsZXMudHMiXSwibmFtZXMiOlsicHJvdmlkZVZhcmlhYmxlcyIsImlzUmVhZHkiLCJXaWRnZXRWYXJpYWJsZUN1c3RvbWlzYXRpb25zIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNBLGdCQUFULEdBQTRFO0FBQ3hFLFNBQU8sRUFBUDtBQUNIO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsZUFBZUMsT0FBZixHQUF3QztBQUNwQyxTQURvQyxDQUM1QjtBQUNYLEMsQ0FFRDtBQUNBO0FBQ0E7OztBQVFBO0FBQ0E7QUFDTyxNQUFNQyw0QkFBNEQsR0FBRyxFQUFyRSIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLy8gUG9wdWxhdGUgdGhpcyBjbGFzcyB3aXRoIHRoZSBkZXRhaWxzIG9mIHlvdXIgY3VzdG9taXNhdGlvbnMgd2hlbiBjb3B5aW5nIGl0LlxuaW1wb3J0IHsgSVRlbXBsYXRlUGFyYW1zIH0gZnJvbSBcIm1hdHJpeC13aWRnZXQtYXBpXCI7XG5cbi8qKlxuICogUHJvdmlkZXMgYSBwYXJ0aWFsIHNldCBvZiB0aGUgdmFyaWFibGVzIG5lZWRlZCB0byByZW5kZXIgYW55IHdpZGdldC4gSWZcbiAqIHZhcmlhYmxlcyBhcmUgbWlzc2luZyBvciBub3QgcHJvdmlkZWQgdGhlbiB0aGV5IHdpbGwgYmUgZmlsbGVkIHdpdGggdGhlXG4gKiBhcHBsaWNhdGlvbi1kZXRlcm1pbmVkIGRlZmF1bHRzLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgYmUgY2FsbGVkIHVudGlsIGFmdGVyIGlzUmVhZHkoKSByZXNvbHZlcy5cbiAqIEByZXR1cm5zIHtQYXJ0aWFsPE9taXQ8SVRlbXBsYXRlUGFyYW1zLCBcIndpZGdldFJvb21JZFwiPj59IFRoZSB2YXJpYWJsZXMuXG4gKi9cbmZ1bmN0aW9uIHByb3ZpZGVWYXJpYWJsZXMoKTogUGFydGlhbDxPbWl0PElUZW1wbGF0ZVBhcmFtcywgXCJ3aWRnZXRSb29tSWRcIj4+IHtcbiAgICByZXR1cm4ge307XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgdG8gd2hldGhlciBvciBub3QgdGhlIGN1c3RvbWlzYXRpb24gcG9pbnQgaXMgcmVhZHkgZm9yIHZhcmlhYmxlc1xuICogdG8gYmUgcHJvdmlkZWQuIFRoaXMgd2lsbCBibG9jayB3aWRnZXRzIGJlaW5nIHJlbmRlcmVkLlxuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IFJlc29sdmVzIHdoZW4gcmVhZHkuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGlzUmVhZHkoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuOyAvLyBkZWZhdWx0IG5vIHdhaXRpbmdcbn1cblxuLy8gVGhpcyBpbnRlcmZhY2Ugc3VtbWFyaXNlcyBhbGwgYXZhaWxhYmxlIGN1c3RvbWlzYXRpb24gcG9pbnRzIGFuZCBhbHNvIG1hcmtzXG4vLyB0aGVtIGFsbCBhcyBvcHRpb25hbC4gVGhpcyBhbGxvd3MgY3VzdG9taXNlcnMgdG8gb25seSBkZWZpbmUgYW5kIGV4cG9ydCB0aGVcbi8vIGN1c3RvbWlzYXRpb25zIHRoZXkgbmVlZCB3aGlsZSBzdGlsbCBtYWludGFpbmluZyB0eXBlIHNhZmV0eS5cbmV4cG9ydCBpbnRlcmZhY2UgSVdpZGdldFZhcmlhYmxlc0N1c3RvbWlzYXRpb25zIHtcbiAgICBwcm92aWRlVmFyaWFibGVzPzogdHlwZW9mIHByb3ZpZGVWYXJpYWJsZXM7XG5cbiAgICAvLyBJZiBub3QgcHJvdmlkZWQsIHRoZSBhcHAgd2lsbCBhc3N1bWUgdGhhdCB0aGUgY3VzdG9taXNhdGlvbiBpcyBhbHdheXMgcmVhZHkuXG4gICAgaXNSZWFkeT86IHR5cGVvZiBpc1JlYWR5O1xufVxuXG4vLyBBIHJlYWwgY3VzdG9taXNhdGlvbiBtb2R1bGUgd2lsbCBkZWZpbmUgYW5kIGV4cG9ydCBvbmUgb3IgbW9yZSBvZiB0aGVcbi8vIGN1c3RvbWlzYXRpb24gcG9pbnRzIHRoYXQgbWFrZSB1cCB0aGUgaW50ZXJmYWNlIGFib3ZlLlxuZXhwb3J0IGNvbnN0IFdpZGdldFZhcmlhYmxlQ3VzdG9taXNhdGlvbnM6IElXaWRnZXRWYXJpYWJsZXNDdXN0b21pc2F0aW9ucyA9IHt9O1xuIl19