"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ModalManager = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _classnames = _interopRequireDefault(require("classnames"));

var _utils = require("matrix-js-sdk/src/utils");

var _Analytics = _interopRequireDefault(require("./Analytics"));

var _dispatcher = _interopRequireDefault(require("./dispatcher/dispatcher"));

var _AsyncWrapper = _interopRequireDefault(require("./AsyncWrapper"));

/*
Copyright 2015, 2016 OpenMarket Ltd
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
const DIALOG_CONTAINER_ID = "mx_Dialog_Container";
const STATIC_DIALOG_CONTAINER_ID = "mx_Dialog_StaticContainer";

class ModalManager {
  constructor() {
    (0, _defineProperty2.default)(this, "counter", 0);
    (0, _defineProperty2.default)(this, "priorityModal", null);
    (0, _defineProperty2.default)(this, "staticModal", null);
    (0, _defineProperty2.default)(this, "modals", []);
    (0, _defineProperty2.default)(this, "onBackgroundClick", () => {
      const modal = this.getCurrentModal();

      if (!modal) {
        return;
      } // we want to pass a reason to the onBeforeClose
      // callback, but close is currently defined to
      // pass all number of arguments to the onFinished callback
      // so, pass the reason to close through a member variable


      modal.closeReason = "backgroundClick";
      modal.close();
      modal.closeReason = null;
    });
  }

  static getOrCreateContainer() {
    let container = document.getElementById(DIALOG_CONTAINER_ID);

    if (!container) {
      container = document.createElement("div");
      container.id = DIALOG_CONTAINER_ID;
      document.body.appendChild(container);
    }

    return container;
  }

  static getOrCreateStaticContainer() {
    let container = document.getElementById(STATIC_DIALOG_CONTAINER_ID);

    if (!container) {
      container = document.createElement("div");
      container.id = STATIC_DIALOG_CONTAINER_ID;
      document.body.appendChild(container);
    }

    return container;
  }

  toggleCurrentDialogVisibility() {
    const modal = this.getCurrentModal();
    if (!modal) return;
    modal.hidden = !modal.hidden;
  }

  hasDialogs() {
    return this.priorityModal || this.staticModal || this.modals.length > 0;
  }

  createTrackedDialog(analyticsAction, analyticsInfo, ...rest) {
    _Analytics.default.trackEvent('Modal', analyticsAction, analyticsInfo);

    return this.createDialog(...rest);
  }

  appendTrackedDialog(analyticsAction, analyticsInfo, ...rest) {
    _Analytics.default.trackEvent('Modal', analyticsAction, analyticsInfo);

    return this.appendDialog(...rest);
  }

  createDialog(Element, ...rest) {
    return this.createDialogAsync(Promise.resolve(Element), ...rest);
  }

  appendDialog(Element, ...rest) {
    return this.appendDialogAsync(Promise.resolve(Element), ...rest);
  }

  createTrackedDialogAsync(analyticsAction, analyticsInfo, ...rest) {
    _Analytics.default.trackEvent('Modal', analyticsAction, analyticsInfo);

    return this.createDialogAsync(...rest);
  }

  appendTrackedDialogAsync(analyticsAction, analyticsInfo, ...rest) {
    _Analytics.default.trackEvent('Modal', analyticsAction, analyticsInfo);

    return this.appendDialogAsync(...rest);
  }

  closeCurrentModal(reason) {
    const modal = this.getCurrentModal();

    if (!modal) {
      return;
    }

    modal.closeReason = reason;
    modal.close();
  }

  buildModal(prom, props, className, options) {
    const modal = {
      onFinished: props ? props.onFinished : null,
      onBeforeClose: options.onBeforeClose,
      beforeClosePromise: null,
      closeReason: null,
      className,
      // these will be set below but we need an object reference to pass to getCloseFn before we can do that
      elem: null,
      close: null
    }; // never call this from onFinished() otherwise it will loop

    const [closeDialog, onFinishedProm] = this.getCloseFn(modal, props); // don't attempt to reuse the same AsyncWrapper for different dialogs,
    // otherwise we'll get confused.

    const modalCount = this.counter++; // FIXME: If a dialog uses getDefaultProps it clobbers the onFinished
    // property set here so you can't close the dialog from a button click!

    modal.elem = /*#__PURE__*/_react.default.createElement(_AsyncWrapper.default, (0, _extends2.default)({
      key: modalCount,
      prom: prom
    }, props, {
      onFinished: closeDialog
    }));
    modal.close = closeDialog;
    return {
      modal,
      closeDialog,
      onFinishedProm
    };
  }

  getCloseFn(modal, props) {
    const deferred = (0, _utils.defer)();
    return [async (...args) => {
      if (modal.beforeClosePromise) {
        await modal.beforeClosePromise;
      } else if (modal.onBeforeClose) {
        modal.beforeClosePromise = modal.onBeforeClose(modal.closeReason);
        const shouldClose = await modal.beforeClosePromise;
        modal.beforeClosePromise = null;

        if (!shouldClose) {
          return;
        }
      }

      deferred.resolve(args);
      if (props && props.onFinished) props.onFinished.apply(null, args);
      const i = this.modals.indexOf(modal);

      if (i >= 0) {
        this.modals.splice(i, 1);
      }

      if (this.priorityModal === modal) {
        this.priorityModal = null; // XXX: This is destructive

        this.modals = [];
      }

      if (this.staticModal === modal) {
        this.staticModal = null; // XXX: This is destructive

        this.modals = [];
      }

      this.reRender();
    }, deferred.promise];
  }
  /**
   * @callback onBeforeClose
   * @param {string?} reason either "backgroundClick" or null
   * @return {Promise<bool>} whether the dialog should close
   */

  /**
   * Open a modal view.
   *
   * This can be used to display a react component which is loaded as an asynchronous
   * webpack component. To do this, set 'loader' as:
   *
   *   (cb) => {
   *       require(['<module>'], cb);
   *   }
   *
   * @param {Promise} prom   a promise which resolves with a React component
   *   which will be displayed as the modal view.
   *
   * @param {Object} props   properties to pass to the displayed
   *    component. (We will also pass an 'onFinished' property.)
   *
   * @param {String} className   CSS class to apply to the modal wrapper
   *
   * @param {boolean} isPriorityModal if true, this modal will be displayed regardless
   *                                  of other modals that are currently in the stack.
   *                                  Also, when closed, all modals will be removed
   *                                  from the stack.
   * @param {boolean} isStaticModal  if true, this modal will be displayed under other
   *                                 modals in the stack. When closed, all modals will
   *                                 also be removed from the stack. This is not compatible
   *                                 with being a priority modal. Only one modal can be
   *                                 static at a time.
   * @param {Object} options? extra options for the dialog
   * @param {onBeforeClose} options.onBeforeClose a callback to decide whether to close the dialog
   * @returns {object} Object with 'close' parameter being a function that will close the dialog
   */


  createDialogAsync(prom, props, className, isPriorityModal = false, isStaticModal = false, options = {}) {
    const {
      modal,
      closeDialog,
      onFinishedProm
    } = this.buildModal(prom, props, className, options);

    if (isPriorityModal) {
      // XXX: This is destructive
      this.priorityModal = modal;
    } else if (isStaticModal) {
      // This is intentionally destructive
      this.staticModal = modal;
    } else {
      this.modals.unshift(modal);
    }

    this.reRender();
    return {
      close: closeDialog,
      finished: onFinishedProm
    };
  }

  appendDialogAsync(prom, props, className) {
    const {
      modal,
      closeDialog,
      onFinishedProm
    } = this.buildModal(prom, props, className, {});
    this.modals.push(modal);
    this.reRender();
    return {
      close: closeDialog,
      finished: onFinishedProm
    };
  }

  getCurrentModal() {
    return this.priorityModal ? this.priorityModal : this.modals[0] || this.staticModal;
  }

  async reRender() {
    // await next tick because sometimes ReactDOM can race with itself and cause the modal to wrongly stick around
    await (0, _utils.sleep)(0);

    if (this.modals.length === 0 && !this.priorityModal && !this.staticModal) {
      // If there is no modal to render, make all of Element available
      // to screen reader users again
      _dispatcher.default.dispatch({
        action: 'aria_unhide_main_app'
      });

      _reactDom.default.unmountComponentAtNode(ModalManager.getOrCreateContainer());

      _reactDom.default.unmountComponentAtNode(ModalManager.getOrCreateStaticContainer());

      return;
    } // Hide the content outside the modal to screen reader users
    // so they won't be able to navigate into it and act on it using
    // screen reader specific features


    _dispatcher.default.dispatch({
      action: 'aria_hide_main_app'
    });

    if (this.staticModal) {
      const classes = (0, _classnames.default)("mx_Dialog_wrapper mx_Dialog_staticWrapper", this.staticModal.className);

      const staticDialog = /*#__PURE__*/_react.default.createElement("div", {
        className: classes
      }, /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_Dialog"
      }, this.staticModal.elem), /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_Dialog_background mx_Dialog_staticBackground",
        onClick: this.onBackgroundClick
      }));

      _reactDom.default.render(staticDialog, ModalManager.getOrCreateStaticContainer());
    } else {
      // This is safe to call repeatedly if we happen to do that
      _reactDom.default.unmountComponentAtNode(ModalManager.getOrCreateStaticContainer());
    }

    const modal = this.getCurrentModal();

    if (modal !== this.staticModal && !modal.hidden) {
      const classes = (0, _classnames.default)("mx_Dialog_wrapper", modal.className, {
        mx_Dialog_wrapperWithStaticUnder: this.staticModal
      });

      const dialog = /*#__PURE__*/_react.default.createElement("div", {
        className: classes
      }, /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_Dialog"
      }, modal.elem), /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_Dialog_background",
        onClick: this.onBackgroundClick
      }));

      setImmediate(() => _reactDom.default.render(dialog, ModalManager.getOrCreateContainer()));
    } else {
      // This is safe to call repeatedly if we happen to do that
      _reactDom.default.unmountComponentAtNode(ModalManager.getOrCreateContainer());
    }
  }

}

exports.ModalManager = ModalManager;

if (!window.singletonModalManager) {
  window.singletonModalManager = new ModalManager();
}

var _default = window.singletonModalManager;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9Nb2RhbC50c3giXSwibmFtZXMiOlsiRElBTE9HX0NPTlRBSU5FUl9JRCIsIlNUQVRJQ19ESUFMT0dfQ09OVEFJTkVSX0lEIiwiTW9kYWxNYW5hZ2VyIiwibW9kYWwiLCJnZXRDdXJyZW50TW9kYWwiLCJjbG9zZVJlYXNvbiIsImNsb3NlIiwiZ2V0T3JDcmVhdGVDb250YWluZXIiLCJjb250YWluZXIiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiY3JlYXRlRWxlbWVudCIsImlkIiwiYm9keSIsImFwcGVuZENoaWxkIiwiZ2V0T3JDcmVhdGVTdGF0aWNDb250YWluZXIiLCJ0b2dnbGVDdXJyZW50RGlhbG9nVmlzaWJpbGl0eSIsImhpZGRlbiIsImhhc0RpYWxvZ3MiLCJwcmlvcml0eU1vZGFsIiwic3RhdGljTW9kYWwiLCJtb2RhbHMiLCJsZW5ndGgiLCJjcmVhdGVUcmFja2VkRGlhbG9nIiwiYW5hbHl0aWNzQWN0aW9uIiwiYW5hbHl0aWNzSW5mbyIsInJlc3QiLCJBbmFseXRpY3MiLCJ0cmFja0V2ZW50IiwiY3JlYXRlRGlhbG9nIiwiYXBwZW5kVHJhY2tlZERpYWxvZyIsImFwcGVuZERpYWxvZyIsIkVsZW1lbnQiLCJjcmVhdGVEaWFsb2dBc3luYyIsIlByb21pc2UiLCJyZXNvbHZlIiwiYXBwZW5kRGlhbG9nQXN5bmMiLCJjcmVhdGVUcmFja2VkRGlhbG9nQXN5bmMiLCJhcHBlbmRUcmFja2VkRGlhbG9nQXN5bmMiLCJjbG9zZUN1cnJlbnRNb2RhbCIsInJlYXNvbiIsImJ1aWxkTW9kYWwiLCJwcm9tIiwicHJvcHMiLCJjbGFzc05hbWUiLCJvcHRpb25zIiwib25GaW5pc2hlZCIsIm9uQmVmb3JlQ2xvc2UiLCJiZWZvcmVDbG9zZVByb21pc2UiLCJlbGVtIiwiY2xvc2VEaWFsb2ciLCJvbkZpbmlzaGVkUHJvbSIsImdldENsb3NlRm4iLCJtb2RhbENvdW50IiwiY291bnRlciIsImRlZmVycmVkIiwiYXJncyIsInNob3VsZENsb3NlIiwiYXBwbHkiLCJpIiwiaW5kZXhPZiIsInNwbGljZSIsInJlUmVuZGVyIiwicHJvbWlzZSIsImlzUHJpb3JpdHlNb2RhbCIsImlzU3RhdGljTW9kYWwiLCJ1bnNoaWZ0IiwiZmluaXNoZWQiLCJwdXNoIiwiZGlzIiwiZGlzcGF0Y2giLCJhY3Rpb24iLCJSZWFjdERPTSIsInVubW91bnRDb21wb25lbnRBdE5vZGUiLCJjbGFzc2VzIiwic3RhdGljRGlhbG9nIiwib25CYWNrZ3JvdW5kQ2xpY2siLCJyZW5kZXIiLCJteF9EaWFsb2dfd3JhcHBlcldpdGhTdGF0aWNVbmRlciIsImRpYWxvZyIsInNldEltbWVkaWF0ZSIsIndpbmRvdyIsInNpbmdsZXRvbk1vZGFsTWFuYWdlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQWlCQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUF4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFXQSxNQUFNQSxtQkFBbUIsR0FBRyxxQkFBNUI7QUFDQSxNQUFNQywwQkFBMEIsR0FBRywyQkFBbkM7O0FBOEJPLE1BQU1DLFlBQU4sQ0FBbUI7QUFBQTtBQUFBLG1EQUNKLENBREk7QUFBQSx5REFLZSxJQUxmO0FBQUEsdURBU2EsSUFUYjtBQUFBLGtEQVlVLEVBWlY7QUFBQSw2REFtUU0sTUFBTTtBQUM5QixZQUFNQyxLQUFLLEdBQUcsS0FBS0MsZUFBTCxFQUFkOztBQUNBLFVBQUksQ0FBQ0QsS0FBTCxFQUFZO0FBQ1I7QUFDSCxPQUo2QixDQUs5QjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0FBLE1BQUFBLEtBQUssQ0FBQ0UsV0FBTixHQUFvQixpQkFBcEI7QUFDQUYsTUFBQUEsS0FBSyxDQUFDRyxLQUFOO0FBQ0FILE1BQUFBLEtBQUssQ0FBQ0UsV0FBTixHQUFvQixJQUFwQjtBQUNILEtBL1FxQjtBQUFBOztBQWNhLFNBQXBCRSxvQkFBb0IsR0FBRztB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QUMsTUFBTVIsa0JBQVNLLE1BQVQsQ0FBZ0JFLE1BQWhCLEVBQXdCN0UsWUFBWSxDQUFDSyxvQkFBYixFQUF4QixDQUFQLENBQVo7QUFDSCxLQWZELE1BZU87QUFDSDtBQUNBaUUsd0JBQVNDLHNCQUFULENBQWdDdkUsWUFBWSxDQUFDSyxvQkFBYixFQUFoQztBQUNIO0FBQ0o7O0FBalZxQjs7OztBQW9WMUIsSUFBSSxDQUFDMEUsTUFBTSxDQUFDQyxxQkFBWixFQUFtQztBQUMvQkQsRUFBQUEsTUFBTSxDQUFDQyxxQkFBUCxHQUErQixJQUFJaEYsWUFBSixFQUEvQjtBQUNIOztlQUNjK0UsTUFBTSxDQUFDQyxxQiIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxNSwgMjAxNiBPcGVuTWFya2V0IEx0ZFxuQ29weXJpZ2h0IDIwMjAgVGhlIE1hdHJpeC5vcmcgRm91bmRhdGlvbiBDLkkuQy5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IGRlZmVyLCBzbGVlcCB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy91dGlsc1wiO1xuXG5pbXBvcnQgQW5hbHl0aWNzIGZyb20gJy4vQW5hbHl0aWNzJztcbmltcG9ydCBkaXMgZnJvbSAnLi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXInO1xuaW1wb3J0IEFzeW5jV3JhcHBlciBmcm9tICcuL0FzeW5jV3JhcHBlcic7XG5cbmNvbnN0IERJQUxPR19DT05UQUlORVJfSUQgPSBcIm14X0RpYWxvZ19Db250YWluZXJcIjtcbmNvbnN0IFNUQVRJQ19ESUFMT0dfQ09OVEFJTkVSX0lEID0gXCJteF9EaWFsb2dfU3RhdGljQ29udGFpbmVyXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSU1vZGFsPFQgZXh0ZW5kcyBhbnlbXT4ge1xuICAgIGVsZW06IFJlYWN0LlJlYWN0Tm9kZTtcbiAgICBjbGFzc05hbWU/OiBzdHJpbmc7XG4gICAgYmVmb3JlQ2xvc2VQcm9taXNlPzogUHJvbWlzZTxib29sZWFuPjtcbiAgICBjbG9zZVJlYXNvbj86IHN0cmluZztcbiAgICBvbkJlZm9yZUNsb3NlPyhyZWFzb24/OiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+O1xuICAgIG9uRmluaXNoZWQoLi4uYXJnczogVCk6IHZvaWQ7XG4gICAgY2xvc2UoLi4uYXJnczogVCk6IHZvaWQ7XG4gICAgaGlkZGVuPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJSGFuZGxlPFQgZXh0ZW5kcyBhbnlbXT4ge1xuICAgIGZpbmlzaGVkOiBQcm9taXNlPFQ+O1xuICAgIGNsb3NlKC4uLmFyZ3M6IFQpOiB2b2lkO1xufVxuXG5pbnRlcmZhY2UgSVByb3BzPFQgZXh0ZW5kcyBhbnlbXT4ge1xuICAgIG9uRmluaXNoZWQ/KC4uLmFyZ3M6IFQpOiB2b2lkO1xuICAgIC8vIFRPRE8gaW1wcm92ZSB0eXBpbmcgaGVyZSBvbmNlIGFsbCBNb2RhbHMgYXJlIFRTIGFuZCB3ZSBjYW4gZXhoYXVzdGl2ZWx5IGNoZWNrIHRoZSBwcm9wc1xuICAgIFtrZXk6IHN0cmluZ106IGFueTtcbn1cblxuaW50ZXJmYWNlIElPcHRpb25zPFQgZXh0ZW5kcyBhbnlbXT4ge1xuICAgIG9uQmVmb3JlQ2xvc2U/OiBJTW9kYWw8VD5bXCJvbkJlZm9yZUNsb3NlXCJdO1xufVxuXG50eXBlIFBhcmFtZXRlcnNXaXRob3V0Rmlyc3Q8VCBleHRlbmRzICguLi5hcmdzOiBhbnkpID0+IGFueT4gPSBUIGV4dGVuZHMgKGE6IGFueSwgLi4uYXJnczogaW5mZXIgUCkgPT4gYW55ID8gUCA6IG5ldmVyO1xuXG5leHBvcnQgY2xhc3MgTW9kYWxNYW5hZ2VyIHtcbiAgICBwcml2YXRlIGNvdW50ZXIgPSAwO1xuICAgIC8vIFRoZSBtb2RhbCB0byBwcmlvcml0aXNlIG92ZXIgYWxsIG90aGVycy4gSWYgdGhpcyBpcyBzZXQsIG9ubHkgc2hvd1xuICAgIC8vIHRoaXMgbW9kYWwuIFJlbW92ZSBhbGwgb3RoZXIgbW9kYWxzIGZyb20gdGhlIHN0YWNrIHdoZW4gdGhpcyBtb2RhbFxuICAgIC8vIGlzIGNsb3NlZC5cbiAgICBwcml2YXRlIHByaW9yaXR5TW9kYWw6IElNb2RhbDxhbnk+ID0gbnVsbDtcbiAgICAvLyBUaGUgbW9kYWwgdG8ga2VlcCBvcGVuIHVuZGVybmVhdGggb3RoZXIgbW9kYWxzIGlmIHBvc3NpYmxlLiBVc2VmdWxcbiAgICAvLyBmb3IgY2FzZXMgbGlrZSBTZXR0aW5ncyB3aGVyZSB0aGUgbW9kYWwgc2hvdWxkIHJlbWFpbiBvcGVuIHdoaWxlIHRoZVxuICAgIC8vIHVzZXIgaXMgcHJvbXB0ZWQgZm9yIG1vcmUgaW5mb3JtYXRpb24vZXJyb3JzLlxuICAgIHByaXZhdGUgc3RhdGljTW9kYWw6IElNb2RhbDxhbnk+ID0gbnVsbDtcbiAgICAvLyBBIGxpc3Qgb2YgdGhlIG1vZGFscyB3ZSBoYXZlIHN0YWNrZWQgdXAsIHdpdGggdGhlIG1vc3QgcmVjZW50IGF0IFswXVxuICAgIC8vIE5laXRoZXIgdGhlIHN0YXRpYyBub3IgcHJpb3JpdHkgbW9kYWwgd2lsbCBiZSBpbiB0aGlzIGxpc3QuXG4gICAgcHJpdmF0ZSBtb2RhbHM6IElNb2RhbDxhbnk+W10gPSBbXTtcblxuICAgIHByaXZhdGUgc3RhdGljIGdldE9yQ3JlYXRlQ29udGFpbmVyKCkge1xuICAgICAgICBsZXQgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoRElBTE9HX0NPTlRBSU5FUl9JRCk7XG5cbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBjb250YWluZXIuaWQgPSBESUFMT0dfQ09OVEFJTkVSX0lEO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXRPckNyZWF0ZVN0YXRpY0NvbnRhaW5lcigpIHtcbiAgICAgICAgbGV0IGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFNUQVRJQ19ESUFMT0dfQ09OVEFJTkVSX0lEKTtcblxuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5pZCA9IFNUQVRJQ19ESUFMT0dfQ09OVEFJTkVSX0lEO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgdG9nZ2xlQ3VycmVudERpYWxvZ1Zpc2liaWxpdHkoKSB7XG4gICAgICAgIGNvbnN0IG1vZGFsID0gdGhpcy5nZXRDdXJyZW50TW9kYWwoKTtcbiAgICAgICAgaWYgKCFtb2RhbCkgcmV0dXJuO1xuICAgICAgICBtb2RhbC5oaWRkZW4gPSAhbW9kYWwuaGlkZGVuO1xuICAgIH1cblxuICAgIHB1YmxpYyBoYXNEaWFsb2dzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmlvcml0eU1vZGFsIHx8IHRoaXMuc3RhdGljTW9kYWwgfHwgdGhpcy5tb2RhbHMubGVuZ3RoID4gMDtcbiAgICB9XG5cbiAgICBwdWJsaWMgY3JlYXRlVHJhY2tlZERpYWxvZzxUIGV4dGVuZHMgYW55W10+KFxuICAgICAgICBhbmFseXRpY3NBY3Rpb246IHN0cmluZyxcbiAgICAgICAgYW5hbHl0aWNzSW5mbzogc3RyaW5nLFxuICAgICAgICAuLi5yZXN0OiBQYXJhbWV0ZXJzPE1vZGFsTWFuYWdlcltcImNyZWF0ZURpYWxvZ1wiXT5cbiAgICApIHtcbiAgICAgICAgQW5hbHl0aWNzLnRyYWNrRXZlbnQoJ01vZGFsJywgYW5hbHl0aWNzQWN0aW9uLCBhbmFseXRpY3NJbmZvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRGlhbG9nPFQ+KC4uLnJlc3QpO1xuICAgIH1cblxuICAgIHB1YmxpYyBhcHBlbmRUcmFja2VkRGlhbG9nPFQgZXh0ZW5kcyBhbnlbXT4oXG4gICAgICAgIGFuYWx5dGljc0FjdGlvbjogc3RyaW5nLFxuICAgICAgICBhbmFseXRpY3NJbmZvOiBzdHJpbmcsXG4gICAgICAgIC4uLnJlc3Q6IFBhcmFtZXRlcnM8TW9kYWxNYW5hZ2VyW1wiYXBwZW5kRGlhbG9nXCJdPlxuICAgICkge1xuICAgICAgICBBbmFseXRpY3MudHJhY2tFdmVudCgnTW9kYWwnLCBhbmFseXRpY3NBY3Rpb24sIGFuYWx5dGljc0luZm8pO1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBlbmREaWFsb2c8VD4oLi4ucmVzdCk7XG4gICAgfVxuXG4gICAgcHVibGljIGNyZWF0ZURpYWxvZzxUIGV4dGVuZHMgYW55W10+KFxuICAgICAgICBFbGVtZW50OiBSZWFjdC5Db21wb25lbnRUeXBlLFxuICAgICAgICAuLi5yZXN0OiBQYXJhbWV0ZXJzV2l0aG91dEZpcnN0PE1vZGFsTWFuYWdlcltcImNyZWF0ZURpYWxvZ0FzeW5jXCJdPlxuICAgICkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVEaWFsb2dBc3luYzxUPihQcm9taXNlLnJlc29sdmUoRWxlbWVudCksIC4uLnJlc3QpO1xuICAgIH1cblxuICAgIHB1YmxpYyBhcHBlbmREaWFsb2c8VCBleHRlbmRzIGFueVtdPihcbiAgICAgICAgRWxlbWVudDogUmVhY3QuQ29tcG9uZW50VHlwZSxcbiAgICAgICAgLi4ucmVzdDogUGFyYW1ldGVyc1dpdGhvdXRGaXJzdDxNb2RhbE1hbmFnZXJbXCJhcHBlbmREaWFsb2dBc3luY1wiXT5cbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwZW5kRGlhbG9nQXN5bmM8VD4oUHJvbWlzZS5yZXNvbHZlKEVsZW1lbnQpLCAuLi5yZXN0KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY3JlYXRlVHJhY2tlZERpYWxvZ0FzeW5jPFQgZXh0ZW5kcyBhbnlbXT4oXG4gICAgICAgIGFuYWx5dGljc0FjdGlvbjogc3RyaW5nLFxuICAgICAgICBhbmFseXRpY3NJbmZvOiBzdHJpbmcsXG4gICAgICAgIC4uLnJlc3Q6IFBhcmFtZXRlcnM8TW9kYWxNYW5hZ2VyW1wiY3JlYXRlRGlhbG9nQXN5bmNcIl0+XG4gICAgKSB7XG4gICAgICAgIEFuYWx5dGljcy50cmFja0V2ZW50KCdNb2RhbCcsIGFuYWx5dGljc0FjdGlvbiwgYW5hbHl0aWNzSW5mbyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZURpYWxvZ0FzeW5jPFQ+KC4uLnJlc3QpO1xuICAgIH1cblxuICAgIHB1YmxpYyBhcHBlbmRUcmFja2VkRGlhbG9nQXN5bmM8VCBleHRlbmRzIGFueVtdPihcbiAgICAgICAgYW5hbHl0aWNzQWN0aW9uOiBzdHJpbmcsXG4gICAgICAgIGFuYWx5dGljc0luZm86IHN0cmluZyxcbiAgICAgICAgLi4ucmVzdDogUGFyYW1ldGVyczxNb2RhbE1hbmFnZXJbXCJhcHBlbmREaWFsb2dBc3luY1wiXT5cbiAgICApIHtcbiAgICAgICAgQW5hbHl0aWNzLnRyYWNrRXZlbnQoJ01vZGFsJywgYW5hbHl0aWNzQWN0aW9uLCBhbmFseXRpY3NJbmZvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwZW5kRGlhbG9nQXN5bmM8VD4oLi4ucmVzdCk7XG4gICAgfVxuXG4gICAgcHVibGljIGNsb3NlQ3VycmVudE1vZGFsKHJlYXNvbjogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IG1vZGFsID0gdGhpcy5nZXRDdXJyZW50TW9kYWwoKTtcbiAgICAgICAgaWYgKCFtb2RhbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1vZGFsLmNsb3NlUmVhc29uID0gcmVhc29uO1xuICAgICAgICBtb2RhbC5jbG9zZSgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgYnVpbGRNb2RhbDxUIGV4dGVuZHMgYW55W10+KFxuICAgICAgICBwcm9tOiBQcm9taXNlPFJlYWN0LkNvbXBvbmVudFR5cGU+LFxuICAgICAgICBwcm9wcz86IElQcm9wczxUPixcbiAgICAgICAgY2xhc3NOYW1lPzogc3RyaW5nLFxuICAgICAgICBvcHRpb25zPzogSU9wdGlvbnM8VD4sXG4gICAgKSB7XG4gICAgICAgIGNvbnN0IG1vZGFsOiBJTW9kYWw8VD4gPSB7XG4gICAgICAgICAgICBvbkZpbmlzaGVkOiBwcm9wcyA/IHByb3BzLm9uRmluaXNoZWQgOiBudWxsLFxuICAgICAgICAgICAgb25CZWZvcmVDbG9zZTogb3B0aW9ucy5vbkJlZm9yZUNsb3NlLFxuICAgICAgICAgICAgYmVmb3JlQ2xvc2VQcm9taXNlOiBudWxsLFxuICAgICAgICAgICAgY2xvc2VSZWFzb246IG51bGwsXG4gICAgICAgICAgICBjbGFzc05hbWUsXG5cbiAgICAgICAgICAgIC8vIHRoZXNlIHdpbGwgYmUgc2V0IGJlbG93IGJ1dCB3ZSBuZWVkIGFuIG9iamVjdCByZWZlcmVuY2UgdG8gcGFzcyB0byBnZXRDbG9zZUZuIGJlZm9yZSB3ZSBjYW4gZG8gdGhhdFxuICAgICAgICAgICAgZWxlbTogbnVsbCxcbiAgICAgICAgICAgIGNsb3NlOiBudWxsLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIG5ldmVyIGNhbGwgdGhpcyBmcm9tIG9uRmluaXNoZWQoKSBvdGhlcndpc2UgaXQgd2lsbCBsb29wXG4gICAgICAgIGNvbnN0IFtjbG9zZURpYWxvZywgb25GaW5pc2hlZFByb21dID0gdGhpcy5nZXRDbG9zZUZuPFQ+KG1vZGFsLCBwcm9wcyk7XG5cbiAgICAgICAgLy8gZG9uJ3QgYXR0ZW1wdCB0byByZXVzZSB0aGUgc2FtZSBBc3luY1dyYXBwZXIgZm9yIGRpZmZlcmVudCBkaWFsb2dzLFxuICAgICAgICAvLyBvdGhlcndpc2Ugd2UnbGwgZ2V0IGNvbmZ1c2VkLlxuICAgICAgICBjb25zdCBtb2RhbENvdW50ID0gdGhpcy5jb3VudGVyKys7XG5cbiAgICAgICAgLy8gRklYTUU6IElmIGEgZGlhbG9nIHVzZXMgZ2V0RGVmYXVsdFByb3BzIGl0IGNsb2JiZXJzIHRoZSBvbkZpbmlzaGVkXG4gICAgICAgIC8vIHByb3BlcnR5IHNldCBoZXJlIHNvIHlvdSBjYW4ndCBjbG9zZSB0aGUgZGlhbG9nIGZyb20gYSBidXR0b24gY2xpY2shXG4gICAgICAgIG1vZGFsLmVsZW0gPSA8QXN5bmNXcmFwcGVyIGtleT17bW9kYWxDb3VudH0gcHJvbT17cHJvbX0gey4uLnByb3BzfSBvbkZpbmlzaGVkPXtjbG9zZURpYWxvZ30gLz47XG4gICAgICAgIG1vZGFsLmNsb3NlID0gY2xvc2VEaWFsb2c7XG5cbiAgICAgICAgcmV0dXJuIHsgbW9kYWwsIGNsb3NlRGlhbG9nLCBvbkZpbmlzaGVkUHJvbSB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0Q2xvc2VGbjxUIGV4dGVuZHMgYW55W10+KFxuICAgICAgICBtb2RhbDogSU1vZGFsPFQ+LFxuICAgICAgICBwcm9wczogSVByb3BzPFQ+LFxuICAgICk6IFtJSGFuZGxlPFQ+W1wiY2xvc2VcIl0sIElIYW5kbGU8VD5bXCJmaW5pc2hlZFwiXV0ge1xuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IGRlZmVyPFQ+KCk7XG4gICAgICAgIHJldHVybiBbYXN5bmMgKC4uLmFyZ3M6IFQpID0+IHtcbiAgICAgICAgICAgIGlmIChtb2RhbC5iZWZvcmVDbG9zZVByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBtb2RhbC5iZWZvcmVDbG9zZVByb21pc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGFsLm9uQmVmb3JlQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICBtb2RhbC5iZWZvcmVDbG9zZVByb21pc2UgPSBtb2RhbC5vbkJlZm9yZUNsb3NlKG1vZGFsLmNsb3NlUmVhc29uKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRDbG9zZSA9IGF3YWl0IG1vZGFsLmJlZm9yZUNsb3NlUHJvbWlzZTtcbiAgICAgICAgICAgICAgICBtb2RhbC5iZWZvcmVDbG9zZVByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghc2hvdWxkQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoYXJncyk7XG4gICAgICAgICAgICBpZiAocHJvcHMgJiYgcHJvcHMub25GaW5pc2hlZCkgcHJvcHMub25GaW5pc2hlZC5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgIGNvbnN0IGkgPSB0aGlzLm1vZGFscy5pbmRleE9mKG1vZGFsKTtcbiAgICAgICAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGFscy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnByaW9yaXR5TW9kYWwgPT09IG1vZGFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmlvcml0eU1vZGFsID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8vIFhYWDogVGhpcyBpcyBkZXN0cnVjdGl2ZVxuICAgICAgICAgICAgICAgIHRoaXMubW9kYWxzID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRpY01vZGFsID09PSBtb2RhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGljTW9kYWwgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gWFhYOiBUaGlzIGlzIGRlc3RydWN0aXZlXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RhbHMgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yZVJlbmRlcigpO1xuICAgICAgICB9LCBkZWZlcnJlZC5wcm9taXNlXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAY2FsbGJhY2sgb25CZWZvcmVDbG9zZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nP30gcmVhc29uIGVpdGhlciBcImJhY2tncm91bmRDbGlja1wiIG9yIG51bGxcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPGJvb2w+fSB3aGV0aGVyIHRoZSBkaWFsb2cgc2hvdWxkIGNsb3NlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBPcGVuIGEgbW9kYWwgdmlldy5cbiAgICAgKlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gZGlzcGxheSBhIHJlYWN0IGNvbXBvbmVudCB3aGljaCBpcyBsb2FkZWQgYXMgYW4gYXN5bmNocm9ub3VzXG4gICAgICogd2VicGFjayBjb21wb25lbnQuIFRvIGRvIHRoaXMsIHNldCAnbG9hZGVyJyBhczpcbiAgICAgKlxuICAgICAqICAgKGNiKSA9PiB7XG4gICAgICogICAgICAgcmVxdWlyZShbJzxtb2R1bGU+J10sIGNiKTtcbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UHJvbWlzZX0gcHJvbSAgIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aXRoIGEgUmVhY3QgY29tcG9uZW50XG4gICAgICogICB3aGljaCB3aWxsIGJlIGRpc3BsYXllZCBhcyB0aGUgbW9kYWwgdmlldy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAgIHByb3BlcnRpZXMgdG8gcGFzcyB0byB0aGUgZGlzcGxheWVkXG4gICAgICogICAgY29tcG9uZW50LiAoV2Ugd2lsbCBhbHNvIHBhc3MgYW4gJ29uRmluaXNoZWQnIHByb3BlcnR5LilcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWUgICBDU1MgY2xhc3MgdG8gYXBwbHkgdG8gdGhlIG1vZGFsIHdyYXBwZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNQcmlvcml0eU1vZGFsIGlmIHRydWUsIHRoaXMgbW9kYWwgd2lsbCBiZSBkaXNwbGF5ZWQgcmVnYXJkbGVzc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIG90aGVyIG1vZGFscyB0aGF0IGFyZSBjdXJyZW50bHkgaW4gdGhlIHN0YWNrLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFsc28sIHdoZW4gY2xvc2VkLCBhbGwgbW9kYWxzIHdpbGwgYmUgcmVtb3ZlZFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gdGhlIHN0YWNrLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdGF0aWNNb2RhbCAgaWYgdHJ1ZSwgdGhpcyBtb2RhbCB3aWxsIGJlIGRpc3BsYXllZCB1bmRlciBvdGhlclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kYWxzIGluIHRoZSBzdGFjay4gV2hlbiBjbG9zZWQsIGFsbCBtb2RhbHMgd2lsbFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxzbyBiZSByZW1vdmVkIGZyb20gdGhlIHN0YWNrLiBUaGlzIGlzIG5vdCBjb21wYXRpYmxlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIGJlaW5nIGEgcHJpb3JpdHkgbW9kYWwuIE9ubHkgb25lIG1vZGFsIGNhbiBiZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljIGF0IGEgdGltZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucz8gZXh0cmEgb3B0aW9ucyBmb3IgdGhlIGRpYWxvZ1xuICAgICAqIEBwYXJhbSB7b25CZWZvcmVDbG9zZX0gb3B0aW9ucy5vbkJlZm9yZUNsb3NlIGEgY2FsbGJhY2sgdG8gZGVjaWRlIHdoZXRoZXIgdG8gY2xvc2UgdGhlIGRpYWxvZ1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IE9iamVjdCB3aXRoICdjbG9zZScgcGFyYW1ldGVyIGJlaW5nIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGNsb3NlIHRoZSBkaWFsb2dcbiAgICAgKi9cbiAgICBwcml2YXRlIGNyZWF0ZURpYWxvZ0FzeW5jPFQgZXh0ZW5kcyBhbnlbXT4oXG4gICAgICAgIHByb206IFByb21pc2U8UmVhY3QuQ29tcG9uZW50VHlwZT4sXG4gICAgICAgIHByb3BzPzogSVByb3BzPFQ+LFxuICAgICAgICBjbGFzc05hbWU/OiBzdHJpbmcsXG4gICAgICAgIGlzUHJpb3JpdHlNb2RhbCA9IGZhbHNlLFxuICAgICAgICBpc1N0YXRpY01vZGFsID0gZmFsc2UsXG4gICAgICAgIG9wdGlvbnM6IElPcHRpb25zPFQ+ID0ge30sXG4gICAgKTogSUhhbmRsZTxUPiB7XG4gICAgICAgIGNvbnN0IHsgbW9kYWwsIGNsb3NlRGlhbG9nLCBvbkZpbmlzaGVkUHJvbSB9ID0gdGhpcy5idWlsZE1vZGFsPFQ+KHByb20sIHByb3BzLCBjbGFzc05hbWUsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoaXNQcmlvcml0eU1vZGFsKSB7XG4gICAgICAgICAgICAvLyBYWFg6IFRoaXMgaXMgZGVzdHJ1Y3RpdmVcbiAgICAgICAgICAgIHRoaXMucHJpb3JpdHlNb2RhbCA9IG1vZGFsO1xuICAgICAgICB9IGVsc2UgaWYgKGlzU3RhdGljTW9kYWwpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBkZXN0cnVjdGl2ZVxuICAgICAgICAgICAgdGhpcy5zdGF0aWNNb2RhbCA9IG1vZGFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb2RhbHMudW5zaGlmdChtb2RhbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlUmVuZGVyKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbG9zZTogY2xvc2VEaWFsb2csXG4gICAgICAgICAgICBmaW5pc2hlZDogb25GaW5pc2hlZFByb20sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhcHBlbmREaWFsb2dBc3luYzxUIGV4dGVuZHMgYW55W10+KFxuICAgICAgICBwcm9tOiBQcm9taXNlPFJlYWN0LkNvbXBvbmVudFR5cGU+LFxuICAgICAgICBwcm9wcz86IElQcm9wczxUPixcbiAgICAgICAgY2xhc3NOYW1lPzogc3RyaW5nLFxuICAgICk6IElIYW5kbGU8VD4ge1xuICAgICAgICBjb25zdCB7IG1vZGFsLCBjbG9zZURpYWxvZywgb25GaW5pc2hlZFByb20gfSA9IHRoaXMuYnVpbGRNb2RhbDxUPihwcm9tLCBwcm9wcywgY2xhc3NOYW1lLCB7fSk7XG5cbiAgICAgICAgdGhpcy5tb2RhbHMucHVzaChtb2RhbCk7XG4gICAgICAgIHRoaXMucmVSZW5kZXIoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsb3NlOiBjbG9zZURpYWxvZyxcbiAgICAgICAgICAgIGZpbmlzaGVkOiBvbkZpbmlzaGVkUHJvbSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uQmFja2dyb3VuZENsaWNrID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2RhbCA9IHRoaXMuZ2V0Q3VycmVudE1vZGFsKCk7XG4gICAgICAgIGlmICghbW9kYWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSB3YW50IHRvIHBhc3MgYSByZWFzb24gdG8gdGhlIG9uQmVmb3JlQ2xvc2VcbiAgICAgICAgLy8gY2FsbGJhY2ssIGJ1dCBjbG9zZSBpcyBjdXJyZW50bHkgZGVmaW5lZCB0b1xuICAgICAgICAvLyBwYXNzIGFsbCBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHRoZSBvbkZpbmlzaGVkIGNhbGxiYWNrXG4gICAgICAgIC8vIHNvLCBwYXNzIHRoZSByZWFzb24gdG8gY2xvc2UgdGhyb3VnaCBhIG1lbWJlciB2YXJpYWJsZVxuICAgICAgICBtb2RhbC5jbG9zZVJlYXNvbiA9IFwiYmFja2dyb3VuZENsaWNrXCI7XG4gICAgICAgIG1vZGFsLmNsb3NlKCk7XG4gICAgICAgIG1vZGFsLmNsb3NlUmVhc29uID0gbnVsbDtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBnZXRDdXJyZW50TW9kYWwoKTogSU1vZGFsPGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmlvcml0eU1vZGFsID8gdGhpcy5wcmlvcml0eU1vZGFsIDogKHRoaXMubW9kYWxzWzBdIHx8IHRoaXMuc3RhdGljTW9kYWwpO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgcmVSZW5kZXIoKSB7XG4gICAgICAgIC8vIGF3YWl0IG5leHQgdGljayBiZWNhdXNlIHNvbWV0aW1lcyBSZWFjdERPTSBjYW4gcmFjZSB3aXRoIGl0c2VsZiBhbmQgY2F1c2UgdGhlIG1vZGFsIHRvIHdyb25nbHkgc3RpY2sgYXJvdW5kXG4gICAgICAgIGF3YWl0IHNsZWVwKDApO1xuXG4gICAgICAgIGlmICh0aGlzLm1vZGFscy5sZW5ndGggPT09IDAgJiYgIXRoaXMucHJpb3JpdHlNb2RhbCAmJiAhdGhpcy5zdGF0aWNNb2RhbCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gbW9kYWwgdG8gcmVuZGVyLCBtYWtlIGFsbCBvZiBFbGVtZW50IGF2YWlsYWJsZVxuICAgICAgICAgICAgLy8gdG8gc2NyZWVuIHJlYWRlciB1c2VycyBhZ2FpblxuICAgICAgICAgICAgZGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdhcmlhX3VuaGlkZV9tYWluX2FwcCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFJlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUoTW9kYWxNYW5hZ2VyLmdldE9yQ3JlYXRlQ29udGFpbmVyKCkpO1xuICAgICAgICAgICAgUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZShNb2RhbE1hbmFnZXIuZ2V0T3JDcmVhdGVTdGF0aWNDb250YWluZXIoKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIaWRlIHRoZSBjb250ZW50IG91dHNpZGUgdGhlIG1vZGFsIHRvIHNjcmVlbiByZWFkZXIgdXNlcnNcbiAgICAgICAgLy8gc28gdGhleSB3b24ndCBiZSBhYmxlIHRvIG5hdmlnYXRlIGludG8gaXQgYW5kIGFjdCBvbiBpdCB1c2luZ1xuICAgICAgICAvLyBzY3JlZW4gcmVhZGVyIHNwZWNpZmljIGZlYXR1cmVzXG4gICAgICAgIGRpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICBhY3Rpb246ICdhcmlhX2hpZGVfbWFpbl9hcHAnLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5zdGF0aWNNb2RhbCkge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NlcyA9IGNsYXNzTmFtZXMoXCJteF9EaWFsb2dfd3JhcHBlciBteF9EaWFsb2dfc3RhdGljV3JhcHBlclwiLCB0aGlzLnN0YXRpY01vZGFsLmNsYXNzTmFtZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHN0YXRpY0RpYWxvZyA9IChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3Nlc30+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXhfRGlhbG9nXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICB7IHRoaXMuc3RhdGljTW9kYWwuZWxlbSB9XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm14X0RpYWxvZ19iYWNrZ3JvdW5kIG14X0RpYWxvZ19zdGF0aWNCYWNrZ3JvdW5kXCIgb25DbGljaz17dGhpcy5vbkJhY2tncm91bmRDbGlja30gLz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIFJlYWN0RE9NLnJlbmRlcihzdGF0aWNEaWFsb2csIE1vZGFsTWFuYWdlci5nZXRPckNyZWF0ZVN0YXRpY0NvbnRhaW5lcigpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgc2FmZSB0byBjYWxsIHJlcGVhdGVkbHkgaWYgd2UgaGFwcGVuIHRvIGRvIHRoYXRcbiAgICAgICAgICAgIFJlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUoTW9kYWxNYW5hZ2VyLmdldE9yQ3JlYXRlU3RhdGljQ29udGFpbmVyKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbW9kYWwgPSB0aGlzLmdldEN1cnJlbnRNb2RhbCgpO1xuICAgICAgICBpZiAobW9kYWwgIT09IHRoaXMuc3RhdGljTW9kYWwgJiYgIW1vZGFsLmhpZGRlbikge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NlcyA9IGNsYXNzTmFtZXMoXCJteF9EaWFsb2dfd3JhcHBlclwiLCBtb2RhbC5jbGFzc05hbWUsIHtcbiAgICAgICAgICAgICAgICBteF9EaWFsb2dfd3JhcHBlcldpdGhTdGF0aWNVbmRlcjogdGhpcy5zdGF0aWNNb2RhbCxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBkaWFsb2cgPSAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzZXN9PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm14X0RpYWxvZ1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgeyBtb2RhbC5lbGVtIH1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXhfRGlhbG9nX2JhY2tncm91bmRcIiBvbkNsaWNrPXt0aGlzLm9uQmFja2dyb3VuZENsaWNrfSAvPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IFJlYWN0RE9NLnJlbmRlcihkaWFsb2csIE1vZGFsTWFuYWdlci5nZXRPckNyZWF0ZUNvbnRhaW5lcigpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHNhZmUgdG8gY2FsbCByZXBlYXRlZGx5IGlmIHdlIGhhcHBlbiB0byBkbyB0aGF0XG4gICAgICAgICAgICBSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlKE1vZGFsTWFuYWdlci5nZXRPckNyZWF0ZUNvbnRhaW5lcigpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuaWYgKCF3aW5kb3cuc2luZ2xldG9uTW9kYWxNYW5hZ2VyKSB7XG4gICAgd2luZG93LnNpbmdsZXRvbk1vZGFsTWFuYWdlciA9IG5ldyBNb2RhbE1hbmFnZXIoKTtcbn1cbmV4cG9ydCBkZWZhdWx0IHdpbmRvdy5zaW5nbGV0b25Nb2RhbE1hbmFnZXI7XG4iXX0=