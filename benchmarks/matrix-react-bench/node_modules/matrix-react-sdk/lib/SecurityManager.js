"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AccessCancelledError = void 0;
exports.accessSecretStorage = accessSecretStorage;
exports.crossSigningCallbacks = void 0;
exports.getDehydrationKey = getDehydrationKey;
exports.isSecretStorageBeingAccessed = isSecretStorageBeingAccessed;
exports.promptForBackupPassphrase = promptForBackupPassphrase;
exports.tryToUnlockSecretStorageWithDehydrationKey = tryToUnlockSecretStorageWithDehydrationKey;

var _Modal = _interopRequireDefault(require("./Modal"));

var sdk = _interopRequireWildcard(require("./index"));

var _MatrixClientPeg = require("./MatrixClientPeg");

var _key_passphrase = require("matrix-js-sdk/src/crypto/key_passphrase");

var _recoverykey = require("matrix-js-sdk/src/crypto/recoverykey");

var _languageHandler = require("./languageHandler");

var _olmlib = require("matrix-js-sdk/src/crypto/olmlib");

var _WellKnownUtils = require("./utils/WellKnownUtils");

var _AccessSecretStorageDialog = _interopRequireDefault(require("./components/views/dialogs/security/AccessSecretStorageDialog"));

var _RestoreKeyBackupDialog = _interopRequireDefault(require("./components/views/dialogs/security/RestoreKeyBackupDialog"));

var _SettingsStore = _interopRequireDefault(require("./settings/SettingsStore"));

var _Security = _interopRequireDefault(require("./customisations/Security"));

var _logger = require("matrix-js-sdk/src/logger");

var _QuestionDialog = _interopRequireDefault(require("./components/views/dialogs/QuestionDialog"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// This stores the secret storage private keys in memory for the JS SDK. This is
// only meant to act as a cache to avoid prompting the user multiple times
// during the same single operation. Use `accessSecretStorage` below to scope a
// single secret storage operation, as it will clear the cached keys once the
// operation ends.
let secretStorageKeys = {};
let secretStorageKeyInfo = {};
let secretStorageBeingAccessed = false;
let nonInteractive = false;
let dehydrationCache = {};

function isCachingAllowed() {
  return secretStorageBeingAccessed;
}
/**
 * This can be used by other components to check if secret storage access is in
 * progress, so that we can e.g. avoid intermittently showing toasts during
 * secret storage setup.
 *
 * @returns {bool}
 */


function isSecretStorageBeingAccessed() {
  return secretStorageBeingAccessed;
}

class AccessCancelledError extends Error {
  constructor() {
    super("Secret storage access canceled");
  }

}

exports.AccessCancelledError = AccessCancelledError;

async function confirmToDismiss() {
  const [sure] = await _Modal.default.createDialog(_QuestionDialog.default, {
    title: (0, _languageHandler._t)("Cancel entering passphrase?"),
    description: (0, _languageHandler._t)("Are you sure you want to cancel entering passphrase?"),
    danger: false,
    button: (0, _languageHandler._t)("Go Back"),
    cancelButton: (0, _languageHandler._t)("Cancel")
  }).finished;
  return !sure;
}

function makeInputToKey(keyInfo) {
  return async ({
    passphrase,
    recoveryKey
  }) => {
    if (passphrase) {
      return (0, _key_passphrase.deriveKey)(passphrase, keyInfo.passphrase.salt, keyInfo.passphrase.iterations);
    } else {
      return (0, _recoverykey.decodeRecoveryKey)(recoveryKey);
    }
  };
}

async function getSecretStorageKey({
  keys: keyInfos
}, ssssItemName) {
  var _SecurityCustomisatio;

  const cli = _MatrixClientPeg.MatrixClientPeg.get();

  let keyId = await cli.getDefaultSecretStorageKeyId();
  let keyInfo;

  if (keyId) {
    // use the default SSSS key if set
    keyInfo = keyInfos[keyId];

    if (!keyInfo) {
      // if the default key is not available, pretend the default key
      // isn't set
      keyId = undefined;
    }
  }

  if (!keyId) {
    // if no default SSSS key is set, fall back to a heuristic of using the
    // only available key, if only one key is set
    const keyInfoEntries = Object.entries(keyInfos);

    if (keyInfoEntries.length > 1) {
      throw new Error("Multiple storage key requests not implemented");
    }

    [keyId, keyInfo] = keyInfoEntries[0];
  } // Check the in-memory cache


  if (isCachingAllowed() && secretStorageKeys[keyId]) {
    return [keyId, secretStorageKeys[keyId]];
  }

  if (dehydrationCache.key) {
    if (await _MatrixClientPeg.MatrixClientPeg.get().checkSecretStorageKey(dehydrationCache.key, keyInfo)) {
      cacheSecretStorageKey(keyId, keyInfo, dehydrationCache.key);
      return [keyId, dehydrationCache.key];
    }
  }

  const keyFromCustomisations = (_SecurityCustomisatio = _Security.default.getSecretStorageKey) === null || _SecurityCustomisatio === void 0 ? void 0 : _SecurityCustomisatio.call(_Security.default);

  if (keyFromCustomisations) {
    _logger.logger.log("Using key from security customisations (secret storage)");

    cacheSecretStorageKey(keyId, keyInfo, keyFromCustomisations);
    return [keyId, keyFromCustomisations];
  }

  if (nonInteractive) {
    throw new Error("Could not unlock non-interactively");
  }

  const inputToKey = makeInputToKey(keyInfo);

  const {
    finished
  } = _Modal.default.createTrackedDialog("Access Secret Storage dialog", "", _AccessSecretStorageDialog.default,
  /* props= */
  {
    keyInfo,
    checkPrivateKey: async input => {
      const key = await inputToKey(input);
      return await _MatrixClientPeg.MatrixClientPeg.get().checkSecretStorageKey(key, keyInfo);
    }
  },
  /* className= */
  null,
  /* isPriorityModal= */
  false,
  /* isStaticModal= */
  false,
  /* options= */
  {
    onBeforeClose: async reason => {
      if (reason === "backgroundClick") {
        return confirmToDismiss();
      }

      return true;
    }
  });

  const [input] = await finished;

  if (!input) {
    throw new AccessCancelledError();
  }

  const key = await inputToKey(input); // Save to cache to avoid future prompts in the current session

  cacheSecretStorageKey(keyId, keyInfo, key);
  return [keyId, key];
}

async function getDehydrationKey(keyInfo, checkFunc) {
  var _SecurityCustomisatio2;

  const keyFromCustomisations = (_SecurityCustomisatio2 = _Security.default.getSecretStorageKey) === null || _SecurityCustomisatio2 === void 0 ? void 0 : _SecurityCustomisatio2.call(_Security.default);

  if (keyFromCustomisations) {
    _logger.logger.log("Using key from security customisations (dehydration)");

    return keyFromCustomisations;
  }

  const inputToKey = makeInputToKey(keyInfo);

  const {
    finished
  } = _Modal.default.createTrackedDialog("Access Secret Storage dialog", "", _AccessSecretStorageDialog.default,
  /* props= */
  {
    keyInfo,
    checkPrivateKey: async input => {
      const key = await inputToKey(input);

      try {
        checkFunc(key);
        return true;
      } catch (e) {
        return false;
      }
    }
  },
  /* className= */
  null,
  /* isPriorityModal= */
  false,
  /* isStaticModal= */
  false,
  /* options= */
  {
    onBeforeClose: async reason => {
      if (reason === "backgroundClick") {
        return confirmToDismiss();
      }

      return true;
    }
  });

  const [input] = await finished;

  if (!input) {
    throw new AccessCancelledError();
  }

  const key = await inputToKey(input); // need to copy the key because rehydration (unpickling) will clobber it

  dehydrationCache = {
    key: new Uint8Array(key),
    keyInfo
  };
  return key;
}

function cacheSecretStorageKey(keyId, keyInfo, key) {
  if (isCachingAllowed()) {
    secretStorageKeys[keyId] = key;
    secretStorageKeyInfo[keyId] = keyInfo;
  }
}

async function onSecretRequested(userId, deviceId, requestId, name, deviceTrust) {
  _logger.logger.log("onSecretRequested", userId, deviceId, requestId, name, deviceTrust);

  const client = _MatrixClientPeg.MatrixClientPeg.get();

  if (userId !== client.getUserId()) {
    return;
  }

  if (!deviceTrust || !deviceTrust.isVerified()) {
    _logger.logger.log(`Ignoring secret request from untrusted device ${deviceId}`);

    return;
  }

  if (name === "m.cross_signing.master" || name === "m.cross_signing.self_signing" || name === "m.cross_signing.user_signing") {
    const callbacks = client.getCrossSigningCacheCallbacks();
    if (!callbacks.getCrossSigningKeyCache) return;
    const keyId = name.replace("m.cross_signing.", "");
    const key = await callbacks.getCrossSigningKeyCache(keyId);

    if (!key) {
      _logger.logger.log(`${keyId} requested by ${deviceId}, but not found in cache`);
    }

    return key && (0, _olmlib.encodeBase64)(key);
  } else if (name === "m.megolm_backup.v1") {
    const key = await client.crypto.getSessionBackupPrivateKey();

    if (!key) {
      _logger.logger.log(`session backup key requested by ${deviceId}, but not found in cache`);
    }

    return key && (0, _olmlib.encodeBase64)(key);
  }

  _logger.logger.warn("onSecretRequested didn't recognise the secret named ", name);
}

const crossSigningCallbacks = {
  getSecretStorageKey,
  cacheSecretStorageKey,
  onSecretRequested,
  getDehydrationKey
};
exports.crossSigningCallbacks = crossSigningCallbacks;

async function promptForBackupPassphrase() {
  let key;

  const {
    finished
  } = _Modal.default.createTrackedDialog('Restore Backup', '', _RestoreKeyBackupDialog.default, {
    showSummary: false,
    keyCallback: k => key = k
  }, null,
  /* priority = */
  false,
  /* static = */
  true);

  const success = await finished;
  if (!success) throw new Error("Key backup prompt cancelled");
  return key;
}
/**
 * This helper should be used whenever you need to access secret storage. It
 * ensures that secret storage (and also cross-signing since they each depend on
 * each other in a cycle of sorts) have been bootstrapped before running the
 * provided function.
 *
 * Bootstrapping secret storage may take one of these paths:
 * 1. Create secret storage from a passphrase and store cross-signing keys
 *    in secret storage.
 * 2. Access existing secret storage by requesting passphrase and accessing
 *    cross-signing keys as needed.
 * 3. All keys are loaded and there's nothing to do.
 *
 * Additionally, the secret storage keys are cached during the scope of this function
 * to ensure the user is prompted only once for their secret storage
 * passphrase. The cache is then cleared once the provided function completes.
 *
 * @param {Function} [func] An operation to perform once secret storage has been
 * bootstrapped. Optional.
 * @param {bool} [forceReset] Reset secret storage even if it's already set up
 */


async function accessSecretStorage(func = async () => {}, forceReset = false) {
  const cli = _MatrixClientPeg.MatrixClientPeg.get();

  secretStorageBeingAccessed = true;

  try {
    if (!(await cli.hasSecretStorageKey()) || forceReset) {
      // This dialog calls bootstrap itself after guiding the user through
      // passphrase creation.
      const {
        finished
      } = _Modal.default.createTrackedDialogAsync('Create Secret Storage dialog', '', Promise.resolve().then(() => _interopRequireWildcard(require("./async-components/views/dialogs/security/CreateSecretStorageDialog"))), {
        forceReset
      }, null,
      /* priority = */
      false,
      /* static = */
      true,
      /* options = */
      {
        onBeforeClose: async reason => {
          // If Secure Backup is required, you cannot leave the modal.
          if (reason === "backgroundClick") {
            return !(0, _WellKnownUtils.isSecureBackupRequired)();
          }

          return true;
        }
      });

      const [confirmed] = await finished;

      if (!confirmed) {
        throw new Error("Secret storage creation canceled");
      }
    } else {
      // FIXME: Using an import will result in test failures
      const InteractiveAuthDialog = sdk.getComponent("dialogs.InteractiveAuthDialog");
      await cli.bootstrapCrossSigning({
        authUploadDeviceSigningKeys: async makeRequest => {
          const {
            finished
          } = _Modal.default.createTrackedDialog('Cross-signing keys dialog', '', InteractiveAuthDialog, {
            title: (0, _languageHandler._t)("Setting up keys"),
            matrixClient: cli,
            makeRequest
          });

          const [confirmed] = await finished;

          if (!confirmed) {
            throw new Error("Cross-signing key upload auth canceled");
          }
        }
      });
      await cli.bootstrapSecretStorage({
        getKeyBackupPassphrase: promptForBackupPassphrase
      });
      const keyId = Object.keys(secretStorageKeys)[0];

      if (keyId && _SettingsStore.default.getValue("feature_dehydration")) {
        let dehydrationKeyInfo = {};

        if (secretStorageKeyInfo[keyId] && secretStorageKeyInfo[keyId].passphrase) {
          dehydrationKeyInfo = {
            passphrase: secretStorageKeyInfo[keyId].passphrase
          };
        }

        _logger.logger.log("Setting dehydration key");

        await cli.setDehydrationKey(secretStorageKeys[keyId], dehydrationKeyInfo, "Backup device");
      } else if (!keyId) {
        _logger.logger.warn("Not setting dehydration key: no SSSS key found");
      } else {
        _logger.logger.log("Not setting dehydration key: feature disabled");
      }
    } // `return await` needed here to ensure `finally` block runs after the
    // inner operation completes.


    return await func();
  } catch (e) {
    var _SecurityCustomisatio3;

    (_SecurityCustomisatio3 = _Security.default.catchAccessSecretStorageError) === null || _SecurityCustomisatio3 === void 0 ? void 0 : _SecurityCustomisatio3.call(_Security.default, e);

    _logger.logger.error(e); // Re-throw so that higher level logic can abort as needed


    throw e;
  } finally {
    // Clear secret storage key cache now that work is complete
    secretStorageBeingAccessed = false;

    if (!isCachingAllowed()) {
      secretStorageKeys = {};
      secretStorageKeyInfo = {};
    }
  }
} // FIXME: this function name is a bit of a mouthful


async function tryToUnlockSecretStorageWithDehydrationKey(client) {
  const key = dehydrationCache.key;
  let restoringBackup = false;

  if (key && (await client.isSecretStorageReady())) {
    _logger.logger.log("Trying to set up cross-signing using dehydration key");

    secretStorageBeingAccessed = true;
    nonInteractive = true;

    try {
      await client.checkOwnCrossSigningTrust(); // we also need to set a new dehydrated device to replace the
      // device we rehydrated

      let dehydrationKeyInfo = {};

      if (dehydrationCache.keyInfo && dehydrationCache.keyInfo.passphrase) {
        dehydrationKeyInfo = {
          passphrase: dehydrationCache.keyInfo.passphrase
        };
      }

      await client.setDehydrationKey(key, dehydrationKeyInfo, "Backup device"); // and restore from backup

      const backupInfo = await client.getKeyBackupVersion();

      if (backupInfo) {
        restoringBackup = true; // don't await, because this can take a long time

        client.restoreKeyBackupWithSecretStorage(backupInfo).finally(() => {
          secretStorageBeingAccessed = false;
          nonInteractive = false;

          if (!isCachingAllowed()) {
            secretStorageKeys = {};
            secretStorageKeyInfo = {};
          }
        });
      }
    } finally {
      dehydrationCache = {}; // the secret storage cache is needed for restoring from backup, so
      // don't clear it yet if we're restoring from backup

      if (!restoringBackup) {
        secretStorageBeingAccessed = false;
        nonInteractive = false;

        if (!isCachingAllowed()) {
          secretStorageKeys = {};
          secretStorageKeyInfo = {};
        }
      }
    }
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9TZWN1cml0eU1hbmFnZXIudHMiXSwibmFtZXMiOlsic2VjcmV0U3RvcmFnZUtleXMiLCJzZWNyZXRTdG9yYWdlS2V5SW5mbyIsInNlY3JldFN0b3JhZ2VCZWluZ0FjY2Vzc2VkIiwibm9uSW50ZXJhY3RpdmUiLCJkZWh5ZHJhdGlvbkNhY2hlIiwiaXNDYWNoaW5nQWxsb3dlZCIsImlzU2VjcmV0U3RvcmFnZUJlaW5nQWNjZXNzZWQiLCJBY2Nlc3NDYW5jZWxsZWRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJjb25maXJtVG9EaXNtaXNzIiwic3VyZSIsIk1vZGFsIiwiY3JlYXRlRGlhbG9nIiwiUXVlc3Rpb25EaWFsb2ciLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwiZGFuZ2VyIiwiYnV0dG9uIiwiY2FuY2VsQnV0dG9uIiwiZmluaXNoZWQiLCJtYWtlSW5wdXRUb0tleSIsImtleUluZm8iLCJwYXNzcGhyYXNlIiwicmVjb3ZlcnlLZXkiLCJzYWx0IiwiaXRlcmF0aW9ucyIsImdldFNlY3JldFN0b3JhZ2VLZXkiLCJrZXlzIiwia2V5SW5mb3MiLCJzc3NzSXRlbU5hbWUiLCJjbGkiLCJNYXRyaXhDbGllbnRQZWciLCJnZXQiLCJrZXlJZCIsImdldERlZmF1bHRTZWNyZXRTdG9yYWdlS2V5SWQiLCJ1bmRlZmluZWQiLCJrZXlJbmZvRW50cmllcyIsIk9iamVjdCIsImVudHJpZXMiLCJsZW5ndGgiLCJrZXkiLCJjaGVja1NlY3JldFN0b3JhZ2VLZXkiLCJjYWNoZVNlY3JldFN0b3JhZ2VLZXkiLCJrZXlGcm9tQ3VzdG9taXNhdGlvbnMiLCJTZWN1cml0eUN1c3RvbWlzYXRpb25zIiwibG9nZ2VyIiwibG9nIiwiaW5wdXRUb0tleSIsImNyZWF0ZVRyYWNrZWREaWFsb2ciLCJBY2Nlc3NTZWNyZXRTdG9yYWdlRGlhbG9nIiwiY2hlY2tQcml2YXRlS2V5IiwiaW5wdXQiLCJvbkJlZm9yZUNsb3NlIiwicmVhc29uIiwiZ2V0RGVoeWRyYXRpb25LZXkiLCJjaGVja0Z1bmMiLCJlIiwiVWludDhBcnJheSIsIm9uU2VjcmV0UmVxdWVzdGVkIiwidXNlcklkIiwiZGV2aWNlSWQiLCJyZXF1ZXN0SWQiLCJuYW1lIiwiZGV2aWNlVHJ1c3QiLCJjbGllbnQiLCJnZXRVc2VySWQiLCJpc1ZlcmlmaWVkIiwiY2FsbGJhY2tzIiwiZ2V0Q3Jvc3NTaWduaW5nQ2FjaGVDYWxsYmFja3MiLCJnZXRDcm9zc1NpZ25pbmdLZXlDYWNoZSIsInJlcGxhY2UiLCJjcnlwdG8iLCJnZXRTZXNzaW9uQmFja3VwUHJpdmF0ZUtleSIsIndhcm4iLCJjcm9zc1NpZ25pbmdDYWxsYmFja3MiLCJwcm9tcHRGb3JCYWNrdXBQYXNzcGhyYXNlIiwiUmVzdG9yZUtleUJhY2t1cERpYWxvZyIsInNob3dTdW1tYXJ5Iiwia2V5Q2FsbGJhY2siLCJrIiwic3VjY2VzcyIsImFjY2Vzc1NlY3JldFN0b3JhZ2UiLCJmdW5jIiwiZm9yY2VSZXNldCIsImhhc1NlY3JldFN0b3JhZ2VLZXkiLCJjcmVhdGVUcmFja2VkRGlhbG9nQXN5bmMiLCJjb25maXJtZWQiLCJJbnRlcmFjdGl2ZUF1dGhEaWFsb2ciLCJzZGsiLCJnZXRDb21wb25lbnQiLCJib290c3RyYXBDcm9zc1NpZ25pbmciLCJhdXRoVXBsb2FkRGV2aWNlU2lnbmluZ0tleXMiLCJtYWtlUmVxdWVzdCIsIm1hdHJpeENsaWVudCIsImJvb3RzdHJhcFNlY3JldFN0b3JhZ2UiLCJnZXRLZXlCYWNrdXBQYXNzcGhyYXNlIiwiU2V0dGluZ3NTdG9yZSIsImdldFZhbHVlIiwiZGVoeWRyYXRpb25LZXlJbmZvIiwic2V0RGVoeWRyYXRpb25LZXkiLCJjYXRjaEFjY2Vzc1NlY3JldFN0b3JhZ2VFcnJvciIsImVycm9yIiwidHJ5VG9VbmxvY2tTZWNyZXRTdG9yYWdlV2l0aERlaHlkcmF0aW9uS2V5IiwicmVzdG9yaW5nQmFja3VwIiwiaXNTZWNyZXRTdG9yYWdlUmVhZHkiLCJjaGVja093bkNyb3NzU2lnbmluZ1RydXN0IiwiYmFja3VwSW5mbyIsImdldEtleUJhY2t1cFZlcnNpb24iLCJyZXN0b3JlS2V5QmFja3VwV2l0aFNlY3JldFN0b3JhZ2UiLCJmaW5hbGx5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFtQkE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBR0E7O0FBRUE7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJQSxpQkFBNkMsR0FBRyxFQUFwRDtBQUNBLElBQUlDLG9CQUEyRCxHQUFHLEVBQWxFO0FBQ0EsSUFBSUMsMEJBQTBCLEdBQUcsS0FBakM7QUFFQSxJQUFJQyxjQUFjLEdBQUcsS0FBckI7QUFFQSxJQUFJQyxnQkFHSCxHQUFHLEVBSEo7O0FBS0EsU0FBU0MsZ0JBQVQsR0FBcUM7QUFDakMsU0FBT0gsMEJBQVA7QUFDSDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTyxTQUFTSSw0QkFBVCxHQUFpRDtBQUNwRCxTQUFPSiwwQkFBUDtBQUNIOztBQUVNLE1BQU1LLG9CQUFOLFNBQW1DQyxLQUFuQyxDQUF5QztBQUM1Q0MsRUFBQUEsV0FBVyxHQUFHO0FBQ1YsVUFBTSxnQ0FBTjtBQUNIOztBQUgyQzs7OztBQU1oRCxlQUFlQyxnQkFBZixHQUFvRDtBQUNoRCxRQUFNLENBQUNDLElBQUQsSUFBUyxNQUFNQyxlQUFNQyxZQUFOLENBQW1CQyx1QkFBbkIsRUFBbUM7QUFDcERDLElBQUFBLEtBQUssRUFBRSx5QkFBRyw2QkFBSCxDQUQ2QztBQUVwREMsSUFBQUEsV0FBVyxFQUFFLHlCQUFHLHNEQUFILENBRnVDO0FBR3BEQyxJQUFBQSxNQUFNLEVBQUUsS0FINEM7QUFJcERDLElBQUFBLE1BQU0sRUFBRSx5QkFBRyxTQUFILENBSjRDO0FBS3BEQyxJQUFBQSxZQUFZLEVBQUUseUJBQUcsUUFBSDtBQUxzQyxHQUFuQyxFQU1sQkMsUUFOSDtBQU9BLFNBQU8sQ0FBQ1QsSUFBUjtBQUNIOztBQUVE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QUFQLENBQXlCM0QsR0FBekIsRUFBOEIwRCxrQkFBOUIsRUFBa0QsZUFBbEQsQ0FBTixDQVRBLENBV0E7O0FBQ0EsWUFBTVEsVUFBVSxHQUFHLE1BQU0xQyxNQUFNLENBQUMyQyxtQkFBUCxFQUF6Qjs7QUFDQSxVQUFJRCxVQUFKLEVBQWdCO0FBQ1pILFFBQUFBLGVBQWUsR0FBRyxJQUFsQixDQURZLENBRVo7O0FBQ0F2QyxRQUFBQSxNQUFNLENBQUM0QyxpQ0FBUCxDQUF5Q0YsVUFBekMsRUFDS0csT0FETCxDQUNhLE1BQU07QUFDWDVHLFVBQUFBLDBCQUEwQixHQUFHLEtBQTdCO0FBQ0FDLFVBQUFBLGNBQWMsR0FBRyxLQUFqQjs7QUFDQSxjQUFJLENBQUNFLGdCQUFnQixFQUFyQixFQUF5QjtBQUNyQkwsWUFBQUEsaUJBQWlCLEdBQUcsRUFBcEI7QUFDQUMsWUFBQUEsb0JBQW9CLEdBQUcsRUFBdkI7QUFDSDtBQUNKLFNBUkw7QUFTSDtBQUNKLEtBMUJELFNBMEJVO0FBQ05HLE1BQUFBLGdCQUFnQixHQUFHLEVBQW5CLENBRE0sQ0FFTjtBQUNBOztBQUNBLFVBQUksQ0FBQ29HLGVBQUwsRUFBc0I7QUFDbEJ0RyxRQUFBQSwwQkFBMEIsR0FBRyxLQUE3QjtBQUNBQyxRQUFBQSxjQUFjLEdBQUcsS0FBakI7O0FBQ0EsWUFBSSxDQUFDRSxnQkFBZ0IsRUFBckIsRUFBeUI7QUFDckJMLFVBQUFBLGlCQUFpQixHQUFHLEVBQXBCO0FBQ0FDLFVBQUFBLG9CQUFvQixHQUFHLEVBQXZCO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7QUFDSiIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxOSwgMjAyMCBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB7IElDcnlwdG9DYWxsYmFja3MgfSBmcm9tICdtYXRyaXgtanMtc2RrL3NyYy9tYXRyaXgnO1xuaW1wb3J0IHsgSVNlY3JldFN0b3JhZ2VLZXlJbmZvIH0gZnJvbSAnbWF0cml4LWpzLXNkay9zcmMvY3J5cHRvL2FwaSc7XG5pbXBvcnQgeyBNYXRyaXhDbGllbnQgfSBmcm9tICdtYXRyaXgtanMtc2RrL3NyYy9jbGllbnQnO1xuaW1wb3J0IE1vZGFsIGZyb20gJy4vTW9kYWwnO1xuaW1wb3J0ICogYXMgc2RrIGZyb20gJy4vaW5kZXgnO1xuaW1wb3J0IHsgTWF0cml4Q2xpZW50UGVnIH0gZnJvbSAnLi9NYXRyaXhDbGllbnRQZWcnO1xuaW1wb3J0IHsgZGVyaXZlS2V5IH0gZnJvbSAnbWF0cml4LWpzLXNkay9zcmMvY3J5cHRvL2tleV9wYXNzcGhyYXNlJztcbmltcG9ydCB7IGRlY29kZVJlY292ZXJ5S2V5IH0gZnJvbSAnbWF0cml4LWpzLXNkay9zcmMvY3J5cHRvL3JlY292ZXJ5a2V5JztcbmltcG9ydCB7IF90IH0gZnJvbSAnLi9sYW5ndWFnZUhhbmRsZXInO1xuaW1wb3J0IHsgZW5jb2RlQmFzZTY0IH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL2NyeXB0by9vbG1saWJcIjtcbmltcG9ydCB7IGlzU2VjdXJlQmFja3VwUmVxdWlyZWQgfSBmcm9tICcuL3V0aWxzL1dlbGxLbm93blV0aWxzJztcbmltcG9ydCBBY2Nlc3NTZWNyZXRTdG9yYWdlRGlhbG9nIGZyb20gJy4vY29tcG9uZW50cy92aWV3cy9kaWFsb2dzL3NlY3VyaXR5L0FjY2Vzc1NlY3JldFN0b3JhZ2VEaWFsb2cnO1xuaW1wb3J0IFJlc3RvcmVLZXlCYWNrdXBEaWFsb2cgZnJvbSAnLi9jb21wb25lbnRzL3ZpZXdzL2RpYWxvZ3Mvc2VjdXJpdHkvUmVzdG9yZUtleUJhY2t1cERpYWxvZyc7XG5pbXBvcnQgU2V0dGluZ3NTdG9yZSBmcm9tIFwiLi9zZXR0aW5ncy9TZXR0aW5nc1N0b3JlXCI7XG5pbXBvcnQgU2VjdXJpdHlDdXN0b21pc2F0aW9ucyBmcm9tIFwiLi9jdXN0b21pc2F0aW9ucy9TZWN1cml0eVwiO1xuaW1wb3J0IHsgRGV2aWNlVHJ1c3RMZXZlbCB9IGZyb20gJ21hdHJpeC1qcy1zZGsvc3JjL2NyeXB0by9Dcm9zc1NpZ25pbmcnO1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvbG9nZ2VyXCI7XG5pbXBvcnQgeyBDb21wb25lbnRUeXBlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUXVlc3Rpb25EaWFsb2cgZnJvbSBcIi4vY29tcG9uZW50cy92aWV3cy9kaWFsb2dzL1F1ZXN0aW9uRGlhbG9nXCI7XG5cbi8vIFRoaXMgc3RvcmVzIHRoZSBzZWNyZXQgc3RvcmFnZSBwcml2YXRlIGtleXMgaW4gbWVtb3J5IGZvciB0aGUgSlMgU0RLLiBUaGlzIGlzXG4vLyBvbmx5IG1lYW50IHRvIGFjdCBhcyBhIGNhY2hlIHRvIGF2b2lkIHByb21wdGluZyB0aGUgdXNlciBtdWx0aXBsZSB0aW1lc1xuLy8gZHVyaW5nIHRoZSBzYW1lIHNpbmdsZSBvcGVyYXRpb24uIFVzZSBgYWNjZXNzU2VjcmV0U3RvcmFnZWAgYmVsb3cgdG8gc2NvcGUgYVxuLy8gc2luZ2xlIHNlY3JldCBzdG9yYWdlIG9wZXJhdGlvbiwgYXMgaXQgd2lsbCBjbGVhciB0aGUgY2FjaGVkIGtleXMgb25jZSB0aGVcbi8vIG9wZXJhdGlvbiBlbmRzLlxubGV0IHNlY3JldFN0b3JhZ2VLZXlzOiBSZWNvcmQ8c3RyaW5nLCBVaW50OEFycmF5PiA9IHt9O1xubGV0IHNlY3JldFN0b3JhZ2VLZXlJbmZvOiBSZWNvcmQ8c3RyaW5nLCBJU2VjcmV0U3RvcmFnZUtleUluZm8+ID0ge307XG5sZXQgc2VjcmV0U3RvcmFnZUJlaW5nQWNjZXNzZWQgPSBmYWxzZTtcblxubGV0IG5vbkludGVyYWN0aXZlID0gZmFsc2U7XG5cbmxldCBkZWh5ZHJhdGlvbkNhY2hlOiB7XG4gICAga2V5PzogVWludDhBcnJheTtcbiAgICBrZXlJbmZvPzogSVNlY3JldFN0b3JhZ2VLZXlJbmZvO1xufSA9IHt9O1xuXG5mdW5jdGlvbiBpc0NhY2hpbmdBbGxvd2VkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBzZWNyZXRTdG9yYWdlQmVpbmdBY2Nlc3NlZDtcbn1cblxuLyoqXG4gKiBUaGlzIGNhbiBiZSB1c2VkIGJ5IG90aGVyIGNvbXBvbmVudHMgdG8gY2hlY2sgaWYgc2VjcmV0IHN0b3JhZ2UgYWNjZXNzIGlzIGluXG4gKiBwcm9ncmVzcywgc28gdGhhdCB3ZSBjYW4gZS5nLiBhdm9pZCBpbnRlcm1pdHRlbnRseSBzaG93aW5nIHRvYXN0cyBkdXJpbmdcbiAqIHNlY3JldCBzdG9yYWdlIHNldHVwLlxuICpcbiAqIEByZXR1cm5zIHtib29sfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTZWNyZXRTdG9yYWdlQmVpbmdBY2Nlc3NlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gc2VjcmV0U3RvcmFnZUJlaW5nQWNjZXNzZWQ7XG59XG5cbmV4cG9ydCBjbGFzcyBBY2Nlc3NDYW5jZWxsZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJTZWNyZXQgc3RvcmFnZSBhY2Nlc3MgY2FuY2VsZWRcIik7XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjb25maXJtVG9EaXNtaXNzKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IFtzdXJlXSA9IGF3YWl0IE1vZGFsLmNyZWF0ZURpYWxvZyhRdWVzdGlvbkRpYWxvZywge1xuICAgICAgICB0aXRsZTogX3QoXCJDYW5jZWwgZW50ZXJpbmcgcGFzc3BocmFzZT9cIiksXG4gICAgICAgIGRlc2NyaXB0aW9uOiBfdChcIkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBjYW5jZWwgZW50ZXJpbmcgcGFzc3BocmFzZT9cIiksXG4gICAgICAgIGRhbmdlcjogZmFsc2UsXG4gICAgICAgIGJ1dHRvbjogX3QoXCJHbyBCYWNrXCIpLFxuICAgICAgICBjYW5jZWxCdXR0b246IF90KFwiQ2FuY2VsXCIpLFxuICAgIH0pLmZpbmlzaGVkO1xuICAgIHJldHVybiAhc3VyZTtcbn1cblxuZnVuY3Rpb24gbWFrZUlucHV0VG9LZXkoXG4gICAga2V5SW5mbzogSVNlY3JldFN0b3JhZ2VLZXlJbmZvLFxuKTogKGtleVBhcmFtczogeyBwYXNzcGhyYXNlOiBzdHJpbmcsIHJlY292ZXJ5S2V5OiBzdHJpbmcgfSkgPT4gUHJvbWlzZTxVaW50OEFycmF5PiB7XG4gICAgcmV0dXJuIGFzeW5jICh7IHBhc3NwaHJhc2UsIHJlY292ZXJ5S2V5IH0pID0+IHtcbiAgICAgICAgaWYgKHBhc3NwaHJhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBkZXJpdmVLZXkoXG4gICAgICAgICAgICAgICAgcGFzc3BocmFzZSxcbiAgICAgICAgICAgICAgICBrZXlJbmZvLnBhc3NwaHJhc2Uuc2FsdCxcbiAgICAgICAgICAgICAgICBrZXlJbmZvLnBhc3NwaHJhc2UuaXRlcmF0aW9ucyxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlUmVjb3ZlcnlLZXkocmVjb3ZlcnlLZXkpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0U2VjcmV0U3RvcmFnZUtleShcbiAgICB7IGtleXM6IGtleUluZm9zIH06IHsga2V5czogUmVjb3JkPHN0cmluZywgSVNlY3JldFN0b3JhZ2VLZXlJbmZvPiB9LFxuICAgIHNzc3NJdGVtTmFtZSxcbik6IFByb21pc2U8W3N0cmluZywgVWludDhBcnJheV0+IHtcbiAgICBjb25zdCBjbGkgPSBNYXRyaXhDbGllbnRQZWcuZ2V0KCk7XG4gICAgbGV0IGtleUlkID0gYXdhaXQgY2xpLmdldERlZmF1bHRTZWNyZXRTdG9yYWdlS2V5SWQoKTtcbiAgICBsZXQga2V5SW5mbztcbiAgICBpZiAoa2V5SWQpIHtcbiAgICAgICAgLy8gdXNlIHRoZSBkZWZhdWx0IFNTU1Mga2V5IGlmIHNldFxuICAgICAgICBrZXlJbmZvID0ga2V5SW5mb3Nba2V5SWRdO1xuICAgICAgICBpZiAoIWtleUluZm8pIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBkZWZhdWx0IGtleSBpcyBub3QgYXZhaWxhYmxlLCBwcmV0ZW5kIHRoZSBkZWZhdWx0IGtleVxuICAgICAgICAgICAgLy8gaXNuJ3Qgc2V0XG4gICAgICAgICAgICBrZXlJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWtleUlkKSB7XG4gICAgICAgIC8vIGlmIG5vIGRlZmF1bHQgU1NTUyBrZXkgaXMgc2V0LCBmYWxsIGJhY2sgdG8gYSBoZXVyaXN0aWMgb2YgdXNpbmcgdGhlXG4gICAgICAgIC8vIG9ubHkgYXZhaWxhYmxlIGtleSwgaWYgb25seSBvbmUga2V5IGlzIHNldFxuICAgICAgICBjb25zdCBrZXlJbmZvRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGtleUluZm9zKTtcbiAgICAgICAgaWYgKGtleUluZm9FbnRyaWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11bHRpcGxlIHN0b3JhZ2Uga2V5IHJlcXVlc3RzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBba2V5SWQsIGtleUluZm9dID0ga2V5SW5mb0VudHJpZXNbMF07XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgdGhlIGluLW1lbW9yeSBjYWNoZVxuICAgIGlmIChpc0NhY2hpbmdBbGxvd2VkKCkgJiYgc2VjcmV0U3RvcmFnZUtleXNba2V5SWRdKSB7XG4gICAgICAgIHJldHVybiBba2V5SWQsIHNlY3JldFN0b3JhZ2VLZXlzW2tleUlkXV07XG4gICAgfVxuXG4gICAgaWYgKGRlaHlkcmF0aW9uQ2FjaGUua2V5KSB7XG4gICAgICAgIGlmIChhd2FpdCBNYXRyaXhDbGllbnRQZWcuZ2V0KCkuY2hlY2tTZWNyZXRTdG9yYWdlS2V5KGRlaHlkcmF0aW9uQ2FjaGUua2V5LCBrZXlJbmZvKSkge1xuICAgICAgICAgICAgY2FjaGVTZWNyZXRTdG9yYWdlS2V5KGtleUlkLCBrZXlJbmZvLCBkZWh5ZHJhdGlvbkNhY2hlLmtleSk7XG4gICAgICAgICAgICByZXR1cm4gW2tleUlkLCBkZWh5ZHJhdGlvbkNhY2hlLmtleV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBrZXlGcm9tQ3VzdG9taXNhdGlvbnMgPSBTZWN1cml0eUN1c3RvbWlzYXRpb25zLmdldFNlY3JldFN0b3JhZ2VLZXk/LigpO1xuICAgIGlmIChrZXlGcm9tQ3VzdG9taXNhdGlvbnMpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIlVzaW5nIGtleSBmcm9tIHNlY3VyaXR5IGN1c3RvbWlzYXRpb25zIChzZWNyZXQgc3RvcmFnZSlcIik7XG4gICAgICAgIGNhY2hlU2VjcmV0U3RvcmFnZUtleShrZXlJZCwga2V5SW5mbywga2V5RnJvbUN1c3RvbWlzYXRpb25zKTtcbiAgICAgICAgcmV0dXJuIFtrZXlJZCwga2V5RnJvbUN1c3RvbWlzYXRpb25zXTtcbiAgICB9XG5cbiAgICBpZiAobm9uSW50ZXJhY3RpdmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHVubG9jayBub24taW50ZXJhY3RpdmVseVwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnB1dFRvS2V5ID0gbWFrZUlucHV0VG9LZXkoa2V5SW5mbyk7XG4gICAgY29uc3QgeyBmaW5pc2hlZCB9ID0gTW9kYWwuY3JlYXRlVHJhY2tlZERpYWxvZyhcIkFjY2VzcyBTZWNyZXQgU3RvcmFnZSBkaWFsb2dcIiwgXCJcIixcbiAgICAgICAgQWNjZXNzU2VjcmV0U3RvcmFnZURpYWxvZyxcbiAgICAgICAgLyogcHJvcHM9ICovXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleUluZm8sXG4gICAgICAgICAgICBjaGVja1ByaXZhdGVLZXk6IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IGlucHV0VG9LZXkoaW5wdXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBNYXRyaXhDbGllbnRQZWcuZ2V0KCkuY2hlY2tTZWNyZXRTdG9yYWdlS2V5KGtleSwga2V5SW5mbyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICAvKiBjbGFzc05hbWU9ICovIG51bGwsXG4gICAgICAgIC8qIGlzUHJpb3JpdHlNb2RhbD0gKi8gZmFsc2UsXG4gICAgICAgIC8qIGlzU3RhdGljTW9kYWw9ICovIGZhbHNlLFxuICAgICAgICAvKiBvcHRpb25zPSAqLyB7XG4gICAgICAgICAgICBvbkJlZm9yZUNsb3NlOiBhc3luYyAocmVhc29uKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlYXNvbiA9PT0gXCJiYWNrZ3JvdW5kQ2xpY2tcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlybVRvRGlzbWlzcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgKTtcbiAgICBjb25zdCBbaW5wdXRdID0gYXdhaXQgZmluaXNoZWQ7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgICB0aHJvdyBuZXcgQWNjZXNzQ2FuY2VsbGVkRXJyb3IoKTtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gYXdhaXQgaW5wdXRUb0tleShpbnB1dCk7XG5cbiAgICAvLyBTYXZlIHRvIGNhY2hlIHRvIGF2b2lkIGZ1dHVyZSBwcm9tcHRzIGluIHRoZSBjdXJyZW50IHNlc3Npb25cbiAgICBjYWNoZVNlY3JldFN0b3JhZ2VLZXkoa2V5SWQsIGtleUluZm8sIGtleSk7XG5cbiAgICByZXR1cm4gW2tleUlkLCBrZXldO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RGVoeWRyYXRpb25LZXkoXG4gICAga2V5SW5mbzogSVNlY3JldFN0b3JhZ2VLZXlJbmZvLFxuICAgIGNoZWNrRnVuYzogKFVpbnQ4QXJyYXkpID0+IHZvaWQsXG4pOiBQcm9taXNlPFVpbnQ4QXJyYXk+IHtcbiAgICBjb25zdCBrZXlGcm9tQ3VzdG9taXNhdGlvbnMgPSBTZWN1cml0eUN1c3RvbWlzYXRpb25zLmdldFNlY3JldFN0b3JhZ2VLZXk/LigpO1xuICAgIGlmIChrZXlGcm9tQ3VzdG9taXNhdGlvbnMpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIlVzaW5nIGtleSBmcm9tIHNlY3VyaXR5IGN1c3RvbWlzYXRpb25zIChkZWh5ZHJhdGlvbilcIik7XG4gICAgICAgIHJldHVybiBrZXlGcm9tQ3VzdG9taXNhdGlvbnM7XG4gICAgfVxuXG4gICAgY29uc3QgaW5wdXRUb0tleSA9IG1ha2VJbnB1dFRvS2V5KGtleUluZm8pO1xuICAgIGNvbnN0IHsgZmluaXNoZWQgfSA9IE1vZGFsLmNyZWF0ZVRyYWNrZWREaWFsb2coXCJBY2Nlc3MgU2VjcmV0IFN0b3JhZ2UgZGlhbG9nXCIsIFwiXCIsXG4gICAgICAgIEFjY2Vzc1NlY3JldFN0b3JhZ2VEaWFsb2csXG4gICAgICAgIC8qIHByb3BzPSAqL1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXlJbmZvLFxuICAgICAgICAgICAgY2hlY2tQcml2YXRlS2V5OiBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBpbnB1dFRvS2V5KGlucHV0KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmMoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgLyogY2xhc3NOYW1lPSAqLyBudWxsLFxuICAgICAgICAvKiBpc1ByaW9yaXR5TW9kYWw9ICovIGZhbHNlLFxuICAgICAgICAvKiBpc1N0YXRpY01vZGFsPSAqLyBmYWxzZSxcbiAgICAgICAgLyogb3B0aW9ucz0gKi8ge1xuICAgICAgICAgICAgb25CZWZvcmVDbG9zZTogYXN5bmMgKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZWFzb24gPT09IFwiYmFja2dyb3VuZENsaWNrXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpcm1Ub0Rpc21pc3MoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICk7XG4gICAgY29uc3QgW2lucHV0XSA9IGF3YWl0IGZpbmlzaGVkO1xuICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFjY2Vzc0NhbmNlbGxlZEVycm9yKCk7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IGF3YWl0IGlucHV0VG9LZXkoaW5wdXQpO1xuXG4gICAgLy8gbmVlZCB0byBjb3B5IHRoZSBrZXkgYmVjYXVzZSByZWh5ZHJhdGlvbiAodW5waWNrbGluZykgd2lsbCBjbG9iYmVyIGl0XG4gICAgZGVoeWRyYXRpb25DYWNoZSA9IHsga2V5OiBuZXcgVWludDhBcnJheShrZXkpLCBrZXlJbmZvIH07XG5cbiAgICByZXR1cm4ga2V5O1xufVxuXG5mdW5jdGlvbiBjYWNoZVNlY3JldFN0b3JhZ2VLZXkoXG4gICAga2V5SWQ6IHN0cmluZyxcbiAgICBrZXlJbmZvOiBJU2VjcmV0U3RvcmFnZUtleUluZm8sXG4gICAga2V5OiBVaW50OEFycmF5LFxuKTogdm9pZCB7XG4gICAgaWYgKGlzQ2FjaGluZ0FsbG93ZWQoKSkge1xuICAgICAgICBzZWNyZXRTdG9yYWdlS2V5c1trZXlJZF0gPSBrZXk7XG4gICAgICAgIHNlY3JldFN0b3JhZ2VLZXlJbmZvW2tleUlkXSA9IGtleUluZm87XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBvblNlY3JldFJlcXVlc3RlZChcbiAgICB1c2VySWQ6IHN0cmluZyxcbiAgICBkZXZpY2VJZDogc3RyaW5nLFxuICAgIHJlcXVlc3RJZDogc3RyaW5nLFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBkZXZpY2VUcnVzdDogRGV2aWNlVHJ1c3RMZXZlbCxcbik6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgbG9nZ2VyLmxvZyhcIm9uU2VjcmV0UmVxdWVzdGVkXCIsIHVzZXJJZCwgZGV2aWNlSWQsIHJlcXVlc3RJZCwgbmFtZSwgZGV2aWNlVHJ1c3QpO1xuICAgIGNvbnN0IGNsaWVudCA9IE1hdHJpeENsaWVudFBlZy5nZXQoKTtcbiAgICBpZiAodXNlcklkICE9PSBjbGllbnQuZ2V0VXNlcklkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWRldmljZVRydXN0IHx8ICFkZXZpY2VUcnVzdC5pc1ZlcmlmaWVkKCkpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgSWdub3Jpbmcgc2VjcmV0IHJlcXVlc3QgZnJvbSB1bnRydXN0ZWQgZGV2aWNlICR7ZGV2aWNlSWR9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgICBuYW1lID09PSBcIm0uY3Jvc3Nfc2lnbmluZy5tYXN0ZXJcIiB8fFxuICAgICAgICBuYW1lID09PSBcIm0uY3Jvc3Nfc2lnbmluZy5zZWxmX3NpZ25pbmdcIiB8fFxuICAgICAgICBuYW1lID09PSBcIm0uY3Jvc3Nfc2lnbmluZy51c2VyX3NpZ25pbmdcIlxuICAgICkge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBjbGllbnQuZ2V0Q3Jvc3NTaWduaW5nQ2FjaGVDYWxsYmFja3MoKTtcbiAgICAgICAgaWYgKCFjYWxsYmFja3MuZ2V0Q3Jvc3NTaWduaW5nS2V5Q2FjaGUpIHJldHVybjtcbiAgICAgICAgY29uc3Qga2V5SWQgPSBuYW1lLnJlcGxhY2UoXCJtLmNyb3NzX3NpZ25pbmcuXCIsIFwiXCIpO1xuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBjYWxsYmFja3MuZ2V0Q3Jvc3NTaWduaW5nS2V5Q2FjaGUoa2V5SWQpO1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhcbiAgICAgICAgICAgICAgICBgJHtrZXlJZH0gcmVxdWVzdGVkIGJ5ICR7ZGV2aWNlSWR9LCBidXQgbm90IGZvdW5kIGluIGNhY2hlYCxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleSAmJiBlbmNvZGVCYXNlNjQoa2V5KTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwibS5tZWdvbG1fYmFja3VwLnYxXCIpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgY2xpZW50LmNyeXB0by5nZXRTZXNzaW9uQmFja3VwUHJpdmF0ZUtleSgpO1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhcbiAgICAgICAgICAgICAgICBgc2Vzc2lvbiBiYWNrdXAga2V5IHJlcXVlc3RlZCBieSAke2RldmljZUlkfSwgYnV0IG5vdCBmb3VuZCBpbiBjYWNoZWAsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXkgJiYgZW5jb2RlQmFzZTY0KGtleSk7XG4gICAgfVxuICAgIGxvZ2dlci53YXJuKFwib25TZWNyZXRSZXF1ZXN0ZWQgZGlkbid0IHJlY29nbmlzZSB0aGUgc2VjcmV0IG5hbWVkIFwiLCBuYW1lKTtcbn1cblxuZXhwb3J0IGNvbnN0IGNyb3NzU2lnbmluZ0NhbGxiYWNrczogSUNyeXB0b0NhbGxiYWNrcyA9IHtcbiAgICBnZXRTZWNyZXRTdG9yYWdlS2V5LFxuICAgIGNhY2hlU2VjcmV0U3RvcmFnZUtleSxcbiAgICBvblNlY3JldFJlcXVlc3RlZCxcbiAgICBnZXREZWh5ZHJhdGlvbktleSxcbn07XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9tcHRGb3JCYWNrdXBQYXNzcGhyYXNlKCk6IFByb21pc2U8VWludDhBcnJheT4ge1xuICAgIGxldCBrZXk7XG5cbiAgICBjb25zdCB7IGZpbmlzaGVkIH0gPSBNb2RhbC5jcmVhdGVUcmFja2VkRGlhbG9nKCdSZXN0b3JlIEJhY2t1cCcsICcnLCBSZXN0b3JlS2V5QmFja3VwRGlhbG9nLCB7XG4gICAgICAgIHNob3dTdW1tYXJ5OiBmYWxzZSwga2V5Q2FsbGJhY2s6IGsgPT4ga2V5ID0gayxcbiAgICB9LCBudWxsLCAvKiBwcmlvcml0eSA9ICovIGZhbHNlLCAvKiBzdGF0aWMgPSAqLyB0cnVlKTtcblxuICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCBmaW5pc2hlZDtcbiAgICBpZiAoIXN1Y2Nlc3MpIHRocm93IG5ldyBFcnJvcihcIktleSBiYWNrdXAgcHJvbXB0IGNhbmNlbGxlZFwiKTtcblxuICAgIHJldHVybiBrZXk7XG59XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgc2hvdWxkIGJlIHVzZWQgd2hlbmV2ZXIgeW91IG5lZWQgdG8gYWNjZXNzIHNlY3JldCBzdG9yYWdlLiBJdFxuICogZW5zdXJlcyB0aGF0IHNlY3JldCBzdG9yYWdlIChhbmQgYWxzbyBjcm9zcy1zaWduaW5nIHNpbmNlIHRoZXkgZWFjaCBkZXBlbmQgb25cbiAqIGVhY2ggb3RoZXIgaW4gYSBjeWNsZSBvZiBzb3J0cykgaGF2ZSBiZWVuIGJvb3RzdHJhcHBlZCBiZWZvcmUgcnVubmluZyB0aGVcbiAqIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICpcbiAqIEJvb3RzdHJhcHBpbmcgc2VjcmV0IHN0b3JhZ2UgbWF5IHRha2Ugb25lIG9mIHRoZXNlIHBhdGhzOlxuICogMS4gQ3JlYXRlIHNlY3JldCBzdG9yYWdlIGZyb20gYSBwYXNzcGhyYXNlIGFuZCBzdG9yZSBjcm9zcy1zaWduaW5nIGtleXNcbiAqICAgIGluIHNlY3JldCBzdG9yYWdlLlxuICogMi4gQWNjZXNzIGV4aXN0aW5nIHNlY3JldCBzdG9yYWdlIGJ5IHJlcXVlc3RpbmcgcGFzc3BocmFzZSBhbmQgYWNjZXNzaW5nXG4gKiAgICBjcm9zcy1zaWduaW5nIGtleXMgYXMgbmVlZGVkLlxuICogMy4gQWxsIGtleXMgYXJlIGxvYWRlZCBhbmQgdGhlcmUncyBub3RoaW5nIHRvIGRvLlxuICpcbiAqIEFkZGl0aW9uYWxseSwgdGhlIHNlY3JldCBzdG9yYWdlIGtleXMgYXJlIGNhY2hlZCBkdXJpbmcgdGhlIHNjb3BlIG9mIHRoaXMgZnVuY3Rpb25cbiAqIHRvIGVuc3VyZSB0aGUgdXNlciBpcyBwcm9tcHRlZCBvbmx5IG9uY2UgZm9yIHRoZWlyIHNlY3JldCBzdG9yYWdlXG4gKiBwYXNzcGhyYXNlLiBUaGUgY2FjaGUgaXMgdGhlbiBjbGVhcmVkIG9uY2UgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGNvbXBsZXRlcy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZnVuY10gQW4gb3BlcmF0aW9uIHRvIHBlcmZvcm0gb25jZSBzZWNyZXQgc3RvcmFnZSBoYXMgYmVlblxuICogYm9vdHN0cmFwcGVkLiBPcHRpb25hbC5cbiAqIEBwYXJhbSB7Ym9vbH0gW2ZvcmNlUmVzZXRdIFJlc2V0IHNlY3JldCBzdG9yYWdlIGV2ZW4gaWYgaXQncyBhbHJlYWR5IHNldCB1cFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWNjZXNzU2VjcmV0U3RvcmFnZShmdW5jID0gYXN5bmMgKCkgPT4geyB9LCBmb3JjZVJlc2V0ID0gZmFsc2UpIHtcbiAgICBjb25zdCBjbGkgPSBNYXRyaXhDbGllbnRQZWcuZ2V0KCk7XG4gICAgc2VjcmV0U3RvcmFnZUJlaW5nQWNjZXNzZWQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghKGF3YWl0IGNsaS5oYXNTZWNyZXRTdG9yYWdlS2V5KCkpIHx8IGZvcmNlUmVzZXQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgZGlhbG9nIGNhbGxzIGJvb3RzdHJhcCBpdHNlbGYgYWZ0ZXIgZ3VpZGluZyB0aGUgdXNlciB0aHJvdWdoXG4gICAgICAgICAgICAvLyBwYXNzcGhyYXNlIGNyZWF0aW9uLlxuICAgICAgICAgICAgY29uc3QgeyBmaW5pc2hlZCB9ID0gTW9kYWwuY3JlYXRlVHJhY2tlZERpYWxvZ0FzeW5jKCdDcmVhdGUgU2VjcmV0IFN0b3JhZ2UgZGlhbG9nJywgJycsXG4gICAgICAgICAgICAgICAgaW1wb3J0KFxuICAgICAgICAgICAgICAgICAgICBcIi4vYXN5bmMtY29tcG9uZW50cy92aWV3cy9kaWFsb2dzL3NlY3VyaXR5L0NyZWF0ZVNlY3JldFN0b3JhZ2VEaWFsb2dcIlxuICAgICAgICAgICAgICAgICkgYXMgdW5rbm93biBhcyBQcm9taXNlPENvbXBvbmVudFR5cGU8e30+PixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlUmVzZXQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIC8qIHByaW9yaXR5ID0gKi8gZmFsc2UsXG4gICAgICAgICAgICAgICAgLyogc3RhdGljID0gKi8gdHJ1ZSxcbiAgICAgICAgICAgICAgICAvKiBvcHRpb25zID0gKi8ge1xuICAgICAgICAgICAgICAgICAgICBvbkJlZm9yZUNsb3NlOiBhc3luYyAocmVhc29uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBTZWN1cmUgQmFja3VwIGlzIHJlcXVpcmVkLCB5b3UgY2Fubm90IGxlYXZlIHRoZSBtb2RhbC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWFzb24gPT09IFwiYmFja2dyb3VuZENsaWNrXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWlzU2VjdXJlQmFja3VwUmVxdWlyZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgW2NvbmZpcm1lZF0gPSBhd2FpdCBmaW5pc2hlZDtcbiAgICAgICAgICAgIGlmICghY29uZmlybWVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VjcmV0IHN0b3JhZ2UgY3JlYXRpb24gY2FuY2VsZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogVXNpbmcgYW4gaW1wb3J0IHdpbGwgcmVzdWx0IGluIHRlc3QgZmFpbHVyZXNcbiAgICAgICAgICAgIGNvbnN0IEludGVyYWN0aXZlQXV0aERpYWxvZyA9IHNkay5nZXRDb21wb25lbnQoXCJkaWFsb2dzLkludGVyYWN0aXZlQXV0aERpYWxvZ1wiKTtcbiAgICAgICAgICAgIGF3YWl0IGNsaS5ib290c3RyYXBDcm9zc1NpZ25pbmcoe1xuICAgICAgICAgICAgICAgIGF1dGhVcGxvYWREZXZpY2VTaWduaW5nS2V5czogYXN5bmMgKG1ha2VSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZmluaXNoZWQgfSA9IE1vZGFsLmNyZWF0ZVRyYWNrZWREaWFsb2coXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ3Jvc3Mtc2lnbmluZyBrZXlzIGRpYWxvZycsICcnLCBJbnRlcmFjdGl2ZUF1dGhEaWFsb2csXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IF90KFwiU2V0dGluZyB1cCBrZXlzXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeENsaWVudDogY2xpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VSZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2NvbmZpcm1lZF0gPSBhd2FpdCBmaW5pc2hlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25maXJtZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNyb3NzLXNpZ25pbmcga2V5IHVwbG9hZCBhdXRoIGNhbmNlbGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgY2xpLmJvb3RzdHJhcFNlY3JldFN0b3JhZ2Uoe1xuICAgICAgICAgICAgICAgIGdldEtleUJhY2t1cFBhc3NwaHJhc2U6IHByb21wdEZvckJhY2t1cFBhc3NwaHJhc2UsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3Qga2V5SWQgPSBPYmplY3Qua2V5cyhzZWNyZXRTdG9yYWdlS2V5cylbMF07XG4gICAgICAgICAgICBpZiAoa2V5SWQgJiYgU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZShcImZlYXR1cmVfZGVoeWRyYXRpb25cIikpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGVoeWRyYXRpb25LZXlJbmZvID0ge307XG4gICAgICAgICAgICAgICAgaWYgKHNlY3JldFN0b3JhZ2VLZXlJbmZvW2tleUlkXSAmJiBzZWNyZXRTdG9yYWdlS2V5SW5mb1trZXlJZF0ucGFzc3BocmFzZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWh5ZHJhdGlvbktleUluZm8gPSB7IHBhc3NwaHJhc2U6IHNlY3JldFN0b3JhZ2VLZXlJbmZvW2tleUlkXS5wYXNzcGhyYXNlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coXCJTZXR0aW5nIGRlaHlkcmF0aW9uIGtleVwiKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBjbGkuc2V0RGVoeWRyYXRpb25LZXkoc2VjcmV0U3RvcmFnZUtleXNba2V5SWRdLCBkZWh5ZHJhdGlvbktleUluZm8sIFwiQmFja3VwIGRldmljZVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWtleUlkKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJOb3Qgc2V0dGluZyBkZWh5ZHJhdGlvbiBrZXk6IG5vIFNTU1Mga2V5IGZvdW5kXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFwiTm90IHNldHRpbmcgZGVoeWRyYXRpb24ga2V5OiBmZWF0dXJlIGRpc2FibGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYHJldHVybiBhd2FpdGAgbmVlZGVkIGhlcmUgdG8gZW5zdXJlIGBmaW5hbGx5YCBibG9jayBydW5zIGFmdGVyIHRoZVxuICAgICAgICAvLyBpbm5lciBvcGVyYXRpb24gY29tcGxldGVzLlxuICAgICAgICByZXR1cm4gYXdhaXQgZnVuYygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgU2VjdXJpdHlDdXN0b21pc2F0aW9ucy5jYXRjaEFjY2Vzc1NlY3JldFN0b3JhZ2VFcnJvcj8uKGUpO1xuICAgICAgICBsb2dnZXIuZXJyb3IoZSk7XG4gICAgICAgIC8vIFJlLXRocm93IHNvIHRoYXQgaGlnaGVyIGxldmVsIGxvZ2ljIGNhbiBhYm9ydCBhcyBuZWVkZWRcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICAvLyBDbGVhciBzZWNyZXQgc3RvcmFnZSBrZXkgY2FjaGUgbm93IHRoYXQgd29yayBpcyBjb21wbGV0ZVxuICAgICAgICBzZWNyZXRTdG9yYWdlQmVpbmdBY2Nlc3NlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoIWlzQ2FjaGluZ0FsbG93ZWQoKSkge1xuICAgICAgICAgICAgc2VjcmV0U3RvcmFnZUtleXMgPSB7fTtcbiAgICAgICAgICAgIHNlY3JldFN0b3JhZ2VLZXlJbmZvID0ge307XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIEZJWE1FOiB0aGlzIGZ1bmN0aW9uIG5hbWUgaXMgYSBiaXQgb2YgYSBtb3V0aGZ1bFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRyeVRvVW5sb2NrU2VjcmV0U3RvcmFnZVdpdGhEZWh5ZHJhdGlvbktleShcbiAgICBjbGllbnQ6IE1hdHJpeENsaWVudCxcbik6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGtleSA9IGRlaHlkcmF0aW9uQ2FjaGUua2V5O1xuICAgIGxldCByZXN0b3JpbmdCYWNrdXAgPSBmYWxzZTtcbiAgICBpZiAoa2V5ICYmIChhd2FpdCBjbGllbnQuaXNTZWNyZXRTdG9yYWdlUmVhZHkoKSkpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIlRyeWluZyB0byBzZXQgdXAgY3Jvc3Mtc2lnbmluZyB1c2luZyBkZWh5ZHJhdGlvbiBrZXlcIik7XG4gICAgICAgIHNlY3JldFN0b3JhZ2VCZWluZ0FjY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgbm9uSW50ZXJhY3RpdmUgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgY2xpZW50LmNoZWNrT3duQ3Jvc3NTaWduaW5nVHJ1c3QoKTtcblxuICAgICAgICAgICAgLy8gd2UgYWxzbyBuZWVkIHRvIHNldCBhIG5ldyBkZWh5ZHJhdGVkIGRldmljZSB0byByZXBsYWNlIHRoZVxuICAgICAgICAgICAgLy8gZGV2aWNlIHdlIHJlaHlkcmF0ZWRcbiAgICAgICAgICAgIGxldCBkZWh5ZHJhdGlvbktleUluZm8gPSB7fTtcbiAgICAgICAgICAgIGlmIChkZWh5ZHJhdGlvbkNhY2hlLmtleUluZm8gJiYgZGVoeWRyYXRpb25DYWNoZS5rZXlJbmZvLnBhc3NwaHJhc2UpIHtcbiAgICAgICAgICAgICAgICBkZWh5ZHJhdGlvbktleUluZm8gPSB7IHBhc3NwaHJhc2U6IGRlaHlkcmF0aW9uQ2FjaGUua2V5SW5mby5wYXNzcGhyYXNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBjbGllbnQuc2V0RGVoeWRyYXRpb25LZXkoa2V5LCBkZWh5ZHJhdGlvbktleUluZm8sIFwiQmFja3VwIGRldmljZVwiKTtcblxuICAgICAgICAgICAgLy8gYW5kIHJlc3RvcmUgZnJvbSBiYWNrdXBcbiAgICAgICAgICAgIGNvbnN0IGJhY2t1cEluZm8gPSBhd2FpdCBjbGllbnQuZ2V0S2V5QmFja3VwVmVyc2lvbigpO1xuICAgICAgICAgICAgaWYgKGJhY2t1cEluZm8pIHtcbiAgICAgICAgICAgICAgICByZXN0b3JpbmdCYWNrdXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IGF3YWl0LCBiZWNhdXNlIHRoaXMgY2FuIHRha2UgYSBsb25nIHRpbWVcbiAgICAgICAgICAgICAgICBjbGllbnQucmVzdG9yZUtleUJhY2t1cFdpdGhTZWNyZXRTdG9yYWdlKGJhY2t1cEluZm8pXG4gICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY3JldFN0b3JhZ2VCZWluZ0FjY2Vzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBub25JbnRlcmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0NhY2hpbmdBbGxvd2VkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNyZXRTdG9yYWdlS2V5cyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY3JldFN0b3JhZ2VLZXlJbmZvID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZGVoeWRyYXRpb25DYWNoZSA9IHt9O1xuICAgICAgICAgICAgLy8gdGhlIHNlY3JldCBzdG9yYWdlIGNhY2hlIGlzIG5lZWRlZCBmb3IgcmVzdG9yaW5nIGZyb20gYmFja3VwLCBzb1xuICAgICAgICAgICAgLy8gZG9uJ3QgY2xlYXIgaXQgeWV0IGlmIHdlJ3JlIHJlc3RvcmluZyBmcm9tIGJhY2t1cFxuICAgICAgICAgICAgaWYgKCFyZXN0b3JpbmdCYWNrdXApIHtcbiAgICAgICAgICAgICAgICBzZWNyZXRTdG9yYWdlQmVpbmdBY2Nlc3NlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5vbkludGVyYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0NhY2hpbmdBbGxvd2VkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VjcmV0U3RvcmFnZUtleXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgc2VjcmV0U3RvcmFnZUtleUluZm8gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4iXX0=