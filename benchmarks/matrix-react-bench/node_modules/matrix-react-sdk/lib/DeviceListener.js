"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _MatrixClientPeg = require("./MatrixClientPeg");

var _dispatcher = _interopRequireDefault(require("./dispatcher/dispatcher"));

var _BulkUnverifiedSessionsToast = require("./toasts/BulkUnverifiedSessionsToast");

var _SetupEncryptionToast = require("./toasts/SetupEncryptionToast");

var _UnverifiedSessionToast = require("./toasts/UnverifiedSessionToast");

var _SecurityManager = require("./SecurityManager");

var _WellKnownUtils = require("./utils/WellKnownUtils");

var _MatrixChat = require("./components/structures/MatrixChat");

var _logger = require("matrix-js-sdk/src/logger");

/*
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
const KEY_BACKUP_POLL_INTERVAL = 5 * 60 * 1000;

class DeviceListener {
  constructor() {
    (0, _defineProperty2.default)(this, "dispatcherRef", void 0);
    (0, _defineProperty2.default)(this, "dismissed", new Set());
    (0, _defineProperty2.default)(this, "dismissedThisDeviceToast", false);
    (0, _defineProperty2.default)(this, "keyBackupInfo", null);
    (0, _defineProperty2.default)(this, "keyBackupFetchedAt", null);
    (0, _defineProperty2.default)(this, "ourDeviceIdsAtStart", null);
    (0, _defineProperty2.default)(this, "displayingToastsForDeviceIds", new Set());
    (0, _defineProperty2.default)(this, "onWillUpdateDevices", async (users, initialFetch) => {
      // If we didn't know about *any* devices before (ie. it's fresh login),
      // then they are all pre-existing devices, so ignore this and set the
      // devicesAtStart list to the devices that we see after the fetch.
      if (initialFetch) return;

      const myUserId = _MatrixClientPeg.MatrixClientPeg.get().getUserId();

      if (users.includes(myUserId)) this.ensureDeviceIdsAtStartPopulated(); // No need to do a recheck here: we just need to get a snapshot of our devices
      // before we download any new ones.
    });
    (0, _defineProperty2.default)(this, "onDevicesUpdated", users => {
      if (!users.includes(_MatrixClientPeg.MatrixClientPeg.get().getUserId())) return;
      this.recheck();
    });
    (0, _defineProperty2.default)(this, "onDeviceVerificationChanged", userId => {
      if (userId !== _MatrixClientPeg.MatrixClientPeg.get().getUserId()) return;
      this.recheck();
    });
    (0, _defineProperty2.default)(this, "onUserTrustStatusChanged", userId => {
      if (userId !== _MatrixClientPeg.MatrixClientPeg.get().getUserId()) return;
      this.recheck();
    });
    (0, _defineProperty2.default)(this, "onCrossSingingKeysChanged", () => {
      this.recheck();
    });
    (0, _defineProperty2.default)(this, "onAccountData", ev => {
      // User may have:
      // * migrated SSSS to symmetric
      // * uploaded keys to secret storage
      // * completed secret storage creation
      // which result in account data changes affecting checks below.
      if (ev.getType().startsWith('m.secret_storage.') || ev.getType().startsWith('m.cross_signing.') || ev.getType() === 'm.megolm_backup.v1') {
        this.recheck();
      }
    });
    (0, _defineProperty2.default)(this, "onSync", (state, prevState) => {
      if (state === 'PREPARED' && prevState === null) this.recheck();
    });
    (0, _defineProperty2.default)(this, "onRoomStateEvents", ev => {
      if (ev.getType() !== "m.room.encryption") {
        return;
      } // If a room changes to encrypted, re-check as it may be our first
      // encrypted room. This also catches encrypted room creation as well.


      this.recheck();
    });
    (0, _defineProperty2.default)(this, "onAction", ({
      action
    }) => {
      if (action !== "on_logged_in") return;
      this.recheck();
    });
  }

  static sharedInstance() {
    if (!window.mxDeviceListener) window.mxDeviceListener = new DeviceListener();
    return window.mxDeviceListener;
  }

  start() {
    _MatrixClientPeg.MatrixClientPeg.get().on('crypto.willUpdateDevices', this.onWillUpdateDevices);

    _MatrixClientPeg.MatrixClientPeg.get().on('crypto.devicesUpdated', this.onDevicesUpdated);

    _MatrixClientPeg.MatrixClientPeg.get().on('deviceVerificationChanged', this.onDeviceVerificationChanged);

    _MatrixClientPeg.MatrixClientPeg.get().on('userTrustStatusChanged', this.onUserTrustStatusChanged);

    _MatrixClientPeg.MatrixClientPeg.get().on('crossSigning.keysChanged', this.onCrossSingingKeysChanged);

    _MatrixClientPeg.MatrixClientPeg.get().on('accountData', this.onAccountData);

    _MatrixClientPeg.MatrixClientPeg.get().on('sync', this.onSync);

    _MatrixClientPeg.MatrixClientPeg.get().on('RoomState.events', this.onRoomStateEvents);

    this.dispatcherRef = _dispatcher.default.register(this.onAction);
    this.recheck();
  }

  stop() {
    if (_MatrixClientPeg.MatrixClientPeg.get()) {
      _MatrixClientPeg.MatrixClientPeg.get().removeListener('crypto.willUpdateDevices', this.onWillUpdateDevices);

      _MatrixClientPeg.MatrixClientPeg.get().removeListener('crypto.devicesUpdated', this.onDevicesUpdated);

      _MatrixClientPeg.MatrixClientPeg.get().removeListener('deviceVerificationChanged', this.onDeviceVerificationChanged);

      _MatrixClientPeg.MatrixClientPeg.get().removeListener('userTrustStatusChanged', this.onUserTrustStatusChanged);

      _MatrixClientPeg.MatrixClientPeg.get().removeListener('crossSigning.keysChanged', this.onCrossSingingKeysChanged);

      _MatrixClientPeg.MatrixClientPeg.get().removeListener('accountData', this.onAccountData);

      _MatrixClientPeg.MatrixClientPeg.get().removeListener('sync', this.onSync);

      _MatrixClientPeg.MatrixClientPeg.get().removeListener('RoomState.events', this.onRoomStateEvents);
    }

    if (this.dispatcherRef) {
      _dispatcher.default.unregister(this.dispatcherRef);

      this.dispatcherRef = null;
    }

    this.dismissed.clear();
    this.dismissedThisDeviceToast = false;
    this.keyBackupInfo = null;
    this.keyBackupFetchedAt = null;
    this.ourDeviceIdsAtStart = null;
    this.displayingToastsForDeviceIds = new Set();
  }
  /**
   * Dismiss notifications about our own unverified devices
   *
   * @param {String[]} deviceIds List of device IDs to dismiss notifications for
   */


  async dismissUnverifiedSessions(deviceIds) {
    _logger.logger.log("Dismissing unverified sessions: " + Array.from(deviceIds).join(','));

    for (const d of deviceIds) {
      this.dismissed.add(d);
    }

    this.recheck();
  }

  dismissEncryptionSetup() {
    this.dismissedThisDeviceToast = true;
    this.recheck();
  }

  ensureDeviceIdsAtStartPopulated() {
    if (this.ourDeviceIdsAtStart === null) {
      const cli = _MatrixClientPeg.MatrixClientPeg.get();

      this.ourDeviceIdsAtStart = new Set(cli.getStoredDevicesForUser(cli.getUserId()).map(d => d.deviceId));
    }
  }

  // The server doesn't tell us when key backup is set up, so we poll
  // & cache the result
  async getKeyBackupInfo() {
    const now = new Date().getTime();

    if (!this.keyBackupInfo || this.keyBackupFetchedAt < now - KEY_BACKUP_POLL_INTERVAL) {
      this.keyBackupInfo = await _MatrixClientPeg.MatrixClientPeg.get().getKeyBackupVersion();
      this.keyBackupFetchedAt = now;
    }

    return this.keyBackupInfo;
  }

  shouldShowSetupEncryptionToast() {
    // If we're in the middle of a secret storage operation, we're likely
    // modifying the state involved here, so don't add new toasts to setup.
    if ((0, _SecurityManager.isSecretStorageBeingAccessed)()) return false; // Show setup toasts once the user is in at least one encrypted room.

    const cli = _MatrixClientPeg.MatrixClientPeg.get();

    return cli && cli.getRooms().some(r => cli.isRoomEncrypted(r.roomId));
  }

  async recheck() {
    const cli = _MatrixClientPeg.MatrixClientPeg.get();

    if (!(await cli.doesServerSupportUnstableFeature("org.matrix.e2e_cross_signing"))) return;
    if (!cli.isCryptoEnabled()) return; // don't recheck until the initial sync is complete: lots of account data events will fire
    // while the initial sync is processing and we don't need to recheck on each one of them
    // (we add a listener on sync to do once check after the initial sync is done)

    if (!cli.isInitialSyncComplete()) return;
    const crossSigningReady = await cli.isCrossSigningReady();
    const secretStorageReady = await cli.isSecretStorageReady();
    const allSystemsReady = crossSigningReady && secretStorageReady;

    if (this.dismissedThisDeviceToast || allSystemsReady) {
      (0, _SetupEncryptionToast.hideToast)();
    } else if (this.shouldShowSetupEncryptionToast()) {
      // make sure our keys are finished downloading
      await cli.downloadKeys([cli.getUserId()]); // cross signing isn't enabled - nag to enable it
      // There are 3 different toasts for:

      if (!cli.getCrossSigningId() && cli.getStoredCrossSigningForUser(cli.getUserId())) {
        // Cross-signing on account but this device doesn't trust the master key (verify this session)
        (0, _SetupEncryptionToast.showToast)(_SetupEncryptionToast.Kind.VERIFY_THIS_SESSION);
      } else {
        const backupInfo = await this.getKeyBackupInfo();

        if (backupInfo) {
          // No cross-signing on account but key backup available (upgrade encryption)
          (0, _SetupEncryptionToast.showToast)(_SetupEncryptionToast.Kind.UPGRADE_ENCRYPTION);
        } else {
          // No cross-signing or key backup on account (set up encryption)
          await cli.waitForClientWellKnown();

          if ((0, _WellKnownUtils.isSecureBackupRequired)() && (0, _MatrixChat.isLoggedIn)()) {
            // If we're meant to set up, and Secure Backup is required,
            // trigger the flow directly without a toast once logged in.
            (0, _SetupEncryptionToast.hideToast)();
            (0, _SecurityManager.accessSecretStorage)();
          } else {
            (0, _SetupEncryptionToast.showToast)(_SetupEncryptionToast.Kind.SET_UP_ENCRYPTION);
          }
        }
      }
    } // This needs to be done after awaiting on downloadKeys() above, so
    // we make sure we get the devices after the fetch is done.


    this.ensureDeviceIdsAtStartPopulated(); // Unverified devices that were there last time the app ran
    // (technically could just be a boolean: we don't actually
    // need to remember the device IDs, but for the sake of
    // symmetry...).

    const oldUnverifiedDeviceIds = new Set(); // Unverified devices that have appeared since then

    const newUnverifiedDeviceIds = new Set(); // as long as cross-signing isn't ready,
    // you can't see or dismiss any device toasts

    if (crossSigningReady) {
      const devices = cli.getStoredDevicesForUser(cli.getUserId());

      for (const device of devices) {
        if (device.deviceId === cli.deviceId) continue;
        const deviceTrust = await cli.checkDeviceTrust(cli.getUserId(), device.deviceId);

        if (!deviceTrust.isCrossSigningVerified() && !this.dismissed.has(device.deviceId)) {
          if (this.ourDeviceIdsAtStart.has(device.deviceId)) {
            oldUnverifiedDeviceIds.add(device.deviceId);
          } else {
            newUnverifiedDeviceIds.add(device.deviceId);
          }
        }
      }
    }

    _logger.logger.log("Old unverified sessions: " + Array.from(oldUnverifiedDeviceIds).join(','));

    _logger.logger.log("New unverified sessions: " + Array.from(newUnverifiedDeviceIds).join(',')); // Display or hide the batch toast for old unverified sessions


    if (oldUnverifiedDeviceIds.size > 0) {
      (0, _BulkUnverifiedSessionsToast.showToast)(oldUnverifiedDeviceIds);
    } else {
      (0, _BulkUnverifiedSessionsToast.hideToast)();
    } // Show toasts for new unverified devices if they aren't already there


    for (const deviceId of newUnverifiedDeviceIds) {
      (0, _UnverifiedSessionToast.showToast)(deviceId);
    } // ...and hide any we don't need any more


    for (const deviceId of this.displayingToastsForDeviceIds) {
      if (!newUnverifiedDeviceIds.has(deviceId)) {
        (0, _UnverifiedSessionToast.hideToast)(deviceId);
      }
    }

    this.displayingToastsForDeviceIds = newUnverifiedDeviceIds;
  }

}

exports.default = DeviceListener;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9EZXZpY2VMaXN0ZW5lci50cyJdLCJuYW1lcyI6WyJLRVlfQkFDS1VQX1BPTExfSU5URVJWQUwiLCJEZXZpY2VMaXN0ZW5lciIsIlNldCIsInVzZXJzIiwiaW5pdGlhbEZldGNoIiwibXlVc2VySWQiLCJNYXRyaXhDbGllbnRQZWciLCJnZXQiLCJnZXRVc2VySWQiLCJpbmNsdWRlcyIsImVuc3VyZURldmljZUlkc0F0U3RhcnRQb3B1bGF0ZWQiLCJyZWNoZWNrIiwidXNlcklkIiwiZXYiLCJnZXRUeXBlIiwic3RhcnRzV2l0aCIsInN0YXRlIiwicHJldlN0YXRlIiwiYWN0aW9uIiwic2hhcmVkSW5zdGFuY2UiLCJ3aW5kb3ciLCJteERldmljZUxpc3RlbmVyIiwic3RhcnQiLCJvbiIsIm9uV2lsbFVwZGF0ZURldmljZXMiLCJvbkRldmljZXNVcGRhdGVkIiwib25EZXZpY2VWZXJpZmljYXRpb25DaGFuZ2VkIiwib25Vc2VyVHJ1c3RTdGF0dXNDaGFuZ2VkIiwib25Dcm9zc1NpbmdpbmdLZXlzQ2hhbmdlZCIsIm9uQWNjb3VudERhdGEiLCJvblN5bmMiLCJvblJvb21TdGF0ZUV2ZW50cyIsImRpc3BhdGNoZXJSZWYiLCJkaXMiLCJyZWdpc3RlciIsIm9uQWN0aW9uIiwic3RvcCIsInJlbW92ZUxpc3RlbmVyIiwidW5yZWdpc3RlciIsImRpc21pc3NlZCIsImNsZWFyIiwiZGlzbWlzc2VkVGhpc0RldmljZVRvYXN0Iiwia2V5QmFja3VwSW5mbyIsImtleUJhY2t1cEZldGNoZWRBdCIsIm91ckRldmljZUlkc0F0U3RhcnQiLCJkaXNwbGF5aW5nVG9hc3RzRm9yRGV2aWNlSWRzIiwiZGlzbWlzc1VudmVyaWZpZWRTZXNzaW9ucyIsImRldmljZUlkcyIsImxvZ2dlciIsImxvZyIsIkFycmF5IiwiZnJvbSIsImpvaW4iLCJkIiwiYWRkIiwiZGlzbWlzc0VuY3J5cHRpb25TZXR1cCIsImNsaSIsImdldFN0b3JlZERldmljZXNGb3JVc2VyIiwibWFwIiwiZGV2aWNlSWQiLCJnZXRLZXlCYWNrdXBJbmZvIiwibm93IiwiRGF0ZSIsImdldFRpbWUiLCJnZXRLZXlCYWNrdXBWZXJzaW9uIiwic2hvdWxkU2hvd1NldHVwRW5jcnlwdGlvblRvYXN0IiwiZ2V0Um9vbXMiLCJzb21lIiwiciIsImlzUm9vbUVuY3J5cHRlZCIsInJvb21JZCIsImRvZXNTZXJ2ZXJTdXBwb3J0VW5zdGFibGVGZWF0dXJlIiwiaXNDcnlwdG9FbmFibGVkIiwiaXNJbml0aWFsU3luY0NvbXBsZXRlIiwiY3Jvc3NTaWduaW5nUmVhZHkiLCJpc0Nyb3NzU2lnbmluZ1JlYWR5Iiwic2VjcmV0U3RvcmFnZVJlYWR5IiwiaXNTZWNyZXRTdG9yYWdlUmVhZHkiLCJhbGxTeXN0ZW1zUmVhZHkiLCJkb3dubG9hZEtleXMiLCJnZXRDcm9zc1NpZ25pbmdJZCIsImdldFN0b3JlZENyb3NzU2lnbmluZ0ZvclVzZXIiLCJTZXR1cEtpbmQiLCJWRVJJRllfVEhJU19TRVNTSU9OIiwiYmFja3VwSW5mbyIsIlVQR1JBREVfRU5DUllQVElPTiIsIndhaXRGb3JDbGllbnRXZWxsS25vd24iLCJTRVRfVVBfRU5DUllQVElPTiIsIm9sZFVudmVyaWZpZWREZXZpY2VJZHMiLCJuZXdVbnZlcmlmaWVkRGV2aWNlSWRzIiwiZGV2aWNlcyIsImRldmljZSIsImRldmljZVRydXN0IiwiY2hlY2tEZXZpY2VUcnVzdCIsImlzQ3Jvc3NTaWduaW5nVmVyaWZpZWQiLCJoYXMiLCJzaXplIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWdCQTs7QUFDQTs7QUFDQTs7QUFJQTs7QUFLQTs7QUFJQTs7QUFDQTs7QUFDQTs7QUFJQTs7QUFyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBeUJBLE1BQU1BLHdCQUF3QixHQUFHLElBQUksRUFBSixHQUFTLElBQTFDOztBQUVlLE1BQU1DLGNBQU4sQ0FBcUI7QUFBQTtBQUFBO0FBQUEscURBR1os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QUFDSCxLQUZELE1BRU87QUFDSDtBQUNILEtBdEZtQixDQXdGcEI7OztBQUNBLFNBQUssTUFBTTdCLFFBQVgsSUFBdUI4QixzQkFBdkIsRUFBK0M7QUFDM0MsNkNBQTRCOUIsUUFBNUI7QUFDSCxLQTNGbUIsQ0E2RnBCOzs7QUFDQSxTQUFLLE1BQU1BLFFBQVgsSUFBdUIsS0FBS2QsNEJBQTVCLEVBQTBEO0FBQ3RELFVBQUksQ0FBQzRDLHNCQUFzQixDQUFDTSxHQUF2QixDQUEyQnBDLFFBQTNCLENBQUwsRUFBMkM7QUFDdkMsK0NBQTRCQSxRQUE1QjtBQUNIO0FBQ0o7O0FBRUQsU0FBS2QsNEJBQUwsR0FBb0M0QyxzQkFBcEM7QUFDSDs7QUFoUitCIiwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDIwIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IHsgTWF0cml4Q2xpZW50UGVnIH0gZnJvbSAnLi9NYXRyaXhDbGllbnRQZWcnO1xuaW1wb3J0IGRpcyBmcm9tIFwiLi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXJcIjtcbmltcG9ydCB7XG4gICAgaGlkZVRvYXN0IGFzIGhpZGVCdWxrVW52ZXJpZmllZFNlc3Npb25zVG9hc3QsXG4gICAgc2hvd1RvYXN0IGFzIHNob3dCdWxrVW52ZXJpZmllZFNlc3Npb25zVG9hc3QsXG59IGZyb20gXCIuL3RvYXN0cy9CdWxrVW52ZXJpZmllZFNlc3Npb25zVG9hc3RcIjtcbmltcG9ydCB7XG4gICAgaGlkZVRvYXN0IGFzIGhpZGVTZXR1cEVuY3J5cHRpb25Ub2FzdCxcbiAgICBLaW5kIGFzIFNldHVwS2luZCxcbiAgICBzaG93VG9hc3QgYXMgc2hvd1NldHVwRW5jcnlwdGlvblRvYXN0LFxufSBmcm9tIFwiLi90b2FzdHMvU2V0dXBFbmNyeXB0aW9uVG9hc3RcIjtcbmltcG9ydCB7XG4gICAgaGlkZVRvYXN0IGFzIGhpZGVVbnZlcmlmaWVkU2Vzc2lvbnNUb2FzdCxcbiAgICBzaG93VG9hc3QgYXMgc2hvd1VudmVyaWZpZWRTZXNzaW9uc1RvYXN0LFxufSBmcm9tIFwiLi90b2FzdHMvVW52ZXJpZmllZFNlc3Npb25Ub2FzdFwiO1xuaW1wb3J0IHsgaXNTZWNyZXRTdG9yYWdlQmVpbmdBY2Nlc3NlZCwgYWNjZXNzU2VjcmV0U3RvcmFnZSB9IGZyb20gXCIuL1NlY3VyaXR5TWFuYWdlclwiO1xuaW1wb3J0IHsgaXNTZWN1cmVCYWNrdXBSZXF1aXJlZCB9IGZyb20gJy4vdXRpbHMvV2VsbEtub3duVXRpbHMnO1xuaW1wb3J0IHsgaXNMb2dnZWRJbiB9IGZyb20gJy4vY29tcG9uZW50cy9zdHJ1Y3R1cmVzL01hdHJpeENoYXQnO1xuaW1wb3J0IHsgTWF0cml4RXZlbnQgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvbW9kZWxzL2V2ZW50XCI7XG5pbXBvcnQgeyBBY3Rpb25QYXlsb2FkIH0gZnJvbSBcIi4vZGlzcGF0Y2hlci9wYXlsb2Fkc1wiO1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvbG9nZ2VyXCI7XG5cbmNvbnN0IEtFWV9CQUNLVVBfUE9MTF9JTlRFUlZBTCA9IDUgKiA2MCAqIDEwMDA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERldmljZUxpc3RlbmVyIHtcbiAgICBwcml2YXRlIGRpc3BhdGNoZXJSZWY6IHN0cmluZztcbiAgICAvLyBkZXZpY2UgSURzIGZvciB3aGljaCB0aGUgdXNlciBoYXMgZGlzbWlzc2VkIHRoZSB2ZXJpZnkgdG9hc3QgKCdMYXRlcicpXG4gICAgcHJpdmF0ZSBkaXNtaXNzZWQgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAvLyBoYXMgdGhlIHVzZXIgZGlzbWlzc2VkIGFueSBvZiB0aGUgdmFyaW91cyBuYWcgdG9hc3RzIHRvIHNldHVwIGVuY3J5cHRpb24gb24gdGhpcyBkZXZpY2U/XG4gICAgcHJpdmF0ZSBkaXNtaXNzZWRUaGlzRGV2aWNlVG9hc3QgPSBmYWxzZTtcbiAgICAvLyBjYWNoZSBvZiB0aGUga2V5IGJhY2t1cCBpbmZvXG4gICAgcHJpdmF0ZSBrZXlCYWNrdXBJbmZvOiBvYmplY3QgPSBudWxsO1xuICAgIHByaXZhdGUga2V5QmFja3VwRmV0Y2hlZEF0OiBudW1iZXIgPSBudWxsO1xuICAgIC8vIFdlIGtlZXAgYSBsaXN0IG9mIG91ciBvd24gZGV2aWNlIElEcyBzbyB3ZSBjYW4gYmF0Y2ggb25lcyB0aGF0IHdlcmUgYWxyZWFkeVxuICAgIC8vIHRoZXJlIHRoZSBsYXN0IHRpbWUgdGhlIGFwcCBsYXVuY2hlZCBpbnRvIGEgc2luZ2xlIHRvYXN0LCBidXQgZGlzcGxheSBuZXdcbiAgICAvLyBvbmVzIGluIHRoZWlyIG93biB0b2FzdHMuXG4gICAgcHJpdmF0ZSBvdXJEZXZpY2VJZHNBdFN0YXJ0OiBTZXQ8c3RyaW5nPiA9IG51bGw7XG4gICAgLy8gVGhlIHNldCBvZiBkZXZpY2UgSURzIHdlJ3JlIGN1cnJlbnRseSBkaXNwbGF5aW5nIHRvYXN0cyBmb3JcbiAgICBwcml2YXRlIGRpc3BsYXlpbmdUb2FzdHNGb3JEZXZpY2VJZHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAgIHN0YXRpYyBzaGFyZWRJbnN0YW5jZSgpIHtcbiAgICAgICAgaWYgKCF3aW5kb3cubXhEZXZpY2VMaXN0ZW5lcikgd2luZG93Lm14RGV2aWNlTGlzdGVuZXIgPSBuZXcgRGV2aWNlTGlzdGVuZXIoKTtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5teERldmljZUxpc3RlbmVyO1xuICAgIH1cblxuICAgIHN0YXJ0KCkge1xuICAgICAgICBNYXRyaXhDbGllbnRQZWcuZ2V0KCkub24oJ2NyeXB0by53aWxsVXBkYXRlRGV2aWNlcycsIHRoaXMub25XaWxsVXBkYXRlRGV2aWNlcyk7XG4gICAgICAgIE1hdHJpeENsaWVudFBlZy5nZXQoKS5vbignY3J5cHRvLmRldmljZXNVcGRhdGVkJywgdGhpcy5vbkRldmljZXNVcGRhdGVkKTtcbiAgICAgICAgTWF0cml4Q2xpZW50UGVnLmdldCgpLm9uKCdkZXZpY2VWZXJpZmljYXRpb25DaGFuZ2VkJywgdGhpcy5vbkRldmljZVZlcmlmaWNhdGlvbkNoYW5nZWQpO1xuICAgICAgICBNYXRyaXhDbGllbnRQZWcuZ2V0KCkub24oJ3VzZXJUcnVzdFN0YXR1c0NoYW5nZWQnLCB0aGlzLm9uVXNlclRydXN0U3RhdHVzQ2hhbmdlZCk7XG4gICAgICAgIE1hdHJpeENsaWVudFBlZy5nZXQoKS5vbignY3Jvc3NTaWduaW5nLmtleXNDaGFuZ2VkJywgdGhpcy5vbkNyb3NzU2luZ2luZ0tleXNDaGFuZ2VkKTtcbiAgICAgICAgTWF0cml4Q2xpZW50UGVnLmdldCgpLm9uKCdhY2NvdW50RGF0YScsIHRoaXMub25BY2NvdW50RGF0YSk7XG4gICAgICAgIE1hdHJpeENsaWVudFBlZy5nZXQoKS5vbignc3luYycsIHRoaXMub25TeW5jKTtcbiAgICAgICAgTWF0cml4Q2xpZW50UGVnLmdldCgpLm9uKCdSb29tU3RhdGUuZXZlbnRzJywgdGhpcy5vblJvb21TdGF0ZUV2ZW50cyk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlclJlZiA9IGRpcy5yZWdpc3Rlcih0aGlzLm9uQWN0aW9uKTtcbiAgICAgICAgdGhpcy5yZWNoZWNrKCk7XG4gICAgfVxuXG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKE1hdHJpeENsaWVudFBlZy5nZXQoKSkge1xuICAgICAgICAgICAgTWF0cml4Q2xpZW50UGVnLmdldCgpLnJlbW92ZUxpc3RlbmVyKCdjcnlwdG8ud2lsbFVwZGF0ZURldmljZXMnLCB0aGlzLm9uV2lsbFVwZGF0ZURldmljZXMpO1xuICAgICAgICAgICAgTWF0cml4Q2xpZW50UGVnLmdldCgpLnJlbW92ZUxpc3RlbmVyKCdjcnlwdG8uZGV2aWNlc1VwZGF0ZWQnLCB0aGlzLm9uRGV2aWNlc1VwZGF0ZWQpO1xuICAgICAgICAgICAgTWF0cml4Q2xpZW50UGVnLmdldCgpLnJlbW92ZUxpc3RlbmVyKCdkZXZpY2VWZXJpZmljYXRpb25DaGFuZ2VkJywgdGhpcy5vbkRldmljZVZlcmlmaWNhdGlvbkNoYW5nZWQpO1xuICAgICAgICAgICAgTWF0cml4Q2xpZW50UGVnLmdldCgpLnJlbW92ZUxpc3RlbmVyKCd1c2VyVHJ1c3RTdGF0dXNDaGFuZ2VkJywgdGhpcy5vblVzZXJUcnVzdFN0YXR1c0NoYW5nZWQpO1xuICAgICAgICAgICAgTWF0cml4Q2xpZW50UGVnLmdldCgpLnJlbW92ZUxpc3RlbmVyKCdjcm9zc1NpZ25pbmcua2V5c0NoYW5nZWQnLCB0aGlzLm9uQ3Jvc3NTaW5naW5nS2V5c0NoYW5nZWQpO1xuICAgICAgICAgICAgTWF0cml4Q2xpZW50UGVnLmdldCgpLnJlbW92ZUxpc3RlbmVyKCdhY2NvdW50RGF0YScsIHRoaXMub25BY2NvdW50RGF0YSk7XG4gICAgICAgICAgICBNYXRyaXhDbGllbnRQZWcuZ2V0KCkucmVtb3ZlTGlzdGVuZXIoJ3N5bmMnLCB0aGlzLm9uU3luYyk7XG4gICAgICAgICAgICBNYXRyaXhDbGllbnRQZWcuZ2V0KCkucmVtb3ZlTGlzdGVuZXIoJ1Jvb21TdGF0ZS5ldmVudHMnLCB0aGlzLm9uUm9vbVN0YXRlRXZlbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaXNwYXRjaGVyUmVmKSB7XG4gICAgICAgICAgICBkaXMudW5yZWdpc3Rlcih0aGlzLmRpc3BhdGNoZXJSZWYpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGVyUmVmID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc21pc3NlZC5jbGVhcigpO1xuICAgICAgICB0aGlzLmRpc21pc3NlZFRoaXNEZXZpY2VUb2FzdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmtleUJhY2t1cEluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLmtleUJhY2t1cEZldGNoZWRBdCA9IG51bGw7XG4gICAgICAgIHRoaXMub3VyRGV2aWNlSWRzQXRTdGFydCA9IG51bGw7XG4gICAgICAgIHRoaXMuZGlzcGxheWluZ1RvYXN0c0ZvckRldmljZUlkcyA9IG5ldyBTZXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNtaXNzIG5vdGlmaWNhdGlvbnMgYWJvdXQgb3VyIG93biB1bnZlcmlmaWVkIGRldmljZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGRldmljZUlkcyBMaXN0IG9mIGRldmljZSBJRHMgdG8gZGlzbWlzcyBub3RpZmljYXRpb25zIGZvclxuICAgICAqL1xuICAgIGFzeW5jIGRpc21pc3NVbnZlcmlmaWVkU2Vzc2lvbnMoZGV2aWNlSWRzOiBJdGVyYWJsZTxzdHJpbmc+KSB7XG4gICAgICAgIGxvZ2dlci5sb2coXCJEaXNtaXNzaW5nIHVudmVyaWZpZWQgc2Vzc2lvbnM6IFwiICsgQXJyYXkuZnJvbShkZXZpY2VJZHMpLmpvaW4oJywnKSk7XG4gICAgICAgIGZvciAoY29uc3QgZCBvZiBkZXZpY2VJZHMpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzbWlzc2VkLmFkZChkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVjaGVjaygpO1xuICAgIH1cblxuICAgIGRpc21pc3NFbmNyeXB0aW9uU2V0dXAoKSB7XG4gICAgICAgIHRoaXMuZGlzbWlzc2VkVGhpc0RldmljZVRvYXN0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZWNoZWNrKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBlbnN1cmVEZXZpY2VJZHNBdFN0YXJ0UG9wdWxhdGVkKCkge1xuICAgICAgICBpZiAodGhpcy5vdXJEZXZpY2VJZHNBdFN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBjbGkgPSBNYXRyaXhDbGllbnRQZWcuZ2V0KCk7XG4gICAgICAgICAgICB0aGlzLm91ckRldmljZUlkc0F0U3RhcnQgPSBuZXcgU2V0KFxuICAgICAgICAgICAgICAgIGNsaS5nZXRTdG9yZWREZXZpY2VzRm9yVXNlcihjbGkuZ2V0VXNlcklkKCkpLm1hcChkID0+IGQuZGV2aWNlSWQpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgb25XaWxsVXBkYXRlRGV2aWNlcyA9IGFzeW5jICh1c2Vyczogc3RyaW5nW10sIGluaXRpYWxGZXRjaD86IGJvb2xlYW4pID0+IHtcbiAgICAgICAgLy8gSWYgd2UgZGlkbid0IGtub3cgYWJvdXQgKmFueSogZGV2aWNlcyBiZWZvcmUgKGllLiBpdCdzIGZyZXNoIGxvZ2luKSxcbiAgICAgICAgLy8gdGhlbiB0aGV5IGFyZSBhbGwgcHJlLWV4aXN0aW5nIGRldmljZXMsIHNvIGlnbm9yZSB0aGlzIGFuZCBzZXQgdGhlXG4gICAgICAgIC8vIGRldmljZXNBdFN0YXJ0IGxpc3QgdG8gdGhlIGRldmljZXMgdGhhdCB3ZSBzZWUgYWZ0ZXIgdGhlIGZldGNoLlxuICAgICAgICBpZiAoaW5pdGlhbEZldGNoKSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgbXlVc2VySWQgPSBNYXRyaXhDbGllbnRQZWcuZ2V0KCkuZ2V0VXNlcklkKCk7XG4gICAgICAgIGlmICh1c2Vycy5pbmNsdWRlcyhteVVzZXJJZCkpIHRoaXMuZW5zdXJlRGV2aWNlSWRzQXRTdGFydFBvcHVsYXRlZCgpO1xuXG4gICAgICAgIC8vIE5vIG5lZWQgdG8gZG8gYSByZWNoZWNrIGhlcmU6IHdlIGp1c3QgbmVlZCB0byBnZXQgYSBzbmFwc2hvdCBvZiBvdXIgZGV2aWNlc1xuICAgICAgICAvLyBiZWZvcmUgd2UgZG93bmxvYWQgYW55IG5ldyBvbmVzLlxuICAgIH07XG5cbiAgICBwcml2YXRlIG9uRGV2aWNlc1VwZGF0ZWQgPSAodXNlcnM6IHN0cmluZ1tdKSA9PiB7XG4gICAgICAgIGlmICghdXNlcnMuaW5jbHVkZXMoTWF0cml4Q2xpZW50UGVnLmdldCgpLmdldFVzZXJJZCgpKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLnJlY2hlY2soKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbkRldmljZVZlcmlmaWNhdGlvbkNoYW5nZWQgPSAodXNlcklkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKHVzZXJJZCAhPT0gTWF0cml4Q2xpZW50UGVnLmdldCgpLmdldFVzZXJJZCgpKSByZXR1cm47XG4gICAgICAgIHRoaXMucmVjaGVjaygpO1xuICAgIH07XG5cbiAgICBwcml2YXRlIG9uVXNlclRydXN0U3RhdHVzQ2hhbmdlZCA9ICh1c2VySWQ6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAodXNlcklkICE9PSBNYXRyaXhDbGllbnRQZWcuZ2V0KCkuZ2V0VXNlcklkKCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5yZWNoZWNrKCk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25Dcm9zc1NpbmdpbmdLZXlzQ2hhbmdlZCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5yZWNoZWNrKCk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25BY2NvdW50RGF0YSA9IChldjogTWF0cml4RXZlbnQpID0+IHtcbiAgICAgICAgLy8gVXNlciBtYXkgaGF2ZTpcbiAgICAgICAgLy8gKiBtaWdyYXRlZCBTU1NTIHRvIHN5bW1ldHJpY1xuICAgICAgICAvLyAqIHVwbG9hZGVkIGtleXMgdG8gc2VjcmV0IHN0b3JhZ2VcbiAgICAgICAgLy8gKiBjb21wbGV0ZWQgc2VjcmV0IHN0b3JhZ2UgY3JlYXRpb25cbiAgICAgICAgLy8gd2hpY2ggcmVzdWx0IGluIGFjY291bnQgZGF0YSBjaGFuZ2VzIGFmZmVjdGluZyBjaGVja3MgYmVsb3cuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGV2LmdldFR5cGUoKS5zdGFydHNXaXRoKCdtLnNlY3JldF9zdG9yYWdlLicpIHx8XG4gICAgICAgICAgICBldi5nZXRUeXBlKCkuc3RhcnRzV2l0aCgnbS5jcm9zc19zaWduaW5nLicpIHx8XG4gICAgICAgICAgICBldi5nZXRUeXBlKCkgPT09ICdtLm1lZ29sbV9iYWNrdXAudjEnXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5yZWNoZWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvblN5bmMgPSAoc3RhdGUsIHByZXZTdGF0ZSkgPT4ge1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdQUkVQQVJFRCcgJiYgcHJldlN0YXRlID09PSBudWxsKSB0aGlzLnJlY2hlY2soKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvblJvb21TdGF0ZUV2ZW50cyA9IChldjogTWF0cml4RXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2LmdldFR5cGUoKSAhPT0gXCJtLnJvb20uZW5jcnlwdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBhIHJvb20gY2hhbmdlcyB0byBlbmNyeXB0ZWQsIHJlLWNoZWNrIGFzIGl0IG1heSBiZSBvdXIgZmlyc3RcbiAgICAgICAgLy8gZW5jcnlwdGVkIHJvb20uIFRoaXMgYWxzbyBjYXRjaGVzIGVuY3J5cHRlZCByb29tIGNyZWF0aW9uIGFzIHdlbGwuXG4gICAgICAgIHRoaXMucmVjaGVjaygpO1xuICAgIH07XG5cbiAgICBwcml2YXRlIG9uQWN0aW9uID0gKHsgYWN0aW9uIH06IEFjdGlvblBheWxvYWQpID0+IHtcbiAgICAgICAgaWYgKGFjdGlvbiAhPT0gXCJvbl9sb2dnZWRfaW5cIikgcmV0dXJuO1xuICAgICAgICB0aGlzLnJlY2hlY2soKTtcbiAgICB9O1xuXG4gICAgLy8gVGhlIHNlcnZlciBkb2Vzbid0IHRlbGwgdXMgd2hlbiBrZXkgYmFja3VwIGlzIHNldCB1cCwgc28gd2UgcG9sbFxuICAgIC8vICYgY2FjaGUgdGhlIHJlc3VsdFxuICAgIHByaXZhdGUgYXN5bmMgZ2V0S2V5QmFja3VwSW5mbygpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgaWYgKCF0aGlzLmtleUJhY2t1cEluZm8gfHwgdGhpcy5rZXlCYWNrdXBGZXRjaGVkQXQgPCBub3cgLSBLRVlfQkFDS1VQX1BPTExfSU5URVJWQUwpIHtcbiAgICAgICAgICAgIHRoaXMua2V5QmFja3VwSW5mbyA9IGF3YWl0IE1hdHJpeENsaWVudFBlZy5nZXQoKS5nZXRLZXlCYWNrdXBWZXJzaW9uKCk7XG4gICAgICAgICAgICB0aGlzLmtleUJhY2t1cEZldGNoZWRBdCA9IG5vdztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5rZXlCYWNrdXBJbmZvO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2hvdWxkU2hvd1NldHVwRW5jcnlwdGlvblRvYXN0KCkge1xuICAgICAgICAvLyBJZiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgc2VjcmV0IHN0b3JhZ2Ugb3BlcmF0aW9uLCB3ZSdyZSBsaWtlbHlcbiAgICAgICAgLy8gbW9kaWZ5aW5nIHRoZSBzdGF0ZSBpbnZvbHZlZCBoZXJlLCBzbyBkb24ndCBhZGQgbmV3IHRvYXN0cyB0byBzZXR1cC5cbiAgICAgICAgaWYgKGlzU2VjcmV0U3RvcmFnZUJlaW5nQWNjZXNzZWQoKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBTaG93IHNldHVwIHRvYXN0cyBvbmNlIHRoZSB1c2VyIGlzIGluIGF0IGxlYXN0IG9uZSBlbmNyeXB0ZWQgcm9vbS5cbiAgICAgICAgY29uc3QgY2xpID0gTWF0cml4Q2xpZW50UGVnLmdldCgpO1xuICAgICAgICByZXR1cm4gY2xpICYmIGNsaS5nZXRSb29tcygpLnNvbWUociA9PiBjbGkuaXNSb29tRW5jcnlwdGVkKHIucm9vbUlkKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyByZWNoZWNrKCkge1xuICAgICAgICBjb25zdCBjbGkgPSBNYXRyaXhDbGllbnRQZWcuZ2V0KCk7XG5cbiAgICAgICAgaWYgKCEoYXdhaXQgY2xpLmRvZXNTZXJ2ZXJTdXBwb3J0VW5zdGFibGVGZWF0dXJlKFwib3JnLm1hdHJpeC5lMmVfY3Jvc3Nfc2lnbmluZ1wiKSkpIHJldHVybjtcblxuICAgICAgICBpZiAoIWNsaS5pc0NyeXB0b0VuYWJsZWQoKSkgcmV0dXJuO1xuICAgICAgICAvLyBkb24ndCByZWNoZWNrIHVudGlsIHRoZSBpbml0aWFsIHN5bmMgaXMgY29tcGxldGU6IGxvdHMgb2YgYWNjb3VudCBkYXRhIGV2ZW50cyB3aWxsIGZpcmVcbiAgICAgICAgLy8gd2hpbGUgdGhlIGluaXRpYWwgc3luYyBpcyBwcm9jZXNzaW5nIGFuZCB3ZSBkb24ndCBuZWVkIHRvIHJlY2hlY2sgb24gZWFjaCBvbmUgb2YgdGhlbVxuICAgICAgICAvLyAod2UgYWRkIGEgbGlzdGVuZXIgb24gc3luYyB0byBkbyBvbmNlIGNoZWNrIGFmdGVyIHRoZSBpbml0aWFsIHN5bmMgaXMgZG9uZSlcbiAgICAgICAgaWYgKCFjbGkuaXNJbml0aWFsU3luY0NvbXBsZXRlKCkpIHJldHVybjtcblxuICAgICAgICBjb25zdCBjcm9zc1NpZ25pbmdSZWFkeSA9IGF3YWl0IGNsaS5pc0Nyb3NzU2lnbmluZ1JlYWR5KCk7XG4gICAgICAgIGNvbnN0IHNlY3JldFN0b3JhZ2VSZWFkeSA9IGF3YWl0IGNsaS5pc1NlY3JldFN0b3JhZ2VSZWFkeSgpO1xuICAgICAgICBjb25zdCBhbGxTeXN0ZW1zUmVhZHkgPSBjcm9zc1NpZ25pbmdSZWFkeSAmJiBzZWNyZXRTdG9yYWdlUmVhZHk7XG5cbiAgICAgICAgaWYgKHRoaXMuZGlzbWlzc2VkVGhpc0RldmljZVRvYXN0IHx8IGFsbFN5c3RlbXNSZWFkeSkge1xuICAgICAgICAgICAgaGlkZVNldHVwRW5jcnlwdGlvblRvYXN0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zaG91bGRTaG93U2V0dXBFbmNyeXB0aW9uVG9hc3QoKSkge1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIG91ciBrZXlzIGFyZSBmaW5pc2hlZCBkb3dubG9hZGluZ1xuICAgICAgICAgICAgYXdhaXQgY2xpLmRvd25sb2FkS2V5cyhbY2xpLmdldFVzZXJJZCgpXSk7XG4gICAgICAgICAgICAvLyBjcm9zcyBzaWduaW5nIGlzbid0IGVuYWJsZWQgLSBuYWcgdG8gZW5hYmxlIGl0XG4gICAgICAgICAgICAvLyBUaGVyZSBhcmUgMyBkaWZmZXJlbnQgdG9hc3RzIGZvcjpcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhY2xpLmdldENyb3NzU2lnbmluZ0lkKCkgJiZcbiAgICAgICAgICAgICAgICBjbGkuZ2V0U3RvcmVkQ3Jvc3NTaWduaW5nRm9yVXNlcihjbGkuZ2V0VXNlcklkKCkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBDcm9zcy1zaWduaW5nIG9uIGFjY291bnQgYnV0IHRoaXMgZGV2aWNlIGRvZXNuJ3QgdHJ1c3QgdGhlIG1hc3RlciBrZXkgKHZlcmlmeSB0aGlzIHNlc3Npb24pXG4gICAgICAgICAgICAgICAgc2hvd1NldHVwRW5jcnlwdGlvblRvYXN0KFNldHVwS2luZC5WRVJJRllfVEhJU19TRVNTSU9OKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFja3VwSW5mbyA9IGF3YWl0IHRoaXMuZ2V0S2V5QmFja3VwSW5mbygpO1xuICAgICAgICAgICAgICAgIGlmIChiYWNrdXBJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGNyb3NzLXNpZ25pbmcgb24gYWNjb3VudCBidXQga2V5IGJhY2t1cCBhdmFpbGFibGUgKHVwZ3JhZGUgZW5jcnlwdGlvbilcbiAgICAgICAgICAgICAgICAgICAgc2hvd1NldHVwRW5jcnlwdGlvblRvYXN0KFNldHVwS2luZC5VUEdSQURFX0VOQ1JZUFRJT04pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGNyb3NzLXNpZ25pbmcgb3Iga2V5IGJhY2t1cCBvbiBhY2NvdW50IChzZXQgdXAgZW5jcnlwdGlvbilcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2xpLndhaXRGb3JDbGllbnRXZWxsS25vd24oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2VjdXJlQmFja3VwUmVxdWlyZWQoKSAmJiBpc0xvZ2dlZEluKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIG1lYW50IHRvIHNldCB1cCwgYW5kIFNlY3VyZSBCYWNrdXAgaXMgcmVxdWlyZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIHRoZSBmbG93IGRpcmVjdGx5IHdpdGhvdXQgYSB0b2FzdCBvbmNlIGxvZ2dlZCBpbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVTZXR1cEVuY3J5cHRpb25Ub2FzdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzU2VjcmV0U3RvcmFnZSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1NldHVwRW5jcnlwdGlvblRvYXN0KFNldHVwS2luZC5TRVRfVVBfRU5DUllQVElPTik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRvbmUgYWZ0ZXIgYXdhaXRpbmcgb24gZG93bmxvYWRLZXlzKCkgYWJvdmUsIHNvXG4gICAgICAgIC8vIHdlIG1ha2Ugc3VyZSB3ZSBnZXQgdGhlIGRldmljZXMgYWZ0ZXIgdGhlIGZldGNoIGlzIGRvbmUuXG4gICAgICAgIHRoaXMuZW5zdXJlRGV2aWNlSWRzQXRTdGFydFBvcHVsYXRlZCgpO1xuXG4gICAgICAgIC8vIFVudmVyaWZpZWQgZGV2aWNlcyB0aGF0IHdlcmUgdGhlcmUgbGFzdCB0aW1lIHRoZSBhcHAgcmFuXG4gICAgICAgIC8vICh0ZWNobmljYWxseSBjb3VsZCBqdXN0IGJlIGEgYm9vbGVhbjogd2UgZG9uJ3QgYWN0dWFsbHlcbiAgICAgICAgLy8gbmVlZCB0byByZW1lbWJlciB0aGUgZGV2aWNlIElEcywgYnV0IGZvciB0aGUgc2FrZSBvZlxuICAgICAgICAvLyBzeW1tZXRyeS4uLikuXG4gICAgICAgIGNvbnN0IG9sZFVudmVyaWZpZWREZXZpY2VJZHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgICAgLy8gVW52ZXJpZmllZCBkZXZpY2VzIHRoYXQgaGF2ZSBhcHBlYXJlZCBzaW5jZSB0aGVuXG4gICAgICAgIGNvbnN0IG5ld1VudmVyaWZpZWREZXZpY2VJZHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAgICAgICAvLyBhcyBsb25nIGFzIGNyb3NzLXNpZ25pbmcgaXNuJ3QgcmVhZHksXG4gICAgICAgIC8vIHlvdSBjYW4ndCBzZWUgb3IgZGlzbWlzcyBhbnkgZGV2aWNlIHRvYXN0c1xuICAgICAgICBpZiAoY3Jvc3NTaWduaW5nUmVhZHkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRldmljZXMgPSBjbGkuZ2V0U3RvcmVkRGV2aWNlc0ZvclVzZXIoY2xpLmdldFVzZXJJZCgpKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGV2aWNlIG9mIGRldmljZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGV2aWNlLmRldmljZUlkID09PSBjbGkuZGV2aWNlSWQpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZGV2aWNlVHJ1c3QgPSBhd2FpdCBjbGkuY2hlY2tEZXZpY2VUcnVzdChjbGkuZ2V0VXNlcklkKCksIGRldmljZS5kZXZpY2VJZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXZpY2VUcnVzdC5pc0Nyb3NzU2lnbmluZ1ZlcmlmaWVkKCkgJiYgIXRoaXMuZGlzbWlzc2VkLmhhcyhkZXZpY2UuZGV2aWNlSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm91ckRldmljZUlkc0F0U3RhcnQuaGFzKGRldmljZS5kZXZpY2VJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFVudmVyaWZpZWREZXZpY2VJZHMuYWRkKGRldmljZS5kZXZpY2VJZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdVbnZlcmlmaWVkRGV2aWNlSWRzLmFkZChkZXZpY2UuZGV2aWNlSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbG9nZ2VyLmxvZyhcIk9sZCB1bnZlcmlmaWVkIHNlc3Npb25zOiBcIiArIEFycmF5LmZyb20ob2xkVW52ZXJpZmllZERldmljZUlkcykuam9pbignLCcpKTtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIk5ldyB1bnZlcmlmaWVkIHNlc3Npb25zOiBcIiArIEFycmF5LmZyb20obmV3VW52ZXJpZmllZERldmljZUlkcykuam9pbignLCcpKTtcblxuICAgICAgICAvLyBEaXNwbGF5IG9yIGhpZGUgdGhlIGJhdGNoIHRvYXN0IGZvciBvbGQgdW52ZXJpZmllZCBzZXNzaW9uc1xuICAgICAgICBpZiAob2xkVW52ZXJpZmllZERldmljZUlkcy5zaXplID4gMCkge1xuICAgICAgICAgICAgc2hvd0J1bGtVbnZlcmlmaWVkU2Vzc2lvbnNUb2FzdChvbGRVbnZlcmlmaWVkRGV2aWNlSWRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpZGVCdWxrVW52ZXJpZmllZFNlc3Npb25zVG9hc3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNob3cgdG9hc3RzIGZvciBuZXcgdW52ZXJpZmllZCBkZXZpY2VzIGlmIHRoZXkgYXJlbid0IGFscmVhZHkgdGhlcmVcbiAgICAgICAgZm9yIChjb25zdCBkZXZpY2VJZCBvZiBuZXdVbnZlcmlmaWVkRGV2aWNlSWRzKSB7XG4gICAgICAgICAgICBzaG93VW52ZXJpZmllZFNlc3Npb25zVG9hc3QoZGV2aWNlSWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLi4uYW5kIGhpZGUgYW55IHdlIGRvbid0IG5lZWQgYW55IG1vcmVcbiAgICAgICAgZm9yIChjb25zdCBkZXZpY2VJZCBvZiB0aGlzLmRpc3BsYXlpbmdUb2FzdHNGb3JEZXZpY2VJZHMpIHtcbiAgICAgICAgICAgIGlmICghbmV3VW52ZXJpZmllZERldmljZUlkcy5oYXMoZGV2aWNlSWQpKSB7XG4gICAgICAgICAgICAgICAgaGlkZVVudmVyaWZpZWRTZXNzaW9uc1RvYXN0KGRldmljZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlzcGxheWluZ1RvYXN0c0ZvckRldmljZUlkcyA9IG5ld1VudmVyaWZpZWREZXZpY2VJZHM7XG4gICAgfVxufVxuIl19