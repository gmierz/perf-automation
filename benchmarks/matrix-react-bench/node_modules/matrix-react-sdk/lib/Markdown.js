"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var commonmark = _interopRequireWildcard(require("commonmark"));

var _lodash = require("lodash");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
Copyright 2016 OpenMarket Ltd
Copyright 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
const ALLOWED_HTML_TAGS = ['sub', 'sup', 'del', 'u']; // These types of node are definitely text

const TEXT_NODES = ['text', 'softbreak', 'linebreak', 'paragraph', 'document']; // As far as @types/commonmark is concerned, these are not public, so add them

function isAllowedHtmlTag(node) {
  if (node.literal != null && node.literal.match('^<((div|span) data-mx-maths="[^"]*"|/(div|span))>$') != null) {
    return true;
  } // Regex won't work for tags with attrs, but we only
  // allow <del> anyway.


  const matches = /^<\/?(.*)>$/.exec(node.literal);

  if (matches && matches.length == 2) {
    const tag = matches[1];
    return ALLOWED_HTML_TAGS.indexOf(tag) > -1;
  }

  return false;
}
/*
 * Returns true if the parse output containing the node
 * comprises multiple block level elements (ie. lines),
 * or false if it is only a single line.
 */


function isMultiLine(node) {
  let par = node;

  while (par.parent) {
    par = par.parent;
  }

  return par.firstChild != par.lastChild;
}
/**
 * Class that wraps commonmark, adding the ability to see whether
 * a given message actually uses any markdown syntax or whether
 * it's plain text.
 */


class Markdown {
  constructor(input) {
    (0, _defineProperty2.default)(this, "input", void 0);
    (0, _defineProperty2.default)(this, "parsed", void 0);
    this.input = input;
    const parser = new commonmark.Parser();
    this.parsed = parser.parse(this.input);
  }

  isPlainText() {
    const walker = this.parsed.walker();
    let ev;

    while (ev = walker.next()) {
      const node = ev.node;

      if (TEXT_NODES.indexOf(node.type) > -1) {
        // definitely text
        continue;
      } else if (node.type == 'html_inline' || node.type == 'html_block') {
        // if it's an allowed html tag, we need to render it and therefore
        // we will need to use HTML. If it's not allowed, it's not HTML since
        // we'll just be treating it as text.
        if (isAllowedHtmlTag(node)) {
          return false;
        }
      } else {
        return false;
      }
    }

    return true;
  }

  toHTML({
    externalLinks = false
  } = {}) {
    const renderer = new commonmark.HtmlRenderer({
      safe: false,
      // Set soft breaks to hard HTML breaks: commonmark
      // puts softbreaks in for multiple lines in a blockquote,
      // so if these are just newline characters then the
      // block quote ends up all on one line
      // (https://github.com/vector-im/element-web/issues/3154)
      softbreak: '<br />'
    }); // Trying to strip out the wrapping <p/> causes a lot more complication
    // than it's worth, i think.  For instance, this code will go and strip
    // out any <p/> tag (no matter where it is in the tree) which doesn't
    // contain \n's.
    // On the flip side, <p/>s are quite opionated and restricted on where
    // you can nest them.
    //
    // Let's try sending with <p/>s anyway for now, though.

    const realParagraph = renderer.paragraph;

    renderer.paragraph = function (node, entering) {
      // If there is only one top level node, just return the
      // bare text: it's a single line of text and so should be
      // 'inline', rather than unnecessarily wrapped in its own
      // p tag. If, however, we have multiple nodes, each gets
      // its own p tag to keep them as separate paragraphs.
      // However, if it's a blockquote, adds a p tag anyway
      // in order to avoid deviation to commonmark and unexpected
      // results when parsing the formatted HTML.
      if (node.parent.type === 'block_quote' || isMultiLine(node)) {
        realParagraph.call(this, node, entering);
      }
    };

    renderer.link = function (node, entering) {
      const attrs = this.attrs(node);

      if (entering) {
        attrs.push(['href', this.esc(node.destination)]);

        if (node.title) {
          attrs.push(['title', this.esc(node.title)]);
        } // Modified link behaviour to treat them all as external and
        // thus opening in a new tab.


        if (externalLinks) {
          attrs.push(['target', '_blank']);
          attrs.push(['rel', 'noreferrer noopener']);
        }

        this.tag('a', attrs);
      } else {
        this.tag('/a');
      }
    };

    renderer.html_inline = function (node) {
      if (isAllowedHtmlTag(node)) {
        this.lit(node.literal);
        return;
      } else {
        this.lit((0, _lodash.escape)(node.literal));
      }
    };

    renderer.html_block = function (node) {
      /*
      // as with `paragraph`, we only insert line breaks
      // if there are multiple lines in the markdown.
      const isMultiLine = is_multi_line(node);
      if (isMultiLine) this.cr();
      */
      renderer.html_inline(node);
      /*
      if (isMultiLine) this.cr();
      */
    };

    return renderer.render(this.parsed);
  }
  /*
   * Render the markdown message to plain text. That is, essentially
   * just remove any backslashes escaping what would otherwise be
   * markdown syntax
   * (to fix https://github.com/vector-im/element-web/issues/2870).
   *
   * N.B. this does **NOT** render arbitrary MD to plain text - only MD
   * which has no formatting.  Otherwise it emits HTML(!).
   */


  toPlaintext() {
    const renderer = new commonmark.HtmlRenderer({
      safe: false
    });

    renderer.paragraph = function (node, entering) {
      // as with toHTML, only append lines to paragraphs if there are
      // multiple paragraphs
      if (isMultiLine(node)) {
        if (!entering && node.next) {
          this.lit('\n\n');
        }
      }
    };

    renderer.html_block = function (node) {
      this.lit(node.literal);
      if (isMultiLine(node) && node.next) this.lit('\n\n');
    };

    return renderer.render(this.parsed);
  }

}

exports.default = Markdown;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9NYXJrZG93bi50cyJdLCJuYW1lcyI6WyJBTExPV0VEX0hUTUxfVEFHUyIsIlRFWFRfTk9ERVMiLCJpc0FsbG93ZWRIdG1sVGFnIiwibm9kZSIsImxpdGVyYWwiLCJtYXRjaCIsIm1hdGNoZXMiLCJleGVjIiwibGVuZ3RoIiwidGFnIiwiaW5kZXhPZiIsImlzTXVsdGlMaW5lIiwicGFyIiwicGFyZW50IiwiZmlyc3RDaGlsZCIsImxhc3RDaGlsZCIsIk1hcmtkb3duIiwiY29uc3RydWN0b3IiLCJpbnB1dCIsInBhcnNlciIsImNvbW1vbm1hcmsiLCJQYXJzZXIiLCJwYXJzZWQiLCJwYXJzZSIsImlzUGxhaW5UZXh0Iiwid2Fsa2VyIiwiZXYiLCJuZXh0IiwidHlwZSIsInRvSFRNTCIsImV4dGVybmFsTGlua3MiLCJyZW5kZXJlciIsIkh0bWxSZW5kZXJlciIsInNhZmUiLCJzb2Z0YnJlYWsiLCJyZWFsUGFyYWdyYXBoIiwicGFyYWdyYXBoIiwiZW50ZXJpbmciLCJjYWxsIiwibGluayIsImF0dHJzIiwicHVzaCIsImVzYyIsImRlc3RpbmF0aW9uIiwidGl0bGUiLCJodG1sX2lubGluZSIsImxpdCIsImh0bWxfYmxvY2siLCJyZW5kZXIiLCJ0b1BsYWludGV4dCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFpQkE7O0FBQ0E7Ozs7OztBQWxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBLE1BQU1BLGlCQUFpQixHQUFHLENBQUMsS0FBRCxFQUFRLEtBQVIsRUFBZSxLQUFmLEVBQXNCLEdBQXRCLENBQTFCLEMsQ0FFQTs7QUFDQSxNQUFNQyxVQUFVLEdBQUcsQ0FBQyxNQUFELEVBQVMsV0FBVCxFQUFzQixXQUF0QixFQUFtQyxXQUFuQyxFQUFnRCxVQUFoRCxDQUFuQixDLENBRUE7O0FBUUEsU0FBU0MsZ0JBQVQsQ0FBMEJDLElBQTFCLEVBQTBE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QUFLMUIsTUFBckIsQ0FBUDtBQUNIOztBQS9JeUIiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMTYgT3Blbk1hcmtldCBMdGRcbkNvcHlyaWdodCAyMDIxIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0ICogYXMgY29tbW9ubWFyayBmcm9tICdjb21tb25tYXJrJztcbmltcG9ydCB7IGVzY2FwZSB9IGZyb20gXCJsb2Rhc2hcIjtcblxuY29uc3QgQUxMT1dFRF9IVE1MX1RBR1MgPSBbJ3N1YicsICdzdXAnLCAnZGVsJywgJ3UnXTtcblxuLy8gVGhlc2UgdHlwZXMgb2Ygbm9kZSBhcmUgZGVmaW5pdGVseSB0ZXh0XG5jb25zdCBURVhUX05PREVTID0gWyd0ZXh0JywgJ3NvZnRicmVhaycsICdsaW5lYnJlYWsnLCAncGFyYWdyYXBoJywgJ2RvY3VtZW50J107XG5cbi8vIEFzIGZhciBhcyBAdHlwZXMvY29tbW9ubWFyayBpcyBjb25jZXJuZWQsIHRoZXNlIGFyZSBub3QgcHVibGljLCBzbyBhZGQgdGhlbVxuaW50ZXJmYWNlIENvbW1vbm1hcmtIdG1sUmVuZGVyZXJJbnRlcm5hbCBleHRlbmRzIGNvbW1vbm1hcmsuSHRtbFJlbmRlcmVyIHtcbiAgICBwYXJhZ3JhcGg6IChub2RlOiBjb21tb25tYXJrLk5vZGUsIGVudGVyaW5nOiBib29sZWFuKSA9PiB2b2lkO1xuICAgIGxpbms6IChub2RlOiBjb21tb25tYXJrLk5vZGUsIGVudGVyaW5nOiBib29sZWFuKSA9PiB2b2lkO1xuICAgIGh0bWxfaW5saW5lOiAobm9kZTogY29tbW9ubWFyay5Ob2RlKSA9PiB2b2lkOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuICAgIGh0bWxfYmxvY2s6IChub2RlOiBjb21tb25tYXJrLk5vZGUpID0+IHZvaWQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG59XG5cbmZ1bmN0aW9uIGlzQWxsb3dlZEh0bWxUYWcobm9kZTogY29tbW9ubWFyay5Ob2RlKTogYm9vbGVhbiB7XG4gICAgaWYgKG5vZGUubGl0ZXJhbCAhPSBudWxsICYmXG4gICAgICAgIG5vZGUubGl0ZXJhbC5tYXRjaCgnXjwoKGRpdnxzcGFuKSBkYXRhLW14LW1hdGhzPVwiW15cIl0qXCJ8LyhkaXZ8c3BhbikpPiQnKSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFJlZ2V4IHdvbid0IHdvcmsgZm9yIHRhZ3Mgd2l0aCBhdHRycywgYnV0IHdlIG9ubHlcbiAgICAvLyBhbGxvdyA8ZGVsPiBhbnl3YXkuXG4gICAgY29uc3QgbWF0Y2hlcyA9IC9ePFxcLz8oLiopPiQvLmV4ZWMobm9kZS5saXRlcmFsKTtcbiAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IG1hdGNoZXNbMV07XG4gICAgICAgIHJldHVybiBBTExPV0VEX0hUTUxfVEFHUy5pbmRleE9mKHRhZykgPiAtMTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhcnNlIG91dHB1dCBjb250YWluaW5nIHRoZSBub2RlXG4gKiBjb21wcmlzZXMgbXVsdGlwbGUgYmxvY2sgbGV2ZWwgZWxlbWVudHMgKGllLiBsaW5lcyksXG4gKiBvciBmYWxzZSBpZiBpdCBpcyBvbmx5IGEgc2luZ2xlIGxpbmUuXG4gKi9cbmZ1bmN0aW9uIGlzTXVsdGlMaW5lKG5vZGU6IGNvbW1vbm1hcmsuTm9kZSk6IGJvb2xlYW4ge1xuICAgIGxldCBwYXIgPSBub2RlO1xuICAgIHdoaWxlIChwYXIucGFyZW50KSB7XG4gICAgICAgIHBhciA9IHBhci5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBwYXIuZmlyc3RDaGlsZCAhPSBwYXIubGFzdENoaWxkO1xufVxuXG4vKipcbiAqIENsYXNzIHRoYXQgd3JhcHMgY29tbW9ubWFyaywgYWRkaW5nIHRoZSBhYmlsaXR5IHRvIHNlZSB3aGV0aGVyXG4gKiBhIGdpdmVuIG1lc3NhZ2UgYWN0dWFsbHkgdXNlcyBhbnkgbWFya2Rvd24gc3ludGF4IG9yIHdoZXRoZXJcbiAqIGl0J3MgcGxhaW4gdGV4dC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFya2Rvd24ge1xuICAgIHByaXZhdGUgaW5wdXQ6IHN0cmluZztcbiAgICBwcml2YXRlIHBhcnNlZDogY29tbW9ubWFyay5Ob2RlO1xuXG4gICAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuXG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBjb21tb25tYXJrLlBhcnNlcigpO1xuICAgICAgICB0aGlzLnBhcnNlZCA9IHBhcnNlci5wYXJzZSh0aGlzLmlucHV0KTtcbiAgICB9XG5cbiAgICBpc1BsYWluVGV4dCgpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3Qgd2Fsa2VyID0gdGhpcy5wYXJzZWQud2Fsa2VyKCk7XG5cbiAgICAgICAgbGV0IGV2O1xuICAgICAgICB3aGlsZSAoIChldiA9IHdhbGtlci5uZXh0KCkpICkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGV2Lm5vZGU7XG4gICAgICAgICAgICBpZiAoVEVYVF9OT0RFUy5pbmRleE9mKG5vZGUudHlwZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIGRlZmluaXRlbHkgdGV4dFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT0gJ2h0bWxfaW5saW5lJyB8fCBub2RlLnR5cGUgPT0gJ2h0bWxfYmxvY2snKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQncyBhbiBhbGxvd2VkIGh0bWwgdGFnLCB3ZSBuZWVkIHRvIHJlbmRlciBpdCBhbmQgdGhlcmVmb3JlXG4gICAgICAgICAgICAgICAgLy8gd2Ugd2lsbCBuZWVkIHRvIHVzZSBIVE1MLiBJZiBpdCdzIG5vdCBhbGxvd2VkLCBpdCdzIG5vdCBIVE1MIHNpbmNlXG4gICAgICAgICAgICAgICAgLy8gd2UnbGwganVzdCBiZSB0cmVhdGluZyBpdCBhcyB0ZXh0LlxuICAgICAgICAgICAgICAgIGlmIChpc0FsbG93ZWRIdG1sVGFnKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0b0hUTUwoeyBleHRlcm5hbExpbmtzID0gZmFsc2UgfSA9IHt9KTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBuZXcgY29tbW9ubWFyay5IdG1sUmVuZGVyZXIoe1xuICAgICAgICAgICAgc2FmZTogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIFNldCBzb2Z0IGJyZWFrcyB0byBoYXJkIEhUTUwgYnJlYWtzOiBjb21tb25tYXJrXG4gICAgICAgICAgICAvLyBwdXRzIHNvZnRicmVha3MgaW4gZm9yIG11bHRpcGxlIGxpbmVzIGluIGEgYmxvY2txdW90ZSxcbiAgICAgICAgICAgIC8vIHNvIGlmIHRoZXNlIGFyZSBqdXN0IG5ld2xpbmUgY2hhcmFjdGVycyB0aGVuIHRoZVxuICAgICAgICAgICAgLy8gYmxvY2sgcXVvdGUgZW5kcyB1cCBhbGwgb24gb25lIGxpbmVcbiAgICAgICAgICAgIC8vIChodHRwczovL2dpdGh1Yi5jb20vdmVjdG9yLWltL2VsZW1lbnQtd2ViL2lzc3Vlcy8zMTU0KVxuICAgICAgICAgICAgc29mdGJyZWFrOiAnPGJyIC8+JyxcbiAgICAgICAgfSkgYXMgQ29tbW9ubWFya0h0bWxSZW5kZXJlckludGVybmFsO1xuXG4gICAgICAgIC8vIFRyeWluZyB0byBzdHJpcCBvdXQgdGhlIHdyYXBwaW5nIDxwLz4gY2F1c2VzIGEgbG90IG1vcmUgY29tcGxpY2F0aW9uXG4gICAgICAgIC8vIHRoYW4gaXQncyB3b3J0aCwgaSB0aGluay4gIEZvciBpbnN0YW5jZSwgdGhpcyBjb2RlIHdpbGwgZ28gYW5kIHN0cmlwXG4gICAgICAgIC8vIG91dCBhbnkgPHAvPiB0YWcgKG5vIG1hdHRlciB3aGVyZSBpdCBpcyBpbiB0aGUgdHJlZSkgd2hpY2ggZG9lc24ndFxuICAgICAgICAvLyBjb250YWluIFxcbidzLlxuICAgICAgICAvLyBPbiB0aGUgZmxpcCBzaWRlLCA8cC8+cyBhcmUgcXVpdGUgb3Bpb25hdGVkIGFuZCByZXN0cmljdGVkIG9uIHdoZXJlXG4gICAgICAgIC8vIHlvdSBjYW4gbmVzdCB0aGVtLlxuICAgICAgICAvL1xuICAgICAgICAvLyBMZXQncyB0cnkgc2VuZGluZyB3aXRoIDxwLz5zIGFueXdheSBmb3Igbm93LCB0aG91Z2guXG5cbiAgICAgICAgY29uc3QgcmVhbFBhcmFncmFwaCA9IHJlbmRlcmVyLnBhcmFncmFwaDtcblxuICAgICAgICByZW5kZXJlci5wYXJhZ3JhcGggPSBmdW5jdGlvbihub2RlOiBjb21tb25tYXJrLk5vZGUsIGVudGVyaW5nOiBib29sZWFuKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBvbmx5IG9uZSB0b3AgbGV2ZWwgbm9kZSwganVzdCByZXR1cm4gdGhlXG4gICAgICAgICAgICAvLyBiYXJlIHRleHQ6IGl0J3MgYSBzaW5nbGUgbGluZSBvZiB0ZXh0IGFuZCBzbyBzaG91bGQgYmVcbiAgICAgICAgICAgIC8vICdpbmxpbmUnLCByYXRoZXIgdGhhbiB1bm5lY2Vzc2FyaWx5IHdyYXBwZWQgaW4gaXRzIG93blxuICAgICAgICAgICAgLy8gcCB0YWcuIElmLCBob3dldmVyLCB3ZSBoYXZlIG11bHRpcGxlIG5vZGVzLCBlYWNoIGdldHNcbiAgICAgICAgICAgIC8vIGl0cyBvd24gcCB0YWcgdG8ga2VlcCB0aGVtIGFzIHNlcGFyYXRlIHBhcmFncmFwaHMuXG4gICAgICAgICAgICAvLyBIb3dldmVyLCBpZiBpdCdzIGEgYmxvY2txdW90ZSwgYWRkcyBhIHAgdGFnIGFueXdheVxuICAgICAgICAgICAgLy8gaW4gb3JkZXIgdG8gYXZvaWQgZGV2aWF0aW9uIHRvIGNvbW1vbm1hcmsgYW5kIHVuZXhwZWN0ZWRcbiAgICAgICAgICAgIC8vIHJlc3VsdHMgd2hlbiBwYXJzaW5nIHRoZSBmb3JtYXR0ZWQgSFRNTC5cbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudC50eXBlID09PSAnYmxvY2tfcXVvdGUnfHwgaXNNdWx0aUxpbmUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZWFsUGFyYWdyYXBoLmNhbGwodGhpcywgbm9kZSwgZW50ZXJpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJlbmRlcmVyLmxpbmsgPSBmdW5jdGlvbihub2RlLCBlbnRlcmluZykge1xuICAgICAgICAgICAgY29uc3QgYXR0cnMgPSB0aGlzLmF0dHJzKG5vZGUpO1xuICAgICAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICAgICAgYXR0cnMucHVzaChbJ2hyZWYnLCB0aGlzLmVzYyhub2RlLmRlc3RpbmF0aW9uKV0pO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnRpdGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJzLnB1c2goWyd0aXRsZScsIHRoaXMuZXNjKG5vZGUudGl0bGUpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE1vZGlmaWVkIGxpbmsgYmVoYXZpb3VyIHRvIHRyZWF0IHRoZW0gYWxsIGFzIGV4dGVybmFsIGFuZFxuICAgICAgICAgICAgICAgIC8vIHRodXMgb3BlbmluZyBpbiBhIG5ldyB0YWIuXG4gICAgICAgICAgICAgICAgaWYgKGV4dGVybmFsTGlua3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMucHVzaChbJ3RhcmdldCcsICdfYmxhbmsnXSk7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJzLnB1c2goWydyZWwnLCAnbm9yZWZlcnJlciBub29wZW5lciddKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50YWcoJ2EnLCBhdHRycyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudGFnKCcvYScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJlbmRlcmVyLmh0bWxfaW5saW5lID0gZnVuY3Rpb24obm9kZTogY29tbW9ubWFyay5Ob2RlKSB7XG4gICAgICAgICAgICBpZiAoaXNBbGxvd2VkSHRtbFRhZyhub2RlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGl0KG5vZGUubGl0ZXJhbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpdChlc2NhcGUobm9kZS5saXRlcmFsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVuZGVyZXIuaHRtbF9ibG9jayA9IGZ1bmN0aW9uKG5vZGU6IGNvbW1vbm1hcmsuTm9kZSkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIC8vIGFzIHdpdGggYHBhcmFncmFwaGAsIHdlIG9ubHkgaW5zZXJ0IGxpbmUgYnJlYWtzXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgbGluZXMgaW4gdGhlIG1hcmtkb3duLlxuICAgICAgICAgICAgY29uc3QgaXNNdWx0aUxpbmUgPSBpc19tdWx0aV9saW5lKG5vZGUpO1xuICAgICAgICAgICAgaWYgKGlzTXVsdGlMaW5lKSB0aGlzLmNyKCk7XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmVuZGVyZXIuaHRtbF9pbmxpbmUobm9kZSk7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgaWYgKGlzTXVsdGlMaW5lKSB0aGlzLmNyKCk7XG4gICAgICAgICAgICAqL1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiByZW5kZXJlci5yZW5kZXIodGhpcy5wYXJzZWQpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogUmVuZGVyIHRoZSBtYXJrZG93biBtZXNzYWdlIHRvIHBsYWluIHRleHQuIFRoYXQgaXMsIGVzc2VudGlhbGx5XG4gICAgICoganVzdCByZW1vdmUgYW55IGJhY2tzbGFzaGVzIGVzY2FwaW5nIHdoYXQgd291bGQgb3RoZXJ3aXNlIGJlXG4gICAgICogbWFya2Rvd24gc3ludGF4XG4gICAgICogKHRvIGZpeCBodHRwczovL2dpdGh1Yi5jb20vdmVjdG9yLWltL2VsZW1lbnQtd2ViL2lzc3Vlcy8yODcwKS5cbiAgICAgKlxuICAgICAqIE4uQi4gdGhpcyBkb2VzICoqTk9UKiogcmVuZGVyIGFyYml0cmFyeSBNRCB0byBwbGFpbiB0ZXh0IC0gb25seSBNRFxuICAgICAqIHdoaWNoIGhhcyBubyBmb3JtYXR0aW5nLiAgT3RoZXJ3aXNlIGl0IGVtaXRzIEhUTUwoISkuXG4gICAgICovXG4gICAgdG9QbGFpbnRleHQoKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBuZXcgY29tbW9ubWFyay5IdG1sUmVuZGVyZXIoeyBzYWZlOiBmYWxzZSB9KSBhcyBDb21tb25tYXJrSHRtbFJlbmRlcmVySW50ZXJuYWw7XG5cbiAgICAgICAgcmVuZGVyZXIucGFyYWdyYXBoID0gZnVuY3Rpb24obm9kZTogY29tbW9ubWFyay5Ob2RlLCBlbnRlcmluZzogYm9vbGVhbikge1xuICAgICAgICAgICAgLy8gYXMgd2l0aCB0b0hUTUwsIG9ubHkgYXBwZW5kIGxpbmVzIHRvIHBhcmFncmFwaHMgaWYgdGhlcmUgYXJlXG4gICAgICAgICAgICAvLyBtdWx0aXBsZSBwYXJhZ3JhcGhzXG4gICAgICAgICAgICBpZiAoaXNNdWx0aUxpbmUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVudGVyaW5nICYmIG5vZGUubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpdCgnXFxuXFxuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJlbmRlcmVyLmh0bWxfYmxvY2sgPSBmdW5jdGlvbihub2RlOiBjb21tb25tYXJrLk5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMubGl0KG5vZGUubGl0ZXJhbCk7XG4gICAgICAgICAgICBpZiAoaXNNdWx0aUxpbmUobm9kZSkgJiYgbm9kZS5uZXh0KSB0aGlzLmxpdCgnXFxuXFxuJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyLnJlbmRlcih0aGlzLnBhcnNlZCk7XG4gICAgfVxufVxuIl19