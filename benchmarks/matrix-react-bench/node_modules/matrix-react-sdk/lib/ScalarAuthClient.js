"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _url = _interopRequireDefault(require("url"));

var _SettingsStore = _interopRequireDefault(require("./settings/SettingsStore"));

var _Terms = require("./Terms");

var _MatrixClientPeg = require("./MatrixClientPeg");

var _browserRequest = _interopRequireDefault(require("browser-request"));

var _SdkConfig = _interopRequireDefault(require("./SdkConfig"));

var _serviceTypes = require("matrix-js-sdk/src/service-types");

var _logger = require("matrix-js-sdk/src/logger");

/*
Copyright 2016, 2019, 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// The version of the integration manager API we're intending to work with
const imApiVersion = "1.1"; // TODO: Generify the name of this class and all components within - it's not just for Scalar.

class ScalarAuthClient {
  constructor(apiUrl, uiUrl) {
    this.apiUrl = apiUrl;
    this.uiUrl = uiUrl;
    (0, _defineProperty2.default)(this, "scalarToken", void 0);
    (0, _defineProperty2.default)(this, "termsInteractionCallback", void 0);
    (0, _defineProperty2.default)(this, "isDefaultManager", void 0);
    this.scalarToken = null; // `undefined` to allow `startTermsFlow` to fallback to a default
    // callback if this is unset.

    this.termsInteractionCallback = undefined; // We try and store the token on a per-manager basis, but need a fallback
    // for the default manager.

    const configApiUrl = _SdkConfig.default.get()['integrations_rest_url'];

    const configUiUrl = _SdkConfig.default.get()['integrations_ui_url'];

    this.isDefaultManager = apiUrl === configApiUrl && configUiUrl === uiUrl;
  }

  writeTokenToStore() {
    window.localStorage.setItem("mx_scalar_token_at_" + this.apiUrl, this.scalarToken);

    if (this.isDefaultManager) {
      // We remove the old token from storage to migrate upwards. This is safe
      // to do because even if the user switches to /app when this is on /develop
      // they'll at worst register for a new token.
      window.localStorage.removeItem("mx_scalar_token"); // no-op when not present
    }
  }

  readTokenFromStore() {
    let token = window.localStorage.getItem("mx_scalar_token_at_" + this.apiUrl);

    if (!token && this.isDefaultManager) {
      token = window.localStorage.getItem("mx_scalar_token");
    }

    return token;
  }

  readToken() {
    if (this.scalarToken) return this.scalarToken;
    return this.readTokenFromStore();
  }

  setTermsInteractionCallback(callback) {
    this.termsInteractionCallback = callback;
  }

  connect() {
    return this.getScalarToken().then(tok => {
      this.scalarToken = tok;
    });
  }

  hasCredentials() {
    return this.scalarToken != null; // undef or null
  } // Returns a promise that resolves to a scalar_token string


  getScalarToken() {
    const token = this.readToken();

    if (!token) {
      return this.registerForToken();
    } else {
      return this.checkToken(token).catch(e => {
        if (e instanceof _Terms.TermsNotSignedError) {
          // retrying won't help this
          throw e;
        }

        return this.registerForToken();
      });
    }
  }

  getAccountName(token) {
    const url = this.apiUrl + "/account";
    return new Promise(function (resolve, reject) {
      (0, _browserRequest.default)({
        method: "GET",
        uri: url,
        qs: {
          scalar_token: token,
          v: imApiVersion
        },
        json: true
      }, (err, response, body) => {
        if (err) {
          reject(err);
        } else if (body && body.errcode === 'M_TERMS_NOT_SIGNED') {
          reject(new _Terms.TermsNotSignedError());
        } else if (response.statusCode / 100 !== 2) {
          reject(body);
        } else if (!body || !body.user_id) {
          reject(new Error("Missing user_id in response"));
        } else {
          resolve(body.user_id);
        }
      });
    });
  }

  checkToken(token) {
    return this.getAccountName(token).then(userId => {
      const me = _MatrixClientPeg.MatrixClientPeg.get().getUserId();

      if (userId !== me) {
        throw new Error("Scalar token is owned by someone else: " + me);
      }

      return token;
    }).catch(e => {
      if (e instanceof _Terms.TermsNotSignedError) {
        _logger.logger.log("Integration manager requires new terms to be agreed to"); // The terms endpoints are new and so live on standard _matrix prefixes,
        // but IM rest urls are currently configured with paths, so remove the
        // path from the base URL before passing it to the js-sdk
        // We continue to use the full URL for the calls done by
        // matrix-react-sdk, but the standard terms API called
        // by the js-sdk lives on the standard _matrix path. This means we
        // don't support running IMs on a non-root path, but it's the only
        // realistic way of transitioning to _matrix paths since configs in
        // the wild contain bits of the API path.
        // Once we've fully transitioned to _matrix URLs, we can give people
        // a grace period to update their configs, then use the rest url as
        // a regular base url.


        const parsedImRestUrl = _url.default.parse(this.apiUrl);

        parsedImRestUrl.path = '';
        parsedImRestUrl.pathname = '';
        return (0, _Terms.startTermsFlow)([new _Terms.Service(_serviceTypes.SERVICE_TYPES.IM, _url.default.format(parsedImRestUrl), token)], this.termsInteractionCallback).then(() => {
          return token;
        });
      } else {
        throw e;
      }
    });
  }

  registerForToken() {
    // Get openid bearer token from the HS as the first part of our dance
    return _MatrixClientPeg.MatrixClientPeg.get().getOpenIdToken().then(tokenObject => {
      // Now we can send that to scalar and exchange it for a scalar token
      return this.exchangeForScalarToken(tokenObject);
    }).then(token => {
      // Validate it (this mostly checks to see if the IM needs us to agree to some terms)
      return this.checkToken(token);
    }).then(token => {
      this.scalarToken = token;
      this.writeTokenToStore();
      return token;
    });
  }

  exchangeForScalarToken(openidTokenObject) {
    const scalarRestUrl = this.apiUrl;
    return new Promise(function (resolve, reject) {
      (0, _browserRequest.default)({
        method: 'POST',
        uri: scalarRestUrl + '/register',
        qs: {
          v: imApiVersion
        },
        body: openidTokenObject,
        json: true
      }, (err, response, body) => {
        if (err) {
          reject(err);
        } else if (response.statusCode / 100 !== 2) {
          reject(new Error(`Scalar request failed: ${response.statusCode}`));
        } else if (!body || !body.scalar_token) {
          reject(new Error("Missing scalar_token in response"));
        } else {
          resolve(body.scalar_token);
        }
      });
    });
  }

  getScalarPageTitle(url) {
    let scalarPageLookupUrl = this.apiUrl + '/widgets/title_lookup';
    scalarPageLookupUrl = this.getStarterLink(scalarPageLookupUrl);
    scalarPageLookupUrl += '&curl=' + encodeURIComponent(url);
    return new Promise(function (resolve, reject) {
      (0, _browserRequest.default)({
        method: 'GET',
        uri: scalarPageLookupUrl,
        json: true
      }, (err, response, body) => {
        if (err) {
          reject(err);
        } else if (response.statusCode / 100 !== 2) {
          reject(new Error(`Scalar request failed: ${response.statusCode}`));
        } else if (!body) {
          reject(new Error("Missing page title in response"));
        } else {
          let title = "";

          if (body.page_title_cache_item && body.page_title_cache_item.cached_title) {
            title = body.page_title_cache_item.cached_title;
          }

          resolve(title);
        }
      });
    });
  }
  /**
   * Mark all assets associated with the specified widget as "disabled" in the
   * integration manager database.
   * This can be useful to temporarily prevent purchased assets from being displayed.
   * @param  {WidgetType} widgetType The Widget Type to disable assets for
   * @param  {string} widgetId   The widget ID to disable assets for
   * @return {Promise}           Resolves on completion
   */


  disableWidgetAssets(widgetType, widgetId) {
    let url = this.apiUrl + '/widgets/set_assets_state';
    url = this.getStarterLink(url);
    return new Promise((resolve, reject) => {
      (0, _browserRequest.default)({
        method: 'GET',
        // XXX: Actions shouldn't be GET requests
        uri: url,
        json: true,
        qs: {
          'widget_type': widgetType.preferred,
          'widget_id': widgetId,
          'state': 'disable'
        }
      }, (err, response, body) => {
        if (err) {
          reject(err);
        } else if (response.statusCode / 100 !== 2) {
          reject(new Error(`Scalar request failed: ${response.statusCode}`));
        } else if (!body) {
          reject(new Error("Failed to set widget assets state"));
        } else {
          resolve();
        }
      });
    });
  }

  getScalarInterfaceUrlForRoom(room, screen, id) {
    const roomId = room.roomId;
    const roomName = room.name;
    let url = this.uiUrl;
    url += "?scalar_token=" + encodeURIComponent(this.scalarToken);
    url += "&room_id=" + encodeURIComponent(roomId);
    url += "&room_name=" + encodeURIComponent(roomName);
    url += "&theme=" + encodeURIComponent(_SettingsStore.default.getValue("theme"));

    if (id) {
      url += '&integ_id=' + encodeURIComponent(id);
    }

    if (screen) {
      url += '&screen=' + encodeURIComponent(screen);
    }

    return url;
  }

  getStarterLink(starterLinkUrl) {
    return starterLinkUrl + "?scalar_token=" + encodeURIComponent(this.scalarToken);
  }

}

exports.default = ScalarAuthClient;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9TY2FsYXJBdXRoQ2xpZW50LnRzIl0sIm5hbWVzIjpbImltQXBpVmVyc2lvbiIsIlNjYWxhckF1dGhDbGllbnQiLCJjb25zdHJ1Y3RvciIsImFwaVVybCIsInVpVXJsIiwic2NhbGFyVG9rZW4iLCJ0ZXJtc0ludGVyYWN0aW9uQ2FsbGJhY2siLCJ1bmRlZmluZWQiLCJjb25maWdBcGlVcmwiLCJTZGtDb25maWciLCJnZXQiLCJjb25maWdVaVVybCIsImlzRGVmYXVsdE1hbmFnZXIiLCJ3cml0ZVRva2VuVG9TdG9yZSIsIndpbmRvdyIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwicmVhZFRva2VuRnJvbVN0b3JlIiwidG9rZW4iLCJnZXRJdGVtIiwicmVhZFRva2VuIiwic2V0VGVybXNJbnRlcmFjdGlvbkNhbGxiYWNrIiwiY2FsbGJhY2siLCJjb25uZWN0IiwiZ2V0U2NhbGFyVG9rZW4iLCJ0aGVuIiwidG9rIiwiaGFzQ3JlZGVudGlhbHMiLCJyZWdpc3RlckZvclRva2VuIiwiY2hlY2tUb2tlbiIsImNhdGNoIiwiZSIsIlRlcm1zTm90U2lnbmVkRXJyb3IiLCJnZXRBY2NvdW50TmFtZSIsInVybCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwibWV0aG9kIiwidXJpIiwicXMiLCJzY2FsYXJfdG9rZW4iLCJ2IiwianNvbiIsImVyciIsInJlc3BvbnNlIiwiYm9keSIsImVycmNvZGUiLCJzdGF0dXNDb2RlIiwidXNlcl9pZCIsIkVycm9yIiwidXNlcklkIiwibWUiLCJNYXRyaXhDbGllbnRQZWciLCJnZXRVc2VySWQiLCJsb2dnZXIiLCJsb2ciLCJwYXJzZWRJbVJlc3RVcmwiLCJwYXJzZSIsInBhdGgiLCJwYXRobmFtZSIsIlNlcnZpY2UiLCJTRVJWSUNFX1RZUEVTIiwiSU0iLCJmb3JtYXQiLCJnZXRPcGVuSWRUb2tlbiIsInRva2VuT2JqZWN0IiwiZXhjaGFuZ2VGb3JTY2FsYXJUb2tlbiIsIm9wZW5pZFRva2VuT2JqZWN0Iiwic2NhbGFyUmVzdFVybCIsImdldFNjYWxhclBhZ2VUaXRsZSIsInNjYWxhclBhZ2VMb29rdXBVcmwiLCJnZXRTdGFydGVyTGluayIsImVuY29kZVVSSUNvbXBvbmVudCIsInRpdGxlIiwicGFnZV90aXRsZV9jYWNoZV9pdGVtIiwiY2FjaGVkX3RpdGxlIiwiZGlzYWJsZVdpZGdldEFzc2V0cyIsIndpZGdldFR5cGUiLCJ3aWRnZXRJZCIsInByZWZlcnJlZCIsImdldFNjYWxhckludGVyZmFjZVVybEZvclJvb20iLCJyb29tIiwic2NyZWVuIiwiaWQiLCJyb29tSWQiLCJyb29tTmFtZSIsIm5hbWUiLCJTZXR0aW5nc1N0b3JlIiwiZ2V0VmFsdWUiLCJzdGFydGVyTGlua1VybCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFnQkE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBRUE7O0FBR0E7O0FBM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWVBO0FBQ0EsTUFBTUEsWUFBWSxHQUFHLEtBQXJCLEMsQ0FFQTs7QUFFZSxNQUFNQyxnQkFBTixDQUF1QjtBQUtsQ0MsRUFBQUEsV0FBVyxDQUFTQyxNQUFULEVBQWlDQyxLQUFqQyxFQUFnRDtBQUFBLFNBQXZDRCxNQUF1QyxHQUF2Q0EsTUFBdUM7QUFBQSxTQUFmQyxLQUFlLEdBQWZBLEtBQWU7QUFBQTtBQUFBO0FBQUE7QUFDdkQsU0FBS0MsV0FBTCxHQUFtQixJQUFuQixDQUR1RCxDQUV2RDtBQUNBOztBQUNBLFNBQUtDLHdCQUFMLEdBQWdDQyxTQUFoQyxDQUp1RCxDQU12RDtBQUNBOztBQUNBLFVBQU1DLFlBQVksR0FBR0MsbUJBQVVDLEdBQVYsR0FBZ0IsdUJBQWhCLENBQXJCOztBQUNBLFVBQU1DLFdBQVcsR0FBR0YsbUJBQVVDLEdBQVYsR0FBZ0IscUJBQWhCLENBQXBCOztBQUNBLFNBQUtFLGdCQUFMLEdBQXdCVCxNQUFN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SixFQUFRO0FBQ0psRCxNQUFBQSxHQUFHLElBQUksZUFBZXVDLGtCQUFrQixDQUFDVyxFQUFELENBQXhDO0FBQ0g7O0FBQ0QsUUFBSUQsTUFBSixFQUFZO0FBQ1JqRCxNQUFBQSxHQUFHLElBQUksYUFBYXVDLGtCQUFrQixDQUFDVSxNQUFELENBQXRDO0FBQ0g7O0FBQ0QsV0FBT2pELEdBQVA7QUFDSDs7QUFFRHNDLEVBQUFBLGNBQWMsQ0FBQ2tCLGNBQUQsRUFBaUM7QUFDM0MsV0FBT0EsY0FBYyxHQUFHLGdCQUFqQixHQUFvQ2pCLGtCQUFrQixDQUFDLEtBQUtyRSxXQUFOLENBQTdEO0FBQ0g7O0FBbFFpQyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxNiwgMjAxOSwgMjAyMSBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB1cmwgZnJvbSAndXJsJztcbmltcG9ydCBTZXR0aW5nc1N0b3JlIGZyb20gXCIuL3NldHRpbmdzL1NldHRpbmdzU3RvcmVcIjtcbmltcG9ydCB7IFNlcnZpY2UsIHN0YXJ0VGVybXNGbG93LCBUZXJtc0ludGVyYWN0aW9uQ2FsbGJhY2ssIFRlcm1zTm90U2lnbmVkRXJyb3IgfSBmcm9tICcuL1Rlcm1zJztcbmltcG9ydCB7IE1hdHJpeENsaWVudFBlZyB9IGZyb20gXCIuL01hdHJpeENsaWVudFBlZ1wiO1xuaW1wb3J0IHJlcXVlc3QgZnJvbSBcImJyb3dzZXItcmVxdWVzdFwiO1xuXG5pbXBvcnQgU2RrQ29uZmlnIGZyb20gXCIuL1Nka0NvbmZpZ1wiO1xuaW1wb3J0IHsgV2lkZ2V0VHlwZSB9IGZyb20gXCIuL3dpZGdldHMvV2lkZ2V0VHlwZVwiO1xuaW1wb3J0IHsgU0VSVklDRV9UWVBFUyB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9zZXJ2aWNlLXR5cGVzXCI7XG5pbXBvcnQgeyBSb29tIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL21vZGVscy9yb29tXCI7XG5cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9sb2dnZXJcIjtcblxuLy8gVGhlIHZlcnNpb24gb2YgdGhlIGludGVncmF0aW9uIG1hbmFnZXIgQVBJIHdlJ3JlIGludGVuZGluZyB0byB3b3JrIHdpdGhcbmNvbnN0IGltQXBpVmVyc2lvbiA9IFwiMS4xXCI7XG5cbi8vIFRPRE86IEdlbmVyaWZ5IHRoZSBuYW1lIG9mIHRoaXMgY2xhc3MgYW5kIGFsbCBjb21wb25lbnRzIHdpdGhpbiAtIGl0J3Mgbm90IGp1c3QgZm9yIFNjYWxhci5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NhbGFyQXV0aENsaWVudCB7XG4gICAgcHJpdmF0ZSBzY2FsYXJUb2tlbjogc3RyaW5nO1xuICAgIHByaXZhdGUgdGVybXNJbnRlcmFjdGlvbkNhbGxiYWNrOiBUZXJtc0ludGVyYWN0aW9uQ2FsbGJhY2s7XG4gICAgcHJpdmF0ZSBpc0RlZmF1bHRNYW5hZ2VyOiBib29sZWFuO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBhcGlVcmw6IHN0cmluZywgcHJpdmF0ZSB1aVVybDogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2NhbGFyVG9rZW4gPSBudWxsO1xuICAgICAgICAvLyBgdW5kZWZpbmVkYCB0byBhbGxvdyBgc3RhcnRUZXJtc0Zsb3dgIHRvIGZhbGxiYWNrIHRvIGEgZGVmYXVsdFxuICAgICAgICAvLyBjYWxsYmFjayBpZiB0aGlzIGlzIHVuc2V0LlxuICAgICAgICB0aGlzLnRlcm1zSW50ZXJhY3Rpb25DYWxsYmFjayA9IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBXZSB0cnkgYW5kIHN0b3JlIHRoZSB0b2tlbiBvbiBhIHBlci1tYW5hZ2VyIGJhc2lzLCBidXQgbmVlZCBhIGZhbGxiYWNrXG4gICAgICAgIC8vIGZvciB0aGUgZGVmYXVsdCBtYW5hZ2VyLlxuICAgICAgICBjb25zdCBjb25maWdBcGlVcmwgPSBTZGtDb25maWcuZ2V0KClbJ2ludGVncmF0aW9uc19yZXN0X3VybCddO1xuICAgICAgICBjb25zdCBjb25maWdVaVVybCA9IFNka0NvbmZpZy5nZXQoKVsnaW50ZWdyYXRpb25zX3VpX3VybCddO1xuICAgICAgICB0aGlzLmlzRGVmYXVsdE1hbmFnZXIgPSBhcGlVcmwgPT09IGNvbmZpZ0FwaVVybCAmJiBjb25maWdVaVVybCA9PT0gdWlVcmw7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB3cml0ZVRva2VuVG9TdG9yZSgpIHtcbiAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKFwibXhfc2NhbGFyX3Rva2VuX2F0X1wiICsgdGhpcy5hcGlVcmwsIHRoaXMuc2NhbGFyVG9rZW4pO1xuICAgICAgICBpZiAodGhpcy5pc0RlZmF1bHRNYW5hZ2VyKSB7XG4gICAgICAgICAgICAvLyBXZSByZW1vdmUgdGhlIG9sZCB0b2tlbiBmcm9tIHN0b3JhZ2UgdG8gbWlncmF0ZSB1cHdhcmRzLiBUaGlzIGlzIHNhZmVcbiAgICAgICAgICAgIC8vIHRvIGRvIGJlY2F1c2UgZXZlbiBpZiB0aGUgdXNlciBzd2l0Y2hlcyB0byAvYXBwIHdoZW4gdGhpcyBpcyBvbiAvZGV2ZWxvcFxuICAgICAgICAgICAgLy8gdGhleSdsbCBhdCB3b3JzdCByZWdpc3RlciBmb3IgYSBuZXcgdG9rZW4uXG4gICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oXCJteF9zY2FsYXJfdG9rZW5cIik7IC8vIG5vLW9wIHdoZW4gbm90IHByZXNlbnRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcmVhZFRva2VuRnJvbVN0b3JlKCk6IHN0cmluZyB7XG4gICAgICAgIGxldCB0b2tlbiA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShcIm14X3NjYWxhcl90b2tlbl9hdF9cIiArIHRoaXMuYXBpVXJsKTtcbiAgICAgICAgaWYgKCF0b2tlbiAmJiB0aGlzLmlzRGVmYXVsdE1hbmFnZXIpIHtcbiAgICAgICAgICAgIHRva2VuID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKFwibXhfc2NhbGFyX3Rva2VuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG5cbiAgICBwcml2YXRlIHJlYWRUb2tlbigpOiBzdHJpbmcge1xuICAgICAgICBpZiAodGhpcy5zY2FsYXJUb2tlbikgcmV0dXJuIHRoaXMuc2NhbGFyVG9rZW47XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbkZyb21TdG9yZSgpO1xuICAgIH1cblxuICAgIHNldFRlcm1zSW50ZXJhY3Rpb25DYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnRlcm1zSW50ZXJhY3Rpb25DYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGNvbm5lY3QoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjYWxhclRva2VuKCkudGhlbigodG9rKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNjYWxhclRva2VuID0gdG9rO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBoYXNDcmVkZW50aWFscygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGFyVG9rZW4gIT0gbnVsbDsgLy8gdW5kZWYgb3IgbnVsbFxuICAgIH1cblxuICAgIC8vIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBzY2FsYXJfdG9rZW4gc3RyaW5nXG4gICAgZ2V0U2NhbGFyVG9rZW4oKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLnJlYWRUb2tlbigpO1xuXG4gICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyRm9yVG9rZW4oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoZWNrVG9rZW4odG9rZW4pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBUZXJtc05vdFNpZ25lZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHJ5aW5nIHdvbid0IGhlbHAgdGhpc1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlckZvclRva2VuKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0QWNjb3VudE5hbWUodG9rZW46IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuYXBpVXJsICsgXCIvYWNjb3VudFwiO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgICAgICB1cmk6IHVybCxcbiAgICAgICAgICAgICAgICBxczogeyBzY2FsYXJfdG9rZW46IHRva2VuLCB2OiBpbUFwaVZlcnNpb24gfSxcbiAgICAgICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgfSwgKGVyciwgcmVzcG9uc2UsIGJvZHkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYm9keSAmJiBib2R5LmVycmNvZGUgPT09ICdNX1RFUk1TX05PVF9TSUdORUQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgVGVybXNOb3RTaWduZWRFcnJvcigpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgLyAxMDAgIT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGJvZHkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWJvZHkgfHwgIWJvZHkudXNlcl9pZCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiTWlzc2luZyB1c2VyX2lkIGluIHJlc3BvbnNlXCIpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGJvZHkudXNlcl9pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgY2hlY2tUb2tlbih0b2tlbjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWNjb3VudE5hbWUodG9rZW4pLnRoZW4odXNlcklkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1lID0gTWF0cml4Q2xpZW50UGVnLmdldCgpLmdldFVzZXJJZCgpO1xuICAgICAgICAgICAgaWYgKHVzZXJJZCAhPT0gbWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTY2FsYXIgdG9rZW4gaXMgb3duZWQgYnkgc29tZW9uZSBlbHNlOiBcIiArIG1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgVGVybXNOb3RTaWduZWRFcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coXCJJbnRlZ3JhdGlvbiBtYW5hZ2VyIHJlcXVpcmVzIG5ldyB0ZXJtcyB0byBiZSBhZ3JlZWQgdG9cIik7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHRlcm1zIGVuZHBvaW50cyBhcmUgbmV3IGFuZCBzbyBsaXZlIG9uIHN0YW5kYXJkIF9tYXRyaXggcHJlZml4ZXMsXG4gICAgICAgICAgICAgICAgLy8gYnV0IElNIHJlc3QgdXJscyBhcmUgY3VycmVudGx5IGNvbmZpZ3VyZWQgd2l0aCBwYXRocywgc28gcmVtb3ZlIHRoZVxuICAgICAgICAgICAgICAgIC8vIHBhdGggZnJvbSB0aGUgYmFzZSBVUkwgYmVmb3JlIHBhc3NpbmcgaXQgdG8gdGhlIGpzLXNka1xuXG4gICAgICAgICAgICAgICAgLy8gV2UgY29udGludWUgdG8gdXNlIHRoZSBmdWxsIFVSTCBmb3IgdGhlIGNhbGxzIGRvbmUgYnlcbiAgICAgICAgICAgICAgICAvLyBtYXRyaXgtcmVhY3Qtc2RrLCBidXQgdGhlIHN0YW5kYXJkIHRlcm1zIEFQSSBjYWxsZWRcbiAgICAgICAgICAgICAgICAvLyBieSB0aGUganMtc2RrIGxpdmVzIG9uIHRoZSBzdGFuZGFyZCBfbWF0cml4IHBhdGguIFRoaXMgbWVhbnMgd2VcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBzdXBwb3J0IHJ1bm5pbmcgSU1zIG9uIGEgbm9uLXJvb3QgcGF0aCwgYnV0IGl0J3MgdGhlIG9ubHlcbiAgICAgICAgICAgICAgICAvLyByZWFsaXN0aWMgd2F5IG9mIHRyYW5zaXRpb25pbmcgdG8gX21hdHJpeCBwYXRocyBzaW5jZSBjb25maWdzIGluXG4gICAgICAgICAgICAgICAgLy8gdGhlIHdpbGQgY29udGFpbiBiaXRzIG9mIHRoZSBBUEkgcGF0aC5cblxuICAgICAgICAgICAgICAgIC8vIE9uY2Ugd2UndmUgZnVsbHkgdHJhbnNpdGlvbmVkIHRvIF9tYXRyaXggVVJMcywgd2UgY2FuIGdpdmUgcGVvcGxlXG4gICAgICAgICAgICAgICAgLy8gYSBncmFjZSBwZXJpb2QgdG8gdXBkYXRlIHRoZWlyIGNvbmZpZ3MsIHRoZW4gdXNlIHRoZSByZXN0IHVybCBhc1xuICAgICAgICAgICAgICAgIC8vIGEgcmVndWxhciBiYXNlIHVybC5cbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRJbVJlc3RVcmwgPSB1cmwucGFyc2UodGhpcy5hcGlVcmwpO1xuICAgICAgICAgICAgICAgIHBhcnNlZEltUmVzdFVybC5wYXRoID0gJyc7XG4gICAgICAgICAgICAgICAgcGFyc2VkSW1SZXN0VXJsLnBhdGhuYW1lID0gJyc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0VGVybXNGbG93KFtuZXcgU2VydmljZShcbiAgICAgICAgICAgICAgICAgICAgU0VSVklDRV9UWVBFUy5JTSxcbiAgICAgICAgICAgICAgICAgICAgdXJsLmZvcm1hdChwYXJzZWRJbVJlc3RVcmwpLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgICAgICApXSwgdGhpcy50ZXJtc0ludGVyYWN0aW9uQ2FsbGJhY2spLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyRm9yVG9rZW4oKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgLy8gR2V0IG9wZW5pZCBiZWFyZXIgdG9rZW4gZnJvbSB0aGUgSFMgYXMgdGhlIGZpcnN0IHBhcnQgb2Ygb3VyIGRhbmNlXG4gICAgICAgIHJldHVybiBNYXRyaXhDbGllbnRQZWcuZ2V0KCkuZ2V0T3BlbklkVG9rZW4oKS50aGVuKCh0b2tlbk9iamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gTm93IHdlIGNhbiBzZW5kIHRoYXQgdG8gc2NhbGFyIGFuZCBleGNoYW5nZSBpdCBmb3IgYSBzY2FsYXIgdG9rZW5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4Y2hhbmdlRm9yU2NhbGFyVG9rZW4odG9rZW5PYmplY3QpO1xuICAgICAgICB9KS50aGVuKCh0b2tlbikgPT4ge1xuICAgICAgICAgICAgLy8gVmFsaWRhdGUgaXQgKHRoaXMgbW9zdGx5IGNoZWNrcyB0byBzZWUgaWYgdGhlIElNIG5lZWRzIHVzIHRvIGFncmVlIHRvIHNvbWUgdGVybXMpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGVja1Rva2VuKHRva2VuKTtcbiAgICAgICAgfSkudGhlbigodG9rZW4pID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGFyVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgIHRoaXMud3JpdGVUb2tlblRvU3RvcmUoKTtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZXhjaGFuZ2VGb3JTY2FsYXJUb2tlbihvcGVuaWRUb2tlbk9iamVjdDogYW55KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3Qgc2NhbGFyUmVzdFVybCA9IHRoaXMuYXBpVXJsO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIHVyaTogc2NhbGFyUmVzdFVybCArICcvcmVnaXN0ZXInLFxuICAgICAgICAgICAgICAgIHFzOiB7IHY6IGltQXBpVmVyc2lvbiB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IG9wZW5pZFRva2VuT2JqZWN0LFxuICAgICAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICB9LCAoZXJyLCByZXNwb25zZSwgYm9keSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlIC8gMTAwICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFNjYWxhciByZXF1ZXN0IGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXNDb2RlfWApKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFib2R5IHx8ICFib2R5LnNjYWxhcl90b2tlbikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiTWlzc2luZyBzY2FsYXJfdG9rZW4gaW4gcmVzcG9uc2VcIikpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYm9keS5zY2FsYXJfdG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXRTY2FsYXJQYWdlVGl0bGUodXJsOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBsZXQgc2NhbGFyUGFnZUxvb2t1cFVybCA9IHRoaXMuYXBpVXJsICsgJy93aWRnZXRzL3RpdGxlX2xvb2t1cCc7XG4gICAgICAgIHNjYWxhclBhZ2VMb29rdXBVcmwgPSB0aGlzLmdldFN0YXJ0ZXJMaW5rKHNjYWxhclBhZ2VMb29rdXBVcmwpO1xuICAgICAgICBzY2FsYXJQYWdlTG9va3VwVXJsICs9ICcmY3VybD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHVybCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgcmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICB1cmk6IHNjYWxhclBhZ2VMb29rdXBVcmwsXG4gICAgICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIH0sIChlcnIsIHJlc3BvbnNlLCBib2R5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgLyAxMDAgIT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgU2NhbGFyIHJlcXVlc3QgZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c0NvZGV9YCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIk1pc3NpbmcgcGFnZSB0aXRsZSBpbiByZXNwb25zZVwiKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRpdGxlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHkucGFnZV90aXRsZV9jYWNoZV9pdGVtICYmIGJvZHkucGFnZV90aXRsZV9jYWNoZV9pdGVtLmNhY2hlZF90aXRsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSBib2R5LnBhZ2VfdGl0bGVfY2FjaGVfaXRlbS5jYWNoZWRfdGl0bGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aXRsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcmsgYWxsIGFzc2V0cyBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCB3aWRnZXQgYXMgXCJkaXNhYmxlZFwiIGluIHRoZVxuICAgICAqIGludGVncmF0aW9uIG1hbmFnZXIgZGF0YWJhc2UuXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZnVsIHRvIHRlbXBvcmFyaWx5IHByZXZlbnQgcHVyY2hhc2VkIGFzc2V0cyBmcm9tIGJlaW5nIGRpc3BsYXllZC5cbiAgICAgKiBAcGFyYW0gIHtXaWRnZXRUeXBlfSB3aWRnZXRUeXBlIFRoZSBXaWRnZXQgVHlwZSB0byBkaXNhYmxlIGFzc2V0cyBmb3JcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHdpZGdldElkICAgVGhlIHdpZGdldCBJRCB0byBkaXNhYmxlIGFzc2V0cyBmb3JcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgUmVzb2x2ZXMgb24gY29tcGxldGlvblxuICAgICAqL1xuICAgIGRpc2FibGVXaWRnZXRBc3NldHMod2lkZ2V0VHlwZTogV2lkZ2V0VHlwZSwgd2lkZ2V0SWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy5hcGlVcmwgKyAnL3dpZGdldHMvc2V0X2Fzc2V0c19zdGF0ZSc7XG4gICAgICAgIHVybCA9IHRoaXMuZ2V0U3RhcnRlckxpbmsodXJsKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsIC8vIFhYWDogQWN0aW9ucyBzaG91bGRuJ3QgYmUgR0VUIHJlcXVlc3RzXG4gICAgICAgICAgICAgICAgdXJpOiB1cmwsXG4gICAgICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBxczoge1xuICAgICAgICAgICAgICAgICAgICAnd2lkZ2V0X3R5cGUnOiB3aWRnZXRUeXBlLnByZWZlcnJlZCxcbiAgICAgICAgICAgICAgICAgICAgJ3dpZGdldF9pZCc6IHdpZGdldElkLFxuICAgICAgICAgICAgICAgICAgICAnc3RhdGUnOiAnZGlzYWJsZScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sIChlcnIsIHJlc3BvbnNlLCBib2R5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgLyAxMDAgIT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgU2NhbGFyIHJlcXVlc3QgZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c0NvZGV9YCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkZhaWxlZCB0byBzZXQgd2lkZ2V0IGFzc2V0cyBzdGF0ZVwiKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXRTY2FsYXJJbnRlcmZhY2VVcmxGb3JSb29tKHJvb206IFJvb20sIHNjcmVlbjogc3RyaW5nLCBpZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3Qgcm9vbUlkID0gcm9vbS5yb29tSWQ7XG4gICAgICAgIGNvbnN0IHJvb21OYW1lID0gcm9vbS5uYW1lO1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51aVVybDtcbiAgICAgICAgdXJsICs9IFwiP3NjYWxhcl90b2tlbj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLnNjYWxhclRva2VuKTtcbiAgICAgICAgdXJsICs9IFwiJnJvb21faWQ9XCIgKyBlbmNvZGVVUklDb21wb25lbnQocm9vbUlkKTtcbiAgICAgICAgdXJsICs9IFwiJnJvb21fbmFtZT1cIiArIGVuY29kZVVSSUNvbXBvbmVudChyb29tTmFtZSk7XG4gICAgICAgIHVybCArPSBcIiZ0aGVtZT1cIiArIGVuY29kZVVSSUNvbXBvbmVudChTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFwidGhlbWVcIikpO1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIHVybCArPSAnJmludGVnX2lkPScgKyBlbmNvZGVVUklDb21wb25lbnQoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY3JlZW4pIHtcbiAgICAgICAgICAgIHVybCArPSAnJnNjcmVlbj0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHNjcmVlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG5cbiAgICBnZXRTdGFydGVyTGluayhzdGFydGVyTGlua1VybDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ZXJMaW5rVXJsICsgXCI/c2NhbGFyX3Rva2VuPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuc2NhbGFyVG9rZW4pO1xuICAgIH1cbn1cbiJdfQ==