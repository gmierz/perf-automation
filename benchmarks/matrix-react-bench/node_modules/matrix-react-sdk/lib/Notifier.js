"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Notifier = void 0;

var _MatrixClientPeg = require("./MatrixClientPeg");

var _SdkConfig = _interopRequireDefault(require("./SdkConfig"));

var _PlatformPeg = _interopRequireDefault(require("./PlatformPeg"));

var TextForEvent = _interopRequireWildcard(require("./TextForEvent"));

var _Analytics = _interopRequireDefault(require("./Analytics"));

var Avatar = _interopRequireWildcard(require("./Avatar"));

var _dispatcher = _interopRequireDefault(require("./dispatcher/dispatcher"));

var _languageHandler = require("./languageHandler");

var _Modal = _interopRequireDefault(require("./Modal"));

var _SettingsStore = _interopRequireDefault(require("./settings/SettingsStore"));

var _DesktopNotificationsToast = require("./toasts/DesktopNotificationsToast");

var _SettingLevel = require("./settings/SettingLevel");

var _NotificationControllers = require("./settings/controllers/NotificationControllers");

var _RoomViewStore = _interopRequireDefault(require("./stores/RoomViewStore"));

var _UserActivity = _interopRequireDefault(require("./UserActivity"));

var _Media = require("./customisations/Media");

var _ErrorDialog = _interopRequireDefault(require("./components/views/dialogs/ErrorDialog"));

var _logger = require("matrix-js-sdk/src/logger");

var _event = require("matrix-js-sdk/src/@types/event");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
Copyright 2015, 2016 OpenMarket Ltd
Copyright 2017 Vector Creations Ltd
Copyright 2017 New Vector Ltd
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/*
 * Dispatches:
 * {
 *   action: "notifier_enabled",
 *   value: boolean
 * }
 */
const MAX_PENDING_ENCRYPTED = 20;
/*
Override both the content body and the TextForEvent handler for specific msgtypes, in notifications.
This is useful when the content body contains fallback text that would explain that the client can't handle a particular
type of tile.
*/

const msgTypeHandlers = {
  [_event.MsgType.KeyVerificationRequest]: event => {
    const name = (event.sender || {}).name;
    return (0, _languageHandler._t)("%(name)s is requesting verification", {
      name
    });
  }
};
const Notifier = {
  notifsByRoom: {},
  // A list of event IDs that we've received but need to wait until
  // they're decrypted until we decide whether to notify for them
  // or not
  pendingEncryptedEventIds: [],
  notificationMessageForEvent: function (ev) {
    if (msgTypeHandlers.hasOwnProperty(ev.getContent().msgtype)) {
      return msgTypeHandlers[ev.getContent().msgtype](ev);
    }

    return TextForEvent.textForEvent(ev);
  },
  _displayPopupNotification: function (ev, room) {
    const plaf = _PlatformPeg.default.get();

    if (!plaf) {
      return;
    }

    if (!plaf.supportsNotifications() || !plaf.maySendNotifications()) {
      return;
    }

    if (global.document.hasFocus()) {
      return;
    }

    let msg = this.notificationMessageForEvent(ev);
    if (!msg) return;
    let title;

    if (!ev.sender || room.name === ev.sender.name) {
      title = room.name; // notificationMessageForEvent includes sender,
      // but we already have the sender here

      if (ev.getContent().body && !msgTypeHandlers.hasOwnProperty(ev.getContent().msgtype)) {
        msg = ev.getContent().body;
      }
    } else if (ev.getType() === 'm.room.member') {
      // context is all in the message here, we don't need
      // to display sender info
      title = room.name;
    } else if (ev.sender) {
      title = ev.sender.name + " (" + room.name + ")"; // notificationMessageForEvent includes sender,
      // but we've just out sender in the title

      if (ev.getContent().body && !msgTypeHandlers.hasOwnProperty(ev.getContent().msgtype)) {
        msg = ev.getContent().body;
      }
    }

    if (!this.isBodyEnabled()) {
      msg = '';
    }

    let avatarUrl = null;

    if (ev.sender && !_SettingsStore.default.getValue("lowBandwidth")) {
      avatarUrl = Avatar.avatarUrlForMember(ev.sender, 40, 40, 'crop');
    }

    const notif = plaf.displayNotification(title, msg, avatarUrl, room); // if displayNotification returns non-null,  the platform supports
    // clearing notifications later, so keep track of this.

    if (notif) {
      if (this.notifsByRoom[ev.getRoomId()] === undefined) this.notifsByRoom[ev.getRoomId()] = [];
      this.notifsByRoom[ev.getRoomId()].push(notif);
    }
  },
  getSoundForRoom: function (roomId) {
    // We do no caching here because the SDK caches setting
    // and the browser will cache the sound.
    const content = _SettingsStore.default.getValue("notificationSound", roomId);

    if (!content) {
      return null;
    }

    if (!content.url) {
      _logger.logger.warn(`${roomId} has custom notification sound event, but no url key`);

      return null;
    }

    if (!content.url.startsWith("mxc://")) {
      _logger.logger.warn(`${roomId} has custom notification sound event, but url is not a mxc url`);

      return null;
    } // Ideally in here we could use MSC1310 to detect the type of file, and reject it.


    return {
      url: (0, _Media.mediaFromMxc)(content.url).srcHttp,
      name: content.name,
      type: content.type,
      size: content.size
    };
  },
  _playAudioNotification: async function (ev, room) {
    const sound = this.getSoundForRoom(room.roomId);

    _logger.logger.log(`Got sound ${sound && sound.name || "default"} for ${room.roomId}`);

    try {
      const selector = document.querySelector(sound ? `audio[src='${sound.url}']` : "#messageAudio");
      let audioElement = selector;

      if (!selector) {
        if (!sound) {
          _logger.logger.error("No audio element or sound to play for notification");

          return;
        }

        audioElement = new Audio(sound.url);

        if (sound.type) {
          audioElement.type = sound.type;
        }

        document.body.appendChild(audioElement);
      }

      await audioElement.play();
    } catch (ex) {
      _logger.logger.warn("Caught error when trying to fetch room notification sound:", ex);
    }
  },
  start: function () {
    // do not re-bind in the case of repeated call
    this.boundOnEvent = this.boundOnEvent || this.onEvent.bind(this);
    this.boundOnSyncStateChange = this.boundOnSyncStateChange || this.onSyncStateChange.bind(this);
    this.boundOnRoomReceipt = this.boundOnRoomReceipt || this.onRoomReceipt.bind(this);
    this.boundOnEventDecrypted = this.boundOnEventDecrypted || this.onEventDecrypted.bind(this);

    _MatrixClientPeg.MatrixClientPeg.get().on('event', this.boundOnEvent);

    _MatrixClientPeg.MatrixClientPeg.get().on('Room.receipt', this.boundOnRoomReceipt);

    _MatrixClientPeg.MatrixClientPeg.get().on('Event.decrypted', this.boundOnEventDecrypted);

    _MatrixClientPeg.MatrixClientPeg.get().on("sync", this.boundOnSyncStateChange);

    this.toolbarHidden = false;
    this.isSyncing = false;
  },
  stop: function () {
    if (_MatrixClientPeg.MatrixClientPeg.get()) {
      _MatrixClientPeg.MatrixClientPeg.get().removeListener('Event', this.boundOnEvent);

      _MatrixClientPeg.MatrixClientPeg.get().removeListener('Room.receipt', this.boundOnRoomReceipt);

      _MatrixClientPeg.MatrixClientPeg.get().removeListener('Event.decrypted', this.boundOnEventDecrypted);

      _MatrixClientPeg.MatrixClientPeg.get().removeListener('sync', this.boundOnSyncStateChange);
    }

    this.isSyncing = false;
  },
  supportsDesktopNotifications: function () {
    const plaf = _PlatformPeg.default.get();

    return plaf && plaf.supportsNotifications();
  },
  setEnabled: function (enable, callback) {
    const plaf = _PlatformPeg.default.get();

    if (!plaf) return; // Dev note: We don't set the "notificationsEnabled" setting to true here because it is a
    // calculated value. It is determined based upon whether or not the master rule is enabled
    // and other flags. Setting it here would cause a circular reference.

    _Analytics.default.trackEvent('Notifier', 'Set Enabled', String(enable)); // make sure that we persist the current setting audio_enabled setting
    // before changing anything


    if (_SettingsStore.default.isLevelSupported(_SettingLevel.SettingLevel.DEVICE)) {
      _SettingsStore.default.setValue("audioNotificationsEnabled", null, _SettingLevel.SettingLevel.DEVICE, this.isEnabled());
    }

    if (enable) {
      // Attempt to get permission from user
      plaf.requestNotificationPermission().then(result => {
        if (result !== 'granted') {
          // The permission request was dismissed or denied
          // TODO: Support alternative branding in messaging
          const brand = _SdkConfig.default.get().brand;

          const description = result === 'denied' ? (0, _languageHandler._t)('%(brand)s does not have permission to send you notifications - ' + 'please check your browser settings', {
            brand
          }) : (0, _languageHandler._t)('%(brand)s was not given permission to send notifications - please try again', {
            brand
          });

          _Modal.default.createTrackedDialog('Unable to enable Notifications', result, _ErrorDialog.default, {
            title: (0, _languageHandler._t)('Unable to enable Notifications'),
            description
          });

          return;
        }

        if (callback) callback();

        _dispatcher.default.dispatch({
          action: "notifier_enabled",
          value: true
        });
      });
    } else {
      _dispatcher.default.dispatch({
        action: "notifier_enabled",
        value: false
      });
    } // set the notifications_hidden flag, as the user has knowingly interacted
    // with the setting we shouldn't nag them any further


    this.setPromptHidden(true);
  },
  isEnabled: function () {
    return this.isPossible() && _SettingsStore.default.getValue("notificationsEnabled");
  },
  isPossible: function () {
    const plaf = _PlatformPeg.default.get();

    if (!plaf) return false;
    if (!plaf.supportsNotifications()) return false;
    if (!plaf.maySendNotifications()) return false;
    return true; // possible, but not necessarily enabled
  },
  isBodyEnabled: function () {
    return this.isEnabled() && _SettingsStore.default.getValue("notificationBodyEnabled");
  },
  isAudioEnabled: function () {
    // We don't route Audio via the HTML Notifications API so it is possible regardless of other things
    return _SettingsStore.default.getValue("audioNotificationsEnabled");
  },
  setPromptHidden: function (hidden, persistent = true) {
    this.toolbarHidden = hidden;

    _Analytics.default.trackEvent('Notifier', 'Set Toolbar Hidden', String(hidden));

    (0, _DesktopNotificationsToast.hideToast)(); // update the info to localStorage for persistent settings

    if (persistent && global.localStorage) {
      global.localStorage.setItem("notifications_hidden", String(hidden));
    }
  },
  shouldShowPrompt: function () {
    const client = _MatrixClientPeg.MatrixClientPeg.get();

    if (!client) {
      return false;
    }

    const isGuest = client.isGuest();
    return !isGuest && this.supportsDesktopNotifications() && !(0, _NotificationControllers.isPushNotifyDisabled)() && !this.isEnabled() && !this._isPromptHidden();
  },
  _isPromptHidden: function () {
    // Check localStorage for any such meta data
    if (global.localStorage) {
      return global.localStorage.getItem("notifications_hidden") === "true";
    }

    return this.toolbarHidden;
  },
  onSyncStateChange: function (state) {
    if (state === "SYNCING") {
      this.isSyncing = true;
    } else if (state === "STOPPED" || state === "ERROR") {
      this.isSyncing = false;
    }
  },
  onEvent: function (ev) {
    if (!this.isSyncing) return; // don't alert for any messages initially

    if (ev.getSender() === _MatrixClientPeg.MatrixClientPeg.get().credentials.userId) return;

    _MatrixClientPeg.MatrixClientPeg.get().decryptEventIfNeeded(ev); // If it's an encrypted event and the type is still 'm.room.encrypted',
    // it hasn't yet been decrypted, so wait until it is.


    if (ev.isBeingDecrypted() || ev.isDecryptionFailure()) {
      this.pendingEncryptedEventIds.push(ev.getId()); // don't let the list fill up indefinitely

      while (this.pendingEncryptedEventIds.length > MAX_PENDING_ENCRYPTED) {
        this.pendingEncryptedEventIds.shift();
      }

      return;
    }

    this._evaluateEvent(ev);
  },
  onEventDecrypted: function (ev) {
    // 'decrypted' means the decryption process has finished: it may have failed,
    // in which case it might decrypt soon if the keys arrive
    if (ev.isDecryptionFailure()) return;
    const idx = this.pendingEncryptedEventIds.indexOf(ev.getId());
    if (idx === -1) return;
    this.pendingEncryptedEventIds.splice(idx, 1);

    this._evaluateEvent(ev);
  },
  onRoomReceipt: function (ev, room) {
    if (room.getUnreadNotificationCount() === 0) {
      // ideally we would clear each notification when it was read,
      // but we have no way, given a read receipt, to know whether
      // the receipt comes before or after an event, so we can't
      // do this. Instead, clear all notifications for a room once
      // there are no notifs left in that room., which is not quite
      // as good but it's something.
      const plaf = _PlatformPeg.default.get();

      if (!plaf) return;
      if (this.notifsByRoom[room.roomId] === undefined) return;

      for (const notif of this.notifsByRoom[room.roomId]) {
        plaf.clearNotification(notif);
      }

      delete this.notifsByRoom[room.roomId];
    }
  },
  _evaluateEvent: function (ev) {
    const room = _MatrixClientPeg.MatrixClientPeg.get().getRoom(ev.getRoomId());

    const actions = _MatrixClientPeg.MatrixClientPeg.get().getPushActionsForEvent(ev);

    if (actions && actions.notify) {
      if (_RoomViewStore.default.getRoomId() === room.roomId && _UserActivity.default.sharedInstance().userActiveRecently()) {
        // don't bother notifying as user was recently active in this room
        return;
      }

      if (_SettingsStore.default.getValue("doNotDisturb")) {
        // Don't bother the user if they didn't ask to be bothered
        return;
      }

      if (this.isEnabled()) {
        this._displayPopupNotification(ev, room);
      }

      if (actions.tweaks.sound && this.isAudioEnabled()) {
        _PlatformPeg.default.get().loudNotification(ev, room);

        this._playAudioNotification(ev, room);
      }
    }
  }
};
exports.Notifier = Notifier;

if (!window.mxNotifier) {
  window.mxNotifier = Notifier;
}

var _default = window.mxNotifier;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9Ob3RpZmllci50cyJdLCJuYW1lcyI6WyJNQVhfUEVORElOR19FTkNSWVBURUQiLCJtc2dUeXBlSGFuZGxlcnMiLCJNc2dUeXBlIiwiS2V5VmVyaWZpY2F0aW9uUmVxdWVzdCIsImV2ZW50IiwibmFtZSIsInNlbmRlciIsIk5vdGlmaWVyIiwibm90aWZzQnlSb29tIiwicGVuZGluZ0VuY3J5cHRlZEV2ZW50SWRzIiwibm90aWZpY2F0aW9uTWVzc2FnZUZvckV2ZW50IiwiZXYiLCJoYXNPd25Qcm9wZXJ0eSIsImdldENvbnRlbnQiLCJtc2d0eXBlIiwiVGV4dEZvckV2ZW50IiwidGV4dEZvckV2ZW50IiwiX2Rpc3BsYXlQb3B1cE5vdGlmaWNhdGlvbiIsInJvb20iLCJwbGFmIiwiUGxhdGZvcm1QZWciLCJnZXQiLCJzdXBwb3J0c05vdGlmaWNhdGlvbnMiLCJtYXlTZW5kTm90aWZpY2F0aW9ucyIsImdsb2JhbCIsImRvY3VtZW50IiwiaGFzRm9jdXMiLCJtc2ciLCJ0aXRsZSIsImJvZHkiLCJnZXRUeXBlIiwiaXNCb2R5RW5hYmxlZCIsImF2YXRhclVybCIsIlNldHRpbmdzU3RvcmUiLCJnZXRWYWx1ZSIsIkF2YXRhciIsImF2YXRhclVybEZvck1lbWJlciIsIm5vdGlmIiwiZGlzcGxheU5vdGlmaWNhdGlvbiIsImdldFJvb21JZCIsInVuZGVmaW5lZCIsInB1c2giLCJnZXRTb3VuZEZvclJvb20iLCJyb29tSWQiLCJjb250ZW50IiwidXJsIiwibG9nZ2VyIiwid2FybiIsInN0YXJ0c1dpdGgiLCJzcmNIdHRwIiwidHlwZSIsInNpemUiLCJfcGxheUF1ZGlvTm90aWZpY2F0aW9uIiwic291bmQiLCJsb2ciLCJzZWxlY3RvciIsInF1ZXJ5U2VsZWN0b3IiLCJhdWRpb0VsZW1lbnQiLCJlcnJvciIsIkF1ZGlvIiwiYXBwZW5kQ2hpbGQiLCJwbGF5IiwiZXgiLCJzdGFydCIsImJvdW5kT25FdmVudCIsIm9uRXZlbnQiLCJiaW5kIiwiYm91bmRPblN5bmNTdGF0ZUNoYW5nZSIsIm9uU3luY1N0YXRlQ2hhbmdlIiwiYm91bmRPblJvb21SZWNlaXB0Iiwib25Sb29tUmVjZWlwdCIsImJvdW5kT25FdmVudERlY3J5cHRlZCIsIm9uRXZlbnREZWNyeXB0ZWQiLCJNYXRyaXhDbGllbnRQZWciLCJvbiIsInRvb2xiYXJIaWRkZW4iLCJpc1N5bmNpbmciLCJzdG9wIiwicmVtb3ZlTGlzdGVuZXIiLCJzdXBwb3J0c0Rlc2t0b3BOb3RpZmljYXRpb25zIiwic2V0RW5hYmxlZCIsImVuYWJsZSIsImNhbGxiYWNrIiwiQW5hbHl0aWNzIiwidHJhY2tFdmVudCIsIlN0cmluZyIsImlzTGV2ZWxTdXBwb3J0ZWQiLCJTZXR0aW5nTGV2ZWwiLCJERVZJQ0UiLCJzZXRWYWx1ZSIsImlzRW5hYmxlZCIsInJlcXVlc3ROb3RpZmljYXRpb25QZXJtaXNzaW9uIiwidGhlbiIsInJlc3VsdCIsImJyYW5kIiwiU2RrQ29uZmlnIiwiZGVzY3JpcHRpb24iLCJNb2RhbCIsImNyZWF0ZVRyYWNrZWREaWFsb2ciLCJFcnJvckRpYWxvZyIsImRpcyIsImRpc3BhdGNoIiwiYWN0aW9uIiwidmFsdWUiLCJzZXRQcm9tcHRIaWRkZW4iLCJpc1Bvc3NpYmxlIiwiaXNBdWRpb0VuYWJsZWQiLCJoaWRkZW4iLCJwZXJzaXN0ZW50IiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsInNob3VsZFNob3dQcm9tcHQiLCJjbGllbnQiLCJpc0d1ZXN0IiwiX2lzUHJvbXB0SGlkZGVuIiwiZ2V0SXRlbSIsInN0YXRlIiwiZ2V0U2VuZGVyIiwiY3JlZGVudGlhbHMiLCJ1c2VySWQiLCJkZWNyeXB0RXZlbnRJZk5lZWRlZCIsImlzQmVpbmdEZWNyeXB0ZWQiLCJpc0RlY3J5cHRpb25GYWlsdXJlIiwiZ2V0SWQiLCJsZW5ndGgiLCJzaGlmdCIsIl9ldmFsdWF0ZUV2ZW50IiwiaWR4IiwiaW5kZXhPZiIsInNwbGljZSIsImdldFVucmVhZE5vdGlmaWNhdGlvbkNvdW50IiwiY2xlYXJOb3RpZmljYXRpb24iLCJnZXRSb29tIiwiYWN0aW9ucyIsImdldFB1c2hBY3Rpb25zRm9yRXZlbnQiLCJub3RpZnkiLCJSb29tVmlld1N0b3JlIiwiVXNlckFjdGl2aXR5Iiwic2hhcmVkSW5zdGFuY2UiLCJ1c2VyQWN0aXZlUmVjZW50bHkiLCJ0d2Vha3MiLCJsb3VkTm90aWZpY2F0aW9uIiwid2luZG93IiwibXhOb3RpZmllciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBc0JBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOzs7Ozs7QUF6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBLE1BQU1BLHFCQUFxQixHQUFHLEVBQTlCO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxNQUFNQyxlQUFlLEdBQUc7QUFDcEIsR0FBQ0MsZUFBUUMsc0JBQVQsR0FBbUNDLEtBQUQsSUFBVztBQUN6QyxVQUFNQyxJQUFJLEdBQUcsQ0FBQ0QsS0FBSyxDQUFDRSxNQUFOLElBQWdCLEVBQWpCLEVBQXFCRCxJQUFsQztBQUNBLFdBQU8seUJBQUcscUNBQUgsRUFBMEM7QUFBRUEsTUFBQUE7QUFBRixLQUExQyxDQUFQO0FBQ0g7QUFKbUIsQ0FBeEI7QUFPTyxNQUFNRSxRQUFRLEdBQUc7QUFDcEJDLEVBQUFBLFlBQVksRUFBRSxFQURNO0FBR3BCO0FBQ0E7QUFDQTtBQUNBQyxFQUFBQSx3QkFBd0IsRUFBRSxFQU5OO0FBUXBCQyxFQUFBQSwyQkFBMkIsRUFBRSxVQUFTQyxFQUFULEVBQWtDO0FBQzNELFFBQUlWLGVBQWUsQ0FBQ1csY0FBaEIsQ0FBK0JELEVBQUUsQ0FBQ0UsVUFBSCxHQUFnQkMsT0FBL0Ms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QXFHO0FBQ2pHO0FBQ0E7QUFDSDs7QUFDRCxVQUFJMUcsdUJBQWNDLFFBQWQsQ0FBdUIsY0FBdkIsQ0FBSixFQUE0QztBQUN4QztBQUNBO0FBQ0g7O0FBRUQsVUFBSSxLQUFLd0QsU0FBTCxFQUFKLEVBQXNCO0FBQ2xCLGFBQUt6RSx5QkFBTCxDQUErQk4sRUFBL0IsRUFBbUNPLElBQW5DO0FBQ0g7O0FBQ0QsVUFBSW1ILE9BQU8sQ0FBQ08sTUFBUixDQUFldkYsS0FBZixJQUF3QixLQUFLcUQsY0FBTCxFQUE1QixFQUFtRDtBQUMvQ3RGLDZCQUFZQyxHQUFaLEdBQWtCd0gsZ0JBQWxCLENBQW1DbEksRUFBbkMsRUFBdUNPLElBQXZDOztBQUNBLGFBQUtrQyxzQkFBTCxDQUE0QnpDLEVBQTVCLEVBQWdDTyxJQUFoQztBQUNIO0FBQ0o7QUFDSjtBQWpWbUIsQ0FBakI7OztBQW9WUCxJQUFJLENBQUM0SCxNQUFNLENBQUNDLFVBQVosRUFBd0I7QUFDcEJELEVBQUFBLE1BQU0sQ0FBQ0MsVUFBUCxHQUFvQnhJLFFBQXBCO0FBQ0g7O2VBRWN1SSxNQUFNLENBQUNDLFUiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMTUsIDIwMTYgT3Blbk1hcmtldCBMdGRcbkNvcHlyaWdodCAyMDE3IFZlY3RvciBDcmVhdGlvbnMgTHRkXG5Db3B5cmlnaHQgMjAxNyBOZXcgVmVjdG9yIEx0ZFxuQ29weXJpZ2h0IDIwMjAgVGhlIE1hdHJpeC5vcmcgRm91bmRhdGlvbiBDLkkuQy5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgeyBNYXRyaXhFdmVudCB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9tb2RlbHMvZXZlbnRcIjtcbmltcG9ydCB7IFJvb20gfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvbW9kZWxzL3Jvb21cIjtcblxuaW1wb3J0IHsgTWF0cml4Q2xpZW50UGVnIH0gZnJvbSAnLi9NYXRyaXhDbGllbnRQZWcnO1xuaW1wb3J0IFNka0NvbmZpZyBmcm9tICcuL1Nka0NvbmZpZyc7XG5pbXBvcnQgUGxhdGZvcm1QZWcgZnJvbSAnLi9QbGF0Zm9ybVBlZyc7XG5pbXBvcnQgKiBhcyBUZXh0Rm9yRXZlbnQgZnJvbSAnLi9UZXh0Rm9yRXZlbnQnO1xuaW1wb3J0IEFuYWx5dGljcyBmcm9tICcuL0FuYWx5dGljcyc7XG5pbXBvcnQgKiBhcyBBdmF0YXIgZnJvbSAnLi9BdmF0YXInO1xuaW1wb3J0IGRpcyBmcm9tICcuL2Rpc3BhdGNoZXIvZGlzcGF0Y2hlcic7XG5pbXBvcnQgeyBfdCB9IGZyb20gJy4vbGFuZ3VhZ2VIYW5kbGVyJztcbmltcG9ydCBNb2RhbCBmcm9tICcuL01vZGFsJztcbmltcG9ydCBTZXR0aW5nc1N0b3JlIGZyb20gXCIuL3NldHRpbmdzL1NldHRpbmdzU3RvcmVcIjtcbmltcG9ydCB7IGhpZGVUb2FzdCBhcyBoaWRlTm90aWZpY2F0aW9uc1RvYXN0IH0gZnJvbSBcIi4vdG9hc3RzL0Rlc2t0b3BOb3RpZmljYXRpb25zVG9hc3RcIjtcbmltcG9ydCB7IFNldHRpbmdMZXZlbCB9IGZyb20gXCIuL3NldHRpbmdzL1NldHRpbmdMZXZlbFwiO1xuaW1wb3J0IHsgaXNQdXNoTm90aWZ5RGlzYWJsZWQgfSBmcm9tIFwiLi9zZXR0aW5ncy9jb250cm9sbGVycy9Ob3RpZmljYXRpb25Db250cm9sbGVyc1wiO1xuaW1wb3J0IFJvb21WaWV3U3RvcmUgZnJvbSBcIi4vc3RvcmVzL1Jvb21WaWV3U3RvcmVcIjtcbmltcG9ydCBVc2VyQWN0aXZpdHkgZnJvbSBcIi4vVXNlckFjdGl2aXR5XCI7XG5pbXBvcnQgeyBtZWRpYUZyb21NeGMgfSBmcm9tIFwiLi9jdXN0b21pc2F0aW9ucy9NZWRpYVwiO1xuaW1wb3J0IEVycm9yRGlhbG9nIGZyb20gXCIuL2NvbXBvbmVudHMvdmlld3MvZGlhbG9ncy9FcnJvckRpYWxvZ1wiO1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvbG9nZ2VyXCI7XG5pbXBvcnQgeyBNc2dUeXBlIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL0B0eXBlcy9ldmVudFwiO1xuXG4vKlxuICogRGlzcGF0Y2hlczpcbiAqIHtcbiAqICAgYWN0aW9uOiBcIm5vdGlmaWVyX2VuYWJsZWRcIixcbiAqICAgdmFsdWU6IGJvb2xlYW5cbiAqIH1cbiAqL1xuXG5jb25zdCBNQVhfUEVORElOR19FTkNSWVBURUQgPSAyMDtcblxuLypcbk92ZXJyaWRlIGJvdGggdGhlIGNvbnRlbnQgYm9keSBhbmQgdGhlIFRleHRGb3JFdmVudCBoYW5kbGVyIGZvciBzcGVjaWZpYyBtc2d0eXBlcywgaW4gbm90aWZpY2F0aW9ucy5cblRoaXMgaXMgdXNlZnVsIHdoZW4gdGhlIGNvbnRlbnQgYm9keSBjb250YWlucyBmYWxsYmFjayB0ZXh0IHRoYXQgd291bGQgZXhwbGFpbiB0aGF0IHRoZSBjbGllbnQgY2FuJ3QgaGFuZGxlIGEgcGFydGljdWxhclxudHlwZSBvZiB0aWxlLlxuKi9cbmNvbnN0IG1zZ1R5cGVIYW5kbGVycyA9IHtcbiAgICBbTXNnVHlwZS5LZXlWZXJpZmljYXRpb25SZXF1ZXN0XTogKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSAoZXZlbnQuc2VuZGVyIHx8IHt9KS5uYW1lO1xuICAgICAgICByZXR1cm4gX3QoXCIlKG5hbWUpcyBpcyByZXF1ZXN0aW5nIHZlcmlmaWNhdGlvblwiLCB7IG5hbWUgfSk7XG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBOb3RpZmllciA9IHtcbiAgICBub3RpZnNCeVJvb206IHt9LFxuXG4gICAgLy8gQSBsaXN0IG9mIGV2ZW50IElEcyB0aGF0IHdlJ3ZlIHJlY2VpdmVkIGJ1dCBuZWVkIHRvIHdhaXQgdW50aWxcbiAgICAvLyB0aGV5J3JlIGRlY3J5cHRlZCB1bnRpbCB3ZSBkZWNpZGUgd2hldGhlciB0byBub3RpZnkgZm9yIHRoZW1cbiAgICAvLyBvciBub3RcbiAgICBwZW5kaW5nRW5jcnlwdGVkRXZlbnRJZHM6IFtdLFxuXG4gICAgbm90aWZpY2F0aW9uTWVzc2FnZUZvckV2ZW50OiBmdW5jdGlvbihldjogTWF0cml4RXZlbnQpOiBzdHJpbmcge1xuICAgICAgICBpZiAobXNnVHlwZUhhbmRsZXJzLmhhc093blByb3BlcnR5KGV2LmdldENvbnRlbnQoKS5tc2d0eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1zZ1R5cGVIYW5kbGVyc1tldi5nZXRDb250ZW50KCkubXNndHlwZV0oZXYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUZXh0Rm9yRXZlbnQudGV4dEZvckV2ZW50KGV2KTtcbiAgICB9LFxuXG4gICAgX2Rpc3BsYXlQb3B1cE5vdGlmaWNhdGlvbjogZnVuY3Rpb24oZXY6IE1hdHJpeEV2ZW50LCByb29tOiBSb29tKSB7XG4gICAgICAgIGNvbnN0IHBsYWYgPSBQbGF0Zm9ybVBlZy5nZXQoKTtcbiAgICAgICAgaWYgKCFwbGFmKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwbGFmLnN1cHBvcnRzTm90aWZpY2F0aW9ucygpIHx8ICFwbGFmLm1heVNlbmROb3RpZmljYXRpb25zKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2xvYmFsLmRvY3VtZW50Lmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtc2cgPSB0aGlzLm5vdGlmaWNhdGlvbk1lc3NhZ2VGb3JFdmVudChldik7XG4gICAgICAgIGlmICghbXNnKSByZXR1cm47XG5cbiAgICAgICAgbGV0IHRpdGxlO1xuICAgICAgICBpZiAoIWV2LnNlbmRlciB8fCByb29tLm5hbWUgPT09IGV2LnNlbmRlci5uYW1lKSB7XG4gICAgICAgICAgICB0aXRsZSA9IHJvb20ubmFtZTtcbiAgICAgICAgICAgIC8vIG5vdGlmaWNhdGlvbk1lc3NhZ2VGb3JFdmVudCBpbmNsdWRlcyBzZW5kZXIsXG4gICAgICAgICAgICAvLyBidXQgd2UgYWxyZWFkeSBoYXZlIHRoZSBzZW5kZXIgaGVyZVxuICAgICAgICAgICAgaWYgKGV2LmdldENvbnRlbnQoKS5ib2R5ICYmICFtc2dUeXBlSGFuZGxlcnMuaGFzT3duUHJvcGVydHkoZXYuZ2V0Q29udGVudCgpLm1zZ3R5cGUpKSB7XG4gICAgICAgICAgICAgICAgbXNnID0gZXYuZ2V0Q29udGVudCgpLmJvZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXYuZ2V0VHlwZSgpID09PSAnbS5yb29tLm1lbWJlcicpIHtcbiAgICAgICAgICAgIC8vIGNvbnRleHQgaXMgYWxsIGluIHRoZSBtZXNzYWdlIGhlcmUsIHdlIGRvbid0IG5lZWRcbiAgICAgICAgICAgIC8vIHRvIGRpc3BsYXkgc2VuZGVyIGluZm9cbiAgICAgICAgICAgIHRpdGxlID0gcm9vbS5uYW1lO1xuICAgICAgICB9IGVsc2UgaWYgKGV2LnNlbmRlcikge1xuICAgICAgICAgICAgdGl0bGUgPSBldi5zZW5kZXIubmFtZSArIFwiIChcIiArIHJvb20ubmFtZSArIFwiKVwiO1xuICAgICAgICAgICAgLy8gbm90aWZpY2F0aW9uTWVzc2FnZUZvckV2ZW50IGluY2x1ZGVzIHNlbmRlcixcbiAgICAgICAgICAgIC8vIGJ1dCB3ZSd2ZSBqdXN0IG91dCBzZW5kZXIgaW4gdGhlIHRpdGxlXG4gICAgICAgICAgICBpZiAoZXYuZ2V0Q29udGVudCgpLmJvZHkgJiYgIW1zZ1R5cGVIYW5kbGVycy5oYXNPd25Qcm9wZXJ0eShldi5nZXRDb250ZW50KCkubXNndHlwZSkpIHtcbiAgICAgICAgICAgICAgICBtc2cgPSBldi5nZXRDb250ZW50KCkuYm9keTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5pc0JvZHlFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIG1zZyA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGF2YXRhclVybCA9IG51bGw7XG4gICAgICAgIGlmIChldi5zZW5kZXIgJiYgIVNldHRpbmdzU3RvcmUuZ2V0VmFsdWUoXCJsb3dCYW5kd2lkdGhcIikpIHtcbiAgICAgICAgICAgIGF2YXRhclVybCA9IEF2YXRhci5hdmF0YXJVcmxGb3JNZW1iZXIoZXYuc2VuZGVyLCA0MCwgNDAsICdjcm9wJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBub3RpZiA9IHBsYWYuZGlzcGxheU5vdGlmaWNhdGlvbih0aXRsZSwgbXNnLCBhdmF0YXJVcmwsIHJvb20pO1xuXG4gICAgICAgIC8vIGlmIGRpc3BsYXlOb3RpZmljYXRpb24gcmV0dXJucyBub24tbnVsbCwgIHRoZSBwbGF0Zm9ybSBzdXBwb3J0c1xuICAgICAgICAvLyBjbGVhcmluZyBub3RpZmljYXRpb25zIGxhdGVyLCBzbyBrZWVwIHRyYWNrIG9mIHRoaXMuXG4gICAgICAgIGlmIChub3RpZikge1xuICAgICAgICAgICAgaWYgKHRoaXMubm90aWZzQnlSb29tW2V2LmdldFJvb21JZCgpXSA9PT0gdW5kZWZpbmVkKSB0aGlzLm5vdGlmc0J5Um9vbVtldi5nZXRSb29tSWQoKV0gPSBbXTtcbiAgICAgICAgICAgIHRoaXMubm90aWZzQnlSb29tW2V2LmdldFJvb21JZCgpXS5wdXNoKG5vdGlmKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRTb3VuZEZvclJvb206IGZ1bmN0aW9uKHJvb21JZDogc3RyaW5nKSB7XG4gICAgICAgIC8vIFdlIGRvIG5vIGNhY2hpbmcgaGVyZSBiZWNhdXNlIHRoZSBTREsgY2FjaGVzIHNldHRpbmdcbiAgICAgICAgLy8gYW5kIHRoZSBicm93c2VyIHdpbGwgY2FjaGUgdGhlIHNvdW5kLlxuICAgICAgICBjb25zdCBjb250ZW50ID0gU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZShcIm5vdGlmaWNhdGlvblNvdW5kXCIsIHJvb21JZCk7XG4gICAgICAgIGlmICghY29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbnRlbnQudXJsKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgJHtyb29tSWR9IGhhcyBjdXN0b20gbm90aWZpY2F0aW9uIHNvdW5kIGV2ZW50LCBidXQgbm8gdXJsIGtleWApO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbnRlbnQudXJsLnN0YXJ0c1dpdGgoXCJteGM6Ly9cIikpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGAke3Jvb21JZH0gaGFzIGN1c3RvbSBub3RpZmljYXRpb24gc291bmQgZXZlbnQsIGJ1dCB1cmwgaXMgbm90IGEgbXhjIHVybGApO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZGVhbGx5IGluIGhlcmUgd2UgY291bGQgdXNlIE1TQzEzMTAgdG8gZGV0ZWN0IHRoZSB0eXBlIG9mIGZpbGUsIGFuZCByZWplY3QgaXQuXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVybDogbWVkaWFGcm9tTXhjKGNvbnRlbnQudXJsKS5zcmNIdHRwLFxuICAgICAgICAgICAgbmFtZTogY29udGVudC5uYW1lLFxuICAgICAgICAgICAgdHlwZTogY29udGVudC50eXBlLFxuICAgICAgICAgICAgc2l6ZTogY29udGVudC5zaXplLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBfcGxheUF1ZGlvTm90aWZpY2F0aW9uOiBhc3luYyBmdW5jdGlvbihldjogTWF0cml4RXZlbnQsIHJvb206IFJvb20pIHtcbiAgICAgICAgY29uc3Qgc291bmQgPSB0aGlzLmdldFNvdW5kRm9yUm9vbShyb29tLnJvb21JZCk7XG4gICAgICAgIGxvZ2dlci5sb2coYEdvdCBzb3VuZCAke3NvdW5kICYmIHNvdW5kLm5hbWUgfHwgXCJkZWZhdWx0XCJ9IGZvciAke3Jvb20ucm9vbUlkfWApO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcjxIVE1MQXVkaW9FbGVtZW50Pihzb3VuZCA/IGBhdWRpb1tzcmM9JyR7c291bmQudXJsfSddYCA6IFwiI21lc3NhZ2VBdWRpb1wiKTtcbiAgICAgICAgICAgIGxldCBhdWRpb0VsZW1lbnQgPSBzZWxlY3RvcjtcbiAgICAgICAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIk5vIGF1ZGlvIGVsZW1lbnQgb3Igc291bmQgdG8gcGxheSBmb3Igbm90aWZpY2F0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF1ZGlvRWxlbWVudCA9IG5ldyBBdWRpbyhzb3VuZC51cmwpO1xuICAgICAgICAgICAgICAgIGlmIChzb3VuZC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvRWxlbWVudC50eXBlID0gc291bmQudHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhdWRpb0VsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgYXVkaW9FbGVtZW50LnBsYXkoKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiQ2F1Z2h0IGVycm9yIHdoZW4gdHJ5aW5nIHRvIGZldGNoIHJvb20gbm90aWZpY2F0aW9uIHNvdW5kOlwiLCBleCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBkbyBub3QgcmUtYmluZCBpbiB0aGUgY2FzZSBvZiByZXBlYXRlZCBjYWxsXG4gICAgICAgIHRoaXMuYm91bmRPbkV2ZW50ID0gdGhpcy5ib3VuZE9uRXZlbnQgfHwgdGhpcy5vbkV2ZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYm91bmRPblN5bmNTdGF0ZUNoYW5nZSA9IHRoaXMuYm91bmRPblN5bmNTdGF0ZUNoYW5nZSB8fCB0aGlzLm9uU3luY1N0YXRlQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYm91bmRPblJvb21SZWNlaXB0ID0gdGhpcy5ib3VuZE9uUm9vbVJlY2VpcHQgfHwgdGhpcy5vblJvb21SZWNlaXB0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYm91bmRPbkV2ZW50RGVjcnlwdGVkID0gdGhpcy5ib3VuZE9uRXZlbnREZWNyeXB0ZWQgfHwgdGhpcy5vbkV2ZW50RGVjcnlwdGVkLmJpbmQodGhpcyk7XG5cbiAgICAgICAgTWF0cml4Q2xpZW50UGVnLmdldCgpLm9uKCdldmVudCcsIHRoaXMuYm91bmRPbkV2ZW50KTtcbiAgICAgICAgTWF0cml4Q2xpZW50UGVnLmdldCgpLm9uKCdSb29tLnJlY2VpcHQnLCB0aGlzLmJvdW5kT25Sb29tUmVjZWlwdCk7XG4gICAgICAgIE1hdHJpeENsaWVudFBlZy5nZXQoKS5vbignRXZlbnQuZGVjcnlwdGVkJywgdGhpcy5ib3VuZE9uRXZlbnREZWNyeXB0ZWQpO1xuICAgICAgICBNYXRyaXhDbGllbnRQZWcuZ2V0KCkub24oXCJzeW5jXCIsIHRoaXMuYm91bmRPblN5bmNTdGF0ZUNoYW5nZSk7XG4gICAgICAgIHRoaXMudG9vbGJhckhpZGRlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU3luY2luZyA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKE1hdHJpeENsaWVudFBlZy5nZXQoKSkge1xuICAgICAgICAgICAgTWF0cml4Q2xpZW50UGVnLmdldCgpLnJlbW92ZUxpc3RlbmVyKCdFdmVudCcsIHRoaXMuYm91bmRPbkV2ZW50KTtcbiAgICAgICAgICAgIE1hdHJpeENsaWVudFBlZy5nZXQoKS5yZW1vdmVMaXN0ZW5lcignUm9vbS5yZWNlaXB0JywgdGhpcy5ib3VuZE9uUm9vbVJlY2VpcHQpO1xuICAgICAgICAgICAgTWF0cml4Q2xpZW50UGVnLmdldCgpLnJlbW92ZUxpc3RlbmVyKCdFdmVudC5kZWNyeXB0ZWQnLCB0aGlzLmJvdW5kT25FdmVudERlY3J5cHRlZCk7XG4gICAgICAgICAgICBNYXRyaXhDbGllbnRQZWcuZ2V0KCkucmVtb3ZlTGlzdGVuZXIoJ3N5bmMnLCB0aGlzLmJvdW5kT25TeW5jU3RhdGVDaGFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNTeW5jaW5nID0gZmFsc2U7XG4gICAgfSxcblxuICAgIHN1cHBvcnRzRGVza3RvcE5vdGlmaWNhdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBwbGFmID0gUGxhdGZvcm1QZWcuZ2V0KCk7XG4gICAgICAgIHJldHVybiBwbGFmICYmIHBsYWYuc3VwcG9ydHNOb3RpZmljYXRpb25zKCk7XG4gICAgfSxcblxuICAgIHNldEVuYWJsZWQ6IGZ1bmN0aW9uKGVuYWJsZTogYm9vbGVhbiwgY2FsbGJhY2s/OiAoKSA9PiB2b2lkKSB7XG4gICAgICAgIGNvbnN0IHBsYWYgPSBQbGF0Zm9ybVBlZy5nZXQoKTtcbiAgICAgICAgaWYgKCFwbGFmKSByZXR1cm47XG5cbiAgICAgICAgLy8gRGV2IG5vdGU6IFdlIGRvbid0IHNldCB0aGUgXCJub3RpZmljYXRpb25zRW5hYmxlZFwiIHNldHRpbmcgdG8gdHJ1ZSBoZXJlIGJlY2F1c2UgaXQgaXMgYVxuICAgICAgICAvLyBjYWxjdWxhdGVkIHZhbHVlLiBJdCBpcyBkZXRlcm1pbmVkIGJhc2VkIHVwb24gd2hldGhlciBvciBub3QgdGhlIG1hc3RlciBydWxlIGlzIGVuYWJsZWRcbiAgICAgICAgLy8gYW5kIG90aGVyIGZsYWdzLiBTZXR0aW5nIGl0IGhlcmUgd291bGQgY2F1c2UgYSBjaXJjdWxhciByZWZlcmVuY2UuXG5cbiAgICAgICAgQW5hbHl0aWNzLnRyYWNrRXZlbnQoJ05vdGlmaWVyJywgJ1NldCBFbmFibGVkJywgU3RyaW5nKGVuYWJsZSkpO1xuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHdlIHBlcnNpc3QgdGhlIGN1cnJlbnQgc2V0dGluZyBhdWRpb19lbmFibGVkIHNldHRpbmdcbiAgICAgICAgLy8gYmVmb3JlIGNoYW5naW5nIGFueXRoaW5nXG4gICAgICAgIGlmIChTZXR0aW5nc1N0b3JlLmlzTGV2ZWxTdXBwb3J0ZWQoU2V0dGluZ0xldmVsLkRFVklDRSkpIHtcbiAgICAgICAgICAgIFNldHRpbmdzU3RvcmUuc2V0VmFsdWUoXCJhdWRpb05vdGlmaWNhdGlvbnNFbmFibGVkXCIsIG51bGwsIFNldHRpbmdMZXZlbC5ERVZJQ0UsIHRoaXMuaXNFbmFibGVkKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuYWJsZSkge1xuICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBnZXQgcGVybWlzc2lvbiBmcm9tIHVzZXJcbiAgICAgICAgICAgIHBsYWYucmVxdWVzdE5vdGlmaWNhdGlvblBlcm1pc3Npb24oKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSAnZ3JhbnRlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHBlcm1pc3Npb24gcmVxdWVzdCB3YXMgZGlzbWlzc2VkIG9yIGRlbmllZFxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBTdXBwb3J0IGFsdGVybmF0aXZlIGJyYW5kaW5nIGluIG1lc3NhZ2luZ1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBicmFuZCA9IFNka0NvbmZpZy5nZXQoKS5icmFuZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSByZXN1bHQgPT09ICdkZW5pZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IF90KCclKGJyYW5kKXMgZG9lcyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIHNlbmQgeW91IG5vdGlmaWNhdGlvbnMgLSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGxlYXNlIGNoZWNrIHlvdXIgYnJvd3NlciBzZXR0aW5ncycsIHsgYnJhbmQgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogX3QoJyUoYnJhbmQpcyB3YXMgbm90IGdpdmVuIHBlcm1pc3Npb24gdG8gc2VuZCBub3RpZmljYXRpb25zIC0gcGxlYXNlIHRyeSBhZ2FpbicsIHsgYnJhbmQgfSk7XG4gICAgICAgICAgICAgICAgICAgIE1vZGFsLmNyZWF0ZVRyYWNrZWREaWFsb2coJ1VuYWJsZSB0byBlbmFibGUgTm90aWZpY2F0aW9ucycsIHJlc3VsdCwgRXJyb3JEaWFsb2csIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBfdCgnVW5hYmxlIHRvIGVuYWJsZSBOb3RpZmljYXRpb25zJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgZGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcIm5vdGlmaWVyX2VuYWJsZWRcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcIm5vdGlmaWVyX2VuYWJsZWRcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgdGhlIG5vdGlmaWNhdGlvbnNfaGlkZGVuIGZsYWcsIGFzIHRoZSB1c2VyIGhhcyBrbm93aW5nbHkgaW50ZXJhY3RlZFxuICAgICAgICAvLyB3aXRoIHRoZSBzZXR0aW5nIHdlIHNob3VsZG4ndCBuYWcgdGhlbSBhbnkgZnVydGhlclxuICAgICAgICB0aGlzLnNldFByb21wdEhpZGRlbih0cnVlKTtcbiAgICB9LFxuXG4gICAgaXNFbmFibGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNQb3NzaWJsZSgpICYmIFNldHRpbmdzU3RvcmUuZ2V0VmFsdWUoXCJub3RpZmljYXRpb25zRW5hYmxlZFwiKTtcbiAgICB9LFxuXG4gICAgaXNQb3NzaWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHBsYWYgPSBQbGF0Zm9ybVBlZy5nZXQoKTtcbiAgICAgICAgaWYgKCFwbGFmKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghcGxhZi5zdXBwb3J0c05vdGlmaWNhdGlvbnMoKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXBsYWYubWF5U2VuZE5vdGlmaWNhdGlvbnMoKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBwb3NzaWJsZSwgYnV0IG5vdCBuZWNlc3NhcmlseSBlbmFibGVkXG4gICAgfSxcblxuICAgIGlzQm9keUVuYWJsZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0VuYWJsZWQoKSAmJiBTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFwibm90aWZpY2F0aW9uQm9keUVuYWJsZWRcIik7XG4gICAgfSxcblxuICAgIGlzQXVkaW9FbmFibGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gV2UgZG9uJ3Qgcm91dGUgQXVkaW8gdmlhIHRoZSBIVE1MIE5vdGlmaWNhdGlvbnMgQVBJIHNvIGl0IGlzIHBvc3NpYmxlIHJlZ2FyZGxlc3Mgb2Ygb3RoZXIgdGhpbmdzXG4gICAgICAgIHJldHVybiBTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFwiYXVkaW9Ob3RpZmljYXRpb25zRW5hYmxlZFwiKTtcbiAgICB9LFxuXG4gICAgc2V0UHJvbXB0SGlkZGVuOiBmdW5jdGlvbihoaWRkZW46IGJvb2xlYW4sIHBlcnNpc3RlbnQgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMudG9vbGJhckhpZGRlbiA9IGhpZGRlbjtcblxuICAgICAgICBBbmFseXRpY3MudHJhY2tFdmVudCgnTm90aWZpZXInLCAnU2V0IFRvb2xiYXIgSGlkZGVuJywgU3RyaW5nKGhpZGRlbikpO1xuXG4gICAgICAgIGhpZGVOb3RpZmljYXRpb25zVG9hc3QoKTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGluZm8gdG8gbG9jYWxTdG9yYWdlIGZvciBwZXJzaXN0ZW50IHNldHRpbmdzXG4gICAgICAgIGlmIChwZXJzaXN0ZW50ICYmIGdsb2JhbC5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICAgIGdsb2JhbC5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShcIm5vdGlmaWNhdGlvbnNfaGlkZGVuXCIsIFN0cmluZyhoaWRkZW4pKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzaG91bGRTaG93UHJvbXB0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gTWF0cml4Q2xpZW50UGVnLmdldCgpO1xuICAgICAgICBpZiAoIWNsaWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzR3Vlc3QgPSBjbGllbnQuaXNHdWVzdCgpO1xuICAgICAgICByZXR1cm4gIWlzR3Vlc3QgJiYgdGhpcy5zdXBwb3J0c0Rlc2t0b3BOb3RpZmljYXRpb25zKCkgJiYgIWlzUHVzaE5vdGlmeURpc2FibGVkKCkgJiZcbiAgICAgICAgICAgICF0aGlzLmlzRW5hYmxlZCgpICYmICF0aGlzLl9pc1Byb21wdEhpZGRlbigpO1xuICAgIH0sXG5cbiAgICBfaXNQcm9tcHRIaWRkZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBDaGVjayBsb2NhbFN0b3JhZ2UgZm9yIGFueSBzdWNoIG1ldGEgZGF0YVxuICAgICAgICBpZiAoZ2xvYmFsLmxvY2FsU3RvcmFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbC5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShcIm5vdGlmaWNhdGlvbnNfaGlkZGVuXCIpID09PSBcInRydWVcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnRvb2xiYXJIaWRkZW47XG4gICAgfSxcblxuICAgIG9uU3luY1N0YXRlQ2hhbmdlOiBmdW5jdGlvbihzdGF0ZTogc3RyaW5nKSB7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gXCJTWU5DSU5HXCIpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTeW5jaW5nID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gXCJTVE9QUEVEXCIgfHwgc3RhdGUgPT09IFwiRVJST1JcIikge1xuICAgICAgICAgICAgdGhpcy5pc1N5bmNpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvbkV2ZW50OiBmdW5jdGlvbihldjogTWF0cml4RXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3luY2luZykgcmV0dXJuOyAvLyBkb24ndCBhbGVydCBmb3IgYW55IG1lc3NhZ2VzIGluaXRpYWxseVxuICAgICAgICBpZiAoZXYuZ2V0U2VuZGVyKCkgPT09IE1hdHJpeENsaWVudFBlZy5nZXQoKS5jcmVkZW50aWFscy51c2VySWQpIHJldHVybjtcblxuICAgICAgICBNYXRyaXhDbGllbnRQZWcuZ2V0KCkuZGVjcnlwdEV2ZW50SWZOZWVkZWQoZXYpO1xuXG4gICAgICAgIC8vIElmIGl0J3MgYW4gZW5jcnlwdGVkIGV2ZW50IGFuZCB0aGUgdHlwZSBpcyBzdGlsbCAnbS5yb29tLmVuY3J5cHRlZCcsXG4gICAgICAgIC8vIGl0IGhhc24ndCB5ZXQgYmVlbiBkZWNyeXB0ZWQsIHNvIHdhaXQgdW50aWwgaXQgaXMuXG4gICAgICAgIGlmIChldi5pc0JlaW5nRGVjcnlwdGVkKCkgfHwgZXYuaXNEZWNyeXB0aW9uRmFpbHVyZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdFbmNyeXB0ZWRFdmVudElkcy5wdXNoKGV2LmdldElkKCkpO1xuICAgICAgICAgICAgLy8gZG9uJ3QgbGV0IHRoZSBsaXN0IGZpbGwgdXAgaW5kZWZpbml0ZWx5XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5wZW5kaW5nRW5jcnlwdGVkRXZlbnRJZHMubGVuZ3RoID4gTUFYX1BFTkRJTkdfRU5DUllQVEVEKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nRW5jcnlwdGVkRXZlbnRJZHMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2V2YWx1YXRlRXZlbnQoZXYpO1xuICAgIH0sXG5cbiAgICBvbkV2ZW50RGVjcnlwdGVkOiBmdW5jdGlvbihldjogTWF0cml4RXZlbnQpIHtcbiAgICAgICAgLy8gJ2RlY3J5cHRlZCcgbWVhbnMgdGhlIGRlY3J5cHRpb24gcHJvY2VzcyBoYXMgZmluaXNoZWQ6IGl0IG1heSBoYXZlIGZhaWxlZCxcbiAgICAgICAgLy8gaW4gd2hpY2ggY2FzZSBpdCBtaWdodCBkZWNyeXB0IHNvb24gaWYgdGhlIGtleXMgYXJyaXZlXG4gICAgICAgIGlmIChldi5pc0RlY3J5cHRpb25GYWlsdXJlKCkpIHJldHVybjtcblxuICAgICAgICBjb25zdCBpZHggPSB0aGlzLnBlbmRpbmdFbmNyeXB0ZWRFdmVudElkcy5pbmRleE9mKGV2LmdldElkKCkpO1xuICAgICAgICBpZiAoaWR4ID09PSAtMSkgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMucGVuZGluZ0VuY3J5cHRlZEV2ZW50SWRzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB0aGlzLl9ldmFsdWF0ZUV2ZW50KGV2KTtcbiAgICB9LFxuXG4gICAgb25Sb29tUmVjZWlwdDogZnVuY3Rpb24oZXY6IE1hdHJpeEV2ZW50LCByb29tOiBSb29tKSB7XG4gICAgICAgIGlmIChyb29tLmdldFVucmVhZE5vdGlmaWNhdGlvbkNvdW50KCkgPT09IDApIHtcbiAgICAgICAgICAgIC8vIGlkZWFsbHkgd2Ugd291bGQgY2xlYXIgZWFjaCBub3RpZmljYXRpb24gd2hlbiBpdCB3YXMgcmVhZCxcbiAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIG5vIHdheSwgZ2l2ZW4gYSByZWFkIHJlY2VpcHQsIHRvIGtub3cgd2hldGhlclxuICAgICAgICAgICAgLy8gdGhlIHJlY2VpcHQgY29tZXMgYmVmb3JlIG9yIGFmdGVyIGFuIGV2ZW50LCBzbyB3ZSBjYW4ndFxuICAgICAgICAgICAgLy8gZG8gdGhpcy4gSW5zdGVhZCwgY2xlYXIgYWxsIG5vdGlmaWNhdGlvbnMgZm9yIGEgcm9vbSBvbmNlXG4gICAgICAgICAgICAvLyB0aGVyZSBhcmUgbm8gbm90aWZzIGxlZnQgaW4gdGhhdCByb29tLiwgd2hpY2ggaXMgbm90IHF1aXRlXG4gICAgICAgICAgICAvLyBhcyBnb29kIGJ1dCBpdCdzIHNvbWV0aGluZy5cbiAgICAgICAgICAgIGNvbnN0IHBsYWYgPSBQbGF0Zm9ybVBlZy5nZXQoKTtcbiAgICAgICAgICAgIGlmICghcGxhZikgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHRoaXMubm90aWZzQnlSb29tW3Jvb20ucm9vbUlkXSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5vdGlmIG9mIHRoaXMubm90aWZzQnlSb29tW3Jvb20ucm9vbUlkXSkge1xuICAgICAgICAgICAgICAgIHBsYWYuY2xlYXJOb3RpZmljYXRpb24obm90aWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMubm90aWZzQnlSb29tW3Jvb20ucm9vbUlkXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZXZhbHVhdGVFdmVudDogZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgY29uc3Qgcm9vbSA9IE1hdHJpeENsaWVudFBlZy5nZXQoKS5nZXRSb29tKGV2LmdldFJvb21JZCgpKTtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IE1hdHJpeENsaWVudFBlZy5nZXQoKS5nZXRQdXNoQWN0aW9uc0ZvckV2ZW50KGV2KTtcbiAgICAgICAgaWYgKGFjdGlvbnMgJiYgYWN0aW9ucy5ub3RpZnkpIHtcbiAgICAgICAgICAgIGlmIChSb29tVmlld1N0b3JlLmdldFJvb21JZCgpID09PSByb29tLnJvb21JZCAmJiBVc2VyQWN0aXZpdHkuc2hhcmVkSW5zdGFuY2UoKS51c2VyQWN0aXZlUmVjZW50bHkoKSkge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IGJvdGhlciBub3RpZnlpbmcgYXMgdXNlciB3YXMgcmVjZW50bHkgYWN0aXZlIGluIHRoaXMgcm9vbVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFwiZG9Ob3REaXN0dXJiXCIpKSB7XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgYm90aGVyIHRoZSB1c2VyIGlmIHRoZXkgZGlkbid0IGFzayB0byBiZSBib3RoZXJlZFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwbGF5UG9wdXBOb3RpZmljYXRpb24oZXYsIHJvb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFjdGlvbnMudHdlYWtzLnNvdW5kICYmIHRoaXMuaXNBdWRpb0VuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgIFBsYXRmb3JtUGVnLmdldCgpLmxvdWROb3RpZmljYXRpb24oZXYsIHJvb20pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BsYXlBdWRpb05vdGlmaWNhdGlvbihldiwgcm9vbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcblxuaWYgKCF3aW5kb3cubXhOb3RpZmllcikge1xuICAgIHdpbmRvdy5teE5vdGlmaWVyID0gTm90aWZpZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHdpbmRvdy5teE5vdGlmaWVyO1xuIl19