"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.UploadCanceledError = exports.BLURHASH_FIELD = void 0;
exports.uploadFile = uploadFile;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _event = require("matrix-js-sdk/src/@types/event");

var _dispatcher = _interopRequireDefault(require("./dispatcher/dispatcher"));

var sdk = _interopRequireWildcard(require("./index"));

var _languageHandler = require("./languageHandler");

var _Modal = _interopRequireDefault(require("./Modal"));

var _RoomViewStore = _interopRequireDefault(require("./stores/RoomViewStore"));

var _browserEncryptAttachment = _interopRequireDefault(require("browser-encrypt-attachment"));

var _pngChunksExtract = _interopRequireDefault(require("png-chunks-extract"));

var _Spinner = _interopRequireDefault(require("./components/views/elements/Spinner"));

var _actions = require("./dispatcher/actions");

var _CountlyAnalytics = _interopRequireDefault(require("./CountlyAnalytics"));

var _BlurhashEncoder = require("./BlurhashEncoder");

var _SettingsStore = _interopRequireDefault(require("./settings/SettingsStore"));

var _sendTimePerformanceMetrics = require("./sendTimePerformanceMetrics");

var _logger = require("matrix-js-sdk/src/logger");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const MAX_WIDTH = 800;
const MAX_HEIGHT = 600; // scraped out of a macOS hidpi (5660ppm) screenshot png
//                  5669 px (x-axis)      , 5669 px (y-axis)      , per metre

const PHYS_HIDPI = [0x00, 0x00, 0x16, 0x25, 0x00, 0x00, 0x16, 0x25, 0x01];
const BLURHASH_FIELD = "xyz.amorgan.blurhash"; // MSC2448

exports.BLURHASH_FIELD = BLURHASH_FIELD;

class UploadCanceledError extends Error {}

exports.UploadCanceledError = UploadCanceledError;

/**
 * Create a thumbnail for a image DOM element.
 * The image will be smaller than MAX_WIDTH and MAX_HEIGHT.
 * The thumbnail will have the same aspect ratio as the original.
 * Draws the element into a canvas using CanvasRenderingContext2D.drawImage
 * Then calls Canvas.toBlob to get a blob object for the image data.
 *
 * Since it needs to calculate the dimensions of the source image and the
 * thumbnailed image it returns an info object filled out with information
 * about the original image and the thumbnail.
 *
 * @param {HTMLElement} element The element to thumbnail.
 * @param {number} inputWidth The width of the image in the input element.
 * @param {number} inputHeight the width of the image in the input element.
 * @param {String} mimeType The mimeType to save the blob as.
 * @return {Promise} A promise that resolves with an object with an info key
 *  and a thumbnail key.
 */
async function createThumbnail(element, inputWidth, inputHeight, mimeType) {
  let targetWidth = inputWidth;
  let targetHeight = inputHeight;

  if (targetHeight > MAX_HEIGHT) {
    targetWidth = Math.floor(targetWidth * (MAX_HEIGHT / targetHeight));
    targetHeight = MAX_HEIGHT;
  }

  if (targetWidth > MAX_WIDTH) {
    targetHeight = Math.floor(targetHeight * (MAX_WIDTH / targetWidth));
    targetWidth = MAX_WIDTH;
  }

  let canvas;

  if (window.OffscreenCanvas) {
    canvas = new window.OffscreenCanvas(targetWidth, targetHeight);
  } else {
    canvas = document.createElement("canvas");
    canvas.width = targetWidth;
    canvas.height = targetHeight;
  }

  const context = canvas.getContext("2d");
  context.drawImage(element, 0, 0, targetWidth, targetHeight);
  let thumbnailPromise;

  if (window.OffscreenCanvas) {
    thumbnailPromise = canvas.convertToBlob({
      type: mimeType
    });
  } else {
    thumbnailPromise = new Promise(resolve => canvas.toBlob(resolve, mimeType));
  }

  const imageData = context.getImageData(0, 0, targetWidth, targetHeight); // thumbnailPromise and blurhash promise are being awaited concurrently

  const blurhash = await _BlurhashEncoder.BlurhashEncoder.instance.getBlurhash(imageData);
  const thumbnail = await thumbnailPromise;
  return {
    info: {
      thumbnail_info: {
        w: targetWidth,
        h: targetHeight,
        mimetype: thumbnail.type,
        size: thumbnail.size
      },
      w: inputWidth,
      h: inputHeight,
      [BLURHASH_FIELD]: blurhash
    },
    thumbnail
  };
}
/**
 * Load a file into a newly created image element.
 *
 * @param {File} imageFile The file to load in an image element.
 * @return {Promise} A promise that resolves with the html image element.
 */


async function loadImageElement(imageFile) {
  // Load the file into an html element
  const img = document.createElement("img");
  const objectUrl = URL.createObjectURL(imageFile);
  const imgPromise = new Promise((resolve, reject) => {
    img.onload = function () {
      URL.revokeObjectURL(objectUrl);
      resolve(img);
    };

    img.onerror = function (e) {
      reject(e);
    };
  });
  img.src = objectUrl; // check for hi-dpi PNGs and fudge display resolution as needed.
  // this is mainly needed for macOS screencaps

  let parsePromise;

  if (imageFile.type === "image/png") {
    // in practice macOS happens to order the chunks so they fall in
    // the first 0x1000 bytes (thanks to a massive ICC header).
    // Thus we could slice the file down to only sniff the first 0x1000
    // bytes (but this makes extractPngChunks choke on the corrupt file)
    const headers = imageFile; //.slice(0, 0x1000);

    parsePromise = readFileAsArrayBuffer(headers).then(arrayBuffer => {
      const buffer = new Uint8Array(arrayBuffer);
      const chunks = (0, _pngChunksExtract.default)(buffer);

      for (const chunk of chunks) {
        if (chunk.name === 'pHYs') {
          if (chunk.data.byteLength !== PHYS_HIDPI.length) return;
          return chunk.data.every((val, i) => val === PHYS_HIDPI[i]);
        }
      }

      return false;
    });
  }

  const [hidpi] = await Promise.all([parsePromise, imgPromise]);
  const width = hidpi ? img.width >> 1 : img.width;
  const height = hidpi ? img.height >> 1 : img.height;
  return {
    width,
    height,
    img
  };
} // Minimum size for image files before we generate a thumbnail for them.


const IMAGE_SIZE_THRESHOLD_THUMBNAIL = 1 << 15; // 32KB
// Minimum size improvement for image thumbnails, if both are not met then don't bother uploading thumbnail.

const IMAGE_THUMBNAIL_MIN_REDUCTION_SIZE = 1 << 16; // 1MB

const IMAGE_THUMBNAIL_MIN_REDUCTION_PERCENT = 0.1; // 10%
// We don't apply these thresholds to video thumbnails as a poster image is always useful
// and videos tend to be much larger.

/**
 * Read the metadata for an image file and create and upload a thumbnail of the image.
 *
 * @param {MatrixClient} matrixClient A matrixClient to upload the thumbnail with.
 * @param {String} roomId The ID of the room the image will be uploaded in.
 * @param {File} imageFile The image to read and thumbnail.
 * @return {Promise} A promise that resolves with the attachment info.
 */

async function infoForImageFile(matrixClient, roomId, imageFile) {
  let thumbnailType = "image/png";

  if (imageFile.type === "image/jpeg") {
    thumbnailType = "image/jpeg";
  }

  const imageElement = await loadImageElement(imageFile);
  const result = await createThumbnail(imageElement.img, imageElement.width, imageElement.height, thumbnailType);
  const imageInfo = result.info; // we do all sizing checks here because we still rely on thumbnail generation for making a blurhash from.

  const sizeDifference = imageFile.size - imageInfo.thumbnail_info.size;

  if (imageFile.size <= IMAGE_SIZE_THRESHOLD_THUMBNAIL || // image is small enough already
  sizeDifference <= IMAGE_THUMBNAIL_MIN_REDUCTION_SIZE && // thumbnail is not sufficiently smaller than original
  sizeDifference <= imageFile.size * IMAGE_THUMBNAIL_MIN_REDUCTION_PERCENT) {
    delete imageInfo["thumbnail_info"];
    return imageInfo;
  }

  const uploadResult = await uploadFile(matrixClient, roomId, result.thumbnail);
  imageInfo["thumbnail_url"] = uploadResult.url;
  imageInfo["thumbnail_file"] = uploadResult.file;
  return imageInfo;
}
/**
 * Load a file into a newly created video element and pull some strings
 * in an attempt to guarantee the first frame will be showing.
 *
 * @param {File} videoFile The file to load in an video element.
 * @return {Promise} A promise that resolves with the video image element.
 */


function loadVideoElement(videoFile) {
  return new Promise((resolve, reject) => {
    // Load the file into an html element
    const video = document.createElement("video");
    video.preload = "metadata";
    video.playsInline = true;
    video.muted = true;
    const reader = new FileReader();

    reader.onload = function (ev) {
      // Wait until we have enough data to thumbnail the first frame.
      video.onloadeddata = async function () {
        resolve(video);
        video.pause();
      };

      video.onerror = function (e) {
        reject(e);
      };

      video.src = ev.target.result;
      video.load();
      video.play();
    };

    reader.onerror = function (e) {
      reject(e);
    };

    reader.readAsDataURL(videoFile);
  });
}
/**
 * Read the metadata for a video file and create and upload a thumbnail of the video.
 *
 * @param {MatrixClient} matrixClient A matrixClient to upload the thumbnail with.
 * @param {String} roomId The ID of the room the video will be uploaded to.
 * @param {File} videoFile The video to read and thumbnail.
 * @return {Promise} A promise that resolves with the attachment info.
 */


function infoForVideoFile(matrixClient, roomId, videoFile) {
  const thumbnailType = "image/jpeg";
  let videoInfo;
  return loadVideoElement(videoFile).then(video => {
    return createThumbnail(video, video.videoWidth, video.videoHeight, thumbnailType);
  }).then(result => {
    videoInfo = result.info;
    return uploadFile(matrixClient, roomId, result.thumbnail);
  }).then(result => {
    videoInfo.thumbnail_url = result.url;
    videoInfo.thumbnail_file = result.file;
    return videoInfo;
  });
}
/**
 * Read the file as an ArrayBuffer.
 * @param {File} file The file to read
 * @return {Promise} A promise that resolves with an ArrayBuffer when the file
 *   is read.
 */


function readFileAsArrayBuffer(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();

    reader.onload = function (e) {
      resolve(e.target.result);
    };

    reader.onerror = function (e) {
      reject(e);
    };

    reader.readAsArrayBuffer(file);
  });
}
/**
 * Upload the file to the content repository.
 * If the room is encrypted then encrypt the file before uploading.
 *
 * @param {MatrixClient} matrixClient The matrix client to upload the file with.
 * @param {String} roomId The ID of the room being uploaded to.
 * @param {File} file The file to upload.
 * @param {Function?} progressHandler optional callback to be called when a chunk of
 *    data is uploaded.
 * @return {Promise} A promise that resolves with an object.
 *  If the file is unencrypted then the object will have a "url" key.
 *  If the file is encrypted then the object will have a "file" key.
 */


function uploadFile(matrixClient, roomId, file, progressHandler) {
  let canceled = false;

  if (matrixClient.isRoomEncrypted(roomId)) {
    // If the room is encrypted then encrypt the file before uploading it.
    // First read the file into memory.
    let uploadPromise;
    const prom = readFileAsArrayBuffer(file).then(function (data) {
      if (canceled) throw new UploadCanceledError(); // Then encrypt the file.

      return _browserEncryptAttachment.default.encryptAttachment(data);
    }).then(function (encryptResult) {
      if (canceled) throw new UploadCanceledError(); // Pass the encrypted data as a Blob to the uploader.

      const blob = new Blob([encryptResult.data]);
      uploadPromise = matrixClient.uploadContent(blob, {
        progressHandler,
        includeFilename: false
      });
      return uploadPromise.then(url => {
        if (canceled) throw new UploadCanceledError(); // If the attachment is encrypted then bundle the URL along
        // with the information needed to decrypt the attachment and
        // add it under a file key.

        return {
          file: _objectSpread(_objectSpread({}, encryptResult.info), {}, {
            url
          })
        };
      });
    });

    prom.abort = () => {
      canceled = true;
      if (uploadPromise) matrixClient.cancelUpload(uploadPromise);
    };

    return prom;
  } else {
    const basePromise = matrixClient.uploadContent(file, {
      progressHandler
    });
    const promise1 = basePromise.then(function (url) {
      if (canceled) throw new UploadCanceledError(); // If the attachment isn't encrypted then include the URL directly.

      return {
        url
      };
    });

    promise1.abort = () => {
      canceled = true;
      matrixClient.cancelUpload(basePromise);
    };

    return promise1;
  }
}

class ContentMessages {
  constructor() {
    (0, _defineProperty2.default)(this, "inprogress", []);
    (0, _defineProperty2.default)(this, "mediaConfig", null);
  }

  sendStickerContentToRoom(url, roomId, info, text, matrixClient) {
    const startTime = _CountlyAnalytics.default.getTimestamp();

    const prom = matrixClient.sendStickerMessage(roomId, url, info, text).catch(e => {
      _logger.logger.warn(`Failed to send content with URL ${url} to room ${roomId}`, e);

      throw e;
    });

    _CountlyAnalytics.default.instance.trackSendMessage(startTime, prom, roomId, false, false, {
      msgtype: "m.sticker"
    });

    return prom;
  }

  getUploadLimit() {
    if (this.mediaConfig !== null && this.mediaConfig["m.upload.size"] !== undefined) {
      return this.mediaConfig["m.upload.size"];
    } else {
      return null;
    }
  }

  async sendContentListToRoom(files, roomId, relation, matrixClient) {
    if (matrixClient.isGuest()) {
      _dispatcher.default.dispatch({
        action: 'require_registration'
      });

      return;
    }

    const isQuoting = Boolean(_RoomViewStore.default.getQuotingEvent());

    if (isQuoting) {
      // FIXME: Using an import will result in Element crashing
      const QuestionDialog = sdk.getComponent("dialogs.QuestionDialog");

      const {
        finished
      } = _Modal.default.createTrackedDialog('Upload Reply Warning', '', QuestionDialog, {
        title: (0, _languageHandler._t)('Replying With Files'),
        description: /*#__PURE__*/_react.default.createElement("div", null, (0, _languageHandler._t)('At this time it is not possible to reply with a file. ' + 'Would you like to upload this file without replying?')),
        hasCancelButton: true,
        button: (0, _languageHandler._t)("Continue")
      });

      const [shouldUpload] = await finished;
      if (!shouldUpload) return;
    }

    if (!this.mediaConfig) {
      // hot-path optimization to not flash a spinner if we don't need to
      const modal = _Modal.default.createDialog(_Spinner.default, null, 'mx_Dialog_spinner');

      await this.ensureMediaConfigFetched(matrixClient);
      modal.close();
    }

    const tooBigFiles = [];
    const okFiles = [];

    for (let i = 0; i < files.length; ++i) {
      if (this.isFileSizeAcceptable(files[i])) {
        okFiles.push(files[i]);
      } else {
        tooBigFiles.push(files[i]);
      }
    }

    if (tooBigFiles.length > 0) {
      // FIXME: Using an import will result in Element crashing
      const UploadFailureDialog = sdk.getComponent("dialogs.UploadFailureDialog");

      const {
        finished
      } = _Modal.default.createTrackedDialog('Upload Failure', '', UploadFailureDialog, {
        badFiles: tooBigFiles,
        totalFiles: files.length,
        contentMessages: this
      });

      const [shouldContinue] = await finished;
      if (!shouldContinue) return;
    }

    let uploadAll = false; // Promise to complete before sending next file into room, used for synchronisation of file-sending
    // to match the order the files were specified in

    let promBefore = Promise.resolve();

    for (let i = 0; i < okFiles.length; ++i) {
      const file = okFiles[i];

      if (!uploadAll) {
        // FIXME: Using an import will result in Element crashing
        const UploadConfirmDialog = sdk.getComponent("dialogs.UploadConfirmDialog");

        const {
          finished
        } = _Modal.default.createTrackedDialog('Upload Files confirmation', '', UploadConfirmDialog, {
          file,
          currentIndex: i,
          totalFiles: okFiles.length
        });

        const [shouldContinue, shouldUploadAll] = await finished;
        if (!shouldContinue) break;

        if (shouldUploadAll) {
          uploadAll = true;
        }
      }

      promBefore = this.sendContentToRoom(file, roomId, relation, matrixClient, promBefore);
    }
  }

  getCurrentUploads(relation) {
    return this.inprogress.filter(upload => {
      const noRelation = !relation && !upload.relation;
      const matchingRelation = relation && upload.relation && relation.rel_type === upload.relation.rel_type && relation.event_id === upload.relation.event_id;
      return (noRelation || matchingRelation) && !upload.canceled;
    });
    return this.inprogress.filter(u => !u.canceled);
  }

  cancelUpload(promise, matrixClient) {
    let upload;

    for (let i = 0; i < this.inprogress.length; ++i) {
      if (this.inprogress[i].promise === promise) {
        upload = this.inprogress[i];
        break;
      }
    }

    if (upload) {
      upload.canceled = true;
      matrixClient.cancelUpload(upload.promise);

      _dispatcher.default.dispatch({
        action: _actions.Action.UploadCanceled,
        upload
      });
    }
  }

  sendContentToRoom(file, roomId, relation, matrixClient, promBefore) {
    const startTime = _CountlyAnalytics.default.getTimestamp();

    const content = {
      body: file.name || 'Attachment',
      info: {
        size: file.size
      },
      msgtype: "" // set later

    };

    if (relation) {
      content["m.relates_to"] = relation;
    }

    if (_SettingsStore.default.getValue("Performance.addSendMessageTimingMetadata")) {
      (0, _sendTimePerformanceMetrics.decorateStartSendingTime)(content);
    } // if we have a mime type for the file, add it to the message metadata


    if (file.type) {
      content.info.mimetype = file.type;
    }

    const prom = new Promise(resolve => {
      if (file.type.indexOf('image/') === 0) {
        content.msgtype = _event.MsgType.Image;
        infoForImageFile(matrixClient, roomId, file).then(imageInfo => {
          Object.assign(content.info, imageInfo);
          resolve();
        }, e => {
          _logger.logger.error(e);

          content.msgtype = _event.MsgType.File;
          resolve();
        });
      } else if (file.type.indexOf('audio/') === 0) {
        content.msgtype = _event.MsgType.Audio;
        resolve();
      } else if (file.type.indexOf('video/') === 0) {
        content.msgtype = _event.MsgType.Video;
        infoForVideoFile(matrixClient, roomId, file).then(videoInfo => {
          Object.assign(content.info, videoInfo);
          resolve();
        }, e => {
          content.msgtype = _event.MsgType.File;
          resolve();
        });
      } else {
        content.msgtype = _event.MsgType.File;
        resolve();
      }
    }); // create temporary abort handler for before the actual upload gets passed off to js-sdk

    prom.abort = () => {
      upload.canceled = true;
    };

    const upload = {
      fileName: file.name || 'Attachment',
      roomId,
      relation,
      total: file.size,
      loaded: 0,
      promise: prom
    };
    this.inprogress.push(upload);

    _dispatcher.default.dispatch({
      action: _actions.Action.UploadStarted,
      upload
    }); // Focus the composer view


    _dispatcher.default.fire(_actions.Action.FocusSendMessageComposer);

    function onProgress(ev) {
      upload.total = ev.total;
      upload.loaded = ev.loaded;

      _dispatcher.default.dispatch({
        action: _actions.Action.UploadProgress,
        upload
      });
    }

    let error;
    return prom.then(function () {
      if (upload.canceled) throw new UploadCanceledError(); // XXX: upload.promise must be the promise that
      // is returned by uploadFile as it has an abort()
      // method hacked onto it.

      upload.promise = uploadFile(matrixClient, roomId, file, onProgress);
      return upload.promise.then(function (result) {
        content.file = result.file;
        content.url = result.url;
      });
    }).then(() => {
      // Await previous message being sent into the room
      return promBefore;
    }).then(function () {
      if (upload.canceled) throw new UploadCanceledError();
      const threadId = (relation === null || relation === void 0 ? void 0 : relation.rel_type) === _event.RelationType.Thread ? relation.event_id : null;
      const prom = matrixClient.sendMessage(roomId, threadId, content);

      if (_SettingsStore.default.getValue("Performance.addSendMessageTimingMetadata")) {
        prom.then(resp => {
          (0, _sendTimePerformanceMetrics.sendRoundTripMetric)(matrixClient, roomId, resp.event_id);
        });
      }

      _CountlyAnalytics.default.instance.trackSendMessage(startTime, prom, roomId, false, false, content);

      return prom;
    }, function (err) {
      error = err;

      if (!upload.canceled) {
        let desc = (0, _languageHandler._t)("The file '%(fileName)s' failed to upload.", {
          fileName: upload.fileName
        });

        if (err.http_status === 413) {
          desc = (0, _languageHandler._t)("The file '%(fileName)s' exceeds this homeserver's size limit for uploads", {
            fileName: upload.fileName
          });
        } // FIXME: Using an import will result in Element crashing


        const ErrorDialog = sdk.getComponent("dialogs.ErrorDialog");

        _Modal.default.createTrackedDialog('Upload failed', '', ErrorDialog, {
          title: (0, _languageHandler._t)('Upload Failed'),
          description: desc
        });
      }
    }).finally(() => {
      for (let i = 0; i < this.inprogress.length; ++i) {
        if (this.inprogress[i].promise === upload.promise) {
          this.inprogress.splice(i, 1);
          break;
        }
      }

      if (error) {
        // 413: File was too big or upset the server in some way:
        // clear the media size limit so we fetch it again next time
        // we try to upload
        if (error && error.http_status === 413) {
          this.mediaConfig = null;
        }

        _dispatcher.default.dispatch({
          action: _actions.Action.UploadFailed,
          upload,
          error
        });
      } else {
        _dispatcher.default.dispatch({
          action: _actions.Action.UploadFinished,
          upload
        });

        _dispatcher.default.dispatch({
          action: 'message_sent'
        });
      }
    });
  }

  isFileSizeAcceptable(file) {
    if (this.mediaConfig !== null && this.mediaConfig["m.upload.size"] !== undefined && file.size > this.mediaConfig["m.upload.size"]) {
      return false;
    }

    return true;
  }

  ensureMediaConfigFetched(matrixClient) {
    if (this.mediaConfig !== null) return;

    _logger.logger.log("[Media Config] Fetching");

    return matrixClient.getMediaConfig().then(config => {
      _logger.logger.log("[Media Config] Fetched config:", config);

      return config;
    }).catch(() => {
      // Media repo can't or won't report limits, so provide an empty object (no limits).
      _logger.logger.log("[Media Config] Could not fetch config, so not limiting uploads.");

      return {};
    }).then(config => {
      this.mediaConfig = config;
    });
  }

  static sharedInstance() {
    if (window.mxContentMessages === undefined) {
      window.mxContentMessages = new ContentMessages();
    }

    return window.mxContentMessages;
  }

}

exports.default = ContentMessages;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9Db250ZW50TWVzc2FnZXMudHN4Il0sIm5hbWVzIjpbIk1BWF9XSURUSCIsIk1BWF9IRUlHSFQiLCJQSFlTX0hJRFBJIiwiQkxVUkhBU0hfRklFTEQiLCJVcGxvYWRDYW5jZWxlZEVycm9yIiwiRXJyb3IiLCJjcmVhdGVUaHVtYm5haWwiLCJlbGVtZW50IiwiaW5wdXRXaWR0aCIsImlucHV0SGVpZ2h0IiwibWltZVR5cGUiLCJ0YXJnZXRXaWR0aCIsInRhcmdldEhlaWdodCIsIk1hdGgiLCJmbG9vciIsImNhbnZhcyIsIndpbmRvdyIsIk9mZnNjcmVlbkNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIndpZHRoIiwiaGVpZ2h0IiwiY29udGV4dCIsImdldENvbnRleHQiLCJkcmF3SW1hZ2UiLCJ0aHVtYm5haWxQcm9taXNlIiwiY29udmVydFRvQmxvYiIsInR5cGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRvQmxvYiIsImltYWdlRGF0YSIsImdldEltYWdlRGF0YSIsImJsdXJoYXNoIiwiQmx1cmhhc2hFbmNvZGVyIiwiaW5zdGFuY2UiLCJnZXRCbHVyaGFzaCIsInRodW1ibmFpbCIsImluZm8iLCJ0aHVtYm5haWxfaW5mbyIsInciLCJoIiwibWltZXR5cGUiLCJzaXplIiwibG9hZEltYWdlRWxlbWVudCIsImltYWdlRmlsZSIsImltZyIsIm9iamVjdFVybCIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImltZ1Byb21pc2UiLCJyZWplY3QiLCJvbmxvYWQiLCJyZXZva2VPYmplY3RVUkwiLCJvbmVycm9yIiwiZSIsInNyYyIsInBhcnNlUHJvbWlzZSIsImhlYWRlcnMiLCJyZWFkRmlsZUFzQXJyYXlCdWZmZXIiLCJ0aGVuIiwiYXJyYXlCdWZmZXIiLCJidWZmZXIiLCJVaW50OEFycmF5IiwiY2h1bmtzIiwiY2h1bmsiLCJuYW1lIiwiZGF0YSIsImJ5dGVMZW5ndGgiLCJsZW5ndGgiLCJldmVyeSIsInZhbCIsImkiLCJoaWRwaSIsImFsbCIsIklNQUdFX1NJWkVfVEhSRVNIT0xEX1RIVU1CTkFJTCIsIklNQUdFX1RIVU1CTkFJTF9NSU5fUkVEVUNUSU9OX1NJWkUiLCJJTUFHRV9USFVNQk5BSUxfTUlOX1JFRFVDVElPTl9QRVJDRU5UIiwiaW5mb0ZvckltYWdlRmlsZSIsIm1hdHJpeENsaWVudCIsInJvb21JZCIsInRodW1ibmFpbFR5cGUiLCJpbWFnZUVsZW1lbnQiLCJyZXN1bHQiLCJpbWFnZUluZm8iLCJzaXplRGlmZmVyZW5jZSIsInVwbG9hZFJlc3VsdCIsInVwbG9hZEZpbGUiLCJ1cmwiLCJmaWxlIiwibG9hZFZpZGVvRWxlbWVudCIsInZpZGVvRmlsZSIsInZpZGVvIiwicHJlbG9hZCIsInBsYXlzSW5saW5lIiwibXV0ZWQiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwiZXYiLCJvbmxvYWRlZGRhdGEiLCJwYXVzZSIsInRhcmdldCIsImxvYWQiLCJwbGF5IiwicmVhZEFzRGF0YVVSTCIsImluZm9Gb3JWaWRlb0ZpbGUiLCJ2aWRlb0luZm8iLCJ2aWRlb1dpZHRoIiwidmlkZW9IZWlnaHQiLCJ0aHVtYm5haWxfdXJsIiwidGh1bWJuYWlsX2ZpbGUiLCJyZWFkQXNBcnJheUJ1ZmZlciIsInByb2dyZXNzSGFuZGxlciIsImNhbmNlbGVkIiwiaXNSb29tRW5jcnlwdGVkIiwidXBsb2FkUHJvbWlzZSIsInByb20iLCJlbmNyeXB0IiwiZW5jcnlwdEF0dGFjaG1lbnQiLCJlbmNyeXB0UmVzdWx0IiwiYmxvYiIsIkJsb2IiLCJ1cGxvYWRDb250ZW50IiwiaW5jbHVkZUZpbGVuYW1lIiwiYWJvcnQiLCJjYW5jZWxVcGxvYWQiLCJiYXNlUHJvbWlzZSIsInByb21pc2UxIiwiQ29udGVudE1lc3NhZ2VzIiwic2VuZFN0aWNrZXJDb250ZW50VG9Sb29tIiwidGV4dCIsInN0YXJ0VGltZSIsIkNvdW50bHlBbmFseXRpY3MiLCJnZXRUaW1lc3RhbXAiLCJzZW5kU3RpY2tlck1lc3NhZ2UiLCJjYXRjaCIsImxvZ2dlciIsIndhcm4iLCJ0cmFja1NlbmRNZXNzYWdlIiwibXNndHlwZSIsImdldFVwbG9hZExpbWl0IiwibWVkaWFDb25maWciLCJ1bmRlZmluZWQiLCJzZW5kQ29udGVudExpc3RUb1Jvb20iLCJmaWxlcyIsInJlbGF0aW9uIiwiaXNHdWVzdCIsImRpcyIsImRpc3BhdGNoIiwiYWN0aW9uIiwiaXNRdW90aW5nIiwiQm9vbGVhbiIsIlJvb21WaWV3U3RvcmUiLCJnZXRRdW90aW5nRXZlbnQiLCJRdWVzdGlvbkRpYWxvZyIsInNkayIsImdldENvbXBvbmVudCIsImZpbmlzaGVkIiwiTW9kYWwiLCJjcmVhdGVUcmFja2VkRGlhbG9nIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsImhhc0NhbmNlbEJ1dHRvbiIsImJ1dHRvbiIsInNob3VsZFVwbG9hZCIsIm1vZGFsIiwiY3JlYXRlRGlhbG9nIiwiU3Bpbm5lciIsImVuc3VyZU1lZGlhQ29uZmlnRmV0Y2hlZCIsImNsb3NlIiwidG9vQmlnRmlsZXMiLCJva0ZpbGVzIiwiaXNGaWxlU2l6ZUFjY2VwdGFibGUiLCJwdXNoIiwiVXBsb2FkRmFpbHVyZURpYWxvZyIsImJhZEZpbGVzIiwidG90YWxGaWxlcyIsImNvbnRlbnRNZXNzYWdlcyIsInNob3VsZENvbnRpbnVlIiwidXBsb2FkQWxsIiwicHJvbUJlZm9yZSIsIlVwbG9hZENvbmZpcm1EaWFsb2ciLCJjdXJyZW50SW5kZXgiLCJzaG91bGRVcGxvYWRBbGwiLCJzZW5kQ29udGVudFRvUm9vbSIsImdldEN1cnJlbnRVcGxvYWRzIiwiaW5wcm9ncmVzcyIsImZpbHRlciIsInVwbG9hZCIsIm5vUmVsYXRpb24iLCJtYXRjaGluZ1JlbGF0aW9uIiwicmVsX3R5cGUiLCJldmVudF9pZCIsInUiLCJwcm9taXNlIiwiQWN0aW9uIiwiVXBsb2FkQ2FuY2VsZWQiLCJjb250ZW50IiwiYm9keSIsIlNldHRpbmdzU3RvcmUiLCJnZXRWYWx1ZSIsImluZGV4T2YiLCJNc2dUeXBlIiwiSW1hZ2UiLCJPYmplY3QiLCJhc3NpZ24iLCJlcnJvciIsIkZpbGUiLCJBdWRpbyIsIlZpZGVvIiwiZmlsZU5hbWUiLCJ0b3RhbCIsImxvYWRlZCIsIlVwbG9hZFN0YXJ0ZWQiLCJmaXJlIiwiRm9jdXNTZW5kTWVzc2FnZUNvbXBvc2VyIiwib25Qcm9ncmVzcyIsIlVwbG9hZFByb2dyZXNzIiwidGhyZWFkSWQiLCJSZWxhdGlvblR5cGUiLCJUaHJlYWQiLCJzZW5kTWVzc2FnZSIsInJlc3AiLCJlcnIiLCJkZXNjIiwiaHR0cF9zdGF0dXMiLCJFcnJvckRpYWxvZyIsImZpbmFsbHkiLCJzcGxpY2UiLCJVcGxvYWRGYWlsZWQiLCJVcGxvYWRGaW5pc2hlZCIsImxvZyIsImdldE1lZGlhQ29uZmlnIiwiY29uZmlnIiwic2hhcmVkSW5zdGFuY2UiLCJteENvbnRlbnRNZXNzYWdlcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBa0JBOztBQUlBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQVVBOztBQUNBOztBQUNBOztBQUVBOzs7Ozs7Ozs7O0FBR0EsTUFBTUEsU0FBUyxHQUFHLEdBQWxCO0FBQ0EsTUFBTUMsVUFBVSxHQUFHLEdBQW5CLEMsQ0FFQTtBQUNBOztBQUNBLE1BQU1DLFVBQVUsR0FBRyxDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixJQUFuQixFQUF5QixJQUF6QixFQUErQixJQUEvQixFQUFxQyxJQUFyQyxFQUEyQyxJQUEzQyxFQUFpRCxJQUFqRCxDQUFuQjtBQUVPLE1BQU1DLGNBQWMsR0FBRyxzQkFBdkIsQyxDQUErQzs7OztBQUUvQyxNQUFNQyxtQkFBTixTQUFrQ0MsS0FBbEMsQ0FBd0M7Ozs7QUFtQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWVDLGVBQWYsQ0FDSUMsT0FESixFQUVJQyxVQUZKLEVBR0lDLFdBSEosRUFJSUMsUUFKSixFQUt1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ekYsWUFBRCxFQUE2QjtBQUN6RCxRQUFJLEtBQUs4RCxXQUFMLEtBQXFCLElBQXpCLEVBQStCOztBQUUvQkwsbUJBQU8rRixHQUFQLENBQVcseUJBQVg7O0FBQ0EsV0FBT3hKLFlBQVksQ0FBQ3lKLGNBQWIsR0FBOEI1SyxJQUE5QixDQUFvQzZLLE1BQUQsSUFBWTtBQUNsRGpHLHFCQUFPK0YsR0FBUCxDQUFXLGdDQUFYLEVBQTZDRSxNQUE3Qzs7QUFDQSxhQUFPQSxNQUFQO0FBQ0gsS0FITSxFQUdKbEcsS0FISSxDQUdFLE1BQU07QUFDWDtBQUNBQyxxQkFBTytGLEdBQVAsQ0FBVyxpRUFBWDs7QUFDQSxhQUFPLEVBQVA7QUFDSCxLQVBNLEVBT0ozSyxJQVBJLENBT0U2SyxNQUFELElBQVk7QUFDaEIsV0FBSzVGLFdBQUwsR0FBbUI0RixNQUFuQjtBQUNILEtBVE0sQ0FBUDtBQVVIOztBQUVvQixTQUFkQyxjQUFjLEdBQUc7QUFDcEIsUUFBSTFOLE1BQU0sQ0FBQzJOLGlCQUFQLEtBQTZCN0YsU0FBakMsRUFBNEM7QUFDeEM5SCxNQUFBQSxNQUFNLENBQUMyTixpQkFBUCxHQUEyQixJQUFJM0csZUFBSixFQUEzQjtBQUNIOztBQUNELFdBQU9oSCxNQUFNLENBQUMyTixpQkFBZDtBQUNIOztBQTNUZ0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMTUsIDIwMTYgT3Blbk1hcmtldCBMdGRcbkNvcHlyaWdodCAyMDE5IE5ldyBWZWN0b3IgTHRkXG5Db3B5cmlnaHQgMjAyMCBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IE1hdHJpeENsaWVudCB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9jbGllbnRcIjtcbmltcG9ydCB7IElFbmNyeXB0ZWRGaWxlLCBJTWVkaWFFdmVudEluZm8gfSBmcm9tIFwiLi9jdXN0b21pc2F0aW9ucy9tb2RlbHMvSU1lZGlhRXZlbnRDb250ZW50XCI7XG5pbXBvcnQgeyBJVXBsb2FkT3B0cyB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9AdHlwZXMvcmVxdWVzdHNcIjtcbmltcG9ydCB7IE1zZ1R5cGUsIFJlbGF0aW9uVHlwZSB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9AdHlwZXMvZXZlbnRcIjtcblxuaW1wb3J0IGRpcyBmcm9tICcuL2Rpc3BhdGNoZXIvZGlzcGF0Y2hlcic7XG5pbXBvcnQgKiBhcyBzZGsgZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgeyBfdCB9IGZyb20gJy4vbGFuZ3VhZ2VIYW5kbGVyJztcbmltcG9ydCBNb2RhbCBmcm9tICcuL01vZGFsJztcbmltcG9ydCBSb29tVmlld1N0b3JlIGZyb20gJy4vc3RvcmVzL1Jvb21WaWV3U3RvcmUnO1xuaW1wb3J0IGVuY3J5cHQgZnJvbSBcImJyb3dzZXItZW5jcnlwdC1hdHRhY2htZW50XCI7XG5pbXBvcnQgZXh0cmFjdFBuZ0NodW5rcyBmcm9tIFwicG5nLWNodW5rcy1leHRyYWN0XCI7XG5pbXBvcnQgU3Bpbm5lciBmcm9tIFwiLi9jb21wb25lbnRzL3ZpZXdzL2VsZW1lbnRzL1NwaW5uZXJcIjtcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gXCIuL2Rpc3BhdGNoZXIvYWN0aW9uc1wiO1xuaW1wb3J0IENvdW50bHlBbmFseXRpY3MgZnJvbSBcIi4vQ291bnRseUFuYWx5dGljc1wiO1xuaW1wb3J0IHtcbiAgICBVcGxvYWRDYW5jZWxlZFBheWxvYWQsXG4gICAgVXBsb2FkRXJyb3JQYXlsb2FkLFxuICAgIFVwbG9hZEZpbmlzaGVkUGF5bG9hZCxcbiAgICBVcGxvYWRQcm9ncmVzc1BheWxvYWQsXG4gICAgVXBsb2FkU3RhcnRlZFBheWxvYWQsXG59IGZyb20gXCIuL2Rpc3BhdGNoZXIvcGF5bG9hZHMvVXBsb2FkUGF5bG9hZFwiO1xuaW1wb3J0IHsgSVVwbG9hZCB9IGZyb20gXCIuL21vZGVscy9JVXBsb2FkXCI7XG5pbXBvcnQgeyBJQWJvcnRhYmxlUHJvbWlzZSwgSUltYWdlSW5mbyB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9AdHlwZXMvcGFydGlhbHNcIjtcbmltcG9ydCB7IEJsdXJoYXNoRW5jb2RlciB9IGZyb20gXCIuL0JsdXJoYXNoRW5jb2RlclwiO1xuaW1wb3J0IFNldHRpbmdzU3RvcmUgZnJvbSBcIi4vc2V0dGluZ3MvU2V0dGluZ3NTdG9yZVwiO1xuaW1wb3J0IHsgZGVjb3JhdGVTdGFydFNlbmRpbmdUaW1lLCBzZW5kUm91bmRUcmlwTWV0cmljIH0gZnJvbSBcIi4vc2VuZFRpbWVQZXJmb3JtYW5jZU1ldHJpY3NcIjtcblxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL2xvZ2dlclwiO1xuaW1wb3J0IHsgSUV2ZW50UmVsYXRpb24gfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmNcIjtcblxuY29uc3QgTUFYX1dJRFRIID0gODAwO1xuY29uc3QgTUFYX0hFSUdIVCA9IDYwMDtcblxuLy8gc2NyYXBlZCBvdXQgb2YgYSBtYWNPUyBoaWRwaSAoNTY2MHBwbSkgc2NyZWVuc2hvdCBwbmdcbi8vICAgICAgICAgICAgICAgICAgNTY2OSBweCAoeC1heGlzKSAgICAgICwgNTY2OSBweCAoeS1heGlzKSAgICAgICwgcGVyIG1ldHJlXG5jb25zdCBQSFlTX0hJRFBJID0gWzB4MDAsIDB4MDAsIDB4MTYsIDB4MjUsIDB4MDAsIDB4MDAsIDB4MTYsIDB4MjUsIDB4MDFdO1xuXG5leHBvcnQgY29uc3QgQkxVUkhBU0hfRklFTEQgPSBcInh5ei5hbW9yZ2FuLmJsdXJoYXNoXCI7IC8vIE1TQzI0NDhcblxuZXhwb3J0IGNsYXNzIFVwbG9hZENhbmNlbGVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG50eXBlIFRodW1ibmFpbGFibGVFbGVtZW50ID0gSFRNTEltYWdlRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnQ7XG5cbmludGVyZmFjZSBJTWVkaWFDb25maWcge1xuICAgIFwibS51cGxvYWQuc2l6ZVwiPzogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgSUNvbnRlbnQge1xuICAgIGJvZHk6IHN0cmluZztcbiAgICBtc2d0eXBlOiBzdHJpbmc7XG4gICAgaW5mbzoge1xuICAgICAgICBzaXplOiBudW1iZXI7XG4gICAgICAgIG1pbWV0eXBlPzogc3RyaW5nO1xuICAgIH07XG4gICAgZmlsZT86IHN0cmluZztcbiAgICB1cmw/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBJVGh1bWJuYWlsIHtcbiAgICBpbmZvOiB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcbiAgICAgICAgdGh1bWJuYWlsX2luZm86IHtcbiAgICAgICAgICAgIHc6IG51bWJlcjtcbiAgICAgICAgICAgIGg6IG51bWJlcjtcbiAgICAgICAgICAgIG1pbWV0eXBlOiBzdHJpbmc7XG4gICAgICAgICAgICBzaXplOiBudW1iZXI7XG4gICAgICAgIH07XG4gICAgICAgIHc6IG51bWJlcjtcbiAgICAgICAgaDogbnVtYmVyO1xuICAgICAgICBbQkxVUkhBU0hfRklFTERdOiBzdHJpbmc7XG4gICAgfTtcbiAgICB0aHVtYm5haWw6IEJsb2I7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgdGh1bWJuYWlsIGZvciBhIGltYWdlIERPTSBlbGVtZW50LlxuICogVGhlIGltYWdlIHdpbGwgYmUgc21hbGxlciB0aGFuIE1BWF9XSURUSCBhbmQgTUFYX0hFSUdIVC5cbiAqIFRoZSB0aHVtYm5haWwgd2lsbCBoYXZlIHRoZSBzYW1lIGFzcGVjdCByYXRpbyBhcyB0aGUgb3JpZ2luYWwuXG4gKiBEcmF3cyB0aGUgZWxlbWVudCBpbnRvIGEgY2FudmFzIHVzaW5nIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5kcmF3SW1hZ2VcbiAqIFRoZW4gY2FsbHMgQ2FudmFzLnRvQmxvYiB0byBnZXQgYSBibG9iIG9iamVjdCBmb3IgdGhlIGltYWdlIGRhdGEuXG4gKlxuICogU2luY2UgaXQgbmVlZHMgdG8gY2FsY3VsYXRlIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBzb3VyY2UgaW1hZ2UgYW5kIHRoZVxuICogdGh1bWJuYWlsZWQgaW1hZ2UgaXQgcmV0dXJucyBhbiBpbmZvIG9iamVjdCBmaWxsZWQgb3V0IHdpdGggaW5mb3JtYXRpb25cbiAqIGFib3V0IHRoZSBvcmlnaW5hbCBpbWFnZSBhbmQgdGhlIHRodW1ibmFpbC5cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIHRodW1ibmFpbC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnB1dFdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgaW1hZ2UgaW4gdGhlIGlucHV0IGVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5wdXRIZWlnaHQgdGhlIHdpZHRoIG9mIHRoZSBpbWFnZSBpbiB0aGUgaW5wdXQgZWxlbWVudC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lVHlwZSBUaGUgbWltZVR5cGUgdG8gc2F2ZSB0aGUgYmxvYiBhcy5cbiAqIEByZXR1cm4ge1Byb21pc2V9IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYW4gb2JqZWN0IHdpdGggYW4gaW5mbyBrZXlcbiAqICBhbmQgYSB0aHVtYm5haWwga2V5LlxuICovXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVUaHVtYm5haWwoXG4gICAgZWxlbWVudDogVGh1bWJuYWlsYWJsZUVsZW1lbnQsXG4gICAgaW5wdXRXaWR0aDogbnVtYmVyLFxuICAgIGlucHV0SGVpZ2h0OiBudW1iZXIsXG4gICAgbWltZVR5cGU6IHN0cmluZyxcbik6IFByb21pc2U8SVRodW1ibmFpbD4ge1xuICAgIGxldCB0YXJnZXRXaWR0aCA9IGlucHV0V2lkdGg7XG4gICAgbGV0IHRhcmdldEhlaWdodCA9IGlucHV0SGVpZ2h0O1xuICAgIGlmICh0YXJnZXRIZWlnaHQgPiBNQVhfSEVJR0hUKSB7XG4gICAgICAgIHRhcmdldFdpZHRoID0gTWF0aC5mbG9vcih0YXJnZXRXaWR0aCAqIChNQVhfSEVJR0hUIC8gdGFyZ2V0SGVpZ2h0KSk7XG4gICAgICAgIHRhcmdldEhlaWdodCA9IE1BWF9IRUlHSFQ7XG4gICAgfVxuICAgIGlmICh0YXJnZXRXaWR0aCA+IE1BWF9XSURUSCkge1xuICAgICAgICB0YXJnZXRIZWlnaHQgPSBNYXRoLmZsb29yKHRhcmdldEhlaWdodCAqIChNQVhfV0lEVEggLyB0YXJnZXRXaWR0aCkpO1xuICAgICAgICB0YXJnZXRXaWR0aCA9IE1BWF9XSURUSDtcbiAgICB9XG5cbiAgICBsZXQgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IE9mZnNjcmVlbkNhbnZhcztcbiAgICBpZiAod2luZG93Lk9mZnNjcmVlbkNhbnZhcykge1xuICAgICAgICBjYW52YXMgPSBuZXcgd2luZG93Lk9mZnNjcmVlbkNhbnZhcyh0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICBjYW52YXMud2lkdGggPSB0YXJnZXRXaWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRhcmdldEhlaWdodDtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBjb250ZXh0LmRyYXdJbWFnZShlbGVtZW50LCAwLCAwLCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0KTtcblxuICAgIGxldCB0aHVtYm5haWxQcm9taXNlOiBQcm9taXNlPEJsb2I+O1xuXG4gICAgaWYgKHdpbmRvdy5PZmZzY3JlZW5DYW52YXMpIHtcbiAgICAgICAgdGh1bWJuYWlsUHJvbWlzZSA9IChjYW52YXMgYXMgT2Zmc2NyZWVuQ2FudmFzKS5jb252ZXJ0VG9CbG9iKHsgdHlwZTogbWltZVR5cGUgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGh1bWJuYWlsUHJvbWlzZSA9IG5ldyBQcm9taXNlPEJsb2I+KHJlc29sdmUgPT4gKGNhbnZhcyBhcyBIVE1MQ2FudmFzRWxlbWVudCkudG9CbG9iKHJlc29sdmUsIG1pbWVUeXBlKSk7XG4gICAgfVxuXG4gICAgY29uc3QgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCk7XG4gICAgLy8gdGh1bWJuYWlsUHJvbWlzZSBhbmQgYmx1cmhhc2ggcHJvbWlzZSBhcmUgYmVpbmcgYXdhaXRlZCBjb25jdXJyZW50bHlcbiAgICBjb25zdCBibHVyaGFzaCA9IGF3YWl0IEJsdXJoYXNoRW5jb2Rlci5pbnN0YW5jZS5nZXRCbHVyaGFzaChpbWFnZURhdGEpO1xuICAgIGNvbnN0IHRodW1ibmFpbCA9IGF3YWl0IHRodW1ibmFpbFByb21pc2U7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgICB0aHVtYm5haWxfaW5mbzoge1xuICAgICAgICAgICAgICAgIHc6IHRhcmdldFdpZHRoLFxuICAgICAgICAgICAgICAgIGg6IHRhcmdldEhlaWdodCxcbiAgICAgICAgICAgICAgICBtaW1ldHlwZTogdGh1bWJuYWlsLnR5cGUsXG4gICAgICAgICAgICAgICAgc2l6ZTogdGh1bWJuYWlsLnNpemUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdzogaW5wdXRXaWR0aCxcbiAgICAgICAgICAgIGg6IGlucHV0SGVpZ2h0LFxuICAgICAgICAgICAgW0JMVVJIQVNIX0ZJRUxEXTogYmx1cmhhc2gsXG4gICAgICAgIH0sXG4gICAgICAgIHRodW1ibmFpbCxcbiAgICB9O1xufVxuXG4vKipcbiAqIExvYWQgYSBmaWxlIGludG8gYSBuZXdseSBjcmVhdGVkIGltYWdlIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtGaWxlfSBpbWFnZUZpbGUgVGhlIGZpbGUgdG8gbG9hZCBpbiBhbiBpbWFnZSBlbGVtZW50LlxuICogQHJldHVybiB7UHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgaHRtbCBpbWFnZSBlbGVtZW50LlxuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkSW1hZ2VFbGVtZW50KGltYWdlRmlsZTogRmlsZSkge1xuICAgIC8vIExvYWQgdGhlIGZpbGUgaW50byBhbiBodG1sIGVsZW1lbnRcbiAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgIGNvbnN0IG9iamVjdFVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoaW1hZ2VGaWxlKTtcbiAgICBjb25zdCBpbWdQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKG9iamVjdFVybCk7XG4gICAgICAgICAgICByZXNvbHZlKGltZyk7XG4gICAgICAgIH07XG4gICAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIGltZy5zcmMgPSBvYmplY3RVcmw7XG5cbiAgICAvLyBjaGVjayBmb3IgaGktZHBpIFBOR3MgYW5kIGZ1ZGdlIGRpc3BsYXkgcmVzb2x1dGlvbiBhcyBuZWVkZWQuXG4gICAgLy8gdGhpcyBpcyBtYWlubHkgbmVlZGVkIGZvciBtYWNPUyBzY3JlZW5jYXBzXG4gICAgbGV0IHBhcnNlUHJvbWlzZTtcbiAgICBpZiAoaW1hZ2VGaWxlLnR5cGUgPT09IFwiaW1hZ2UvcG5nXCIpIHtcbiAgICAgICAgLy8gaW4gcHJhY3RpY2UgbWFjT1MgaGFwcGVucyB0byBvcmRlciB0aGUgY2h1bmtzIHNvIHRoZXkgZmFsbCBpblxuICAgICAgICAvLyB0aGUgZmlyc3QgMHgxMDAwIGJ5dGVzICh0aGFua3MgdG8gYSBtYXNzaXZlIElDQyBoZWFkZXIpLlxuICAgICAgICAvLyBUaHVzIHdlIGNvdWxkIHNsaWNlIHRoZSBmaWxlIGRvd24gdG8gb25seSBzbmlmZiB0aGUgZmlyc3QgMHgxMDAwXG4gICAgICAgIC8vIGJ5dGVzIChidXQgdGhpcyBtYWtlcyBleHRyYWN0UG5nQ2h1bmtzIGNob2tlIG9uIHRoZSBjb3JydXB0IGZpbGUpXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBpbWFnZUZpbGU7IC8vLnNsaWNlKDAsIDB4MTAwMCk7XG4gICAgICAgIHBhcnNlUHJvbWlzZSA9IHJlYWRGaWxlQXNBcnJheUJ1ZmZlcihoZWFkZXJzKS50aGVuKGFycmF5QnVmZmVyID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rcyA9IGV4dHJhY3RQbmdDaHVua3MoYnVmZmVyKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNodW5rLm5hbWUgPT09ICdwSFlzJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmsuZGF0YS5ieXRlTGVuZ3RoICE9PSBQSFlTX0hJRFBJLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2h1bmsuZGF0YS5ldmVyeSgodmFsLCBpKSA9PiB2YWwgPT09IFBIWVNfSElEUElbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgW2hpZHBpXSA9IGF3YWl0IFByb21pc2UuYWxsKFtwYXJzZVByb21pc2UsIGltZ1Byb21pc2VdKTtcbiAgICBjb25zdCB3aWR0aCA9IGhpZHBpID8gKGltZy53aWR0aCA+PiAxKSA6IGltZy53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBoaWRwaSA/IChpbWcuaGVpZ2h0ID4+IDEpIDogaW1nLmhlaWdodDtcbiAgICByZXR1cm4geyB3aWR0aCwgaGVpZ2h0LCBpbWcgfTtcbn1cblxuLy8gTWluaW11bSBzaXplIGZvciBpbWFnZSBmaWxlcyBiZWZvcmUgd2UgZ2VuZXJhdGUgYSB0aHVtYm5haWwgZm9yIHRoZW0uXG5jb25zdCBJTUFHRV9TSVpFX1RIUkVTSE9MRF9USFVNQk5BSUwgPSAxIDw8IDE1OyAvLyAzMktCXG4vLyBNaW5pbXVtIHNpemUgaW1wcm92ZW1lbnQgZm9yIGltYWdlIHRodW1ibmFpbHMsIGlmIGJvdGggYXJlIG5vdCBtZXQgdGhlbiBkb24ndCBib3RoZXIgdXBsb2FkaW5nIHRodW1ibmFpbC5cbmNvbnN0IElNQUdFX1RIVU1CTkFJTF9NSU5fUkVEVUNUSU9OX1NJWkUgPSAxIDw8IDE2OyAvLyAxTUJcbmNvbnN0IElNQUdFX1RIVU1CTkFJTF9NSU5fUkVEVUNUSU9OX1BFUkNFTlQgPSAwLjE7IC8vIDEwJVxuLy8gV2UgZG9uJ3QgYXBwbHkgdGhlc2UgdGhyZXNob2xkcyB0byB2aWRlbyB0aHVtYm5haWxzIGFzIGEgcG9zdGVyIGltYWdlIGlzIGFsd2F5cyB1c2VmdWxcbi8vIGFuZCB2aWRlb3MgdGVuZCB0byBiZSBtdWNoIGxhcmdlci5cblxuLyoqXG4gKiBSZWFkIHRoZSBtZXRhZGF0YSBmb3IgYW4gaW1hZ2UgZmlsZSBhbmQgY3JlYXRlIGFuZCB1cGxvYWQgYSB0aHVtYm5haWwgb2YgdGhlIGltYWdlLlxuICpcbiAqIEBwYXJhbSB7TWF0cml4Q2xpZW50fSBtYXRyaXhDbGllbnQgQSBtYXRyaXhDbGllbnQgdG8gdXBsb2FkIHRoZSB0aHVtYm5haWwgd2l0aC5cbiAqIEBwYXJhbSB7U3RyaW5nfSByb29tSWQgVGhlIElEIG9mIHRoZSByb29tIHRoZSBpbWFnZSB3aWxsIGJlIHVwbG9hZGVkIGluLlxuICogQHBhcmFtIHtGaWxlfSBpbWFnZUZpbGUgVGhlIGltYWdlIHRvIHJlYWQgYW5kIHRodW1ibmFpbC5cbiAqIEByZXR1cm4ge1Byb21pc2V9IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGF0dGFjaG1lbnQgaW5mby5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaW5mb0ZvckltYWdlRmlsZShtYXRyaXhDbGllbnQ6IE1hdHJpeENsaWVudCwgcm9vbUlkOiBzdHJpbmcsIGltYWdlRmlsZTogRmlsZSkge1xuICAgIGxldCB0aHVtYm5haWxUeXBlID0gXCJpbWFnZS9wbmdcIjtcbiAgICBpZiAoaW1hZ2VGaWxlLnR5cGUgPT09IFwiaW1hZ2UvanBlZ1wiKSB7XG4gICAgICAgIHRodW1ibmFpbFR5cGUgPSBcImltYWdlL2pwZWdcIjtcbiAgICB9XG5cbiAgICBjb25zdCBpbWFnZUVsZW1lbnQgPSBhd2FpdCBsb2FkSW1hZ2VFbGVtZW50KGltYWdlRmlsZSk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjcmVhdGVUaHVtYm5haWwoaW1hZ2VFbGVtZW50LmltZywgaW1hZ2VFbGVtZW50LndpZHRoLCBpbWFnZUVsZW1lbnQuaGVpZ2h0LCB0aHVtYm5haWxUeXBlKTtcbiAgICBjb25zdCBpbWFnZUluZm8gPSByZXN1bHQuaW5mbztcblxuICAgIC8vIHdlIGRvIGFsbCBzaXppbmcgY2hlY2tzIGhlcmUgYmVjYXVzZSB3ZSBzdGlsbCByZWx5IG9uIHRodW1ibmFpbCBnZW5lcmF0aW9uIGZvciBtYWtpbmcgYSBibHVyaGFzaCBmcm9tLlxuICAgIGNvbnN0IHNpemVEaWZmZXJlbmNlID0gaW1hZ2VGaWxlLnNpemUgLSBpbWFnZUluZm8udGh1bWJuYWlsX2luZm8uc2l6ZTtcbiAgICBpZiAoXG4gICAgICAgIGltYWdlRmlsZS5zaXplIDw9IElNQUdFX1NJWkVfVEhSRVNIT0xEX1RIVU1CTkFJTCB8fCAvLyBpbWFnZSBpcyBzbWFsbCBlbm91Z2ggYWxyZWFkeVxuICAgICAgICAoc2l6ZURpZmZlcmVuY2UgPD0gSU1BR0VfVEhVTUJOQUlMX01JTl9SRURVQ1RJT05fU0laRSAmJiAvLyB0aHVtYm5haWwgaXMgbm90IHN1ZmZpY2llbnRseSBzbWFsbGVyIHRoYW4gb3JpZ2luYWxcbiAgICAgICAgICAgIHNpemVEaWZmZXJlbmNlIDw9IChpbWFnZUZpbGUuc2l6ZSAqIElNQUdFX1RIVU1CTkFJTF9NSU5fUkVEVUNUSU9OX1BFUkNFTlQpKVxuICAgICkge1xuICAgICAgICBkZWxldGUgaW1hZ2VJbmZvW1widGh1bWJuYWlsX2luZm9cIl07XG4gICAgICAgIHJldHVybiBpbWFnZUluZm87XG4gICAgfVxuXG4gICAgY29uc3QgdXBsb2FkUmVzdWx0ID0gYXdhaXQgdXBsb2FkRmlsZShtYXRyaXhDbGllbnQsIHJvb21JZCwgcmVzdWx0LnRodW1ibmFpbCk7XG5cbiAgICBpbWFnZUluZm9bXCJ0aHVtYm5haWxfdXJsXCJdID0gdXBsb2FkUmVzdWx0LnVybDtcbiAgICBpbWFnZUluZm9bXCJ0aHVtYm5haWxfZmlsZVwiXSA9IHVwbG9hZFJlc3VsdC5maWxlO1xuICAgIHJldHVybiBpbWFnZUluZm87XG59XG5cbi8qKlxuICogTG9hZCBhIGZpbGUgaW50byBhIG5ld2x5IGNyZWF0ZWQgdmlkZW8gZWxlbWVudCBhbmQgcHVsbCBzb21lIHN0cmluZ3NcbiAqIGluIGFuIGF0dGVtcHQgdG8gZ3VhcmFudGVlIHRoZSBmaXJzdCBmcmFtZSB3aWxsIGJlIHNob3dpbmcuXG4gKlxuICogQHBhcmFtIHtGaWxlfSB2aWRlb0ZpbGUgVGhlIGZpbGUgdG8gbG9hZCBpbiBhbiB2aWRlbyBlbGVtZW50LlxuICogQHJldHVybiB7UHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgdmlkZW8gaW1hZ2UgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gbG9hZFZpZGVvRWxlbWVudCh2aWRlb0ZpbGUpOiBQcm9taXNlPEhUTUxWaWRlb0VsZW1lbnQ+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAvLyBMb2FkIHRoZSBmaWxlIGludG8gYW4gaHRtbCBlbGVtZW50XG4gICAgICAgIGNvbnN0IHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpO1xuICAgICAgICB2aWRlby5wcmVsb2FkID0gXCJtZXRhZGF0YVwiO1xuICAgICAgICB2aWRlby5wbGF5c0lubGluZSA9IHRydWU7XG4gICAgICAgIHZpZGVvLm11dGVkID0gdHJ1ZTtcblxuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgLy8gV2FpdCB1bnRpbCB3ZSBoYXZlIGVub3VnaCBkYXRhIHRvIHRodW1ibmFpbCB0aGUgZmlyc3QgZnJhbWUuXG4gICAgICAgICAgICB2aWRlby5vbmxvYWRlZGRhdGEgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHZpZGVvKTtcbiAgICAgICAgICAgICAgICB2aWRlby5wYXVzZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZpZGVvLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmlkZW8uc3JjID0gZXYudGFyZ2V0LnJlc3VsdCBhcyBzdHJpbmc7XG4gICAgICAgICAgICB2aWRlby5sb2FkKCk7XG4gICAgICAgICAgICB2aWRlby5wbGF5KCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9O1xuICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTCh2aWRlb0ZpbGUpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFJlYWQgdGhlIG1ldGFkYXRhIGZvciBhIHZpZGVvIGZpbGUgYW5kIGNyZWF0ZSBhbmQgdXBsb2FkIGEgdGh1bWJuYWlsIG9mIHRoZSB2aWRlby5cbiAqXG4gKiBAcGFyYW0ge01hdHJpeENsaWVudH0gbWF0cml4Q2xpZW50IEEgbWF0cml4Q2xpZW50IHRvIHVwbG9hZCB0aGUgdGh1bWJuYWlsIHdpdGguXG4gKiBAcGFyYW0ge1N0cmluZ30gcm9vbUlkIFRoZSBJRCBvZiB0aGUgcm9vbSB0aGUgdmlkZW8gd2lsbCBiZSB1cGxvYWRlZCB0by5cbiAqIEBwYXJhbSB7RmlsZX0gdmlkZW9GaWxlIFRoZSB2aWRlbyB0byByZWFkIGFuZCB0aHVtYm5haWwuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBhdHRhY2htZW50IGluZm8uXG4gKi9cbmZ1bmN0aW9uIGluZm9Gb3JWaWRlb0ZpbGUobWF0cml4Q2xpZW50LCByb29tSWQsIHZpZGVvRmlsZSkge1xuICAgIGNvbnN0IHRodW1ibmFpbFR5cGUgPSBcImltYWdlL2pwZWdcIjtcblxuICAgIGxldCB2aWRlb0luZm86IFBhcnRpYWw8SU1lZGlhRXZlbnRJbmZvPjtcbiAgICByZXR1cm4gbG9hZFZpZGVvRWxlbWVudCh2aWRlb0ZpbGUpLnRoZW4oKHZpZGVvKSA9PiB7XG4gICAgICAgIHJldHVybiBjcmVhdGVUaHVtYm5haWwodmlkZW8sIHZpZGVvLnZpZGVvV2lkdGgsIHZpZGVvLnZpZGVvSGVpZ2h0LCB0aHVtYm5haWxUeXBlKTtcbiAgICB9KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgdmlkZW9JbmZvID0gcmVzdWx0LmluZm87XG4gICAgICAgIHJldHVybiB1cGxvYWRGaWxlKG1hdHJpeENsaWVudCwgcm9vbUlkLCByZXN1bHQudGh1bWJuYWlsKTtcbiAgICB9KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgdmlkZW9JbmZvLnRodW1ibmFpbF91cmwgPSByZXN1bHQudXJsO1xuICAgICAgICB2aWRlb0luZm8udGh1bWJuYWlsX2ZpbGUgPSByZXN1bHQuZmlsZTtcbiAgICAgICAgcmV0dXJuIHZpZGVvSW5mbztcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBSZWFkIHRoZSBmaWxlIGFzIGFuIEFycmF5QnVmZmVyLlxuICogQHBhcmFtIHtGaWxlfSBmaWxlIFRoZSBmaWxlIHRvIHJlYWRcbiAqIEByZXR1cm4ge1Byb21pc2V9IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYW4gQXJyYXlCdWZmZXIgd2hlbiB0aGUgZmlsZVxuICogICBpcyByZWFkLlxuICovXG5mdW5jdGlvbiByZWFkRmlsZUFzQXJyYXlCdWZmZXIoZmlsZTogRmlsZSB8IEJsb2IpOiBQcm9taXNlPEFycmF5QnVmZmVyPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJlc29sdmUoZS50YXJnZXQucmVzdWx0IGFzIEFycmF5QnVmZmVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihmaWxlKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBVcGxvYWQgdGhlIGZpbGUgdG8gdGhlIGNvbnRlbnQgcmVwb3NpdG9yeS5cbiAqIElmIHRoZSByb29tIGlzIGVuY3J5cHRlZCB0aGVuIGVuY3J5cHQgdGhlIGZpbGUgYmVmb3JlIHVwbG9hZGluZy5cbiAqXG4gKiBAcGFyYW0ge01hdHJpeENsaWVudH0gbWF0cml4Q2xpZW50IFRoZSBtYXRyaXggY2xpZW50IHRvIHVwbG9hZCB0aGUgZmlsZSB3aXRoLlxuICogQHBhcmFtIHtTdHJpbmd9IHJvb21JZCBUaGUgSUQgb2YgdGhlIHJvb20gYmVpbmcgdXBsb2FkZWQgdG8uXG4gKiBAcGFyYW0ge0ZpbGV9IGZpbGUgVGhlIGZpbGUgdG8gdXBsb2FkLlxuICogQHBhcmFtIHtGdW5jdGlvbj99IHByb2dyZXNzSGFuZGxlciBvcHRpb25hbCBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2hlbiBhIGNodW5rIG9mXG4gKiAgICBkYXRhIGlzIHVwbG9hZGVkLlxuICogQHJldHVybiB7UHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhbiBvYmplY3QuXG4gKiAgSWYgdGhlIGZpbGUgaXMgdW5lbmNyeXB0ZWQgdGhlbiB0aGUgb2JqZWN0IHdpbGwgaGF2ZSBhIFwidXJsXCIga2V5LlxuICogIElmIHRoZSBmaWxlIGlzIGVuY3J5cHRlZCB0aGVuIHRoZSBvYmplY3Qgd2lsbCBoYXZlIGEgXCJmaWxlXCIga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBsb2FkRmlsZShcbiAgICBtYXRyaXhDbGllbnQ6IE1hdHJpeENsaWVudCxcbiAgICByb29tSWQ6IHN0cmluZyxcbiAgICBmaWxlOiBGaWxlIHwgQmxvYixcbiAgICBwcm9ncmVzc0hhbmRsZXI/OiBJVXBsb2FkT3B0c1tcInByb2dyZXNzSGFuZGxlclwiXSxcbik6IElBYm9ydGFibGVQcm9taXNlPHsgdXJsPzogc3RyaW5nLCBmaWxlPzogSUVuY3J5cHRlZEZpbGUgfT4ge1xuICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xuICAgIGlmIChtYXRyaXhDbGllbnQuaXNSb29tRW5jcnlwdGVkKHJvb21JZCkpIHtcbiAgICAgICAgLy8gSWYgdGhlIHJvb20gaXMgZW5jcnlwdGVkIHRoZW4gZW5jcnlwdCB0aGUgZmlsZSBiZWZvcmUgdXBsb2FkaW5nIGl0LlxuICAgICAgICAvLyBGaXJzdCByZWFkIHRoZSBmaWxlIGludG8gbWVtb3J5LlxuICAgICAgICBsZXQgdXBsb2FkUHJvbWlzZTogSUFib3J0YWJsZVByb21pc2U8c3RyaW5nPjtcbiAgICAgICAgY29uc3QgcHJvbSA9IHJlYWRGaWxlQXNBcnJheUJ1ZmZlcihmaWxlKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChjYW5jZWxlZCkgdGhyb3cgbmV3IFVwbG9hZENhbmNlbGVkRXJyb3IoKTtcbiAgICAgICAgICAgIC8vIFRoZW4gZW5jcnlwdCB0aGUgZmlsZS5cbiAgICAgICAgICAgIHJldHVybiBlbmNyeXB0LmVuY3J5cHRBdHRhY2htZW50KGRhdGEpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKGVuY3J5cHRSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChjYW5jZWxlZCkgdGhyb3cgbmV3IFVwbG9hZENhbmNlbGVkRXJyb3IoKTtcblxuICAgICAgICAgICAgLy8gUGFzcyB0aGUgZW5jcnlwdGVkIGRhdGEgYXMgYSBCbG9iIHRvIHRoZSB1cGxvYWRlci5cbiAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbZW5jcnlwdFJlc3VsdC5kYXRhXSk7XG4gICAgICAgICAgICB1cGxvYWRQcm9taXNlID0gbWF0cml4Q2xpZW50LnVwbG9hZENvbnRlbnQoYmxvYiwge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzSGFuZGxlcixcbiAgICAgICAgICAgICAgICBpbmNsdWRlRmlsZW5hbWU6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB1cGxvYWRQcm9taXNlLnRoZW4odXJsID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsZWQpIHRocm93IG5ldyBVcGxvYWRDYW5jZWxlZEVycm9yKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYXR0YWNobWVudCBpcyBlbmNyeXB0ZWQgdGhlbiBidW5kbGUgdGhlIFVSTCBhbG9uZ1xuICAgICAgICAgICAgICAgIC8vIHdpdGggdGhlIGluZm9ybWF0aW9uIG5lZWRlZCB0byBkZWNyeXB0IHRoZSBhdHRhY2htZW50IGFuZFxuICAgICAgICAgICAgICAgIC8vIGFkZCBpdCB1bmRlciBhIGZpbGUga2V5LlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmVuY3J5cHRSZXN1bHQuaW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pIGFzIElBYm9ydGFibGVQcm9taXNlPHsgZmlsZTogSUVuY3J5cHRlZEZpbGUgfT47XG4gICAgICAgIHByb20uYWJvcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBjYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodXBsb2FkUHJvbWlzZSkgbWF0cml4Q2xpZW50LmNhbmNlbFVwbG9hZCh1cGxvYWRQcm9taXNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHByb207XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYmFzZVByb21pc2UgPSBtYXRyaXhDbGllbnQudXBsb2FkQ29udGVudChmaWxlLCB7IHByb2dyZXNzSGFuZGxlciB9KTtcbiAgICAgICAgY29uc3QgcHJvbWlzZTEgPSBiYXNlUHJvbWlzZS50aGVuKGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgaWYgKGNhbmNlbGVkKSB0aHJvdyBuZXcgVXBsb2FkQ2FuY2VsZWRFcnJvcigpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGF0dGFjaG1lbnQgaXNuJ3QgZW5jcnlwdGVkIHRoZW4gaW5jbHVkZSB0aGUgVVJMIGRpcmVjdGx5LlxuICAgICAgICAgICAgcmV0dXJuIHsgdXJsIH07XG4gICAgICAgIH0pIGFzIElBYm9ydGFibGVQcm9taXNlPHsgdXJsOiBzdHJpbmcgfT47XG4gICAgICAgIHByb21pc2UxLmFib3J0ID0gKCkgPT4ge1xuICAgICAgICAgICAgY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICAgICAgbWF0cml4Q2xpZW50LmNhbmNlbFVwbG9hZChiYXNlUHJvbWlzZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwcm9taXNlMTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRlbnRNZXNzYWdlcyB7XG4gICAgcHJpdmF0ZSBpbnByb2dyZXNzOiBJVXBsb2FkW10gPSBbXTtcbiAgICBwcml2YXRlIG1lZGlhQ29uZmlnOiBJTWVkaWFDb25maWcgPSBudWxsO1xuXG4gICAgc2VuZFN0aWNrZXJDb250ZW50VG9Sb29tKHVybDogc3RyaW5nLCByb29tSWQ6IHN0cmluZywgaW5mbzogSUltYWdlSW5mbywgdGV4dDogc3RyaW5nLCBtYXRyaXhDbGllbnQ6IE1hdHJpeENsaWVudCkge1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBDb3VudGx5QW5hbHl0aWNzLmdldFRpbWVzdGFtcCgpO1xuICAgICAgICBjb25zdCBwcm9tID0gbWF0cml4Q2xpZW50LnNlbmRTdGlja2VyTWVzc2FnZShyb29tSWQsIHVybCwgaW5mbywgdGV4dCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBGYWlsZWQgdG8gc2VuZCBjb250ZW50IHdpdGggVVJMICR7dXJsfSB0byByb29tICR7cm9vbUlkfWAsIGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSk7XG4gICAgICAgIENvdW50bHlBbmFseXRpY3MuaW5zdGFuY2UudHJhY2tTZW5kTWVzc2FnZShzdGFydFRpbWUsIHByb20sIHJvb21JZCwgZmFsc2UsIGZhbHNlLCB7IG1zZ3R5cGU6IFwibS5zdGlja2VyXCIgfSk7XG4gICAgICAgIHJldHVybiBwcm9tO1xuICAgIH1cblxuICAgIGdldFVwbG9hZExpbWl0KCkge1xuICAgICAgICBpZiAodGhpcy5tZWRpYUNvbmZpZyAhPT0gbnVsbCAmJiB0aGlzLm1lZGlhQ29uZmlnW1wibS51cGxvYWQuc2l6ZVwiXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZWRpYUNvbmZpZ1tcIm0udXBsb2FkLnNpemVcIl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIHNlbmRDb250ZW50TGlzdFRvUm9vbShcbiAgICAgICAgZmlsZXM6IEZpbGVbXSxcbiAgICAgICAgcm9vbUlkOiBzdHJpbmcsXG4gICAgICAgIHJlbGF0aW9uOiBJRXZlbnRSZWxhdGlvbiB8IG51bGwsXG4gICAgICAgIG1hdHJpeENsaWVudDogTWF0cml4Q2xpZW50LFxuICAgICkge1xuICAgICAgICBpZiAobWF0cml4Q2xpZW50LmlzR3Vlc3QoKSkge1xuICAgICAgICAgICAgZGlzLmRpc3BhdGNoKHsgYWN0aW9uOiAncmVxdWlyZV9yZWdpc3RyYXRpb24nIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNRdW90aW5nID0gQm9vbGVhbihSb29tVmlld1N0b3JlLmdldFF1b3RpbmdFdmVudCgpKTtcbiAgICAgICAgaWYgKGlzUXVvdGluZykge1xuICAgICAgICAgICAgLy8gRklYTUU6IFVzaW5nIGFuIGltcG9ydCB3aWxsIHJlc3VsdCBpbiBFbGVtZW50IGNyYXNoaW5nXG4gICAgICAgICAgICBjb25zdCBRdWVzdGlvbkRpYWxvZyA9IHNkay5nZXRDb21wb25lbnQoXCJkaWFsb2dzLlF1ZXN0aW9uRGlhbG9nXCIpO1xuICAgICAgICAgICAgY29uc3QgeyBmaW5pc2hlZCB9ID0gTW9kYWwuY3JlYXRlVHJhY2tlZERpYWxvZzxbYm9vbGVhbl0+KCdVcGxvYWQgUmVwbHkgV2FybmluZycsICcnLCBRdWVzdGlvbkRpYWxvZywge1xuICAgICAgICAgICAgICAgIHRpdGxlOiBfdCgnUmVwbHlpbmcgV2l0aCBGaWxlcycpLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAoXG4gICAgICAgICAgICAgICAgICAgIDxkaXY+eyBfdChcbiAgICAgICAgICAgICAgICAgICAgICAgICdBdCB0aGlzIHRpbWUgaXQgaXMgbm90IHBvc3NpYmxlIHRvIHJlcGx5IHdpdGggYSBmaWxlLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdXb3VsZCB5b3UgbGlrZSB0byB1cGxvYWQgdGhpcyBmaWxlIHdpdGhvdXQgcmVwbHlpbmc/JyxcbiAgICAgICAgICAgICAgICAgICAgKSB9PC9kaXY+XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBoYXNDYW5jZWxCdXR0b246IHRydWUsXG4gICAgICAgICAgICAgICAgYnV0dG9uOiBfdChcIkNvbnRpbnVlXCIpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBbc2hvdWxkVXBsb2FkXSA9IGF3YWl0IGZpbmlzaGVkO1xuICAgICAgICAgICAgaWYgKCFzaG91bGRVcGxvYWQpIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5tZWRpYUNvbmZpZykgeyAvLyBob3QtcGF0aCBvcHRpbWl6YXRpb24gdG8gbm90IGZsYXNoIGEgc3Bpbm5lciBpZiB3ZSBkb24ndCBuZWVkIHRvXG4gICAgICAgICAgICBjb25zdCBtb2RhbCA9IE1vZGFsLmNyZWF0ZURpYWxvZyhTcGlubmVyLCBudWxsLCAnbXhfRGlhbG9nX3NwaW5uZXInKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlTWVkaWFDb25maWdGZXRjaGVkKG1hdHJpeENsaWVudCk7XG4gICAgICAgICAgICBtb2RhbC5jbG9zZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG9vQmlnRmlsZXMgPSBbXTtcbiAgICAgICAgY29uc3Qgb2tGaWxlcyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRmlsZVNpemVBY2NlcHRhYmxlKGZpbGVzW2ldKSkge1xuICAgICAgICAgICAgICAgIG9rRmlsZXMucHVzaChmaWxlc1tpXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvb0JpZ0ZpbGVzLnB1c2goZmlsZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvb0JpZ0ZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBVc2luZyBhbiBpbXBvcnQgd2lsbCByZXN1bHQgaW4gRWxlbWVudCBjcmFzaGluZ1xuICAgICAgICAgICAgY29uc3QgVXBsb2FkRmFpbHVyZURpYWxvZyA9IHNkay5nZXRDb21wb25lbnQoXCJkaWFsb2dzLlVwbG9hZEZhaWx1cmVEaWFsb2dcIik7XG4gICAgICAgICAgICBjb25zdCB7IGZpbmlzaGVkIH0gPSBNb2RhbC5jcmVhdGVUcmFja2VkRGlhbG9nPFtib29sZWFuXT4oJ1VwbG9hZCBGYWlsdXJlJywgJycsIFVwbG9hZEZhaWx1cmVEaWFsb2csIHtcbiAgICAgICAgICAgICAgICBiYWRGaWxlczogdG9vQmlnRmlsZXMsXG4gICAgICAgICAgICAgICAgdG90YWxGaWxlczogZmlsZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRNZXNzYWdlczogdGhpcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgW3Nob3VsZENvbnRpbnVlXSA9IGF3YWl0IGZpbmlzaGVkO1xuICAgICAgICAgICAgaWYgKCFzaG91bGRDb250aW51ZSkgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHVwbG9hZEFsbCA9IGZhbHNlO1xuICAgICAgICAvLyBQcm9taXNlIHRvIGNvbXBsZXRlIGJlZm9yZSBzZW5kaW5nIG5leHQgZmlsZSBpbnRvIHJvb20sIHVzZWQgZm9yIHN5bmNocm9uaXNhdGlvbiBvZiBmaWxlLXNlbmRpbmdcbiAgICAgICAgLy8gdG8gbWF0Y2ggdGhlIG9yZGVyIHRoZSBmaWxlcyB3ZXJlIHNwZWNpZmllZCBpblxuICAgICAgICBsZXQgcHJvbUJlZm9yZTogUHJvbWlzZTxhbnk+ID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2tGaWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IG9rRmlsZXNbaV07XG4gICAgICAgICAgICBpZiAoIXVwbG9hZEFsbCkge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBVc2luZyBhbiBpbXBvcnQgd2lsbCByZXN1bHQgaW4gRWxlbWVudCBjcmFzaGluZ1xuICAgICAgICAgICAgICAgIGNvbnN0IFVwbG9hZENvbmZpcm1EaWFsb2cgPSBzZGsuZ2V0Q29tcG9uZW50KFwiZGlhbG9ncy5VcGxvYWRDb25maXJtRGlhbG9nXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZmluaXNoZWQgfSA9IE1vZGFsLmNyZWF0ZVRyYWNrZWREaWFsb2c8W2Jvb2xlYW4sIGJvb2xlYW5dPignVXBsb2FkIEZpbGVzIGNvbmZpcm1hdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICcnLCBVcGxvYWRDb25maXJtRGlhbG9nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxGaWxlczogb2tGaWxlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjb25zdCBbc2hvdWxkQ29udGludWUsIHNob3VsZFVwbG9hZEFsbF0gPSBhd2FpdCBmaW5pc2hlZDtcbiAgICAgICAgICAgICAgICBpZiAoIXNob3VsZENvbnRpbnVlKSBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkVXBsb2FkQWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwbG9hZEFsbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcm9tQmVmb3JlID0gdGhpcy5zZW5kQ29udGVudFRvUm9vbShmaWxlLCByb29tSWQsIHJlbGF0aW9uLCBtYXRyaXhDbGllbnQsIHByb21CZWZvcmUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0Q3VycmVudFVwbG9hZHMocmVsYXRpb24/OiBJRXZlbnRSZWxhdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnByb2dyZXNzLmZpbHRlcih1cGxvYWQgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9SZWxhdGlvbiA9ICFyZWxhdGlvbiAmJiAhdXBsb2FkLnJlbGF0aW9uO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmdSZWxhdGlvbiA9IHJlbGF0aW9uICYmIHVwbG9hZC5yZWxhdGlvblxuICAgICAgICAgICAgICAgICYmIHJlbGF0aW9uLnJlbF90eXBlID09PSB1cGxvYWQucmVsYXRpb24ucmVsX3R5cGVcbiAgICAgICAgICAgICAgICAmJiByZWxhdGlvbi5ldmVudF9pZCA9PT0gdXBsb2FkLnJlbGF0aW9uLmV2ZW50X2lkO1xuXG4gICAgICAgICAgICByZXR1cm4gKG5vUmVsYXRpb24gfHwgbWF0Y2hpbmdSZWxhdGlvbikgJiYgIXVwbG9hZC5jYW5jZWxlZDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wcm9ncmVzcy5maWx0ZXIodSA9PiAhdS5jYW5jZWxlZCk7XG4gICAgfVxuXG4gICAgY2FuY2VsVXBsb2FkKHByb21pc2U6IFByb21pc2U8YW55PiwgbWF0cml4Q2xpZW50OiBNYXRyaXhDbGllbnQpIHtcbiAgICAgICAgbGV0IHVwbG9hZDogSVVwbG9hZDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmlucHJvZ3Jlc3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlucHJvZ3Jlc3NbaV0ucHJvbWlzZSA9PT0gcHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHVwbG9hZCA9IHRoaXMuaW5wcm9ncmVzc1tpXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodXBsb2FkKSB7XG4gICAgICAgICAgICB1cGxvYWQuY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICAgICAgbWF0cml4Q2xpZW50LmNhbmNlbFVwbG9hZCh1cGxvYWQucHJvbWlzZSk7XG4gICAgICAgICAgICBkaXMuZGlzcGF0Y2g8VXBsb2FkQ2FuY2VsZWRQYXlsb2FkPih7IGFjdGlvbjogQWN0aW9uLlVwbG9hZENhbmNlbGVkLCB1cGxvYWQgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHNlbmRDb250ZW50VG9Sb29tKFxuICAgICAgICBmaWxlOiBGaWxlLFxuICAgICAgICByb29tSWQ6IHN0cmluZyxcbiAgICAgICAgcmVsYXRpb246IElFdmVudFJlbGF0aW9uLFxuICAgICAgICBtYXRyaXhDbGllbnQ6IE1hdHJpeENsaWVudCxcbiAgICAgICAgcHJvbUJlZm9yZTogUHJvbWlzZTxhbnk+LFxuICAgICkge1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBDb3VudGx5QW5hbHl0aWNzLmdldFRpbWVzdGFtcCgpO1xuICAgICAgICBjb25zdCBjb250ZW50OiBJQ29udGVudCA9IHtcbiAgICAgICAgICAgIGJvZHk6IGZpbGUubmFtZSB8fCAnQXR0YWNobWVudCcsXG4gICAgICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgICAgICAgc2l6ZTogZmlsZS5zaXplLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1zZ3R5cGU6IFwiXCIsIC8vIHNldCBsYXRlclxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChyZWxhdGlvbikge1xuICAgICAgICAgICAgY29udGVudFtcIm0ucmVsYXRlc190b1wiXSA9IHJlbGF0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFNldHRpbmdzU3RvcmUuZ2V0VmFsdWUoXCJQZXJmb3JtYW5jZS5hZGRTZW5kTWVzc2FnZVRpbWluZ01ldGFkYXRhXCIpKSB7XG4gICAgICAgICAgICBkZWNvcmF0ZVN0YXJ0U2VuZGluZ1RpbWUoY29udGVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbWltZSB0eXBlIGZvciB0aGUgZmlsZSwgYWRkIGl0IHRvIHRoZSBtZXNzYWdlIG1ldGFkYXRhXG4gICAgICAgIGlmIChmaWxlLnR5cGUpIHtcbiAgICAgICAgICAgIGNvbnRlbnQuaW5mby5taW1ldHlwZSA9IGZpbGUudHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByb20gPSBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGZpbGUudHlwZS5pbmRleE9mKCdpbWFnZS8nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQubXNndHlwZSA9IE1zZ1R5cGUuSW1hZ2U7XG4gICAgICAgICAgICAgICAgaW5mb0ZvckltYWdlRmlsZShtYXRyaXhDbGllbnQsIHJvb21JZCwgZmlsZSkudGhlbigoaW1hZ2VJbmZvKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY29udGVudC5pbmZvLCBpbWFnZUluZm8pO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSwgKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50Lm1zZ3R5cGUgPSBNc2dUeXBlLkZpbGU7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsZS50eXBlLmluZGV4T2YoJ2F1ZGlvLycpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGVudC5tc2d0eXBlID0gTXNnVHlwZS5BdWRpbztcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZpbGUudHlwZS5pbmRleE9mKCd2aWRlby8nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQubXNndHlwZSA9IE1zZ1R5cGUuVmlkZW87XG4gICAgICAgICAgICAgICAgaW5mb0ZvclZpZGVvRmlsZShtYXRyaXhDbGllbnQsIHJvb21JZCwgZmlsZSkudGhlbigodmlkZW9JbmZvKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY29udGVudC5pbmZvLCB2aWRlb0luZm8pO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSwgKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudC5tc2d0eXBlID0gTXNnVHlwZS5GaWxlO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQubXNndHlwZSA9IE1zZ1R5cGUuRmlsZTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pIGFzIElBYm9ydGFibGVQcm9taXNlPHZvaWQ+O1xuXG4gICAgICAgIC8vIGNyZWF0ZSB0ZW1wb3JhcnkgYWJvcnQgaGFuZGxlciBmb3IgYmVmb3JlIHRoZSBhY3R1YWwgdXBsb2FkIGdldHMgcGFzc2VkIG9mZiB0byBqcy1zZGtcbiAgICAgICAgcHJvbS5hYm9ydCA9ICgpID0+IHtcbiAgICAgICAgICAgIHVwbG9hZC5jYW5jZWxlZCA9IHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgdXBsb2FkOiBJVXBsb2FkID0ge1xuICAgICAgICAgICAgZmlsZU5hbWU6IGZpbGUubmFtZSB8fCAnQXR0YWNobWVudCcsXG4gICAgICAgICAgICByb29tSWQsXG4gICAgICAgICAgICByZWxhdGlvbixcbiAgICAgICAgICAgIHRvdGFsOiBmaWxlLnNpemUsXG4gICAgICAgICAgICBsb2FkZWQ6IDAsXG4gICAgICAgICAgICBwcm9taXNlOiBwcm9tLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmlucHJvZ3Jlc3MucHVzaCh1cGxvYWQpO1xuICAgICAgICBkaXMuZGlzcGF0Y2g8VXBsb2FkU3RhcnRlZFBheWxvYWQ+KHsgYWN0aW9uOiBBY3Rpb24uVXBsb2FkU3RhcnRlZCwgdXBsb2FkIH0pO1xuXG4gICAgICAgIC8vIEZvY3VzIHRoZSBjb21wb3NlciB2aWV3XG4gICAgICAgIGRpcy5maXJlKEFjdGlvbi5Gb2N1c1NlbmRNZXNzYWdlQ29tcG9zZXIpO1xuXG4gICAgICAgIGZ1bmN0aW9uIG9uUHJvZ3Jlc3MoZXYpIHtcbiAgICAgICAgICAgIHVwbG9hZC50b3RhbCA9IGV2LnRvdGFsO1xuICAgICAgICAgICAgdXBsb2FkLmxvYWRlZCA9IGV2LmxvYWRlZDtcbiAgICAgICAgICAgIGRpcy5kaXNwYXRjaDxVcGxvYWRQcm9ncmVzc1BheWxvYWQ+KHsgYWN0aW9uOiBBY3Rpb24uVXBsb2FkUHJvZ3Jlc3MsIHVwbG9hZCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgcmV0dXJuIHByb20udGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh1cGxvYWQuY2FuY2VsZWQpIHRocm93IG5ldyBVcGxvYWRDYW5jZWxlZEVycm9yKCk7XG4gICAgICAgICAgICAvLyBYWFg6IHVwbG9hZC5wcm9taXNlIG11c3QgYmUgdGhlIHByb21pc2UgdGhhdFxuICAgICAgICAgICAgLy8gaXMgcmV0dXJuZWQgYnkgdXBsb2FkRmlsZSBhcyBpdCBoYXMgYW4gYWJvcnQoKVxuICAgICAgICAgICAgLy8gbWV0aG9kIGhhY2tlZCBvbnRvIGl0LlxuICAgICAgICAgICAgdXBsb2FkLnByb21pc2UgPSB1cGxvYWRGaWxlKG1hdHJpeENsaWVudCwgcm9vbUlkLCBmaWxlLCBvblByb2dyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiB1cGxvYWQucHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQuZmlsZSA9IHJlc3VsdC5maWxlO1xuICAgICAgICAgICAgICAgIGNvbnRlbnQudXJsID0gcmVzdWx0LnVybDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIEF3YWl0IHByZXZpb3VzIG1lc3NhZ2UgYmVpbmcgc2VudCBpbnRvIHRoZSByb29tXG4gICAgICAgICAgICByZXR1cm4gcHJvbUJlZm9yZTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh1cGxvYWQuY2FuY2VsZWQpIHRocm93IG5ldyBVcGxvYWRDYW5jZWxlZEVycm9yKCk7XG4gICAgICAgICAgICBjb25zdCB0aHJlYWRJZCA9IHJlbGF0aW9uPy5yZWxfdHlwZSA9PT0gUmVsYXRpb25UeXBlLlRocmVhZFxuICAgICAgICAgICAgICAgID8gcmVsYXRpb24uZXZlbnRfaWRcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBjb25zdCBwcm9tID0gbWF0cml4Q2xpZW50LnNlbmRNZXNzYWdlKHJvb21JZCwgdGhyZWFkSWQsIGNvbnRlbnQpO1xuICAgICAgICAgICAgaWYgKFNldHRpbmdzU3RvcmUuZ2V0VmFsdWUoXCJQZXJmb3JtYW5jZS5hZGRTZW5kTWVzc2FnZVRpbWluZ01ldGFkYXRhXCIpKSB7XG4gICAgICAgICAgICAgICAgcHJvbS50aGVuKHJlc3AgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZW5kUm91bmRUcmlwTWV0cmljKG1hdHJpeENsaWVudCwgcm9vbUlkLCByZXNwLmV2ZW50X2lkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIENvdW50bHlBbmFseXRpY3MuaW5zdGFuY2UudHJhY2tTZW5kTWVzc2FnZShzdGFydFRpbWUsIHByb20sIHJvb21JZCwgZmFsc2UsIGZhbHNlLCBjb250ZW50KTtcbiAgICAgICAgICAgIHJldHVybiBwcm9tO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgaWYgKCF1cGxvYWQuY2FuY2VsZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGVzYyA9IF90KFwiVGhlIGZpbGUgJyUoZmlsZU5hbWUpcycgZmFpbGVkIHRvIHVwbG9hZC5cIiwgeyBmaWxlTmFtZTogdXBsb2FkLmZpbGVOYW1lIH0pO1xuICAgICAgICAgICAgICAgIGlmIChlcnIuaHR0cF9zdGF0dXMgPT09IDQxMykge1xuICAgICAgICAgICAgICAgICAgICBkZXNjID0gX3QoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlRoZSBmaWxlICclKGZpbGVOYW1lKXMnIGV4Y2VlZHMgdGhpcyBob21lc2VydmVyJ3Mgc2l6ZSBsaW1pdCBmb3IgdXBsb2Fkc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBmaWxlTmFtZTogdXBsb2FkLmZpbGVOYW1lIH0sXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBVc2luZyBhbiBpbXBvcnQgd2lsbCByZXN1bHQgaW4gRWxlbWVudCBjcmFzaGluZ1xuICAgICAgICAgICAgICAgIGNvbnN0IEVycm9yRGlhbG9nID0gc2RrLmdldENvbXBvbmVudChcImRpYWxvZ3MuRXJyb3JEaWFsb2dcIik7XG4gICAgICAgICAgICAgICAgTW9kYWwuY3JlYXRlVHJhY2tlZERpYWxvZygnVXBsb2FkIGZhaWxlZCcsICcnLCBFcnJvckRpYWxvZywge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogX3QoJ1VwbG9hZCBGYWlsZWQnKSxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGRlc2MsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmlucHJvZ3Jlc3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbnByb2dyZXNzW2ldLnByb21pc2UgPT09IHVwbG9hZC5wcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wcm9ncmVzcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIDQxMzogRmlsZSB3YXMgdG9vIGJpZyBvciB1cHNldCB0aGUgc2VydmVyIGluIHNvbWUgd2F5OlxuICAgICAgICAgICAgICAgIC8vIGNsZWFyIHRoZSBtZWRpYSBzaXplIGxpbWl0IHNvIHdlIGZldGNoIGl0IGFnYWluIG5leHQgdGltZVxuICAgICAgICAgICAgICAgIC8vIHdlIHRyeSB0byB1cGxvYWRcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IuaHR0cF9zdGF0dXMgPT09IDQxMykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lZGlhQ29uZmlnID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzLmRpc3BhdGNoPFVwbG9hZEVycm9yUGF5bG9hZD4oeyBhY3Rpb246IEFjdGlvbi5VcGxvYWRGYWlsZWQsIHVwbG9hZCwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpcy5kaXNwYXRjaDxVcGxvYWRGaW5pc2hlZFBheWxvYWQ+KHsgYWN0aW9uOiBBY3Rpb24uVXBsb2FkRmluaXNoZWQsIHVwbG9hZCB9KTtcbiAgICAgICAgICAgICAgICBkaXMuZGlzcGF0Y2goeyBhY3Rpb246ICdtZXNzYWdlX3NlbnQnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGlzRmlsZVNpemVBY2NlcHRhYmxlKGZpbGU6IEZpbGUpIHtcbiAgICAgICAgaWYgKHRoaXMubWVkaWFDb25maWcgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHRoaXMubWVkaWFDb25maWdbXCJtLnVwbG9hZC5zaXplXCJdICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGZpbGUuc2l6ZSA+IHRoaXMubWVkaWFDb25maWdbXCJtLnVwbG9hZC5zaXplXCJdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBlbnN1cmVNZWRpYUNvbmZpZ0ZldGNoZWQobWF0cml4Q2xpZW50OiBNYXRyaXhDbGllbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubWVkaWFDb25maWcgIT09IG51bGwpIHJldHVybjtcblxuICAgICAgICBsb2dnZXIubG9nKFwiW01lZGlhIENvbmZpZ10gRmV0Y2hpbmdcIik7XG4gICAgICAgIHJldHVybiBtYXRyaXhDbGllbnQuZ2V0TWVkaWFDb25maWcoKS50aGVuKChjb25maWcpID0+IHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coXCJbTWVkaWEgQ29uZmlnXSBGZXRjaGVkIGNvbmZpZzpcIiwgY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybiBjb25maWc7XG4gICAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIC8vIE1lZGlhIHJlcG8gY2FuJ3Qgb3Igd29uJ3QgcmVwb3J0IGxpbWl0cywgc28gcHJvdmlkZSBhbiBlbXB0eSBvYmplY3QgKG5vIGxpbWl0cykuXG4gICAgICAgICAgICBsb2dnZXIubG9nKFwiW01lZGlhIENvbmZpZ10gQ291bGQgbm90IGZldGNoIGNvbmZpZywgc28gbm90IGxpbWl0aW5nIHVwbG9hZHMuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9KS50aGVuKChjb25maWcpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWVkaWFDb25maWcgPSBjb25maWc7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBzaGFyZWRJbnN0YW5jZSgpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5teENvbnRlbnRNZXNzYWdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3aW5kb3cubXhDb250ZW50TWVzc2FnZXMgPSBuZXcgQ29udGVudE1lc3NhZ2VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdpbmRvdy5teENvbnRlbnRNZXNzYWdlcztcbiAgICB9XG59XG4iXX0=