"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var React = _interopRequireWildcard(require("react"));

var _ToastStore = _interopRequireDefault(require("../../stores/ToastStore"));

var _classnames = _interopRequireDefault(require("classnames"));

var _replaceableComponent = require("../../utils/replaceableComponent");

var _dec, _class;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

let ToastContainer = (_dec = (0, _replaceableComponent.replaceableComponent)("structures.ToastContainer"), _dec(_class = class ToastContainer extends React.Component {
  constructor(props, context) {
    super(props, context);
    (0, _defineProperty2.default)(this, "onToastStoreUpdate", () => {
      this.setState({
        toasts: _ToastStore.default.sharedInstance().getToasts(),
        countSeen: _ToastStore.default.sharedInstance().getCountSeen()
      });
    });
    this.state = {
      toasts: _ToastStore.default.sharedInstance().getToasts(),
      countSeen: _ToastStore.default.sharedInstance().getCountSeen()
    }; // Start listening here rather than in componentDidMount because
    // toasts may dismiss themselves in their didMount if they find
    // they're already irrelevant by the time they're mounted, and
    // our own componentDidMount is too late.

    _ToastStore.default.sharedInstance().on('update', this.onToastStoreUpdate);
  }

  componentWillUnmount() {
    _ToastStore.default.sharedInstance().removeListener('update', this.onToastStoreUpdate);
  }

  render() {
    const totalCount = this.state.toasts.length;
    const isStacked = totalCount > 1;
    let toast;
    let containerClasses;

    if (totalCount !== 0) {
      const topToast = this.state.toasts[0];
      const {
        title,
        icon,
        key,
        component,
        className,
        bodyClassName,
        props
      } = topToast;
      const bodyClasses = (0, _classnames.default)("mx_Toast_body", bodyClassName);
      const toastClasses = (0, _classnames.default)("mx_Toast_toast", className, {
        "mx_Toast_hasIcon": icon,
        [`mx_Toast_icon_${icon}`]: icon
      });
      const toastProps = Object.assign({}, props, {
        key,
        toastKey: key
      });
      const content = /*#__PURE__*/React.createElement(component, toastProps);
      let countIndicator;

      if (title && isStacked || this.state.countSeen > 0) {
        countIndicator = ` (${this.state.countSeen + 1}/${this.state.countSeen + totalCount})`;
      }

      let titleElement;

      if (title) {
        titleElement = /*#__PURE__*/React.createElement("div", {
          className: "mx_Toast_title"
        }, /*#__PURE__*/React.createElement("h2", null, title), /*#__PURE__*/React.createElement("span", null, countIndicator));
      }

      toast = /*#__PURE__*/React.createElement("div", {
        className: toastClasses
      }, titleElement, /*#__PURE__*/React.createElement("div", {
        className: bodyClasses
      }, content));
      containerClasses = (0, _classnames.default)("mx_ToastContainer", {
        "mx_ToastContainer_stacked": isStacked
      });
    }

    return toast ? /*#__PURE__*/React.createElement("div", {
      className: containerClasses,
      role: "alert"
    }, toast) : null;
  }

}) || _class);
exports.default = ToastContainer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3N0cnVjdHVyZXMvVG9hc3RDb250YWluZXIudHN4Il0sIm5hbWVzIjpbIlRvYXN0Q29udGFpbmVyIiwiUmVhY3QiLCJDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsInByb3BzIiwiY29udGV4dCIsInNldFN0YXRlIiwidG9hc3RzIiwiVG9hc3RTdG9yZSIsInNoYXJlZEluc3RhbmNlIiwiZ2V0VG9hc3RzIiwiY291bnRTZWVuIiwiZ2V0Q291bnRTZWVuIiwic3RhdGUiLCJvbiIsIm9uVG9hc3RTdG9yZVVwZGF0ZSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicmVtb3ZlTGlzdGVuZXIiLCJyZW5kZXIiLCJ0b3RhbENvdW50IiwibGVuZ3RoIiwiaXNTdGFja2VkIiwidG9hc3QiLCJjb250YWluZXJDbGFzc2VzIiwidG9wVG9hc3QiLCJ0aXRsZSIsImljb24iLCJrZXkiLCJjb21wb25lbnQiLCJjbGFzc05hbWUiLCJib2R5Q2xhc3NOYW1lIiwiYm9keUNsYXNzZXMiLCJ0b2FzdENsYXNzZXMiLCJ0b2FzdFByb3BzIiwiT2JqZWN0IiwiYXNzaWduIiwidG9hc3RLZXkiLCJjb250ZW50IiwiY3JlYXRlRWxlbWVudCIsImNvdW50SW5kaWNhdG9yIiwidGl0bGVFbGVtZW50Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWdCQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7SUFRcUJBLGMsV0FEcEIsZ0RBQXFCLDJCQUFyQixDLGdCQUFELE1BQ3FCQSxjQURyQixTQUM0Q0MsS0FBSyxDQUFDQyxTQURsRCxDQUN3RTtBQUNwRUMsRUFBQUEsV0FBVyxDQUFDQyxLQUFELEVBQVFDLE9BQVIsRUFBaUI7QUFDeEIsVUFBTUQsS0FBTixFQUFhQyxPQUFiO0FBRHdCLDhEQWtCQyxNQUFNO0FBQy9CLFdBQUtDLFFBQUwsQ0FBYztBQUNWQyxRQUFBQSxNQUFNLEVBQUVDLG9CQUFXQyxjQUFYLEdBQTRCQyxTQUE1QixFQURFO0FBRVZD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RkksR0FNTixJQU5OO0FBT0g7O0FBOUVtRSxDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE5LCAyMDIwIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgVG9hc3RTdG9yZSwgeyBJVG9hc3QgfSBmcm9tIFwiLi4vLi4vc3RvcmVzL1RvYXN0U3RvcmVcIjtcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gXCJjbGFzc25hbWVzXCI7XG5pbXBvcnQgeyByZXBsYWNlYWJsZUNvbXBvbmVudCB9IGZyb20gXCIuLi8uLi91dGlscy9yZXBsYWNlYWJsZUNvbXBvbmVudFwiO1xuXG5pbnRlcmZhY2UgSVN0YXRlIHtcbiAgICB0b2FzdHM6IElUb2FzdDxhbnk+W107XG4gICAgY291bnRTZWVuOiBudW1iZXI7XG59XG5cbkByZXBsYWNlYWJsZUNvbXBvbmVudChcInN0cnVjdHVyZXMuVG9hc3RDb250YWluZXJcIilcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvYXN0Q29udGFpbmVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PHt9LCBJU3RhdGU+IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xuICAgICAgICBzdXBlcihwcm9wcywgY29udGV4dCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB0b2FzdHM6IFRvYXN0U3RvcmUuc2hhcmVkSW5zdGFuY2UoKS5nZXRUb2FzdHMoKSxcbiAgICAgICAgICAgIGNvdW50U2VlbjogVG9hc3RTdG9yZS5zaGFyZWRJbnN0YW5jZSgpLmdldENvdW50U2VlbigpLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFN0YXJ0IGxpc3RlbmluZyBoZXJlIHJhdGhlciB0aGFuIGluIGNvbXBvbmVudERpZE1vdW50IGJlY2F1c2VcbiAgICAgICAgLy8gdG9hc3RzIG1heSBkaXNtaXNzIHRoZW1zZWx2ZXMgaW4gdGhlaXIgZGlkTW91bnQgaWYgdGhleSBmaW5kXG4gICAgICAgIC8vIHRoZXkncmUgYWxyZWFkeSBpcnJlbGV2YW50IGJ5IHRoZSB0aW1lIHRoZXkncmUgbW91bnRlZCwgYW5kXG4gICAgICAgIC8vIG91ciBvd24gY29tcG9uZW50RGlkTW91bnQgaXMgdG9vIGxhdGUuXG4gICAgICAgIFRvYXN0U3RvcmUuc2hhcmVkSW5zdGFuY2UoKS5vbigndXBkYXRlJywgdGhpcy5vblRvYXN0U3RvcmVVcGRhdGUpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBUb2FzdFN0b3JlLnNoYXJlZEluc3RhbmNlKCkucmVtb3ZlTGlzdGVuZXIoJ3VwZGF0ZScsIHRoaXMub25Ub2FzdFN0b3JlVXBkYXRlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uVG9hc3RTdG9yZVVwZGF0ZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICB0b2FzdHM6IFRvYXN0U3RvcmUuc2hhcmVkSW5zdGFuY2UoKS5nZXRUb2FzdHMoKSxcbiAgICAgICAgICAgIGNvdW50U2VlbjogVG9hc3RTdG9yZS5zaGFyZWRJbnN0YW5jZSgpLmdldENvdW50U2VlbigpLFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB0b3RhbENvdW50ID0gdGhpcy5zdGF0ZS50b2FzdHMubGVuZ3RoO1xuICAgICAgICBjb25zdCBpc1N0YWNrZWQgPSB0b3RhbENvdW50ID4gMTtcbiAgICAgICAgbGV0IHRvYXN0O1xuICAgICAgICBsZXQgY29udGFpbmVyQ2xhc3NlcztcbiAgICAgICAgaWYgKHRvdGFsQ291bnQgIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHRvcFRvYXN0ID0gdGhpcy5zdGF0ZS50b2FzdHNbMF07XG4gICAgICAgICAgICBjb25zdCB7IHRpdGxlLCBpY29uLCBrZXksIGNvbXBvbmVudCwgY2xhc3NOYW1lLCBib2R5Q2xhc3NOYW1lLCBwcm9wcyB9ID0gdG9wVG9hc3Q7XG4gICAgICAgICAgICBjb25zdCBib2R5Q2xhc3NlcyA9IGNsYXNzTmFtZXMoXCJteF9Ub2FzdF9ib2R5XCIsIGJvZHlDbGFzc05hbWUpO1xuICAgICAgICAgICAgY29uc3QgdG9hc3RDbGFzc2VzID0gY2xhc3NOYW1lcyhcIm14X1RvYXN0X3RvYXN0XCIsIGNsYXNzTmFtZSwge1xuICAgICAgICAgICAgICAgIFwibXhfVG9hc3RfaGFzSWNvblwiOiBpY29uLFxuICAgICAgICAgICAgICAgIFtgbXhfVG9hc3RfaWNvbl8ke2ljb259YF06IGljb24sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHRvYXN0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB0b2FzdEtleToga2V5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gUmVhY3QuY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHRvYXN0UHJvcHMpO1xuXG4gICAgICAgICAgICBsZXQgY291bnRJbmRpY2F0b3I7XG4gICAgICAgICAgICBpZiAodGl0bGUgJiYgaXNTdGFja2VkIHx8IHRoaXMuc3RhdGUuY291bnRTZWVuID4gMCkge1xuICAgICAgICAgICAgICAgIGNvdW50SW5kaWNhdG9yID0gYCAoJHt0aGlzLnN0YXRlLmNvdW50U2VlbiArIDF9LyR7dGhpcy5zdGF0ZS5jb3VudFNlZW4gKyB0b3RhbENvdW50fSlgO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgdGl0bGVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgICAgICAgICAgdGl0bGVFbGVtZW50ID0gKFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm14X1RvYXN0X3RpdGxlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aDI+eyB0aXRsZSB9PC9oMj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPnsgY291bnRJbmRpY2F0b3IgfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9hc3QgPSAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3RvYXN0Q2xhc3Nlc30+XG4gICAgICAgICAgICAgICAgICAgIHsgdGl0bGVFbGVtZW50IH1cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2JvZHlDbGFzc2VzfT57IGNvbnRlbnQgfTwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29udGFpbmVyQ2xhc3NlcyA9IGNsYXNzTmFtZXMoXCJteF9Ub2FzdENvbnRhaW5lclwiLCB7XG4gICAgICAgICAgICAgICAgXCJteF9Ub2FzdENvbnRhaW5lcl9zdGFja2VkXCI6IGlzU3RhY2tlZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2FzdFxuICAgICAgICAgICAgPyAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NvbnRhaW5lckNsYXNzZXN9IHJvbGU9XCJhbGVydFwiPlxuICAgICAgICAgICAgICAgICAgICB7IHRvYXN0IH1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9XG59XG4iXX0=