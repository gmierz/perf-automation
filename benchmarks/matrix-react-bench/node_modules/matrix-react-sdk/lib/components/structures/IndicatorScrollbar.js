"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _AutoHideScrollbar = _interopRequireDefault(require("./AutoHideScrollbar"));

var _replaceableComponent = require("../../utils/replaceableComponent");

const _excluded = ["children", "trackHorizontalOverflow", "verticalScrollsHorizontally"];

var _dec, _class;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

let IndicatorScrollbar = (_dec = (0, _replaceableComponent.replaceableComponent)("structures.IndicatorScrollbar"), _dec(_class = class IndicatorScrollbar extends _react.default.Component {
  // ts in milliseconds to recheck this._likelyTrackpadUser
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "autoHideScrollbar", /*#__PURE__*/(0, _react.createRef)());
    (0, _defineProperty2.default)(this, "scrollElement", void 0);
    (0, _defineProperty2.default)(this, "likelyTrackpadUser", null);
    (0, _defineProperty2.default)(this, "checkAgainForTrackpad", 0);
    (0, _defineProperty2.default)(this, "collectScroller", scroller => {
      if (scroller && !this.scrollElement) {
        this.scrollElement = scroller; // Using the passive option to not block the main thread
        // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#improving_scrolling_performance_with_passive_listeners

        this.scrollElement.addEventListener("scroll", this.checkOverflow, {
          passive: true
        });
        this.checkOverflow();
      }
    });
    (0, _defineProperty2.default)(this, "checkOverflow", () => {
      const hasTopOverflow = this.scrollElement.scrollTop > 0;
      const hasBottomOverflow = this.scrollElement.scrollHeight > this.scrollElement.scrollTop + this.scrollElement.clientHeight;
      const hasLeftOverflow = this.scrollElement.scrollLeft > 0;
      const hasRightOverflow = this.scrollElement.scrollWidth > this.scrollElement.scrollLeft + this.scrollElement.clientWidth;

      if (hasTopOverflow) {
        this.scrollElement.classList.add("mx_IndicatorScrollbar_topOverflow");
      } else {
        this.scrollElement.classList.remove("mx_IndicatorScrollbar_topOverflow");
      }

      if (hasBottomOverflow) {
        this.scrollElement.classList.add("mx_IndicatorScrollbar_bottomOverflow");
      } else {
        this.scrollElement.classList.remove("mx_IndicatorScrollbar_bottomOverflow");
      }

      if (hasLeftOverflow) {
        this.scrollElement.classList.add("mx_IndicatorScrollbar_leftOverflow");
      } else {
        this.scrollElement.classList.remove("mx_IndicatorScrollbar_leftOverflow");
      }

      if (hasRightOverflow) {
        this.scrollElement.classList.add("mx_IndicatorScrollbar_rightOverflow");
      } else {
        this.scrollElement.classList.remove("mx_IndicatorScrollbar_rightOverflow");
      }

      if (this.props.trackHorizontalOverflow) {
        this.setState({
          // Offset from absolute position of the container
          leftIndicatorOffset: hasLeftOverflow ? `${this.scrollElement.scrollLeft}px` : '0',
          // Negative because we're coming from the right
          rightIndicatorOffset: hasRightOverflow ? `-${this.scrollElement.scrollLeft}px` : '0'
        });
      }
    });
    (0, _defineProperty2.default)(this, "onMouseWheel", e => {
      if (this.props.verticalScrollsHorizontally && this.scrollElement) {
        // xyThreshold is the amount of horizontal motion required for the component to
        // ignore the vertical delta in a scroll. Used to stop trackpads from acting in
        // strange ways. Should be positive.
        const xyThreshold = 0; // yRetention is the factor multiplied by the vertical delta to try and reduce
        // the harshness of the scroll behaviour. Should be a value between 0 and 1.

        const yRetention = 1.0; // whenever we see horizontal scrolling, assume the user is on a trackpad
        // for at least the next 1 minute.

        const now = new Date().getTime();

        if (Math.abs(e.deltaX) > 0) {
          this.likelyTrackpadUser = true;
          this.checkAgainForTrackpad = now + 1 * 60 * 1000;
        } else {
          // if we haven't seen any horizontal scrolling for a while, assume
          // the user might have plugged in a mousewheel
          if (this.likelyTrackpadUser && now >= this.checkAgainForTrackpad) {
            this.likelyTrackpadUser = false;
          }
        } // don't mess with the horizontal scroll for trackpad users
        // See https://github.com/vector-im/element-web/issues/10005


        if (this.likelyTrackpadUser) {
          return;
        }

        if (Math.abs(e.deltaX) <= xyThreshold) {
          // we are vertically scrolling.
          // HACK: We increase the amount of scroll to counteract smooth scrolling browsers.
          // Smooth scrolling browsers (Firefox) use the relative area to determine the scroll
          // amount, which means the likely small area of content results in a small amount of
          // movement - not what people expect. We pick arbitrary values for when to apply more
          // scroll, and how much to apply. On Windows 10, Chrome scrolls 100 units whereas
          // Firefox scrolls just 3 due to smooth scrolling.
          const additionalScroll = e.deltaY < 0 ? -50 : 50; // noinspection JSSuspiciousNameCombination

          const val = Math.abs(e.deltaY) < 25 ? e.deltaY + additionalScroll : e.deltaY;
          this.scrollElement.scrollLeft += val * yRetention;
        }
      }
    });
    this.state = {
      leftIndicatorOffset: 0,
      rightIndicatorOffset: 0
    };
  }

  componentDidUpdate(prevProps) {
    const prevLen = _react.default.Children.count(prevProps.children);

    const curLen = _react.default.Children.count(this.props.children); // check overflow only if amount of children changes.
    // if we don't guard here, we end up with an infinite
    // render > componentDidUpdate > checkOverflow > setState > render loop


    if (prevLen !== curLen) {
      this.checkOverflow();
    }
  }

  componentDidMount() {
    this.checkOverflow();
  }

  componentWillUnmount() {
    if (this.scrollElement) {
      this.scrollElement.removeEventListener("scroll", this.checkOverflow);
    }
  }

  render() {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const _this$props = this.props,
          {
      children,
      trackHorizontalOverflow,
      verticalScrollsHorizontally
    } = _this$props,
          otherProps = (0, _objectWithoutProperties2.default)(_this$props, _excluded);
    const leftIndicatorStyle = {
      left: this.state.leftIndicatorOffset
    };
    const rightIndicatorStyle = {
      right: this.state.rightIndicatorOffset
    };
    const leftOverflowIndicator = trackHorizontalOverflow ? /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_IndicatorScrollbar_leftOverflowIndicator",
      style: leftIndicatorStyle
    }) : null;
    const rightOverflowIndicator = trackHorizontalOverflow ? /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_IndicatorScrollbar_rightOverflowIndicator",
      style: rightIndicatorStyle
    }) : null;
    return /*#__PURE__*/_react.default.createElement(_AutoHideScrollbar.default, (0, _extends2.default)({
      ref: this.autoHideScrollbar,
      wrappedRef: this.collectScroller,
      onWheel: this.onMouseWheel
    }, otherProps), leftOverflowIndicator, children, rightOverflowIndicator);
  }

}) || _class);
exports.default = IndicatorScrollbar;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3N0cnVjdHVyZXMvSW5kaWNhdG9yU2Nyb2xsYmFyLnRzeCJdLCJuYW1lcyI6WyJJbmRpY2F0b3JTY3JvbGxiYXIiLCJSZWFjdCIsIkNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJzY3JvbGxlciIsInNjcm9sbEVsZW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwiY2hlY2tPdmVyZmxvdyIsInBhc3NpdmUiLCJoYXNUb3BPdmVyZmxvdyIsInNjcm9sbFRvcCIsImhhc0JvdHRvbU92ZXJmbG93Iiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiaGFzTGVmdE92ZXJmbG93Iiwic2Nyb2xsTGVmdCIsImhhc1JpZ2h0T3ZlcmZsb3ciLCJzY3JvbGxXaWR0aCIsImNsaWVudFdpZHRoIiwiY2xhc3NMaXN0IiwiYWRkIiwicmVtb3ZlIiwidHJhY2tIb3Jpem9udGFsT3ZlcmZsb3ciLCJzZXRTdGF0ZSIsImxlZnRJbmRpY2F0b3JPZmZzZXQiLCJyaWdodEluZGljYXRvck9mZnNldCIsImUiLCJ2ZXJ0aWNhbFNjcm9sbHNIb3Jpem9udGFsbHkiLCJ4eVRocmVzaG9sZCIsInlSZXRlbnRpb24iLCJub3ciLCJEYXRlIiwiZ2V0VGltZSIsIk1hdGgiLCJhYnMiLCJkZWx0YVgiLCJsaWtlbHlUcmFja3BhZFVzZXIiLCJjaGVja0FnYWluRm9yVHJhY2twYWQiLCJhZGRpdGlvbmFsU2Nyb2xsIiwiZGVsdGFZIiwidmFsIiwic3RhdGUiLCJjb21wb25lbnREaWRVcGRhdGUiLCJwcmV2UHJvcHMiLCJwcmV2TGVuIiwiQ2hpbGRyZW4iLCJjb3VudCIsImNoaWxkcmVuIiwiY3VyTGVuIiwiY29tcG9uZW50RGlkTW91bnQiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZW5kZXIiLCJvdGhlclByb3BzIiwibGVmdEluZGljYXRvclN0eWxlIiwibGVmdCIsInJpZ2h0SW5kaWNhdG9yU3R5bGUiLCJyaWdodCIsImxlZnRPdmVyZmxvd0luZGljYXRvciIsInJpZ2h0T3ZlcmZsb3dJbmRpY2F0b3IiLCJhdXRvSGlkZVNjcm9sbGJhciIsImNvbGxlY3RTY3JvbGxlciIsIm9uTW91c2VXaGVlbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBOztBQUNBOztBQUNBOzs7Ozs7Ozs7O0lBdUJxQkEsa0IsV0FEcEIsZ0RBQXFCLCtCQUFyQixDLGdCQUFELE1BQ3FCQSxrQkFEckIsU0FDZ0RDLGVBQU1DLFNBRHRELENBQ2dGO0FBSXpDO0FBRW5DQyxFQUFBQSxXQUFXLENBQUNDLEtBQUQsRUFBZ0I7QUFDdkIsVUFBTUEsS0FBTjtBQUR1QiwwRUFMQyx1QkFLRDtBQUFBO0FBQUEsOERBSFcsSUFHWDtBQUFBLGlFQUZLLENBRUw7QUFBQSwyREFTQUMsUUFBRCxJQUFvQztBQUMxRCxVQUFJQSxRQUFRLElBQUksQ0FBQyxLQUFLQyxhQUF0QixFQUFxQztBQUNqQyxhQUFLQSxhQUFMLEdBQXFCRCxRQUFyQixDQURpQyxDQUVqQztBQUNBOztBQUNBLGFBQUtDLGFBQUwsQ0FBbUJDLGdCQUFuQixDQUFvQyxRQUFwQyxFQUE4QyxLQUFLQyxhQUFuRCxFQUFrRTtBQUFFQyxVQUFBQSxPQUFPLEVBQUU7QUFBWCxTQUFsRTtBQUNBLGFBQUtELGFBQUw7QUFDSDtBQUNKLEtBakIwQjtBQUFBLHlEQWtDSCxNQUFZO0FBQ2hDLFlBQU1FLGNBQWMsR0FBRyxLQUFLSixhQUFMLENBQW1CSyxTQUFuQixHQUErQixDQUF0RDtBQUNBLFlBQU1DLGlCQUFpQixHQUFHLEtBQUtOLGFBQUwsQ0FBbUJPLFlBQW5CLEdBQ3JCLEtBQUtQLGFBQUwsQ0FBbUJLLFNBQW5CLEdBQStCLEtBQUtMLGFBQUwsQ0FBbUJRLFlBRHZEO0FBRUEsWUFBTUMsZUFBZSxHQUFHLEtBQUtULGFBQUwsQ0FBbUJVLFVBQW5CLEdBQWdDLENBQXhEO0FBQ0EsWUFBTUMsZ0JBQWdCLEdBQUcsS0FBS1gsYUFBTCxDQUFtQlksV0FBbkIsR0FD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QUFNZ0MsbUJBQW1CLEdBQUc7QUFBRUMsTUFBQUEsS0FBSyxFQUFFLEtBQUtoQixLQUFMLENBQVdoQjtBQUFwQixLQUE1QjtBQUNBLFVBQU1pQyxxQkFBcUIsR0FBR3BDLHVCQUF1QixnQkFDL0M7QUFBSyxNQUFBLFNBQVMsRUFBQyw2Q0FBZjtBQUE2RCxNQUFBLEtBQUssRUFBRWdDO0FBQXBFLE1BRCtDLEdBQzhDLElBRG5HO0FBRUEsVUFBTUssc0JBQXNCLEdBQUdyQyx1QkFBdUIsZ0JBQ2hEO0FBQUssTUFBQSxTQUFTLEVBQUMsOENBQWY7QUFBOEQsTUFBQSxLQUFLLEVBQUVrQztBQUFyRSxNQURnRCxHQUMrQyxJQURyRztBQUdBLHdCQUFRLDZCQUFDLDBCQUFEO0FBQ0osTUFBQSxHQUFHLEVBQUUsS0FBS0ksaUJBRE47QUFFSixNQUFBLFVBQVUsRUFBRSxLQUFLQyxlQUZiO0FBR0osTUFBQSxPQUFPLEVBQUUsS0FBS0M7QUFIVixPQUlBVCxVQUpBLEdBTUZLLHFCQU5FLEVBT0ZYLFFBUEUsRUFRRlksc0JBUkUsQ0FBUjtBQVVIOztBQTNKMkUsQyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxOCBOZXcgVmVjdG9yIEx0ZFxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVSZWYgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBBdXRvSGlkZVNjcm9sbGJhciBmcm9tIFwiLi9BdXRvSGlkZVNjcm9sbGJhclwiO1xuaW1wb3J0IHsgcmVwbGFjZWFibGVDb21wb25lbnQgfSBmcm9tIFwiLi4vLi4vdXRpbHMvcmVwbGFjZWFibGVDb21wb25lbnRcIjtcblxuaW50ZXJmYWNlIElQcm9wcyB7XG4gICAgLy8gSWYgdHJ1ZSwgdGhlIHNjcm9sbGJhciB3aWxsIGFwcGVuZCBteF9JbmRpY2F0b3JTY3JvbGxiYXJfbGVmdE92ZXJmbG93SW5kaWNhdG9yXG4gICAgLy8gYW5kIG14X0luZGljYXRvclNjcm9sbGJhcl9yaWdodE92ZXJmbG93SW5kaWNhdG9yIGVsZW1lbnRzIHRvIHRoZSBsaXN0IGZvciBwb3NpdGlvbmluZ1xuICAgIC8vIGJ5IHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICB0cmFja0hvcml6b250YWxPdmVyZmxvdz86IGJvb2xlYW47XG5cbiAgICAvLyBJZiB0cnVlLCB3aGVuIHRoZSB1c2VyIHRyaWVzIHRvIHVzZSB0aGVpciBtb3VzZSB3aGVlbCBpbiB0aGUgY29tcG9uZW50IGl0IHdpbGxcbiAgICAvLyBzY3JvbGwgaG9yaXpvbnRhbGx5IHJhdGhlciB0aGFuIHZlcnRpY2FsbHkuIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCBvbiBjb21wb25lbnRzXG4gICAgLy8gd2l0aCBubyB2ZXJ0aWNhbCBzY3JvbGwgb3Bwb3J0dW5pdHkuXG4gICAgdmVydGljYWxTY3JvbGxzSG9yaXpvbnRhbGx5PzogYm9vbGVhbjtcblxuICAgIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgY2xhc3NOYW1lOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBJU3RhdGUge1xuICAgIGxlZnRJbmRpY2F0b3JPZmZzZXQ6IG51bWJlciB8IHN0cmluZztcbiAgICByaWdodEluZGljYXRvck9mZnNldDogbnVtYmVyIHwgc3RyaW5nO1xufVxuXG5AcmVwbGFjZWFibGVDb21wb25lbnQoXCJzdHJ1Y3R1cmVzLkluZGljYXRvclNjcm9sbGJhclwiKVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5kaWNhdG9yU2Nyb2xsYmFyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PElQcm9wcywgSVN0YXRlPiB7XG4gICAgcHJpdmF0ZSBhdXRvSGlkZVNjcm9sbGJhciA9IGNyZWF0ZVJlZjxBdXRvSGlkZVNjcm9sbGJhcj4oKTtcbiAgICBwcml2YXRlIHNjcm9sbEVsZW1lbnQ6IEhUTUxEaXZFbGVtZW50O1xuICAgIHByaXZhdGUgbGlrZWx5VHJhY2twYWRVc2VyOiBib29sZWFuID0gbnVsbDtcbiAgICBwcml2YXRlIGNoZWNrQWdhaW5Gb3JUcmFja3BhZCA9IDA7IC8vIHRzIGluIG1pbGxpc2Vjb25kcyB0byByZWNoZWNrIHRoaXMuX2xpa2VseVRyYWNrcGFkVXNlclxuXG4gICAgY29uc3RydWN0b3IocHJvcHM6IElQcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGxlZnRJbmRpY2F0b3JPZmZzZXQ6IDAsXG4gICAgICAgICAgICByaWdodEluZGljYXRvck9mZnNldDogMCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNvbGxlY3RTY3JvbGxlciA9IChzY3JvbGxlcjogSFRNTERpdkVsZW1lbnQpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKHNjcm9sbGVyICYmICF0aGlzLnNjcm9sbEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudCA9IHNjcm9sbGVyO1xuICAgICAgICAgICAgLy8gVXNpbmcgdGhlIHBhc3NpdmUgb3B0aW9uIHRvIG5vdCBibG9jayB0aGUgbWFpbiB0aHJlYWRcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9hZGRFdmVudExpc3RlbmVyI2ltcHJvdmluZ19zY3JvbGxpbmdfcGVyZm9ybWFuY2Vfd2l0aF9wYXNzaXZlX2xpc3RlbmVyc1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5jaGVja092ZXJmbG93LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrT3ZlcmZsb3coKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwdWJsaWMgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wczogSVByb3BzKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHByZXZMZW4gPSBSZWFjdC5DaGlsZHJlbi5jb3VudChwcmV2UHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICBjb25zdCBjdXJMZW4gPSBSZWFjdC5DaGlsZHJlbi5jb3VudCh0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgLy8gY2hlY2sgb3ZlcmZsb3cgb25seSBpZiBhbW91bnQgb2YgY2hpbGRyZW4gY2hhbmdlcy5cbiAgICAgICAgLy8gaWYgd2UgZG9uJ3QgZ3VhcmQgaGVyZSwgd2UgZW5kIHVwIHdpdGggYW4gaW5maW5pdGVcbiAgICAgICAgLy8gcmVuZGVyID4gY29tcG9uZW50RGlkVXBkYXRlID4gY2hlY2tPdmVyZmxvdyA+IHNldFN0YXRlID4gcmVuZGVyIGxvb3BcbiAgICAgICAgaWYgKHByZXZMZW4gIT09IGN1ckxlbikge1xuICAgICAgICAgICAgdGhpcy5jaGVja092ZXJmbG93KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgY29tcG9uZW50RGlkTW91bnQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY2hlY2tPdmVyZmxvdygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgY2hlY2tPdmVyZmxvdyA9ICgpOiB2b2lkID0+IHtcbiAgICAgICAgY29uc3QgaGFzVG9wT3ZlcmZsb3cgPSB0aGlzLnNjcm9sbEVsZW1lbnQuc2Nyb2xsVG9wID4gMDtcbiAgICAgICAgY29uc3QgaGFzQm90dG9tT3ZlcmZsb3cgPSB0aGlzLnNjcm9sbEVsZW1lbnQuc2Nyb2xsSGVpZ2h0ID5cbiAgICAgICAgICAgICh0aGlzLnNjcm9sbEVsZW1lbnQuc2Nyb2xsVG9wICsgdGhpcy5zY3JvbGxFbGVtZW50LmNsaWVudEhlaWdodCk7XG4gICAgICAgIGNvbnN0IGhhc0xlZnRPdmVyZmxvdyA9IHRoaXMuc2Nyb2xsRWxlbWVudC5zY3JvbGxMZWZ0ID4gMDtcbiAgICAgICAgY29uc3QgaGFzUmlnaHRPdmVyZmxvdyA9IHRoaXMuc2Nyb2xsRWxlbWVudC5zY3JvbGxXaWR0aCA+XG4gICAgICAgICAgICAodGhpcy5zY3JvbGxFbGVtZW50LnNjcm9sbExlZnQgKyB0aGlzLnNjcm9sbEVsZW1lbnQuY2xpZW50V2lkdGgpO1xuXG4gICAgICAgIGlmIChoYXNUb3BPdmVyZmxvdykge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJteF9JbmRpY2F0b3JTY3JvbGxiYXJfdG9wT3ZlcmZsb3dcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcIm14X0luZGljYXRvclNjcm9sbGJhcl90b3BPdmVyZmxvd1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzQm90dG9tT3ZlcmZsb3cpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibXhfSW5kaWNhdG9yU2Nyb2xsYmFyX2JvdHRvbU92ZXJmbG93XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJteF9JbmRpY2F0b3JTY3JvbGxiYXJfYm90dG9tT3ZlcmZsb3dcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0xlZnRPdmVyZmxvdykge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJteF9JbmRpY2F0b3JTY3JvbGxiYXJfbGVmdE92ZXJmbG93XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJteF9JbmRpY2F0b3JTY3JvbGxiYXJfbGVmdE92ZXJmbG93XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNSaWdodE92ZXJmbG93KSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcIm14X0luZGljYXRvclNjcm9sbGJhcl9yaWdodE92ZXJmbG93XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJteF9JbmRpY2F0b3JTY3JvbGxiYXJfcmlnaHRPdmVyZmxvd1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLnRyYWNrSG9yaXpvbnRhbE92ZXJmbG93KSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAvLyBPZmZzZXQgZnJvbSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgbGVmdEluZGljYXRvck9mZnNldDogaGFzTGVmdE92ZXJmbG93ID8gYCR7dGhpcy5zY3JvbGxFbGVtZW50LnNjcm9sbExlZnR9cHhgIDogJzAnLFxuXG4gICAgICAgICAgICAgICAgLy8gTmVnYXRpdmUgYmVjYXVzZSB3ZSdyZSBjb21pbmcgZnJvbSB0aGUgcmlnaHRcbiAgICAgICAgICAgICAgICByaWdodEluZGljYXRvck9mZnNldDogaGFzUmlnaHRPdmVyZmxvdyA/IGAtJHt0aGlzLnNjcm9sbEVsZW1lbnQuc2Nyb2xsTGVmdH1weGAgOiAnMCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwdWJsaWMgY29tcG9uZW50V2lsbFVubW91bnQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMuY2hlY2tPdmVyZmxvdyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIG9uTW91c2VXaGVlbCA9IChlOiBSZWFjdC5XaGVlbEV2ZW50KTogdm9pZCA9PiB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnZlcnRpY2FsU2Nyb2xsc0hvcml6b250YWxseSAmJiB0aGlzLnNjcm9sbEVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIHh5VGhyZXNob2xkIGlzIHRoZSBhbW91bnQgb2YgaG9yaXpvbnRhbCBtb3Rpb24gcmVxdWlyZWQgZm9yIHRoZSBjb21wb25lbnQgdG9cbiAgICAgICAgICAgIC8vIGlnbm9yZSB0aGUgdmVydGljYWwgZGVsdGEgaW4gYSBzY3JvbGwuIFVzZWQgdG8gc3RvcCB0cmFja3BhZHMgZnJvbSBhY3RpbmcgaW5cbiAgICAgICAgICAgIC8vIHN0cmFuZ2Ugd2F5cy4gU2hvdWxkIGJlIHBvc2l0aXZlLlxuICAgICAgICAgICAgY29uc3QgeHlUaHJlc2hvbGQgPSAwO1xuXG4gICAgICAgICAgICAvLyB5UmV0ZW50aW9uIGlzIHRoZSBmYWN0b3IgbXVsdGlwbGllZCBieSB0aGUgdmVydGljYWwgZGVsdGEgdG8gdHJ5IGFuZCByZWR1Y2VcbiAgICAgICAgICAgIC8vIHRoZSBoYXJzaG5lc3Mgb2YgdGhlIHNjcm9sbCBiZWhhdmlvdXIuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMS5cbiAgICAgICAgICAgIGNvbnN0IHlSZXRlbnRpb24gPSAxLjA7XG5cbiAgICAgICAgICAgIC8vIHdoZW5ldmVyIHdlIHNlZSBob3Jpem9udGFsIHNjcm9sbGluZywgYXNzdW1lIHRoZSB1c2VyIGlzIG9uIGEgdHJhY2twYWRcbiAgICAgICAgICAgIC8vIGZvciBhdCBsZWFzdCB0aGUgbmV4dCAxIG1pbnV0ZS5cbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGUuZGVsdGFYKSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpa2VseVRyYWNrcGFkVXNlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0FnYWluRm9yVHJhY2twYWQgPSBub3cgKyAoMSAqIDYwICogMTAwMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmVuJ3Qgc2VlbiBhbnkgaG9yaXpvbnRhbCBzY3JvbGxpbmcgZm9yIGEgd2hpbGUsIGFzc3VtZVxuICAgICAgICAgICAgICAgIC8vIHRoZSB1c2VyIG1pZ2h0IGhhdmUgcGx1Z2dlZCBpbiBhIG1vdXNld2hlZWxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5saWtlbHlUcmFja3BhZFVzZXIgJiYgbm93ID49IHRoaXMuY2hlY2tBZ2FpbkZvclRyYWNrcGFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlrZWx5VHJhY2twYWRVc2VyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkb24ndCBtZXNzIHdpdGggdGhlIGhvcml6b250YWwgc2Nyb2xsIGZvciB0cmFja3BhZCB1c2Vyc1xuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92ZWN0b3ItaW0vZWxlbWVudC13ZWIvaXNzdWVzLzEwMDA1XG4gICAgICAgICAgICBpZiAodGhpcy5saWtlbHlUcmFja3BhZFVzZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhlLmRlbHRhWCkgPD0geHlUaHJlc2hvbGQpIHsgLy8gd2UgYXJlIHZlcnRpY2FsbHkgc2Nyb2xsaW5nLlxuICAgICAgICAgICAgICAgIC8vIEhBQ0s6IFdlIGluY3JlYXNlIHRoZSBhbW91bnQgb2Ygc2Nyb2xsIHRvIGNvdW50ZXJhY3Qgc21vb3RoIHNjcm9sbGluZyBicm93c2Vycy5cbiAgICAgICAgICAgICAgICAvLyBTbW9vdGggc2Nyb2xsaW5nIGJyb3dzZXJzIChGaXJlZm94KSB1c2UgdGhlIHJlbGF0aXZlIGFyZWEgdG8gZGV0ZXJtaW5lIHRoZSBzY3JvbGxcbiAgICAgICAgICAgICAgICAvLyBhbW91bnQsIHdoaWNoIG1lYW5zIHRoZSBsaWtlbHkgc21hbGwgYXJlYSBvZiBjb250ZW50IHJlc3VsdHMgaW4gYSBzbWFsbCBhbW91bnQgb2ZcbiAgICAgICAgICAgICAgICAvLyBtb3ZlbWVudCAtIG5vdCB3aGF0IHBlb3BsZSBleHBlY3QuIFdlIHBpY2sgYXJiaXRyYXJ5IHZhbHVlcyBmb3Igd2hlbiB0byBhcHBseSBtb3JlXG4gICAgICAgICAgICAgICAgLy8gc2Nyb2xsLCBhbmQgaG93IG11Y2ggdG8gYXBwbHkuIE9uIFdpbmRvd3MgMTAsIENocm9tZSBzY3JvbGxzIDEwMCB1bml0cyB3aGVyZWFzXG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCBzY3JvbGxzIGp1c3QgMyBkdWUgdG8gc21vb3RoIHNjcm9sbGluZy5cblxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZGl0aW9uYWxTY3JvbGwgPSBlLmRlbHRhWSA8IDAgPyAtNTAgOiA1MDtcblxuICAgICAgICAgICAgICAgIC8vIG5vaW5zcGVjdGlvbiBKU1N1c3BpY2lvdXNOYW1lQ29tYmluYXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBNYXRoLmFicyhlLmRlbHRhWSkgPCAyNSA/IChlLmRlbHRhWSArIGFkZGl0aW9uYWxTY3JvbGwpIDogZS5kZWx0YVk7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50LnNjcm9sbExlZnQgKz0gdmFsICogeVJldGVudGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwdWJsaWMgcmVuZGVyKCk6IEpTWC5FbGVtZW50IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICBjb25zdCB7IGNoaWxkcmVuLCB0cmFja0hvcml6b250YWxPdmVyZmxvdywgdmVydGljYWxTY3JvbGxzSG9yaXpvbnRhbGx5LCAuLi5vdGhlclByb3BzIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGNvbnN0IGxlZnRJbmRpY2F0b3JTdHlsZSA9IHsgbGVmdDogdGhpcy5zdGF0ZS5sZWZ0SW5kaWNhdG9yT2Zmc2V0IH07XG4gICAgICAgIGNvbnN0IHJpZ2h0SW5kaWNhdG9yU3R5bGUgPSB7IHJpZ2h0OiB0aGlzLnN0YXRlLnJpZ2h0SW5kaWNhdG9yT2Zmc2V0IH07XG4gICAgICAgIGNvbnN0IGxlZnRPdmVyZmxvd0luZGljYXRvciA9IHRyYWNrSG9yaXpvbnRhbE92ZXJmbG93XG4gICAgICAgICAgICA/IDxkaXYgY2xhc3NOYW1lPVwibXhfSW5kaWNhdG9yU2Nyb2xsYmFyX2xlZnRPdmVyZmxvd0luZGljYXRvclwiIHN0eWxlPXtsZWZ0SW5kaWNhdG9yU3R5bGV9IC8+IDogbnVsbDtcbiAgICAgICAgY29uc3QgcmlnaHRPdmVyZmxvd0luZGljYXRvciA9IHRyYWNrSG9yaXpvbnRhbE92ZXJmbG93XG4gICAgICAgICAgICA/IDxkaXYgY2xhc3NOYW1lPVwibXhfSW5kaWNhdG9yU2Nyb2xsYmFyX3JpZ2h0T3ZlcmZsb3dJbmRpY2F0b3JcIiBzdHlsZT17cmlnaHRJbmRpY2F0b3JTdHlsZX0gLz4gOiBudWxsO1xuXG4gICAgICAgIHJldHVybiAoPEF1dG9IaWRlU2Nyb2xsYmFyXG4gICAgICAgICAgICByZWY9e3RoaXMuYXV0b0hpZGVTY3JvbGxiYXJ9XG4gICAgICAgICAgICB3cmFwcGVkUmVmPXt0aGlzLmNvbGxlY3RTY3JvbGxlcn1cbiAgICAgICAgICAgIG9uV2hlZWw9e3RoaXMub25Nb3VzZVdoZWVsfVxuICAgICAgICAgICAgey4uLm90aGVyUHJvcHN9XG4gICAgICAgID5cbiAgICAgICAgICAgIHsgbGVmdE92ZXJmbG93SW5kaWNhdG9yIH1cbiAgICAgICAgICAgIHsgY2hpbGRyZW4gfVxuICAgICAgICAgICAgeyByaWdodE92ZXJmbG93SW5kaWNhdG9yIH1cbiAgICAgICAgPC9BdXRvSGlkZVNjcm9sbGJhcj4pO1xuICAgIH1cbn1cbiJdfQ==