"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _matrix = require("matrix-js-sdk/src/matrix");

var _react = _interopRequireDefault(require("react"));

var _languageHandler = require("../../../languageHandler");

var _ErrorUtils = require("../../../utils/ErrorUtils");

var _AutoDiscoveryUtils = _interopRequireDefault(require("../../../utils/AutoDiscoveryUtils"));

var _classnames = _interopRequireDefault(require("classnames"));

var Lifecycle = _interopRequireWildcard(require("../../../Lifecycle"));

var _MatrixClientPeg = require("../../../MatrixClientPeg");

var _AuthPage = _interopRequireDefault(require("../../views/auth/AuthPage"));

var _Login = _interopRequireDefault(require("../../../Login"));

var _dispatcher = _interopRequireDefault(require("../../../dispatcher/dispatcher"));

var _SSOButtons = _interopRequireDefault(require("../../views/elements/SSOButtons"));

var _ServerPicker = _interopRequireDefault(require("../../views/elements/ServerPicker"));

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _RegistrationForm = _interopRequireDefault(require("../../views/auth/RegistrationForm"));

var _AccessibleButton = _interopRequireDefault(require("../../views/elements/AccessibleButton"));

var _AuthBody = _interopRequireDefault(require("../../views/auth/AuthBody"));

var _AuthHeader = _interopRequireDefault(require("../../views/auth/AuthHeader"));

var _InteractiveAuth = _interopRequireDefault(require("../InteractiveAuth"));

var _Spinner = _interopRequireDefault(require("../../views/elements/Spinner"));

var _logger = require("matrix-js-sdk/src/logger");

var _dec, _class;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

let Registration = (_dec = (0, _replaceableComponent.replaceableComponent)("structures.auth.Registration"), _dec(_class = class Registration extends _react.default.Component {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "loginLogic", void 0);
    (0, _defineProperty2.default)(this, "onFormSubmit", async formVals => {
      this.setState({
        errorText: "",
        busy: true,
        formVals: formVals,
        doingUIAuth: true
      });
    });
    (0, _defineProperty2.default)(this, "requestEmailToken", (emailAddress, clientSecret, sendAttempt, sessionId) => {
      return this.state.matrixClient.requestRegisterEmailToken(emailAddress, clientSecret, sendAttempt, this.props.makeRegistrationUrl({
        client_secret: clientSecret,
        hs_url: this.state.matrixClient.getHomeserverUrl(),
        is_url: this.state.matrixClient.getIdentityServerUrl(),
        session_id: sessionId
      }));
    });
    (0, _defineProperty2.default)(this, "onUIAuthFinished", async (success, response) => {
      if (!success) {
        let errorText = response.message || response.toString(); // can we give a better error message?

        if (response.errcode === 'M_RESOURCE_LIMIT_EXCEEDED') {
          const errorTop = (0, _ErrorUtils.messageForResourceLimitError)(response.data.limit_type, response.data.admin_contact, {
            'monthly_active_user': (0, _languageHandler._td)("This homeserver has hit its Monthly Active User limit."),
            'hs_blocked': (0, _languageHandler._td)("This homeserver has been blocked by it's administrator."),
            '': (0, _languageHandler._td)("This homeserver has exceeded one of its resource limits.")
          });
          const errorDetail = (0, _ErrorUtils.messageForResourceLimitError)(response.data.limit_type, response.data.admin_contact, {
            '': (0, _languageHandler._td)("Please <a>contact your service administrator</a> to continue using this service.")
          });
          errorText = /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("p", null, errorTop), /*#__PURE__*/_react.default.createElement("p", null, errorDetail));
        } else if (response.required_stages && response.required_stages.indexOf('m.login.msisdn') > -1) {
          let msisdnAvailable = false;

          for (const flow of response.available_flows) {
            msisdnAvailable = msisdnAvailable || flow.stages.includes('m.login.msisdn');
          }

          if (!msisdnAvailable) {
            errorText = (0, _languageHandler._t)('This server does not support authentication with a phone number.');
          }
        } else if (response.errcode === "M_USER_IN_USE") {
          errorText = (0, _languageHandler._t)("Someone already has that username, please try another.");
        } else if (response.errcode === "M_THREEPID_IN_USE") {
          errorText = (0, _languageHandler._t)("That e-mail address is already in use.");
        }

        this.setState({
          busy: false,
          doingUIAuth: false,
          errorText
        });
        return;
      }

      _MatrixClientPeg.MatrixClientPeg.setJustRegisteredUserId(response.user_id);

      const newState = {
        doingUIAuth: false,
        registeredUsername: response.user_id,
        differentLoggedInUserId: null,
        completedNoSignin: false,
        // we're still busy until we get unmounted: don't show the registration form again
        busy: true
      }; // The user came in through an email validation link. To avoid overwriting
      // their session, check to make sure the session isn't someone else, and
      // isn't a guest user since we'll usually have set a guest user session before
      // starting the registration process. This isn't perfect since it's possible
      // the user had a separate guest session they didn't actually mean to replace.

      const [sessionOwner, sessionIsGuest] = await Lifecycle.getStoredSessionOwner();

      if (sessionOwner && !sessionIsGuest && sessionOwner !== response.userId) {
        _logger.logger.log(`Found a session for ${sessionOwner} but ${response.userId} has just registered.`);

        newState.differentLoggedInUserId = sessionOwner;
      }

      if (response.access_token) {
        await this.props.onLoggedIn({
          userId: response.user_id,
          deviceId: response.device_id,
          homeserverUrl: this.state.matrixClient.getHomeserverUrl(),
          identityServerUrl: this.state.matrixClient.getIdentityServerUrl(),
          accessToken: response.access_token
        }, this.state.formVals.password);
        this.setupPushers();
      } else {
        newState.busy = false;
        newState.completedNoSignin = true;
      }

      this.setState(newState);
    });
    (0, _defineProperty2.default)(this, "onLoginClick", ev => {
      ev.preventDefault();
      ev.stopPropagation();
      this.props.onLoginClick();
    });
    (0, _defineProperty2.default)(this, "onGoToFormClicked", ev => {
      ev.preventDefault();
      ev.stopPropagation();
      this.replaceClient(this.props.serverConfig);
      this.setState({
        busy: false,
        doingUIAuth: false
      });
    });
    (0, _defineProperty2.default)(this, "makeRegisterRequest", auth => {
      // We inhibit login if we're trying to register with an email address: this
      // avoids a lot of complex race conditions that can occur if we try to log
      // the user in one one or both of the tabs they might end up with after
      // clicking the email link.
      let inhibitLogin = Boolean(this.state.formVals.email); // Only send inhibitLogin if we're sending username / pw params
      // (Since we need to send no params at all to use the ones saved in the
      // session).

      if (!this.state.formVals.password) inhibitLogin = null;
      const registerParams = {
        username: this.state.formVals.username,
        password: this.state.formVals.password,
        initial_device_display_name: this.props.defaultDeviceDisplayName,
        auth: undefined,
        inhibit_login: undefined
      };
      if (auth) registerParams.auth = auth;
      if (inhibitLogin !== undefined && inhibitLogin !== null) registerParams.inhibit_login = inhibitLogin;
      return this.state.matrixClient.registerRequest(registerParams);
    });
    (0, _defineProperty2.default)(this, "onLoginClickWithCheck", async ev => {
      ev.preventDefault();
      const sessionLoaded = await Lifecycle.loadSession({
        ignoreGuest: true
      });

      if (!sessionLoaded) {
        // ok fine, there's still no session: really go to the login page
        this.props.onLoginClick();
      }

      return sessionLoaded;
    });
    this.state = {
      busy: false,
      errorText: null,
      formVals: {
        email: this.props.email
      },
      doingUIAuth: Boolean(this.props.sessionId),
      flows: null,
      completedNoSignin: false,
      serverIsAlive: true,
      serverErrorIsFatal: false,
      serverDeadError: ""
    };
    const {
      hsUrl,
      isUrl
    } = this.props.serverConfig;
    this.loginLogic = new _Login.default(hsUrl, isUrl, null, {
      defaultDeviceDisplayName: "Element login check" // We shouldn't ever be used

    });
  }

  componentDidMount() {
    this.replaceClient(this.props.serverConfig);
  } // TODO: [REACT-WARNING] Replace with appropriate lifecycle event
  // eslint-disable-next-line


  UNSAFE_componentWillReceiveProps(newProps) {
    if (newProps.serverConfig.hsUrl === this.props.serverConfig.hsUrl && newProps.serverConfig.isUrl === this.props.serverConfig.isUrl) return;
    this.replaceClient(newProps.serverConfig);
  }

  async replaceClient(serverConfig) {
    this.setState({
      errorText: null,
      serverDeadError: null,
      serverErrorIsFatal: false,
      // busy while we do liveness check (we need to avoid trying to render
      // the UI auth component while we don't have a matrix client)
      busy: true
    }); // Do a liveliness check on the URLs

    try {
      await _AutoDiscoveryUtils.default.validateServerConfigWithStaticUrls(serverConfig.hsUrl, serverConfig.isUrl);
      this.setState({
        serverIsAlive: true,
        serverErrorIsFatal: false
      });
    } catch (e) {
      this.setState(_objectSpread({
        busy: false
      }, _AutoDiscoveryUtils.default.authComponentStateForError(e, "register")));

      if (this.state.serverErrorIsFatal) {
        return; // Server is dead - do not continue.
      }
    }

    const {
      hsUrl,
      isUrl
    } = serverConfig;
    const cli = (0, _matrix.createClient)({
      baseUrl: hsUrl,
      idBaseUrl: isUrl
    });
    this.loginLogic.setHomeserverUrl(hsUrl);
    this.loginLogic.setIdentityServerUrl(isUrl);
    let ssoFlow;

    try {
      const loginFlows = await this.loginLogic.getFlows();
      ssoFlow = loginFlows.find(f => f.type === "m.login.sso" || f.type === "m.login.cas");
    } catch (e) {
      _logger.logger.error("Failed to get login flows to check for SSO support", e);
    }

    this.setState({
      matrixClient: cli,
      ssoFlow,
      busy: false
    });

    const showGenericError = e => {
      this.setState({
        errorText: (0, _languageHandler._t)("Unable to query for supported registration methods."),
        // add empty flows array to get rid of spinner
        flows: []
      });
    };

    try {
      // We do the first registration request ourselves to discover whether we need to
      // do SSO instead. If we've already started the UI Auth process though, we don't
      // need to.
      if (!this.state.doingUIAuth) {
        await this.makeRegisterRequest(null); // This should never succeed since we specified no auth object.

        _logger.logger.log("Expecting 401 from register request but got success!");
      }
    } catch (e) {
      if (e.httpStatus === 401) {
        this.setState({
          flows: e.data.flows
        });
      } else if (e.httpStatus === 403 || e.errcode === "M_FORBIDDEN") {
        // Check for 403 or M_FORBIDDEN, Synapse used to send 403 M_UNKNOWN but now sends 403 M_FORBIDDEN.
        // At this point registration is pretty much disabled, but before we do that let's
        // quickly check to see if the server supports SSO instead. If it does, we'll send
        // the user off to the login page to figure their account out.
        if (ssoFlow) {
          // Redirect to login page - server probably expects SSO only
          _dispatcher.default.dispatch({
            action: 'start_login'
          });
        } else {
          this.setState({
            serverErrorIsFatal: true,
            // fatal because user cannot continue on this server
            errorText: (0, _languageHandler._t)("Registration has been disabled on this homeserver."),
            // add empty flows array to get rid of spinner
            flows: []
          });
        }
      } else {
        _logger.logger.log("Unable to query for supported registration methods.", e);

        showGenericError(e);
      }
    }
  }

  setupPushers() {
    if (!this.props.brand) {
      return Promise.resolve();
    }

    const matrixClient = _MatrixClientPeg.MatrixClientPeg.get();

    return matrixClient.getPushers().then(resp => {
      const pushers = resp.pushers;

      for (let i = 0; i < pushers.length; ++i) {
        if (pushers[i].kind === 'email') {
          const emailPusher = pushers[i];
          emailPusher.data = {
            brand: this.props.brand
          };
          matrixClient.setPusher(emailPusher).then(() => {
            _logger.logger.log("Set email branding to " + this.props.brand);
          }, error => {
            _logger.logger.error("Couldn't set email branding: " + error);
          });
        }
      }
    }, error => {
      _logger.logger.error("Couldn't get pushers: " + error);
    });
  }

  getUIAuthInputs() {
    return {
      emailAddress: this.state.formVals.email,
      phoneCountry: this.state.formVals.phoneCountry,
      phoneNumber: this.state.formVals.phoneNumber
    };
  } // Links to the login page shown after registration is completed are routed through this
  // which checks the user hasn't already logged in somewhere else (perhaps we should do
  // this more generally?)


  renderRegisterComponent() {
    if (this.state.matrixClient && this.state.doingUIAuth) {
      return /*#__PURE__*/_react.default.createElement(_InteractiveAuth.default, {
        matrixClient: this.state.matrixClient,
        makeRequest: this.makeRegisterRequest,
        onAuthFinished: this.onUIAuthFinished,
        inputs: this.getUIAuthInputs(),
        requestEmailToken: this.requestEmailToken,
        sessionId: this.props.sessionId,
        clientSecret: this.props.clientSecret,
        emailSid: this.props.idSid,
        poll: true
      });
    } else if (!this.state.matrixClient && !this.state.busy) {
      return null;
    } else if (this.state.busy || !this.state.flows) {
      return /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_AuthBody_spinner"
      }, /*#__PURE__*/_react.default.createElement(_Spinner.default, null));
    } else if (this.state.flows.length) {
      let ssoSection;

      if (this.state.ssoFlow) {
        let continueWithSection;
        const providers = this.state.ssoFlow.identity_providers || []; // when there is only a single (or 0) providers we show a wide button with `Continue with X` text

        if (providers.length > 1) {
          // i18n: ssoButtons is a placeholder to help translators understand context
          continueWithSection = /*#__PURE__*/_react.default.createElement("h3", {
            className: "mx_AuthBody_centered"
          }, (0, _languageHandler._t)("Continue with %(ssoButtons)s", {
            ssoButtons: ""
          }).trim());
        } // i18n: ssoButtons & usernamePassword are placeholders to help translators understand context


        ssoSection = /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, continueWithSection, /*#__PURE__*/_react.default.createElement(_SSOButtons.default, {
          matrixClient: this.loginLogic.createTemporaryClient(),
          flow: this.state.ssoFlow,
          loginType: this.state.ssoFlow.type === "m.login.sso" ? "sso" : "cas",
          fragmentAfterLogin: this.props.fragmentAfterLogin
        }), /*#__PURE__*/_react.default.createElement("h3", {
          className: "mx_AuthBody_centered"
        }, (0, _languageHandler._t)("%(ssoButtons)s Or %(usernamePassword)s", {
          ssoButtons: "",
          usernamePassword: ""
        }).trim()));
      }

      return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, ssoSection, /*#__PURE__*/_react.default.createElement(_RegistrationForm.default, {
        defaultUsername: this.state.formVals.username,
        defaultEmail: this.state.formVals.email,
        defaultPhoneCountry: this.state.formVals.phoneCountry,
        defaultPhoneNumber: this.state.formVals.phoneNumber,
        defaultPassword: this.state.formVals.password,
        onRegisterClick: this.onFormSubmit,
        flows: this.state.flows,
        serverConfig: this.props.serverConfig,
        canSubmit: !this.state.serverErrorIsFatal,
        matrixClient: this.state.matrixClient
      }));
    }
  }

  render() {
    let errorText;
    const err = this.state.errorText;

    if (err) {
      errorText = /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_Login_error"
      }, err);
    }

    let serverDeadSection;

    if (!this.state.serverIsAlive) {
      const classes = (0, _classnames.default)({
        "mx_Login_error": true,
        "mx_Login_serverError": true,
        "mx_Login_serverErrorNonFatal": !this.state.serverErrorIsFatal
      });
      serverDeadSection = /*#__PURE__*/_react.default.createElement("div", {
        className: classes
      }, this.state.serverDeadError);
    }

    const signIn = /*#__PURE__*/_react.default.createElement("span", {
      className: "mx_AuthBody_changeFlow"
    }, (0, _languageHandler._t)("Already have an account? <a>Sign in here</a>", {}, {
      a: sub => /*#__PURE__*/_react.default.createElement("a", {
        onClick: this.onLoginClick,
        href: "#"
      }, sub)
    })); // Only show the 'go back' button if you're not looking at the form


    let goBack;

    if (this.state.doingUIAuth) {
      goBack = /*#__PURE__*/_react.default.createElement("a", {
        className: "mx_AuthBody_changeFlow",
        onClick: this.onGoToFormClicked,
        href: "#"
      }, (0, _languageHandler._t)('Go back'));
    }

    let body;

    if (this.state.completedNoSignin) {
      let regDoneText;

      if (this.state.differentLoggedInUserId) {
        regDoneText = /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("p", null, (0, _languageHandler._t)("Your new account (%(newAccountId)s) is registered, but you're already " + "logged into a different account (%(loggedInUserId)s).", {
          newAccountId: this.state.registeredUsername,
          loggedInUserId: this.state.differentLoggedInUserId
        })), /*#__PURE__*/_react.default.createElement("p", null, /*#__PURE__*/_react.default.createElement(_AccessibleButton.default, {
          element: "span",
          className: "mx_linkButton",
          onClick: async event => {
            const sessionLoaded = await this.onLoginClickWithCheck(event);

            if (sessionLoaded) {
              _dispatcher.default.dispatch({
                action: "view_welcome_page"
              });
            }
          }
        }, (0, _languageHandler._t)("Continue with previous account"))));
      } else if (this.state.formVals.password) {
        // We're the client that started the registration
        regDoneText = /*#__PURE__*/_react.default.createElement("h3", null, (0, _languageHandler._t)("<a>Log in</a> to your new account.", {}, {
          a: sub => /*#__PURE__*/_react.default.createElement("a", {
            href: "#/login",
            onClick: this.onLoginClickWithCheck
          }, sub)
        }));
      } else {
        // We're not the original client: the user probably got to us by clicking the
        // email validation link. We can't offer a 'go straight to your account' link
        // as we don't have the original creds.
        regDoneText = /*#__PURE__*/_react.default.createElement("h3", null, (0, _languageHandler._t)("You can now close this window or <a>log in</a> to your new account.", {}, {
          a: sub => /*#__PURE__*/_react.default.createElement("a", {
            href: "#/login",
            onClick: this.onLoginClickWithCheck
          }, sub)
        }));
      }

      body = /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("h2", null, (0, _languageHandler._t)("Registration Successful")), regDoneText);
    } else {
      body = /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("h2", null, (0, _languageHandler._t)('Create account')), errorText, serverDeadSection, /*#__PURE__*/_react.default.createElement(_ServerPicker.default, {
        title: (0, _languageHandler._t)("Host account on"),
        dialogTitle: (0, _languageHandler._t)("Decide where your account is hosted"),
        serverConfig: this.props.serverConfig,
        onServerConfigChange: this.state.doingUIAuth ? undefined : this.props.onServerConfigChange
      }), this.renderRegisterComponent(), goBack, signIn);
    }

    return /*#__PURE__*/_react.default.createElement(_AuthPage.default, null, /*#__PURE__*/_react.default.createElement(_AuthHeader.default, null), /*#__PURE__*/_react.default.createElement(_AuthBody.default, null, body));
  }

}) || _class);
exports.default = Registration;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3N0cnVjdHVyZXMvYXV0aC9SZWdpc3RyYXRpb24udHN4Il0sIm5hbWVzIjpbIlJlZ2lzdHJhdGlvbiIsIlJlYWN0IiwiQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJwcm9wcyIsImZvcm1WYWxzIiwic2V0U3RhdGUiLCJlcnJvclRleHQiLCJidXN5IiwiZG9pbmdVSUF1dGgiLCJlbWFpbEFkZHJlc3MiLCJjbGllbnRTZWNyZXQiLCJzZW5kQXR0ZW1wdCIsInNlc3Npb25JZCIsInN0YXRlIiwibWF0cml4Q2xpZW50IiwicmVxdWVzdFJlZ2lzdGVyRW1haWxUb2tlbiIsIm1ha2VSZWdpc3RyYXRpb25VcmwiLCJjbGllbnRfc2VjcmV0IiwiaHNfdXJsIiwiZ2V0SG9tZXNlcnZlclVybCIsImlzX3VybCIsImdldElkZW50aXR5U2VydmVyVXJsIiwic2Vzc2lvbl9pZCIsInN1Y2Nlc3MiLCJyZXNwb25zZSIsIm1lc3NhZ2UiLCJ0b1N0cmluZyIsImVycmNvZGUiLCJlcnJvclRvcCIsImRhdGEiLCJsaW1pdF90eXBlIiwiYWRtaW5fY29udGFjdCIsImVycm9yRGV0YWlsIiwicmVxdWlyZWRfc3RhZ2VzIiwiaW5kZXhPZiIsIm1zaXNkbkF2YWlsYWJsZSIsImZsb3ciLCJhdmFpbGFibGVfZmxvd3MiLCJzdGFnZXMiLCJpbmNsdWRlcyIsIk1hdHJpeENsaWVudFBlZyIsInNldEp1c3RSZWdpc3RlcmVkVXNlcklkIiwidXNlcl9pZCIsIm5ld1N0YXRlIiwicmVnaXN0ZXJlZFVzZXJuYW1lIiwiZGlmZmVyZW50TG9nZ2VkSW5Vc2VySWQiLCJjb21wbGV0ZWROb1NpZ25pbiIsInNlc3Npb25Pd25lciIsInNlc3Npb25Jc0d1ZXN0IiwiTGlmZWN5Y2xlIiwiZ2V0U3RvcmVkU2Vzc2lvbk93bmVyIiwidXNlcklkIiwibG9nZ2VyIiwibG9nIiwiYWNjZXNzX3Rva2VuIiwib25Mb2dnZWRJbiIsImRldmljZUlkIiwiZGV2aWNlX2lkIiwiaG9tZXNlcnZlclVybCIsImlkZW50aXR5U2VydmVyVXJsIiwiYWNjZXNzVG9rZW4iLCJwYXNzd29yZCIsInNldHVwUHVzaGVycyIsImV2IiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJvbkxvZ2luQ2xpY2siLCJyZXBsYWNlQ2xpZW50Iiwic2VydmVyQ29uZmlnIiwiYXV0aCIsImluaGliaXRMb2dpbiIsIkJvb2xlYW4iLCJlbWFpbCIsInJlZ2lzdGVyUGFyYW1zIiwidXNlcm5hbWUiLCJpbml0aWFsX2RldmljZV9kaXNwbGF5X25hbWUiLCJkZWZhdWx0RGV2aWNlRGlzcGxheU5hbWUiLCJ1bmRlZmluZWQiLCJpbmhpYml0X2xvZ2luIiwicmVnaXN0ZXJSZXF1ZXN0Iiwic2Vzc2lvbkxvYWRlZCIsImxvYWRTZXNzaW9uIiwiaWdub3JlR3Vlc3QiLCJmbG93cyIsInNlcnZlcklzQWxpdmUiLCJzZXJ2ZXJFcnJvcklzRmF0YWwiLCJzZXJ2ZXJEZWFkRXJyb3IiLCJoc1VybCIsImlzVXJsIiwibG9naW5Mb2dpYyIsIkxvZ2luIiwiY29tcG9uZW50RGlkTW91bnQiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIm5ld1Byb3BzIiwiQXV0b0Rpc2NvdmVyeVV0aWxzIiwidmFsaWRhdGVTZXJ2ZXJDb25maWdXaXRoU3RhdGljVXJscyIsImUiLCJhdXRoQ29tcG9uZW50U3RhdGVGb3JFcnJvciIsImNsaSIsImJhc2VVcmwiLCJpZEJhc2VVcmwiLCJzZXRIb21lc2VydmVyVXJsIiwic2V0SWRlbnRpdHlTZXJ2ZXJVcmwiLCJzc29GbG93IiwibG9naW5GbG93cyIsImdldEZsb3dzIiwiZmluZCIsImYiLCJ0eXBlIiwiZXJyb3IiLCJzaG93R2VuZXJpY0Vycm9yIiwibWFrZVJlZ2lzdGVyUmVxdWVzdCIsImh0dHBTdGF0dXMiLCJkaXMiLCJkaXNwYXRjaCIsImFjdGlvbiIsImJyYW5kIiwiUHJvbWlzZSIsInJlc29sdmUiLCJnZXQiLCJnZXRQdXNoZXJzIiwidGhlbiIsInJlc3AiLCJwdXNoZXJzIiwiaSIsImxlbmd0aCIsImtpbmQiLCJlbWFpbFB1c2hlciIsInNldFB1c2hlciIsImdldFVJQXV0aElucHV0cyIsInBob25lQ291bnRyeSIsInBob25lTnVtYmVyIiwicmVuZGVyUmVnaXN0ZXJDb21wb25lbnQiLCJvblVJQXV0aEZpbmlzaGVkIiwicmVxdWVzdEVtYWlsVG9rZW4iLCJpZFNpZCIsInNzb1NlY3Rpb24iLCJjb250aW51ZVdpdGhTZWN0aW9uIiwicHJvdmlkZXJzIiwiaWRlbnRpdHlfcHJvdmlkZXJzIiwic3NvQnV0dG9ucyIsInRyaW0iLCJjcmVhdGVUZW1wb3JhcnlDbGllbnQiLCJmcmFnbWVudEFmdGVyTG9naW4iLCJ1c2VybmFtZVBhc3N3b3JkIiwib25Gb3JtU3VibWl0IiwicmVuZGVyIiwiZXJyIiwic2VydmVyRGVhZFNlY3Rpb24iLCJjbGFzc2VzIiwic2lnbkluIiwiYSIsInN1YiIsImdvQmFjayIsIm9uR29Ub0Zvcm1DbGlja2VkIiwiYm9keSIsInJlZ0RvbmVUZXh0IiwibmV3QWNjb3VudElkIiwibG9nZ2VkSW5Vc2VySWQiLCJldmVudCIsIm9uTG9naW5DbGlja1dpdGhDaGVjayIsIm9uU2VydmVyQ29uZmlnQ2hhbmdlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWdCQTs7QUFDQTs7QUFHQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0lBMkVxQkEsWSxXQURwQixnREFBcUIsOEJBQXJCLEMsZ0JBQUQsTUFDcUJBLFlBRHJCLFNBQzBDQyxlQUFNQyxTQURoRCxDQUMwRTtBQUd0RUMsRUFBQUEsV0FBVyxDQUFDQyxLQUFELEVBQVE7QUFDZixVQUFNQSxLQUFOO0FBRGU7QUFBQSx3REFvSUksTUFBT0MsUUFBUCxJQUFtQztBQUN0RCxXQUFLQyxRQUFMLENBQWM7QUFD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QUVEckosU0FGQyxFQUdEOEksaUJBSEMsZUFJSCw2QkFBQyxxQkFBRDtBQUNJLFFBQUEsS0FBSyxFQUFFLHlCQUFHLGlCQUFILENBRFg7QUFFSSxRQUFBLFdBQVcsRUFBRSx5QkFBRyxxQ0FBSCxDQUZqQjtBQUdJLFFBQUEsWUFBWSxFQUFFLEtBQUtqSixLQUFMLENBQVdpRSxZQUg3QjtBQUlJLFFBQUEsb0JBQW9CLEVBQUUsS0FBS3ZELEtBQUwsQ0FBV0wsV0FBWCxHQUF5QnFFLFNBQXpCLEdBQXFDLEtBQUsxRSxLQUFMLENBQVc4SjtBQUoxRSxRQUpHLEVBVUQsS0FBSzdCLHVCQUFMLEVBVkMsRUFXRHFCLE1BWEMsRUFZREgsTUFaQyxDQUFQO0FBY0g7O0FBRUQsd0JBQ0ksNkJBQUMsaUJBQUQscUJBQ0ksNkJBQUMsbUJBQUQsT0FESixlQUVJLDZCQUFDLGlCQUFELFFBQ01LLElBRE4sQ0FGSixDQURKO0FBUUg7O0FBaGdCcUUsQyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxNS0yMDIxIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSAnbWF0cml4LWpzLXNkay9zcmMvbWF0cml4JztcbmltcG9ydCBSZWFjdCwgeyBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBNYXRyaXhDbGllbnQgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvY2xpZW50XCI7XG5cbmltcG9ydCB7IF90LCBfdGQgfSBmcm9tICcuLi8uLi8uLi9sYW5ndWFnZUhhbmRsZXInO1xuaW1wb3J0IHsgbWVzc2FnZUZvclJlc291cmNlTGltaXRFcnJvciB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL0Vycm9yVXRpbHMnO1xuaW1wb3J0IEF1dG9EaXNjb3ZlcnlVdGlscywgeyBWYWxpZGF0ZWRTZXJ2ZXJDb25maWcgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvQXV0b0Rpc2NvdmVyeVV0aWxzXCI7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuaW1wb3J0ICogYXMgTGlmZWN5Y2xlIGZyb20gJy4uLy4uLy4uL0xpZmVjeWNsZSc7XG5pbXBvcnQgeyBJTWF0cml4Q2xpZW50Q3JlZHMsIE1hdHJpeENsaWVudFBlZyB9IGZyb20gXCIuLi8uLi8uLi9NYXRyaXhDbGllbnRQZWdcIjtcbmltcG9ydCBBdXRoUGFnZSBmcm9tIFwiLi4vLi4vdmlld3MvYXV0aC9BdXRoUGFnZVwiO1xuaW1wb3J0IExvZ2luLCB7IElTU09GbG93IH0gZnJvbSBcIi4uLy4uLy4uL0xvZ2luXCI7XG5pbXBvcnQgZGlzIGZyb20gXCIuLi8uLi8uLi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXJcIjtcbmltcG9ydCBTU09CdXR0b25zIGZyb20gXCIuLi8uLi92aWV3cy9lbGVtZW50cy9TU09CdXR0b25zXCI7XG5pbXBvcnQgU2VydmVyUGlja2VyIGZyb20gJy4uLy4uL3ZpZXdzL2VsZW1lbnRzL1NlcnZlclBpY2tlcic7XG5pbXBvcnQgeyByZXBsYWNlYWJsZUNvbXBvbmVudCB9IGZyb20gXCIuLi8uLi8uLi91dGlscy9yZXBsYWNlYWJsZUNvbXBvbmVudFwiO1xuaW1wb3J0IFJlZ2lzdHJhdGlvbkZvcm0gZnJvbSAnLi4vLi4vdmlld3MvYXV0aC9SZWdpc3RyYXRpb25Gb3JtJztcbmltcG9ydCBBY2Nlc3NpYmxlQnV0dG9uIGZyb20gJy4uLy4uL3ZpZXdzL2VsZW1lbnRzL0FjY2Vzc2libGVCdXR0b24nO1xuaW1wb3J0IEF1dGhCb2R5IGZyb20gXCIuLi8uLi92aWV3cy9hdXRoL0F1dGhCb2R5XCI7XG5pbXBvcnQgQXV0aEhlYWRlciBmcm9tIFwiLi4vLi4vdmlld3MvYXV0aC9BdXRoSGVhZGVyXCI7XG5pbXBvcnQgSW50ZXJhY3RpdmVBdXRoIGZyb20gXCIuLi9JbnRlcmFjdGl2ZUF1dGhcIjtcbmltcG9ydCBTcGlubmVyIGZyb20gXCIuLi8uLi92aWV3cy9lbGVtZW50cy9TcGlubmVyXCI7XG5cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9sb2dnZXJcIjtcblxuaW50ZXJmYWNlIElQcm9wcyB7XG4gICAgc2VydmVyQ29uZmlnOiBWYWxpZGF0ZWRTZXJ2ZXJDb25maWc7XG4gICAgZGVmYXVsdERldmljZURpc3BsYXlOYW1lOiBzdHJpbmc7XG4gICAgZW1haWw/OiBzdHJpbmc7XG4gICAgYnJhbmQ/OiBzdHJpbmc7XG4gICAgY2xpZW50U2VjcmV0Pzogc3RyaW5nO1xuICAgIHNlc3Npb25JZD86IHN0cmluZztcbiAgICBpZFNpZD86IHN0cmluZztcbiAgICBmcmFnbWVudEFmdGVyTG9naW4/OiBzdHJpbmc7XG5cbiAgICAvLyBDYWxsZWQgd2hlbiB0aGUgdXNlciBoYXMgbG9nZ2VkIGluLiBQYXJhbXM6XG4gICAgLy8gLSBvYmplY3Qgd2l0aCB1c2VySWQsIGRldmljZUlkLCBob21lc2VydmVyVXJsLCBpZGVudGl0eVNlcnZlclVybCwgYWNjZXNzVG9rZW5cbiAgICAvLyAtIFRoZSB1c2VyJ3MgcGFzc3dvcmQsIGlmIGF2YWlsYWJsZSBhbmQgYXBwbGljYWJsZSAobWF5IGJlIGNhY2hlZCBpbiBtZW1vcnlcbiAgICAvLyAgIGZvciBhIHNob3J0IHRpbWUgc28gdGhlIHVzZXIgaXMgbm90IHJlcXVpcmVkIHRvIHJlLWVudGVyIHRoZWlyIHBhc3N3b3JkXG4gICAgLy8gICBmb3Igb3BlcmF0aW9ucyBsaWtlIHVwbG9hZGluZyBjcm9zcy1zaWduaW5nIGtleXMpLlxuICAgIG9uTG9nZ2VkSW4ocGFyYW1zOiBJTWF0cml4Q2xpZW50Q3JlZHMsIHBhc3N3b3JkOiBzdHJpbmcpOiB2b2lkO1xuICAgIG1ha2VSZWdpc3RyYXRpb25VcmwocGFyYW1zOiB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICAgICAgICBjbGllbnRfc2VjcmV0OiBzdHJpbmc7XG4gICAgICAgIGhzX3VybDogc3RyaW5nO1xuICAgICAgICBpc191cmw/OiBzdHJpbmc7XG4gICAgICAgIHNlc3Npb25faWQ6IHN0cmluZztcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cbiAgICB9KTogc3RyaW5nO1xuICAgIC8vIHJlZ2lzdHJhdGlvbiBzaG91bGRuJ3Qga25vdyBvciBjYXJlIGhvdyBsb2dpbiBpcyBkb25lLlxuICAgIG9uTG9naW5DbGljaygpOiB2b2lkO1xuICAgIG9uU2VydmVyQ29uZmlnQ2hhbmdlKGNvbmZpZzogVmFsaWRhdGVkU2VydmVyQ29uZmlnKTogdm9pZDtcbn1cblxuaW50ZXJmYWNlIElTdGF0ZSB7XG4gICAgYnVzeTogYm9vbGVhbjtcbiAgICBlcnJvclRleHQ/OiBSZWFjdE5vZGU7XG4gICAgLy8gdHJ1ZSBpZiB3ZSdyZSB3YWl0aW5nIGZvciB0aGUgdXNlciB0byBjb21wbGV0ZVxuICAgIC8vIFdlIHJlbWVtYmVyIHRoZSB2YWx1ZXMgZW50ZXJlZCBieSB0aGUgdXNlciBiZWNhdXNlXG4gICAgLy8gdGhlIHJlZ2lzdHJhdGlvbiBmb3JtIHdpbGwgYmUgdW5tb3VudGVkIGR1cmluZyB0aGVcbiAgICAvLyBjb3Vyc2Ugb2YgcmVnaXN0cmF0aW9uLCBidXQgaWYgdGhlcmUncyBhbiBlcnJvciB3ZVxuICAgIC8vIHdhbnQgdG8gYnJpbmcgYmFjayB0aGUgcmVnaXN0cmF0aW9uIGZvcm0gd2l0aCB0aGVcbiAgICAvLyB2YWx1ZXMgdGhlIHVzZXIgZW50ZXJlZCBzdGlsbCBpbiBpdC4gV2UgY2FuIGtlZXBcbiAgICAvLyB0aGVtIGluIHRoaXMgY29tcG9uZW50J3Mgc3RhdGUgc2luY2UgdGhpcyBjb21wb25lbnRcbiAgICAvLyBwZXJzaXN0IGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIHJlZ2lzdHJhdGlvbiBwcm9jZXNzLlxuICAgIGZvcm1WYWxzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAgIC8vIHVzZXItaW50ZXJhY3RpdmUgYXV0aFxuICAgIC8vIElmIHdlJ3ZlIGJlZW4gZ2l2ZW4gYSBzZXNzaW9uIElELCB3ZSdyZSByZXN1bWluZ1xuICAgIC8vIHN0cmFpZ2h0IGJhY2sgaW50byBVSSBhdXRoXG4gICAgZG9pbmdVSUF1dGg6IGJvb2xlYW47XG4gICAgLy8gSWYgc2V0LCB3ZSd2ZSByZWdpc3RlcmVkIGJ1dCBhcmUgbm90IGdvaW5nIHRvIGxvZ1xuICAgIC8vIHRoZSB1c2VyIGluIHRvIHRoZWlyIG5ldyBhY2NvdW50IGF1dG9tYXRpY2FsbHkuXG4gICAgY29tcGxldGVkTm9TaWduaW46IGJvb2xlYW47XG4gICAgZmxvd3M6IHtcbiAgICAgICAgc3RhZ2VzOiBzdHJpbmdbXTtcbiAgICB9W107XG4gICAgLy8gV2UgcGVyZm9ybSBsaXZlbGluZXNzIGNoZWNrcyBsYXRlciwgYnV0IGZvciBub3cgc3VwcHJlc3MgdGhlIGVycm9ycy5cbiAgICAvLyBXZSBhbHNvIHRyYWNrIHRoZSBzZXJ2ZXIgZGVhZCBlcnJvcnMgaW5kZXBlbmRlbnRseSBvZiB0aGUgcmVndWxhciBlcnJvcnMgc29cbiAgICAvLyB0aGF0IHdlIGNhbiByZW5kZXIgaXQgZGlmZmVyZW50bHksIGFuZCBvdmVycmlkZSBhbnkgb3RoZXIgZXJyb3IgdGhlIHVzZXIgbWF5XG4gICAgLy8gYmUgc2VlaW5nLlxuICAgIHNlcnZlcklzQWxpdmU6IGJvb2xlYW47XG4gICAgc2VydmVyRXJyb3JJc0ZhdGFsOiBib29sZWFuO1xuICAgIHNlcnZlckRlYWRFcnJvcj86IFJlYWN0Tm9kZTtcblxuICAgIC8vIE91ciBtYXRyaXggY2xpZW50IC0gcGFydCBvZiBzdGF0ZSBiZWNhdXNlIHdlIGNhbid0IHJlbmRlciB0aGUgVUkgYXV0aFxuICAgIC8vIGNvbXBvbmVudCB3aXRob3V0IGl0LlxuICAgIG1hdHJpeENsaWVudD86IE1hdHJpeENsaWVudDtcbiAgICAvLyBUaGUgdXNlciBJRCB3ZSd2ZSBqdXN0IHJlZ2lzdGVyZWRcbiAgICByZWdpc3RlcmVkVXNlcm5hbWU/OiBzdHJpbmc7XG4gICAgLy8gaWYgYSBkaWZmZXJlbnQgdXNlciBJRCB0byB0aGUgb25lIHdlIGp1c3QgcmVnaXN0ZXJlZCBpcyBsb2dnZWQgaW4sXG4gICAgLy8gdGhpcyBpcyB0aGUgdXNlciBJRCB0aGF0J3MgbG9nZ2VkIGluLlxuICAgIGRpZmZlcmVudExvZ2dlZEluVXNlcklkPzogc3RyaW5nO1xuICAgIC8vIHRoZSBTU08gZmxvdyBkZWZpbml0aW9uLCB0aGlzIGlzIGZldGNoZWQgZnJvbSAvbG9naW4gYXMgdGhhdCdzIHRoZSBvbmx5XG4gICAgLy8gcGxhY2UgaXQgaXMgZXhwb3NlZC5cbiAgICBzc29GbG93PzogSVNTT0Zsb3c7XG59XG5cbkByZXBsYWNlYWJsZUNvbXBvbmVudChcInN0cnVjdHVyZXMuYXV0aC5SZWdpc3RyYXRpb25cIilcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlZ2lzdHJhdGlvbiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxJUHJvcHMsIElTdGF0ZT4ge1xuICAgIGxvZ2luTG9naWM6IExvZ2luO1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBidXN5OiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yVGV4dDogbnVsbCxcbiAgICAgICAgICAgIGZvcm1WYWxzOiB7XG4gICAgICAgICAgICAgICAgZW1haWw6IHRoaXMucHJvcHMuZW1haWwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9pbmdVSUF1dGg6IEJvb2xlYW4odGhpcy5wcm9wcy5zZXNzaW9uSWQpLFxuICAgICAgICAgICAgZmxvd3M6IG51bGwsXG4gICAgICAgICAgICBjb21wbGV0ZWROb1NpZ25pbjogZmFsc2UsXG4gICAgICAgICAgICBzZXJ2ZXJJc0FsaXZlOiB0cnVlLFxuICAgICAgICAgICAgc2VydmVyRXJyb3JJc0ZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIHNlcnZlckRlYWRFcnJvcjogXCJcIixcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCB7IGhzVXJsLCBpc1VybCB9ID0gdGhpcy5wcm9wcy5zZXJ2ZXJDb25maWc7XG4gICAgICAgIHRoaXMubG9naW5Mb2dpYyA9IG5ldyBMb2dpbihoc1VybCwgaXNVcmwsIG51bGwsIHtcbiAgICAgICAgICAgIGRlZmF1bHREZXZpY2VEaXNwbGF5TmFtZTogXCJFbGVtZW50IGxvZ2luIGNoZWNrXCIsIC8vIFdlIHNob3VsZG4ndCBldmVyIGJlIHVzZWRcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMucmVwbGFjZUNsaWVudCh0aGlzLnByb3BzLnNlcnZlckNvbmZpZyk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogW1JFQUNULVdBUk5JTkddIFJlcGxhY2Ugd2l0aCBhcHByb3ByaWF0ZSBsaWZlY3ljbGUgZXZlbnRcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcykge1xuICAgICAgICBpZiAobmV3UHJvcHMuc2VydmVyQ29uZmlnLmhzVXJsID09PSB0aGlzLnByb3BzLnNlcnZlckNvbmZpZy5oc1VybCAmJlxuICAgICAgICAgICAgbmV3UHJvcHMuc2VydmVyQ29uZmlnLmlzVXJsID09PSB0aGlzLnByb3BzLnNlcnZlckNvbmZpZy5pc1VybCkgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMucmVwbGFjZUNsaWVudChuZXdQcm9wcy5zZXJ2ZXJDb25maWcpO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgcmVwbGFjZUNsaWVudChzZXJ2ZXJDb25maWc6IFZhbGlkYXRlZFNlcnZlckNvbmZpZykge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGVycm9yVGV4dDogbnVsbCxcbiAgICAgICAgICAgIHNlcnZlckRlYWRFcnJvcjogbnVsbCxcbiAgICAgICAgICAgIHNlcnZlckVycm9ySXNGYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAvLyBidXN5IHdoaWxlIHdlIGRvIGxpdmVuZXNzIGNoZWNrICh3ZSBuZWVkIHRvIGF2b2lkIHRyeWluZyB0byByZW5kZXJcbiAgICAgICAgICAgIC8vIHRoZSBVSSBhdXRoIGNvbXBvbmVudCB3aGlsZSB3ZSBkb24ndCBoYXZlIGEgbWF0cml4IGNsaWVudClcbiAgICAgICAgICAgIGJ1c3k6IHRydWUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIERvIGEgbGl2ZWxpbmVzcyBjaGVjayBvbiB0aGUgVVJMc1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgQXV0b0Rpc2NvdmVyeVV0aWxzLnZhbGlkYXRlU2VydmVyQ29uZmlnV2l0aFN0YXRpY1VybHMoXG4gICAgICAgICAgICAgICAgc2VydmVyQ29uZmlnLmhzVXJsLFxuICAgICAgICAgICAgICAgIHNlcnZlckNvbmZpZy5pc1VybCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBzZXJ2ZXJJc0FsaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNlcnZlckVycm9ySXNGYXRhbDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgYnVzeTogZmFsc2UsXG4gICAgICAgICAgICAgICAgLi4uQXV0b0Rpc2NvdmVyeVV0aWxzLmF1dGhDb21wb25lbnRTdGF0ZUZvckVycm9yKGUsIFwicmVnaXN0ZXJcIiksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnNlcnZlckVycm9ySXNGYXRhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gU2VydmVyIGlzIGRlYWQgLSBkbyBub3QgY29udGludWUuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGhzVXJsLCBpc1VybCB9ID0gc2VydmVyQ29uZmlnO1xuICAgICAgICBjb25zdCBjbGkgPSBjcmVhdGVDbGllbnQoe1xuICAgICAgICAgICAgYmFzZVVybDogaHNVcmwsXG4gICAgICAgICAgICBpZEJhc2VVcmw6IGlzVXJsLFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmxvZ2luTG9naWMuc2V0SG9tZXNlcnZlclVybChoc1VybCk7XG4gICAgICAgIHRoaXMubG9naW5Mb2dpYy5zZXRJZGVudGl0eVNlcnZlclVybChpc1VybCk7XG5cbiAgICAgICAgbGV0IHNzb0Zsb3c6IElTU09GbG93O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbG9naW5GbG93cyA9IGF3YWl0IHRoaXMubG9naW5Mb2dpYy5nZXRGbG93cygpO1xuICAgICAgICAgICAgc3NvRmxvdyA9IGxvZ2luRmxvd3MuZmluZChmID0+IGYudHlwZSA9PT0gXCJtLmxvZ2luLnNzb1wiIHx8IGYudHlwZSA9PT0gXCJtLmxvZ2luLmNhc1wiKSBhcyBJU1NPRmxvdztcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGdldCBsb2dpbiBmbG93cyB0byBjaGVjayBmb3IgU1NPIHN1cHBvcnRcIiwgZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIG1hdHJpeENsaWVudDogY2xpLFxuICAgICAgICAgICAgc3NvRmxvdyxcbiAgICAgICAgICAgIGJ1c3k6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc2hvd0dlbmVyaWNFcnJvciA9IChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBlcnJvclRleHQ6IF90KFwiVW5hYmxlIHRvIHF1ZXJ5IGZvciBzdXBwb3J0ZWQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXCIpLFxuICAgICAgICAgICAgICAgIC8vIGFkZCBlbXB0eSBmbG93cyBhcnJheSB0byBnZXQgcmlkIG9mIHNwaW5uZXJcbiAgICAgICAgICAgICAgICBmbG93czogW10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdlIGRvIHRoZSBmaXJzdCByZWdpc3RyYXRpb24gcmVxdWVzdCBvdXJzZWx2ZXMgdG8gZGlzY292ZXIgd2hldGhlciB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAvLyBkbyBTU08gaW5zdGVhZC4gSWYgd2UndmUgYWxyZWFkeSBzdGFydGVkIHRoZSBVSSBBdXRoIHByb2Nlc3MgdGhvdWdoLCB3ZSBkb24ndFxuICAgICAgICAgICAgLy8gbmVlZCB0by5cbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0ZS5kb2luZ1VJQXV0aCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubWFrZVJlZ2lzdGVyUmVxdWVzdChudWxsKTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBzdWNjZWVkIHNpbmNlIHdlIHNwZWNpZmllZCBubyBhdXRoIG9iamVjdC5cbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFwiRXhwZWN0aW5nIDQwMSBmcm9tIHJlZ2lzdGVyIHJlcXVlc3QgYnV0IGdvdCBzdWNjZXNzIVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUuaHR0cFN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGZsb3dzOiBlLmRhdGEuZmxvd3MsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUuaHR0cFN0YXR1cyA9PT0gNDAzIHx8IGUuZXJyY29kZSA9PT0gXCJNX0ZPUkJJRERFTlwiKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIDQwMyBvciBNX0ZPUkJJRERFTiwgU3luYXBzZSB1c2VkIHRvIHNlbmQgNDAzIE1fVU5LTk9XTiBidXQgbm93IHNlbmRzIDQwMyBNX0ZPUkJJRERFTi5cbiAgICAgICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHJlZ2lzdHJhdGlvbiBpcyBwcmV0dHkgbXVjaCBkaXNhYmxlZCwgYnV0IGJlZm9yZSB3ZSBkbyB0aGF0IGxldCdzXG4gICAgICAgICAgICAgICAgLy8gcXVpY2tseSBjaGVjayB0byBzZWUgaWYgdGhlIHNlcnZlciBzdXBwb3J0cyBTU08gaW5zdGVhZC4gSWYgaXQgZG9lcywgd2UnbGwgc2VuZFxuICAgICAgICAgICAgICAgIC8vIHRoZSB1c2VyIG9mZiB0byB0aGUgbG9naW4gcGFnZSB0byBmaWd1cmUgdGhlaXIgYWNjb3VudCBvdXQuXG4gICAgICAgICAgICAgICAgaWYgKHNzb0Zsb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVkaXJlY3QgdG8gbG9naW4gcGFnZSAtIHNlcnZlciBwcm9iYWJseSBleHBlY3RzIFNTTyBvbmx5XG4gICAgICAgICAgICAgICAgICAgIGRpcy5kaXNwYXRjaCh7IGFjdGlvbjogJ3N0YXJ0X2xvZ2luJyB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckVycm9ySXNGYXRhbDogdHJ1ZSwgLy8gZmF0YWwgYmVjYXVzZSB1c2VyIGNhbm5vdCBjb250aW51ZSBvbiB0aGlzIHNlcnZlclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JUZXh0OiBfdChcIlJlZ2lzdHJhdGlvbiBoYXMgYmVlbiBkaXNhYmxlZCBvbiB0aGlzIGhvbWVzZXJ2ZXIuXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGVtcHR5IGZsb3dzIGFycmF5IHRvIGdldCByaWQgb2Ygc3Bpbm5lclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvd3M6IFtdLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coXCJVbmFibGUgdG8gcXVlcnkgZm9yIHN1cHBvcnRlZCByZWdpc3RyYXRpb24gbWV0aG9kcy5cIiwgZSk7XG4gICAgICAgICAgICAgICAgc2hvd0dlbmVyaWNFcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgb25Gb3JtU3VibWl0ID0gYXN5bmMgKGZvcm1WYWxzKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZXJyb3JUZXh0OiBcIlwiLFxuICAgICAgICAgICAgYnVzeTogdHJ1ZSxcbiAgICAgICAgICAgIGZvcm1WYWxzOiBmb3JtVmFscyxcbiAgICAgICAgICAgIGRvaW5nVUlBdXRoOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSByZXF1ZXN0RW1haWxUb2tlbiA9IChlbWFpbEFkZHJlc3MsIGNsaWVudFNlY3JldCwgc2VuZEF0dGVtcHQsIHNlc3Npb25JZCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5tYXRyaXhDbGllbnQucmVxdWVzdFJlZ2lzdGVyRW1haWxUb2tlbihcbiAgICAgICAgICAgIGVtYWlsQWRkcmVzcyxcbiAgICAgICAgICAgIGNsaWVudFNlY3JldCxcbiAgICAgICAgICAgIHNlbmRBdHRlbXB0LFxuICAgICAgICAgICAgdGhpcy5wcm9wcy5tYWtlUmVnaXN0cmF0aW9uVXJsKHtcbiAgICAgICAgICAgICAgICBjbGllbnRfc2VjcmV0OiBjbGllbnRTZWNyZXQsXG4gICAgICAgICAgICAgICAgaHNfdXJsOiB0aGlzLnN0YXRlLm1hdHJpeENsaWVudC5nZXRIb21lc2VydmVyVXJsKCksXG4gICAgICAgICAgICAgICAgaXNfdXJsOiB0aGlzLnN0YXRlLm1hdHJpeENsaWVudC5nZXRJZGVudGl0eVNlcnZlclVybCgpLFxuICAgICAgICAgICAgICAgIHNlc3Npb25faWQ6IHNlc3Npb25JZCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICApO1xuICAgIH07XG5cbiAgICBwcml2YXRlIG9uVUlBdXRoRmluaXNoZWQgPSBhc3luYyAoc3VjY2VzczogYm9vbGVhbiwgcmVzcG9uc2U6IGFueSkgPT4ge1xuICAgICAgICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGxldCBlcnJvclRleHQgPSByZXNwb25zZS5tZXNzYWdlIHx8IHJlc3BvbnNlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAvLyBjYW4gd2UgZ2l2ZSBhIGJldHRlciBlcnJvciBtZXNzYWdlP1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmVycmNvZGUgPT09ICdNX1JFU09VUkNFX0xJTUlUX0VYQ0VFREVEJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yVG9wID0gbWVzc2FnZUZvclJlc291cmNlTGltaXRFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuZGF0YS5saW1pdF90eXBlLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5kYXRhLmFkbWluX2NvbnRhY3QsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtb250aGx5X2FjdGl2ZV91c2VyJzogX3RkKFwiVGhpcyBob21lc2VydmVyIGhhcyBoaXQgaXRzIE1vbnRobHkgQWN0aXZlIFVzZXIgbGltaXQuXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2hzX2Jsb2NrZWQnOiBfdGQoXCJUaGlzIGhvbWVzZXJ2ZXIgaGFzIGJlZW4gYmxvY2tlZCBieSBpdCdzIGFkbWluaXN0cmF0b3IuXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgJyc6IF90ZChcIlRoaXMgaG9tZXNlcnZlciBoYXMgZXhjZWVkZWQgb25lIG9mIGl0cyByZXNvdXJjZSBsaW1pdHMuXCIpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JEZXRhaWwgPSBtZXNzYWdlRm9yUmVzb3VyY2VMaW1pdEVycm9yKFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5kYXRhLmxpbWl0X3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEuYWRtaW5fY29udGFjdCxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgJyc6IF90ZChcIlBsZWFzZSA8YT5jb250YWN0IHlvdXIgc2VydmljZSBhZG1pbmlzdHJhdG9yPC9hPiB0byBjb250aW51ZSB1c2luZyB0aGlzIHNlcnZpY2UuXCIpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZXJyb3JUZXh0ID0gPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgPHA+eyBlcnJvclRvcCB9PC9wPlxuICAgICAgICAgICAgICAgICAgICA8cD57IGVycm9yRGV0YWlsIH08L3A+XG4gICAgICAgICAgICAgICAgPC9kaXY+O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5yZXF1aXJlZF9zdGFnZXMgJiYgcmVzcG9uc2UucmVxdWlyZWRfc3RhZ2VzLmluZGV4T2YoJ20ubG9naW4ubXNpc2RuJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIGxldCBtc2lzZG5BdmFpbGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZsb3cgb2YgcmVzcG9uc2UuYXZhaWxhYmxlX2Zsb3dzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1zaXNkbkF2YWlsYWJsZSA9IG1zaXNkbkF2YWlsYWJsZSB8fCBmbG93LnN0YWdlcy5pbmNsdWRlcygnbS5sb2dpbi5tc2lzZG4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFtc2lzZG5BdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JUZXh0ID0gX3QoJ1RoaXMgc2VydmVyIGRvZXMgbm90IHN1cHBvcnQgYXV0aGVudGljYXRpb24gd2l0aCBhIHBob25lIG51bWJlci4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLmVycmNvZGUgPT09IFwiTV9VU0VSX0lOX1VTRVwiKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JUZXh0ID0gX3QoXCJTb21lb25lIGFscmVhZHkgaGFzIHRoYXQgdXNlcm5hbWUsIHBsZWFzZSB0cnkgYW5vdGhlci5cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLmVycmNvZGUgPT09IFwiTV9USFJFRVBJRF9JTl9VU0VcIikge1xuICAgICAgICAgICAgICAgIGVycm9yVGV4dCA9IF90KFwiVGhhdCBlLW1haWwgYWRkcmVzcyBpcyBhbHJlYWR5IGluIHVzZS5cIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGJ1c3k6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRvaW5nVUlBdXRoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvclRleHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIE1hdHJpeENsaWVudFBlZy5zZXRKdXN0UmVnaXN0ZXJlZFVzZXJJZChyZXNwb25zZS51c2VyX2lkKTtcblxuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAgICAgICAgIGRvaW5nVUlBdXRoOiBmYWxzZSxcbiAgICAgICAgICAgIHJlZ2lzdGVyZWRVc2VybmFtZTogcmVzcG9uc2UudXNlcl9pZCxcbiAgICAgICAgICAgIGRpZmZlcmVudExvZ2dlZEluVXNlcklkOiBudWxsLFxuICAgICAgICAgICAgY29tcGxldGVkTm9TaWduaW46IGZhbHNlLFxuICAgICAgICAgICAgLy8gd2UncmUgc3RpbGwgYnVzeSB1bnRpbCB3ZSBnZXQgdW5tb3VudGVkOiBkb24ndCBzaG93IHRoZSByZWdpc3RyYXRpb24gZm9ybSBhZ2FpblxuICAgICAgICAgICAgYnVzeTogdHJ1ZSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUaGUgdXNlciBjYW1lIGluIHRocm91Z2ggYW4gZW1haWwgdmFsaWRhdGlvbiBsaW5rLiBUbyBhdm9pZCBvdmVyd3JpdGluZ1xuICAgICAgICAvLyB0aGVpciBzZXNzaW9uLCBjaGVjayB0byBtYWtlIHN1cmUgdGhlIHNlc3Npb24gaXNuJ3Qgc29tZW9uZSBlbHNlLCBhbmRcbiAgICAgICAgLy8gaXNuJ3QgYSBndWVzdCB1c2VyIHNpbmNlIHdlJ2xsIHVzdWFsbHkgaGF2ZSBzZXQgYSBndWVzdCB1c2VyIHNlc3Npb24gYmVmb3JlXG4gICAgICAgIC8vIHN0YXJ0aW5nIHRoZSByZWdpc3RyYXRpb24gcHJvY2Vzcy4gVGhpcyBpc24ndCBwZXJmZWN0IHNpbmNlIGl0J3MgcG9zc2libGVcbiAgICAgICAgLy8gdGhlIHVzZXIgaGFkIGEgc2VwYXJhdGUgZ3Vlc3Qgc2Vzc2lvbiB0aGV5IGRpZG4ndCBhY3R1YWxseSBtZWFuIHRvIHJlcGxhY2UuXG4gICAgICAgIGNvbnN0IFtzZXNzaW9uT3duZXIsIHNlc3Npb25Jc0d1ZXN0XSA9IGF3YWl0IExpZmVjeWNsZS5nZXRTdG9yZWRTZXNzaW9uT3duZXIoKTtcbiAgICAgICAgaWYgKHNlc3Npb25Pd25lciAmJiAhc2Vzc2lvbklzR3Vlc3QgJiYgc2Vzc2lvbk93bmVyICE9PSByZXNwb25zZS51c2VySWQpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coXG4gICAgICAgICAgICAgICAgYEZvdW5kIGEgc2Vzc2lvbiBmb3IgJHtzZXNzaW9uT3duZXJ9IGJ1dCAke3Jlc3BvbnNlLnVzZXJJZH0gaGFzIGp1c3QgcmVnaXN0ZXJlZC5gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG5ld1N0YXRlLmRpZmZlcmVudExvZ2dlZEluVXNlcklkID0gc2Vzc2lvbk93bmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlLmFjY2Vzc190b2tlbikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wcm9wcy5vbkxvZ2dlZEluKHtcbiAgICAgICAgICAgICAgICB1c2VySWQ6IHJlc3BvbnNlLnVzZXJfaWQsXG4gICAgICAgICAgICAgICAgZGV2aWNlSWQ6IHJlc3BvbnNlLmRldmljZV9pZCxcbiAgICAgICAgICAgICAgICBob21lc2VydmVyVXJsOiB0aGlzLnN0YXRlLm1hdHJpeENsaWVudC5nZXRIb21lc2VydmVyVXJsKCksXG4gICAgICAgICAgICAgICAgaWRlbnRpdHlTZXJ2ZXJVcmw6IHRoaXMuc3RhdGUubWF0cml4Q2xpZW50LmdldElkZW50aXR5U2VydmVyVXJsKCksXG4gICAgICAgICAgICAgICAgYWNjZXNzVG9rZW46IHJlc3BvbnNlLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgIH0sIHRoaXMuc3RhdGUuZm9ybVZhbHMucGFzc3dvcmQpO1xuXG4gICAgICAgICAgICB0aGlzLnNldHVwUHVzaGVycygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3U3RhdGUuYnVzeSA9IGZhbHNlO1xuICAgICAgICAgICAgbmV3U3RhdGUuY29tcGxldGVkTm9TaWduaW4gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgc2V0dXBQdXNoZXJzKCkge1xuICAgICAgICBpZiAoIXRoaXMucHJvcHMuYnJhbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXRyaXhDbGllbnQgPSBNYXRyaXhDbGllbnRQZWcuZ2V0KCk7XG4gICAgICAgIHJldHVybiBtYXRyaXhDbGllbnQuZ2V0UHVzaGVycygpLnRoZW4oKHJlc3ApPT57XG4gICAgICAgICAgICBjb25zdCBwdXNoZXJzID0gcmVzcC5wdXNoZXJzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwdXNoZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHB1c2hlcnNbaV0ua2luZCA9PT0gJ2VtYWlsJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbWFpbFB1c2hlciA9IHB1c2hlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGVtYWlsUHVzaGVyLmRhdGEgPSB7IGJyYW5kOiB0aGlzLnByb3BzLmJyYW5kIH07XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeENsaWVudC5zZXRQdXNoZXIoZW1haWxQdXNoZXIpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIlNldCBlbWFpbCBicmFuZGluZyB0byBcIiArIHRoaXMucHJvcHMuYnJhbmQpO1xuICAgICAgICAgICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkNvdWxkbid0IHNldCBlbWFpbCBicmFuZGluZzogXCIgKyBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJDb3VsZG4ndCBnZXQgcHVzaGVyczogXCIgKyBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgb25Mb2dpbkNsaWNrID0gZXYgPT4ge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkxvZ2luQ2xpY2soKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbkdvVG9Gb3JtQ2xpY2tlZCA9IGV2ID0+IHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHRoaXMucmVwbGFjZUNsaWVudCh0aGlzLnByb3BzLnNlcnZlckNvbmZpZyk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgYnVzeTogZmFsc2UsXG4gICAgICAgICAgICBkb2luZ1VJQXV0aDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBwcml2YXRlIG1ha2VSZWdpc3RlclJlcXVlc3QgPSBhdXRoID0+IHtcbiAgICAgICAgLy8gV2UgaW5oaWJpdCBsb2dpbiBpZiB3ZSdyZSB0cnlpbmcgdG8gcmVnaXN0ZXIgd2l0aCBhbiBlbWFpbCBhZGRyZXNzOiB0aGlzXG4gICAgICAgIC8vIGF2b2lkcyBhIGxvdCBvZiBjb21wbGV4IHJhY2UgY29uZGl0aW9ucyB0aGF0IGNhbiBvY2N1ciBpZiB3ZSB0cnkgdG8gbG9nXG4gICAgICAgIC8vIHRoZSB1c2VyIGluIG9uZSBvbmUgb3IgYm90aCBvZiB0aGUgdGFicyB0aGV5IG1pZ2h0IGVuZCB1cCB3aXRoIGFmdGVyXG4gICAgICAgIC8vIGNsaWNraW5nIHRoZSBlbWFpbCBsaW5rLlxuICAgICAgICBsZXQgaW5oaWJpdExvZ2luID0gQm9vbGVhbih0aGlzLnN0YXRlLmZvcm1WYWxzLmVtYWlsKTtcblxuICAgICAgICAvLyBPbmx5IHNlbmQgaW5oaWJpdExvZ2luIGlmIHdlJ3JlIHNlbmRpbmcgdXNlcm5hbWUgLyBwdyBwYXJhbXNcbiAgICAgICAgLy8gKFNpbmNlIHdlIG5lZWQgdG8gc2VuZCBubyBwYXJhbXMgYXQgYWxsIHRvIHVzZSB0aGUgb25lcyBzYXZlZCBpbiB0aGVcbiAgICAgICAgLy8gc2Vzc2lvbikuXG4gICAgICAgIGlmICghdGhpcy5zdGF0ZS5mb3JtVmFscy5wYXNzd29yZCkgaW5oaWJpdExvZ2luID0gbnVsbDtcblxuICAgICAgICBjb25zdCByZWdpc3RlclBhcmFtcyA9IHtcbiAgICAgICAgICAgIHVzZXJuYW1lOiB0aGlzLnN0YXRlLmZvcm1WYWxzLnVzZXJuYW1lLFxuICAgICAgICAgICAgcGFzc3dvcmQ6IHRoaXMuc3RhdGUuZm9ybVZhbHMucGFzc3dvcmQsXG4gICAgICAgICAgICBpbml0aWFsX2RldmljZV9kaXNwbGF5X25hbWU6IHRoaXMucHJvcHMuZGVmYXVsdERldmljZURpc3BsYXlOYW1lLFxuICAgICAgICAgICAgYXV0aDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaW5oaWJpdF9sb2dpbjogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoYXV0aCkgcmVnaXN0ZXJQYXJhbXMuYXV0aCA9IGF1dGg7XG4gICAgICAgIGlmIChpbmhpYml0TG9naW4gIT09IHVuZGVmaW5lZCAmJiBpbmhpYml0TG9naW4gIT09IG51bGwpIHJlZ2lzdGVyUGFyYW1zLmluaGliaXRfbG9naW4gPSBpbmhpYml0TG9naW47XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLm1hdHJpeENsaWVudC5yZWdpc3RlclJlcXVlc3QocmVnaXN0ZXJQYXJhbXMpO1xuICAgIH07XG5cbiAgICBwcml2YXRlIGdldFVJQXV0aElucHV0cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVtYWlsQWRkcmVzczogdGhpcy5zdGF0ZS5mb3JtVmFscy5lbWFpbCxcbiAgICAgICAgICAgIHBob25lQ291bnRyeTogdGhpcy5zdGF0ZS5mb3JtVmFscy5waG9uZUNvdW50cnksXG4gICAgICAgICAgICBwaG9uZU51bWJlcjogdGhpcy5zdGF0ZS5mb3JtVmFscy5waG9uZU51bWJlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBMaW5rcyB0byB0aGUgbG9naW4gcGFnZSBzaG93biBhZnRlciByZWdpc3RyYXRpb24gaXMgY29tcGxldGVkIGFyZSByb3V0ZWQgdGhyb3VnaCB0aGlzXG4gICAgLy8gd2hpY2ggY2hlY2tzIHRoZSB1c2VyIGhhc24ndCBhbHJlYWR5IGxvZ2dlZCBpbiBzb21ld2hlcmUgZWxzZSAocGVyaGFwcyB3ZSBzaG91bGQgZG9cbiAgICAvLyB0aGlzIG1vcmUgZ2VuZXJhbGx5PylcbiAgICBwcml2YXRlIG9uTG9naW5DbGlja1dpdGhDaGVjayA9IGFzeW5jIGV2ID0+IHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBjb25zdCBzZXNzaW9uTG9hZGVkID0gYXdhaXQgTGlmZWN5Y2xlLmxvYWRTZXNzaW9uKHsgaWdub3JlR3Vlc3Q6IHRydWUgfSk7XG4gICAgICAgIGlmICghc2Vzc2lvbkxvYWRlZCkge1xuICAgICAgICAgICAgLy8gb2sgZmluZSwgdGhlcmUncyBzdGlsbCBubyBzZXNzaW9uOiByZWFsbHkgZ28gdG8gdGhlIGxvZ2luIHBhZ2VcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25Mb2dpbkNsaWNrKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2Vzc2lvbkxvYWRlZDtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSByZW5kZXJSZWdpc3RlckNvbXBvbmVudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUubWF0cml4Q2xpZW50ICYmIHRoaXMuc3RhdGUuZG9pbmdVSUF1dGgpIHtcbiAgICAgICAgICAgIHJldHVybiA8SW50ZXJhY3RpdmVBdXRoXG4gICAgICAgICAgICAgICAgbWF0cml4Q2xpZW50PXt0aGlzLnN0YXRlLm1hdHJpeENsaWVudH1cbiAgICAgICAgICAgICAgICBtYWtlUmVxdWVzdD17dGhpcy5tYWtlUmVnaXN0ZXJSZXF1ZXN0fVxuICAgICAgICAgICAgICAgIG9uQXV0aEZpbmlzaGVkPXt0aGlzLm9uVUlBdXRoRmluaXNoZWR9XG4gICAgICAgICAgICAgICAgaW5wdXRzPXt0aGlzLmdldFVJQXV0aElucHV0cygpfVxuICAgICAgICAgICAgICAgIHJlcXVlc3RFbWFpbFRva2VuPXt0aGlzLnJlcXVlc3RFbWFpbFRva2VufVxuICAgICAgICAgICAgICAgIHNlc3Npb25JZD17dGhpcy5wcm9wcy5zZXNzaW9uSWR9XG4gICAgICAgICAgICAgICAgY2xpZW50U2VjcmV0PXt0aGlzLnByb3BzLmNsaWVudFNlY3JldH1cbiAgICAgICAgICAgICAgICBlbWFpbFNpZD17dGhpcy5wcm9wcy5pZFNpZH1cbiAgICAgICAgICAgICAgICBwb2xsPXt0cnVlfVxuICAgICAgICAgICAgLz47XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuc3RhdGUubWF0cml4Q2xpZW50ICYmICF0aGlzLnN0YXRlLmJ1c3kpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuYnVzeSB8fCAhdGhpcy5zdGF0ZS5mbG93cykge1xuICAgICAgICAgICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPVwibXhfQXV0aEJvZHlfc3Bpbm5lclwiPlxuICAgICAgICAgICAgICAgIDxTcGlubmVyIC8+XG4gICAgICAgICAgICA8L2Rpdj47XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5mbG93cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBzc29TZWN0aW9uO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuc3NvRmxvdykge1xuICAgICAgICAgICAgICAgIGxldCBjb250aW51ZVdpdGhTZWN0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVycyA9IHRoaXMuc3RhdGUuc3NvRmxvdy5pZGVudGl0eV9wcm92aWRlcnMgfHwgW107XG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0aGVyZSBpcyBvbmx5IGEgc2luZ2xlIChvciAwKSBwcm92aWRlcnMgd2Ugc2hvdyBhIHdpZGUgYnV0dG9uIHdpdGggYENvbnRpbnVlIHdpdGggWGAgdGV4dFxuICAgICAgICAgICAgICAgIGlmIChwcm92aWRlcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpMThuOiBzc29CdXR0b25zIGlzIGEgcGxhY2Vob2xkZXIgdG8gaGVscCB0cmFuc2xhdG9ycyB1bmRlcnN0YW5kIGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVXaXRoU2VjdGlvbiA9IDxoMyBjbGFzc05hbWU9XCJteF9BdXRoQm9keV9jZW50ZXJlZFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgeyBfdChcIkNvbnRpbnVlIHdpdGggJShzc29CdXR0b25zKXNcIiwgeyBzc29CdXR0b25zOiBcIlwiIH0pLnRyaW0oKSB9XG4gICAgICAgICAgICAgICAgICAgIDwvaDM+O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGkxOG46IHNzb0J1dHRvbnMgJiB1c2VybmFtZVBhc3N3b3JkIGFyZSBwbGFjZWhvbGRlcnMgdG8gaGVscCB0cmFuc2xhdG9ycyB1bmRlcnN0YW5kIGNvbnRleHRcbiAgICAgICAgICAgICAgICBzc29TZWN0aW9uID0gPFJlYWN0LkZyYWdtZW50PlxuICAgICAgICAgICAgICAgICAgICB7IGNvbnRpbnVlV2l0aFNlY3Rpb24gfVxuICAgICAgICAgICAgICAgICAgICA8U1NPQnV0dG9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4Q2xpZW50PXt0aGlzLmxvZ2luTG9naWMuY3JlYXRlVGVtcG9yYXJ5Q2xpZW50KCl9XG4gICAgICAgICAgICAgICAgICAgICAgICBmbG93PXt0aGlzLnN0YXRlLnNzb0Zsb3d9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dpblR5cGU9e3RoaXMuc3RhdGUuc3NvRmxvdy50eXBlID09PSBcIm0ubG9naW4uc3NvXCIgPyBcInNzb1wiIDogXCJjYXNcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50QWZ0ZXJMb2dpbj17dGhpcy5wcm9wcy5mcmFnbWVudEFmdGVyTG9naW59XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJteF9BdXRoQm9keV9jZW50ZXJlZFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgeyBfdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiUoc3NvQnV0dG9ucylzIE9yICUodXNlcm5hbWVQYXNzd29yZClzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzc29CdXR0b25zOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VybmFtZVBhc3N3b3JkOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICApLnRyaW0oKSB9XG4gICAgICAgICAgICAgICAgICAgIDwvaDM+XG4gICAgICAgICAgICAgICAgPC9SZWFjdC5GcmFnbWVudD47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiA8UmVhY3QuRnJhZ21lbnQ+XG4gICAgICAgICAgICAgICAgeyBzc29TZWN0aW9uIH1cbiAgICAgICAgICAgICAgICA8UmVnaXN0cmF0aW9uRm9ybVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VXNlcm5hbWU9e3RoaXMuc3RhdGUuZm9ybVZhbHMudXNlcm5hbWV9XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRFbWFpbD17dGhpcy5zdGF0ZS5mb3JtVmFscy5lbWFpbH1cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFBob25lQ291bnRyeT17dGhpcy5zdGF0ZS5mb3JtVmFscy5waG9uZUNvdW50cnl9XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRQaG9uZU51bWJlcj17dGhpcy5zdGF0ZS5mb3JtVmFscy5waG9uZU51bWJlcn1cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFBhc3N3b3JkPXt0aGlzLnN0YXRlLmZvcm1WYWxzLnBhc3N3b3JkfVxuICAgICAgICAgICAgICAgICAgICBvblJlZ2lzdGVyQ2xpY2s9e3RoaXMub25Gb3JtU3VibWl0fVxuICAgICAgICAgICAgICAgICAgICBmbG93cz17dGhpcy5zdGF0ZS5mbG93c31cbiAgICAgICAgICAgICAgICAgICAgc2VydmVyQ29uZmlnPXt0aGlzLnByb3BzLnNlcnZlckNvbmZpZ31cbiAgICAgICAgICAgICAgICAgICAgY2FuU3VibWl0PXshdGhpcy5zdGF0ZS5zZXJ2ZXJFcnJvcklzRmF0YWx9XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeENsaWVudD17dGhpcy5zdGF0ZS5tYXRyaXhDbGllbnR9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvUmVhY3QuRnJhZ21lbnQ+O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgZXJyb3JUZXh0O1xuICAgICAgICBjb25zdCBlcnIgPSB0aGlzLnN0YXRlLmVycm9yVGV4dDtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZXJyb3JUZXh0ID0gPGRpdiBjbGFzc05hbWU9XCJteF9Mb2dpbl9lcnJvclwiPnsgZXJyIH08L2Rpdj47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc2VydmVyRGVhZFNlY3Rpb247XG4gICAgICAgIGlmICghdGhpcy5zdGF0ZS5zZXJ2ZXJJc0FsaXZlKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzID0gY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICAgICAgXCJteF9Mb2dpbl9lcnJvclwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibXhfTG9naW5fc2VydmVyRXJyb3JcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm14X0xvZ2luX3NlcnZlckVycm9yTm9uRmF0YWxcIjogIXRoaXMuc3RhdGUuc2VydmVyRXJyb3JJc0ZhdGFsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXJ2ZXJEZWFkU2VjdGlvbiA9IChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3Nlc30+XG4gICAgICAgICAgICAgICAgICAgIHsgdGhpcy5zdGF0ZS5zZXJ2ZXJEZWFkRXJyb3IgfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNpZ25JbiA9IDxzcGFuIGNsYXNzTmFtZT1cIm14X0F1dGhCb2R5X2NoYW5nZUZsb3dcIj5cbiAgICAgICAgICAgIHsgX3QoXCJBbHJlYWR5IGhhdmUgYW4gYWNjb3VudD8gPGE+U2lnbiBpbiBoZXJlPC9hPlwiLCB7fSwge1xuICAgICAgICAgICAgICAgIGE6IHN1YiA9PiA8YSBvbkNsaWNrPXt0aGlzLm9uTG9naW5DbGlja30gaHJlZj1cIiNcIj57IHN1YiB9PC9hPixcbiAgICAgICAgICAgIH0pIH1cbiAgICAgICAgPC9zcGFuPjtcblxuICAgICAgICAvLyBPbmx5IHNob3cgdGhlICdnbyBiYWNrJyBidXR0b24gaWYgeW91J3JlIG5vdCBsb29raW5nIGF0IHRoZSBmb3JtXG4gICAgICAgIGxldCBnb0JhY2s7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmRvaW5nVUlBdXRoKSB7XG4gICAgICAgICAgICBnb0JhY2sgPSA8YSBjbGFzc05hbWU9XCJteF9BdXRoQm9keV9jaGFuZ2VGbG93XCIgb25DbGljaz17dGhpcy5vbkdvVG9Gb3JtQ2xpY2tlZH0gaHJlZj1cIiNcIj5cbiAgICAgICAgICAgICAgICB7IF90KCdHbyBiYWNrJykgfVxuICAgICAgICAgICAgPC9hPjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5jb21wbGV0ZWROb1NpZ25pbikge1xuICAgICAgICAgICAgbGV0IHJlZ0RvbmVUZXh0O1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuZGlmZmVyZW50TG9nZ2VkSW5Vc2VySWQpIHtcbiAgICAgICAgICAgICAgICByZWdEb25lVGV4dCA9IDxkaXY+XG4gICAgICAgICAgICAgICAgICAgIDxwPnsgX3QoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIllvdXIgbmV3IGFjY291bnQgKCUobmV3QWNjb3VudElkKXMpIGlzIHJlZ2lzdGVyZWQsIGJ1dCB5b3UncmUgYWxyZWFkeSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcImxvZ2dlZCBpbnRvIGEgZGlmZmVyZW50IGFjY291bnQgKCUobG9nZ2VkSW5Vc2VySWQpcykuXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdBY2NvdW50SWQ6IHRoaXMuc3RhdGUucmVnaXN0ZXJlZFVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlZEluVXNlcklkOiB0aGlzLnN0YXRlLmRpZmZlcmVudExvZ2dlZEluVXNlcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgKSB9PC9wPlxuICAgICAgICAgICAgICAgICAgICA8cD48QWNjZXNzaWJsZUJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudD1cInNwYW5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibXhfbGlua0J1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXthc3luYyBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbkxvYWRlZCA9IGF3YWl0IHRoaXMub25Mb2dpbkNsaWNrV2l0aENoZWNrKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkxvYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXMuZGlzcGF0Y2goeyBhY3Rpb246IFwidmlld193ZWxjb21lX3BhZ2VcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICB7IF90KFwiQ29udGludWUgd2l0aCBwcmV2aW91cyBhY2NvdW50XCIpIH1cbiAgICAgICAgICAgICAgICAgICAgPC9BY2Nlc3NpYmxlQnV0dG9uPjwvcD5cbiAgICAgICAgICAgICAgICA8L2Rpdj47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuZm9ybVZhbHMucGFzc3dvcmQpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSdyZSB0aGUgY2xpZW50IHRoYXQgc3RhcnRlZCB0aGUgcmVnaXN0cmF0aW9uXG4gICAgICAgICAgICAgICAgcmVnRG9uZVRleHQgPSA8aDM+eyBfdChcbiAgICAgICAgICAgICAgICAgICAgXCI8YT5Mb2cgaW48L2E+IHRvIHlvdXIgbmV3IGFjY291bnQuXCIsIHt9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhOiAoc3ViKSA9PiA8YSBocmVmPVwiIy9sb2dpblwiIG9uQ2xpY2s9e3RoaXMub25Mb2dpbkNsaWNrV2l0aENoZWNrfT57IHN1YiB9PC9hPixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICApIH08L2gzPjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UncmUgbm90IHRoZSBvcmlnaW5hbCBjbGllbnQ6IHRoZSB1c2VyIHByb2JhYmx5IGdvdCB0byB1cyBieSBjbGlja2luZyB0aGVcbiAgICAgICAgICAgICAgICAvLyBlbWFpbCB2YWxpZGF0aW9uIGxpbmsuIFdlIGNhbid0IG9mZmVyIGEgJ2dvIHN0cmFpZ2h0IHRvIHlvdXIgYWNjb3VudCcgbGlua1xuICAgICAgICAgICAgICAgIC8vIGFzIHdlIGRvbid0IGhhdmUgdGhlIG9yaWdpbmFsIGNyZWRzLlxuICAgICAgICAgICAgICAgIHJlZ0RvbmVUZXh0ID0gPGgzPnsgX3QoXG4gICAgICAgICAgICAgICAgICAgIFwiWW91IGNhbiBub3cgY2xvc2UgdGhpcyB3aW5kb3cgb3IgPGE+bG9nIGluPC9hPiB0byB5b3VyIG5ldyBhY2NvdW50LlwiLCB7fSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYTogKHN1YikgPT4gPGEgaHJlZj1cIiMvbG9naW5cIiBvbkNsaWNrPXt0aGlzLm9uTG9naW5DbGlja1dpdGhDaGVja30+eyBzdWIgfTwvYT4sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKSB9PC9oMz47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib2R5ID0gPGRpdj5cbiAgICAgICAgICAgICAgICA8aDI+eyBfdChcIlJlZ2lzdHJhdGlvbiBTdWNjZXNzZnVsXCIpIH08L2gyPlxuICAgICAgICAgICAgICAgIHsgcmVnRG9uZVRleHQgfVxuICAgICAgICAgICAgPC9kaXY+O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IDxkaXY+XG4gICAgICAgICAgICAgICAgPGgyPnsgX3QoJ0NyZWF0ZSBhY2NvdW50JykgfTwvaDI+XG4gICAgICAgICAgICAgICAgeyBlcnJvclRleHQgfVxuICAgICAgICAgICAgICAgIHsgc2VydmVyRGVhZFNlY3Rpb24gfVxuICAgICAgICAgICAgICAgIDxTZXJ2ZXJQaWNrZXJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU9e190KFwiSG9zdCBhY2NvdW50IG9uXCIpfVxuICAgICAgICAgICAgICAgICAgICBkaWFsb2dUaXRsZT17X3QoXCJEZWNpZGUgd2hlcmUgeW91ciBhY2NvdW50IGlzIGhvc3RlZFwiKX1cbiAgICAgICAgICAgICAgICAgICAgc2VydmVyQ29uZmlnPXt0aGlzLnByb3BzLnNlcnZlckNvbmZpZ31cbiAgICAgICAgICAgICAgICAgICAgb25TZXJ2ZXJDb25maWdDaGFuZ2U9e3RoaXMuc3RhdGUuZG9pbmdVSUF1dGggPyB1bmRlZmluZWQgOiB0aGlzLnByb3BzLm9uU2VydmVyQ29uZmlnQ2hhbmdlfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgeyB0aGlzLnJlbmRlclJlZ2lzdGVyQ29tcG9uZW50KCkgfVxuICAgICAgICAgICAgICAgIHsgZ29CYWNrIH1cbiAgICAgICAgICAgICAgICB7IHNpZ25JbiB9XG4gICAgICAgICAgICA8L2Rpdj47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPEF1dGhQYWdlPlxuICAgICAgICAgICAgICAgIDxBdXRoSGVhZGVyIC8+XG4gICAgICAgICAgICAgICAgPEF1dGhCb2R5PlxuICAgICAgICAgICAgICAgICAgICB7IGJvZHkgfVxuICAgICAgICAgICAgICAgIDwvQXV0aEJvZHk+XG4gICAgICAgICAgICA8L0F1dGhQYWdlPlxuICAgICAgICApO1xuICAgIH1cbn1cbiJdfQ==