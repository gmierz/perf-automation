"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _languageHandler = require("../../../languageHandler");

var _Login = _interopRequireDefault(require("../../../Login"));

var _SdkConfig = _interopRequireDefault(require("../../../SdkConfig"));

var _ErrorUtils = require("../../../utils/ErrorUtils");

var _AutoDiscoveryUtils = _interopRequireDefault(require("../../../utils/AutoDiscoveryUtils"));

var _classnames = _interopRequireDefault(require("classnames"));

var _AuthPage = _interopRequireDefault(require("../../views/auth/AuthPage"));

var _PlatformPeg = _interopRequireDefault(require("../../../PlatformPeg"));

var _SettingsStore = _interopRequireDefault(require("../../../settings/SettingsStore"));

var _UIFeature = require("../../../settings/UIFeature");

var _CountlyAnalytics = _interopRequireDefault(require("../../../CountlyAnalytics"));

var _PasswordLogin = _interopRequireDefault(require("../../views/auth/PasswordLogin"));

var _InlineSpinner = _interopRequireDefault(require("../../views/elements/InlineSpinner"));

var _Spinner = _interopRequireDefault(require("../../views/elements/Spinner"));

var _SSOButtons = _interopRequireDefault(require("../../views/elements/SSOButtons"));

var _ServerPicker = _interopRequireDefault(require("../../views/elements/ServerPicker"));

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _AuthBody = _interopRequireDefault(require("../../views/auth/AuthBody"));

var _AuthHeader = _interopRequireDefault(require("../../views/auth/AuthHeader"));

var _logger = require("matrix-js-sdk/src/logger");

var _dec, _class;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// These are used in several places, and come from the js-sdk's autodiscovery
// stuff. We define them here so that they'll be picked up by i18n.
(0, _languageHandler._td)("Invalid homeserver discovery response");
(0, _languageHandler._td)("Failed to get autodiscovery configuration from server");
(0, _languageHandler._td)("Invalid base_url for m.homeserver");
(0, _languageHandler._td)("Homeserver URL does not appear to be a valid Matrix homeserver");
(0, _languageHandler._td)("Invalid identity server discovery response");
(0, _languageHandler._td)("Invalid base_url for m.identity_server");
(0, _languageHandler._td)("Identity server URL does not appear to be a valid identity server");
(0, _languageHandler._td)("General failure");
let LoginComponent = (
/*
 * A wire component which glues together login UI components and Login logic
 */
_dec = (0, _replaceableComponent.replaceableComponent)("structures.auth.LoginComponent"), _dec(_class = class LoginComponent extends _react.default.PureComponent {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "unmounted", false);
    (0, _defineProperty2.default)(this, "loginLogic", void 0);
    (0, _defineProperty2.default)(this, "stepRendererMap", void 0);
    (0, _defineProperty2.default)(this, "isBusy", () => this.state.busy || this.props.busy);
    (0, _defineProperty2.default)(this, "onPasswordLogin", async (username, phoneCountry, phoneNumber, password) => {
      if (!this.state.serverIsAlive) {
        this.setState({
          busy: true
        }); // Do a quick liveliness check on the URLs

        let aliveAgain = true;

        try {
          await _AutoDiscoveryUtils.default.validateServerConfigWithStaticUrls(this.props.serverConfig.hsUrl, this.props.serverConfig.isUrl);
          this.setState({
            serverIsAlive: true,
            errorText: ""
          });
        } catch (e) {
          const componentState = _AutoDiscoveryUtils.default.authComponentStateForError(e);

          this.setState(_objectSpread({
            busy: false,
            busyLoggingIn: false
          }, componentState));
          aliveAgain = !componentState.serverErrorIsFatal;
        } // Prevent people from submitting their password when something isn't right.


        if (!aliveAgain) {
          return;
        }
      }

      this.setState({
        busy: true,
        busyLoggingIn: true,
        errorText: null,
        loginIncorrect: false
      });
      this.loginLogic.loginViaPassword(username, phoneCountry, phoneNumber, password).then(data => {
        this.setState({
          serverIsAlive: true
        }); // it must be, we logged in.

        this.props.onLoggedIn(data, password);
      }, error => {
        if (this.unmounted) {
          return;
        }

        let errorText; // Some error strings only apply for logging in

        const usingEmail = username.indexOf("@") > 0;

        if (error.httpStatus === 400 && usingEmail) {
          errorText = (0, _languageHandler._t)('This homeserver does not support login using email address.');
        } else if (error.errcode === 'M_RESOURCE_LIMIT_EXCEEDED') {
          const errorTop = (0, _ErrorUtils.messageForResourceLimitError)(error.data.limit_type, error.data.admin_contact, {
            'monthly_active_user': (0, _languageHandler._td)("This homeserver has hit its Monthly Active User limit."),
            'hs_blocked': (0, _languageHandler._td)("This homeserver has been blocked by it's administrator."),
            '': (0, _languageHandler._td)("This homeserver has exceeded one of its resource limits.")
          });
          const errorDetail = (0, _ErrorUtils.messageForResourceLimitError)(error.data.limit_type, error.data.admin_contact, {
            '': (0, _languageHandler._td)("Please <a>contact your service administrator</a> to continue using this service.")
          });
          errorText = /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("div", null, errorTop), /*#__PURE__*/_react.default.createElement("div", {
            className: "mx_Login_smallError"
          }, errorDetail));
        } else if (error.httpStatus === 401 || error.httpStatus === 403) {
          if (error.errcode === 'M_USER_DEACTIVATED') {
            errorText = (0, _languageHandler._t)('This account has been deactivated.');
          } else if (_SdkConfig.default.get()['disable_custom_urls']) {
            errorText = /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("div", null, (0, _languageHandler._t)('Incorrect username and/or password.')), /*#__PURE__*/_react.default.createElement("div", {
              className: "mx_Login_smallError"
            }, (0, _languageHandler._t)('Please note you are logging into the %(hs)s server, not matrix.org.', {
              hs: this.props.serverConfig.hsName
            })));
          } else {
            errorText = (0, _languageHandler._t)('Incorrect username and/or password.');
          }
        } else {
          // other errors, not specific to doing a password login
          errorText = this.errorTextFromError(error);
        }

        this.setState({
          busy: false,
          busyLoggingIn: false,
          errorText: errorText,
          // 401 would be the sensible status code for 'incorrect password'
          // but the login API gives a 403 https://matrix.org/jira/browse/SYN-744
          // mentions this (although the bug is for UI auth which is not this)
          // We treat both as an incorrect password
          loginIncorrect: error.httpStatus === 401 || error.httpStatus === 403
        });
      });
    });
    (0, _defineProperty2.default)(this, "onUsernameChanged", username => {
      this.setState({
        username: username
      });
    });
    (0, _defineProperty2.default)(this, "onUsernameBlur", async username => {
      const doWellknownLookup = username[0] === "@";
      this.setState({
        username: username,
        busy: doWellknownLookup,
        errorText: null,
        canTryLogin: true
      });

      if (doWellknownLookup) {
        const serverName = username.split(':').slice(1).join(':');

        try {
          const result = await _AutoDiscoveryUtils.default.validateServerName(serverName);
          this.props.onServerConfigChange(result); // We'd like to rely on new props coming in via `onServerConfigChange`
          // so that we know the servers have definitely updated before clearing
          // the busy state. In the case of a full MXID that resolves to the same
          // HS as Element's default HS though, there may not be any server change.
          // To avoid this trap, we clear busy here. For cases where the server
          // actually has changed, `initLoginLogic` will be called and manages
          // busy state for its own liveness check.

          this.setState({
            busy: false
          });
        } catch (e) {
          _logger.logger.error("Problem parsing URL or unhandled error doing .well-known discovery:", e);

          let message = (0, _languageHandler._t)("Failed to perform homeserver discovery");

          if (e.translatedMessage) {
            message = e.translatedMessage;
          }

          let errorText = message;
          let discoveryState = {};

          if (_AutoDiscoveryUtils.default.isLivelinessError(e)) {
            errorText = this.state.errorText;
            discoveryState = _AutoDiscoveryUtils.default.authComponentStateForError(e);
          }

          this.setState(_objectSpread({
            busy: false,
            errorText
          }, discoveryState));
        }
      }
    });
    (0, _defineProperty2.default)(this, "onPhoneCountryChanged", phoneCountry => {
      this.setState({
        phoneCountry: phoneCountry
      });
    });
    (0, _defineProperty2.default)(this, "onPhoneNumberChanged", phoneNumber => {
      this.setState({
        phoneNumber: phoneNumber
      });
    });
    (0, _defineProperty2.default)(this, "onRegisterClick", ev => {
      ev.preventDefault();
      ev.stopPropagation();
      this.props.onRegisterClick();
    });
    (0, _defineProperty2.default)(this, "onTryRegisterClick", ev => {
      var _this$state$flows, _this$state$flows2;

      const hasPasswordFlow = (_this$state$flows = this.state.flows) === null || _this$state$flows === void 0 ? void 0 : _this$state$flows.find(flow => flow.type === "m.login.password");
      const ssoFlow = (_this$state$flows2 = this.state.flows) === null || _this$state$flows2 === void 0 ? void 0 : _this$state$flows2.find(flow => flow.type === "m.login.sso" || flow.type === "m.login.cas"); // If has no password flow but an SSO flow guess that the user wants to register with SSO.
      // TODO: instead hide the Register button if registration is disabled by checking with the server,
      // has no specific errCode currently and uses M_FORBIDDEN.

      if (ssoFlow && !hasPasswordFlow) {
        ev.preventDefault();
        ev.stopPropagation();
        const ssoKind = ssoFlow.type === 'm.login.sso' ? 'sso' : 'cas';

        _PlatformPeg.default.get().startSingleSignOn(this.loginLogic.createTemporaryClient(), ssoKind, this.props.fragmentAfterLogin);
      } else {
        // Don't intercept - just go through to the register page
        this.onRegisterClick(ev);
      }
    });
    (0, _defineProperty2.default)(this, "isSupportedFlow", flow => {
      // technically the flow can have multiple steps, but no one does this
      // for login and loginLogic doesn't support it so we can ignore it.
      if (!this.stepRendererMap[flow.type]) {
        _logger.logger.log("Skipping flow", flow, "due to unsupported login type", flow.type);

        return false;
      }

      return true;
    });
    (0, _defineProperty2.default)(this, "renderPasswordStep", () => {
      return /*#__PURE__*/_react.default.createElement(_PasswordLogin.default, {
        onSubmit: this.onPasswordLogin,
        username: this.state.username,
        phoneCountry: this.state.phoneCountry,
        phoneNumber: this.state.phoneNumber,
        onUsernameChanged: this.onUsernameChanged,
        onUsernameBlur: this.onUsernameBlur,
        onPhoneCountryChanged: this.onPhoneCountryChanged,
        onPhoneNumberChanged: this.onPhoneNumberChanged,
        onForgotPasswordClick: this.props.onForgotPasswordClick,
        loginIncorrect: this.state.loginIncorrect,
        serverConfig: this.props.serverConfig,
        disableSubmit: this.isBusy(),
        busy: this.props.isSyncing || this.state.busyLoggingIn
      });
    });
    (0, _defineProperty2.default)(this, "renderSsoStep", loginType => {
      const flow = this.state.flows.find(flow => flow.type === "m.login." + loginType);
      return /*#__PURE__*/_react.default.createElement(_SSOButtons.default, {
        matrixClient: this.loginLogic.createTemporaryClient(),
        flow: flow,
        loginType: loginType,
        fragmentAfterLogin: this.props.fragmentAfterLogin,
        primary: !this.state.flows.find(flow => flow.type === "m.login.password")
      });
    });
    this.state = {
      busy: false,
      busyLoggingIn: null,
      errorText: null,
      loginIncorrect: false,
      canTryLogin: true,
      flows: null,
      username: props.defaultUsername ? props.defaultUsername : '',
      phoneCountry: null,
      phoneNumber: "",
      serverIsAlive: true,
      serverErrorIsFatal: false,
      serverDeadError: ""
    }; // map from login step type to a function which will render a control
    // letting you do that login type

    this.stepRendererMap = {
      'm.login.password': this.renderPasswordStep,
      // CAS and SSO are the same thing, modulo the url we link to
      'm.login.cas': () => this.renderSsoStep("cas"),
      'm.login.sso': () => this.renderSsoStep("sso")
    };

    _CountlyAnalytics.default.instance.track("onboarding_login_begin");
  } // TODO: [REACT-WARNING] Replace with appropriate lifecycle event
  // eslint-disable-next-line


  UNSAFE_componentWillMount() {
    this.initLoginLogic(this.props.serverConfig);
  }

  componentWillUnmount() {
    this.unmounted = true;
  } // TODO: [REACT-WARNING] Replace with appropriate lifecycle event
  // eslint-disable-next-line


  UNSAFE_componentWillReceiveProps(newProps) {
    if (newProps.serverConfig.hsUrl === this.props.serverConfig.hsUrl && newProps.serverConfig.isUrl === this.props.serverConfig.isUrl) return; // Ensure that we end up actually logging in to the right place

    this.initLoginLogic(newProps.serverConfig);
  }

  async initLoginLogic({
    hsUrl,
    isUrl
  }) {
    let isDefaultServer = false;

    if (this.props.serverConfig.isDefault && hsUrl === this.props.serverConfig.hsUrl && isUrl === this.props.serverConfig.isUrl) {
      isDefaultServer = true;
    }

    const fallbackHsUrl = isDefaultServer ? this.props.fallbackHsUrl : null;
    const loginLogic = new _Login.default(hsUrl, isUrl, fallbackHsUrl, {
      defaultDeviceDisplayName: this.props.defaultDeviceDisplayName
    });
    this.loginLogic = loginLogic;
    this.setState({
      busy: true,
      loginIncorrect: false
    }); // Do a quick liveliness check on the URLs

    try {
      const {
        warning
      } = await _AutoDiscoveryUtils.default.validateServerConfigWithStaticUrls(hsUrl, isUrl);

      if (warning) {
        this.setState(_objectSpread(_objectSpread({}, _AutoDiscoveryUtils.default.authComponentStateForError(warning)), {}, {
          errorText: ""
        }));
      } else {
        this.setState({
          serverIsAlive: true,
          errorText: ""
        });
      }
    } catch (e) {
      this.setState(_objectSpread({
        busy: false
      }, _AutoDiscoveryUtils.default.authComponentStateForError(e)));
    }

    loginLogic.getFlows().then(flows => {
      // look for a flow where we understand all of the steps.
      const supportedFlows = flows.filter(this.isSupportedFlow);

      if (supportedFlows.length > 0) {
        this.setState({
          flows: supportedFlows
        });
        return;
      } // we got to the end of the list without finding a suitable flow.


      this.setState({
        errorText: (0, _languageHandler._t)("This homeserver doesn't offer any login flows which are supported by this client.")
      });
    }, err => {
      this.setState({
        errorText: this.errorTextFromError(err),
        loginIncorrect: false,
        canTryLogin: false
      });
    }).finally(() => {
      this.setState({
        busy: false
      });
    });
  }

  errorTextFromError(err) {
    let errCode = err.errcode;

    if (!errCode && err.httpStatus) {
      errCode = "HTTP " + err.httpStatus;
    }

    let errorText = (0, _languageHandler._t)("There was a problem communicating with the homeserver, " + "please try again later.") + (errCode ? " (" + errCode + ")" : "");

    if (err.cors === 'rejected') {
      if (window.location.protocol === 'https:' && (this.props.serverConfig.hsUrl.startsWith("http:") || !this.props.serverConfig.hsUrl.startsWith("http"))) {
        errorText = /*#__PURE__*/_react.default.createElement("span", null, (0, _languageHandler._t)("Can't connect to homeserver via HTTP when an HTTPS URL is in your browser bar. " + "Either use HTTPS or <a>enable unsafe scripts</a>.", {}, {
          'a': sub => {
            return /*#__PURE__*/_react.default.createElement("a", {
              target: "_blank",
              rel: "noreferrer noopener",
              href: "https://www.google.com/search?&q=enable%20unsafe%20scripts"
            }, sub);
          }
        }));
      } else {
        errorText = /*#__PURE__*/_react.default.createElement("span", null, (0, _languageHandler._t)("Can't connect to homeserver - please check your connectivity, ensure your " + "<a>homeserver's SSL certificate</a> is trusted, and that a browser extension " + "is not blocking requests.", {}, {
          'a': sub => /*#__PURE__*/_react.default.createElement("a", {
            target: "_blank",
            rel: "noreferrer noopener",
            href: this.props.serverConfig.hsUrl
          }, sub)
        }));
      }
    }

    return errorText;
  }

  renderLoginComponentForFlows() {
    if (!this.state.flows) return null; // this is the ideal order we want to show the flows in

    const order = ["m.login.password", "m.login.sso"];
    const flows = order.map(type => this.state.flows.find(flow => flow.type === type)).filter(Boolean);
    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, flows.map(flow => {
      const stepRenderer = this.stepRendererMap[flow.type];
      return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, {
        key: flow.type
      }, stepRenderer());
    }));
  }

  render() {
    const loader = this.isBusy() && !this.state.busyLoggingIn ? /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_Login_loader"
    }, /*#__PURE__*/_react.default.createElement(_Spinner.default, null)) : null;
    const errorText = this.state.errorText;
    let errorTextSection;

    if (errorText) {
      errorTextSection = /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_Login_error"
      }, errorText);
    }

    let serverDeadSection;

    if (!this.state.serverIsAlive) {
      const classes = (0, _classnames.default)({
        "mx_Login_error": true,
        "mx_Login_serverError": true,
        "mx_Login_serverErrorNonFatal": !this.state.serverErrorIsFatal
      });
      serverDeadSection = /*#__PURE__*/_react.default.createElement("div", {
        className: classes
      }, this.state.serverDeadError);
    }

    let footer;

    if (this.props.isSyncing || this.state.busyLoggingIn) {
      footer = /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_AuthBody_paddedFooter"
      }, /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_AuthBody_paddedFooter_title"
      }, /*#__PURE__*/_react.default.createElement(_InlineSpinner.default, {
        w: 20,
        h: 20
      }), this.props.isSyncing ? (0, _languageHandler._t)("Syncing...") : (0, _languageHandler._t)("Signing In...")), this.props.isSyncing && /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_AuthBody_paddedFooter_subtitle"
      }, (0, _languageHandler._t)("If you've joined lots of rooms, this might take a while")));
    } else if (_SettingsStore.default.getValue(_UIFeature.UIFeature.Registration)) {
      footer = /*#__PURE__*/_react.default.createElement("span", {
        className: "mx_AuthBody_changeFlow"
      }, (0, _languageHandler._t)("New? <a>Create account</a>", {}, {
        a: sub => /*#__PURE__*/_react.default.createElement("a", {
          onClick: this.onTryRegisterClick,
          href: "#"
        }, sub)
      }));
    }

    return /*#__PURE__*/_react.default.createElement(_AuthPage.default, null, /*#__PURE__*/_react.default.createElement(_AuthHeader.default, {
      disableLanguageSelector: this.props.isSyncing || this.state.busyLoggingIn
    }), /*#__PURE__*/_react.default.createElement(_AuthBody.default, null, /*#__PURE__*/_react.default.createElement("h2", null, (0, _languageHandler._t)('Sign in'), loader), errorTextSection, serverDeadSection, /*#__PURE__*/_react.default.createElement(_ServerPicker.default, {
      serverConfig: this.props.serverConfig,
      onServerConfigChange: this.props.onServerConfigChange
    }), this.renderLoginComponentForFlows(), footer));
  }

}) || _class);
exports.default = LoginComponent;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3N0cnVjdHVyZXMvYXV0aC9Mb2dpbi50c3giXSwibmFtZXMiOlsiTG9naW5Db21wb25lbnQiLCJSZWFjdCIsIlB1cmVDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsInByb3BzIiwic3RhdGUiLCJidXN5IiwidXNlcm5hbWUiLCJwaG9uZUNvdW50cnkiLCJwaG9uZU51bWJlciIsInBhc3N3b3JkIiwic2VydmVySXNBbGl2ZSIsInNldFN0YXRlIiwiYWxpdmVBZ2FpbiIsIkF1dG9EaXNjb3ZlcnlVdGlscyIsInZhbGlkYXRlU2VydmVyQ29uZmlnV2l0aFN0YXRpY1VybHMiLCJzZXJ2ZXJDb25maWciLCJoc1VybCIsImlzVXJsIiwiZXJyb3JUZXh0IiwiZSIsImNvbXBvbmVudFN0YXRlIiwiYXV0aENvbXBvbmVudFN0YXRlRm9yRXJyb3IiLCJidXN5TG9nZ2luZ0luIiwic2VydmVyRXJyb3JJc0ZhdGFsIiwibG9naW5JbmNvcnJlY3QiLCJsb2dpbkxvZ2ljIiwibG9naW5WaWFQYXNzd29yZCIsInRoZW4iLCJkYXRhIiwib25Mb2dnZWRJbiIsImVycm9yIiwidW5tb3VudGVkIiwidXNpbmdFbWFpbCIsImluZGV4T2YiLCJodHRwU3RhdHVzIiwiZXJyY29kZSIsImVycm9yVG9wIiwibGltaXRfdHlwZSIsImFkbWluX2NvbnRhY3QiLCJlcnJvckRldGFpbCIsIlNka0NvbmZpZyIsImdldCIsImhzIiwiaHNOYW1lIiwiZXJyb3JUZXh0RnJvbUVycm9yIiwiZG9XZWxsa25vd25Mb29rdXAiLCJjYW5UcnlMb2dpbiIsInNlcnZlck5hbWUiLCJzcGxpdCIsInNsaWNlIiwiam9pbiIsInJlc3VsdCIsInZhbGlkYXRlU2VydmVyTmFtZSIsIm9uU2VydmVyQ29uZmlnQ2hhbmdlIiwibG9nZ2VyIiwibWVzc2FnZSIsInRyYW5zbGF0ZWRNZXNzYWdlIiwiZGlzY292ZXJ5U3RhdGUiLCJpc0xpdmVsaW5lc3NFcnJvciIsImV2IiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJvblJlZ2lzdGVyQ2xpY2siLCJoYXNQYXNzd29yZEZsb3ciLCJmbG93cyIsImZpbmQiLCJmbG93IiwidHlwZSIsInNzb0Zsb3ciLCJzc29LaW5kIiwiUGxhdGZvcm1QZWciLCJzdGFydFNpbmdsZVNpZ25PbiIsImNyZWF0ZVRlbXBvcmFyeUNsaWVudCIsImZyYWdtZW50QWZ0ZXJMb2dpbiIsInN0ZXBSZW5kZXJlck1hcCIsImxvZyIsIm9uUGFzc3dvcmRMb2dpbiIsIm9uVXNlcm5hbWVDaGFuZ2VkIiwib25Vc2VybmFtZUJsdXIiLCJvblBob25lQ291bnRyeUNoYW5nZWQiLCJvblBob25lTnVtYmVyQ2hhbmdlZCIsIm9uRm9yZ290UGFzc3dvcmRDbGljayIsImlzQnVzeSIsImlzU3luY2luZyIsImxvZ2luVHlwZSIsImRlZmF1bHRVc2VybmFtZSIsInNlcnZlckRlYWRFcnJvciIsInJlbmRlclBhc3N3b3JkU3RlcCIsInJlbmRlclNzb1N0ZXAiLCJDb3VudGx5QW5hbHl0aWNzIiwiaW5zdGFuY2UiLCJ0cmFjayIsIlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQiLCJpbml0TG9naW5Mb2dpYyIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJuZXdQcm9wcyIsImlzRGVmYXVsdFNlcnZlciIsImlzRGVmYXVsdCIsImZhbGxiYWNrSHNVcmwiLCJMb2dpbiIsImRlZmF1bHREZXZpY2VEaXNwbGF5TmFtZSIsIndhcm5pbmciLCJnZXRGbG93cyIsInN1cHBvcnRlZEZsb3dzIiwiZmlsdGVyIiwiaXNTdXBwb3J0ZWRGbG93IiwibGVuZ3RoIiwiZXJyIiwiZmluYWxseSIsImVyckNvZGUiLCJjb3JzIiwid2luZG93IiwibG9jYXRpb24iLCJwcm90b2NvbCIsInN0YXJ0c1dpdGgiLCJzdWIiLCJyZW5kZXJMb2dpbkNvbXBvbmVudEZvckZsb3dzIiwib3JkZXIiLCJtYXAiLCJCb29sZWFuIiwic3RlcFJlbmRlcmVyIiwicmVuZGVyIiwibG9hZGVyIiwiZXJyb3JUZXh0U2VjdGlvbiIsInNlcnZlckRlYWRTZWN0aW9uIiwiY2xhc3NlcyIsImZvb3RlciIsIlNldHRpbmdzU3RvcmUiLCJnZXRWYWx1ZSIsIlVJRmVhdHVyZSIsIlJlZ2lzdHJhdGlvbiIsImEiLCJvblRyeVJlZ2lzdGVyQ2xpY2siXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBZ0JBOztBQUdBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOzs7Ozs7OztBQUVBO0FBQ0E7QUFDQSwwQkFBSSx1Q0FBSjtBQUNBLDBCQUFJLHVEQUFKO0FBQ0EsMEJBQUksbUNBQUo7QUFDQSwwQkFBSSxnRUFBSjtBQUNBLDBCQUFJLDRDQUFKO0FBQ0EsMEJBQUksd0NBQUo7QUFDQSwwQkFBSSxtRUFBSjtBQUNBLDBCQUFJLGlCQUFKO0lBd0RxQkEsYztBQUpyQjtBQUNBO0FBQ0E7T0FDQyxnREFBcUIsZ0NBQXJCLEMsZ0JBQUQsTUFDcUJBLGNBRHJCLFNBQzRDQyxlQUFNQyxhQURsRCxDQUNnRjtBQU01RUMsRUFBQUEsV0FBVyxDQUFDQyxLQUFELEVBQVE7QUFDZixVQUFNQSxLQUFOO0FBRGUscURBTEMsS0FLRDtBQUFBO0FBQUE7QUFBQSxrREFzRFYsTUFBTSxLQUFLQyxLQUFMLENBQVdDLElBQVgsSUFBbUIsS0FBS0YsS0FBTCxDQUFXRSxJQXREMUI7QUFBQSwyREF3REQsT0FBT0MsUUFBUCxFQUFpQkMsWUFBakIsRUFBK0JDLFdBQS9CLEVBQTRDQyxRQUE1QyxLQUF5RDtBQUN2RSxVQUFJLENBQUMsS0FBS0wsS0FBTCxDQUFXTSxhQUFoQixFQUErQjtBQUMzQixhQUFLQyxRQUFMLENBQWM7QUFBRU4sVUFBQUEsSUFBSSxFQUFFO0FBQVIsU0FBZCxFQUQyQixDQUUzQjs7QUFDQSxZQUFJTyxV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REosRUFLTUMsZ0JBTE4sRUFNTUMsaUJBTk4sZUFPSSw2QkFBQyxxQkFBRDtBQUNJLE1BQUEsWUFBWSxFQUFFLEtBQUsxSCxLQUFMLENBQVdZLFlBRDdCO0FBRUksTUFBQSxvQkFBb0IsRUFBRSxLQUFLWixLQUFMLENBQVdrRDtBQUZyQyxNQVBKLEVBV00sS0FBS2dFLDRCQUFMLEVBWE4sRUFZTVUsTUFaTixDQUZKLENBREo7QUFtQkg7O0FBN2YyRSxDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE1LTIwMjEgVGhlIE1hdHJpeC5vcmcgRm91bmRhdGlvbiBDLkkuQy5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgUmVhY3QsIHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgTWF0cml4RXJyb3IgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvaHR0cC1hcGlcIjtcblxuaW1wb3J0IHsgX3QsIF90ZCB9IGZyb20gJy4uLy4uLy4uL2xhbmd1YWdlSGFuZGxlcic7XG5pbXBvcnQgTG9naW4sIHsgSVNTT0Zsb3csIExvZ2luRmxvdyB9IGZyb20gJy4uLy4uLy4uL0xvZ2luJztcbmltcG9ydCBTZGtDb25maWcgZnJvbSAnLi4vLi4vLi4vU2RrQ29uZmlnJztcbmltcG9ydCB7IG1lc3NhZ2VGb3JSZXNvdXJjZUxpbWl0RXJyb3IgfSBmcm9tICcuLi8uLi8uLi91dGlscy9FcnJvclV0aWxzJztcbmltcG9ydCBBdXRvRGlzY292ZXJ5VXRpbHMsIHsgVmFsaWRhdGVkU2VydmVyQ29uZmlnIH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL0F1dG9EaXNjb3ZlcnlVdGlsc1wiO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSBcImNsYXNzbmFtZXNcIjtcbmltcG9ydCBBdXRoUGFnZSBmcm9tIFwiLi4vLi4vdmlld3MvYXV0aC9BdXRoUGFnZVwiO1xuaW1wb3J0IFBsYXRmb3JtUGVnIGZyb20gJy4uLy4uLy4uL1BsYXRmb3JtUGVnJztcbmltcG9ydCBTZXR0aW5nc1N0b3JlIGZyb20gXCIuLi8uLi8uLi9zZXR0aW5ncy9TZXR0aW5nc1N0b3JlXCI7XG5pbXBvcnQgeyBVSUZlYXR1cmUgfSBmcm9tIFwiLi4vLi4vLi4vc2V0dGluZ3MvVUlGZWF0dXJlXCI7XG5pbXBvcnQgQ291bnRseUFuYWx5dGljcyBmcm9tIFwiLi4vLi4vLi4vQ291bnRseUFuYWx5dGljc1wiO1xuaW1wb3J0IHsgSU1hdHJpeENsaWVudENyZWRzIH0gZnJvbSBcIi4uLy4uLy4uL01hdHJpeENsaWVudFBlZ1wiO1xuaW1wb3J0IFBhc3N3b3JkTG9naW4gZnJvbSBcIi4uLy4uL3ZpZXdzL2F1dGgvUGFzc3dvcmRMb2dpblwiO1xuaW1wb3J0IElubGluZVNwaW5uZXIgZnJvbSBcIi4uLy4uL3ZpZXdzL2VsZW1lbnRzL0lubGluZVNwaW5uZXJcIjtcbmltcG9ydCBTcGlubmVyIGZyb20gXCIuLi8uLi92aWV3cy9lbGVtZW50cy9TcGlubmVyXCI7XG5pbXBvcnQgU1NPQnV0dG9ucyBmcm9tIFwiLi4vLi4vdmlld3MvZWxlbWVudHMvU1NPQnV0dG9uc1wiO1xuaW1wb3J0IFNlcnZlclBpY2tlciBmcm9tIFwiLi4vLi4vdmlld3MvZWxlbWVudHMvU2VydmVyUGlja2VyXCI7XG5pbXBvcnQgeyByZXBsYWNlYWJsZUNvbXBvbmVudCB9IGZyb20gXCIuLi8uLi8uLi91dGlscy9yZXBsYWNlYWJsZUNvbXBvbmVudFwiO1xuaW1wb3J0IEF1dGhCb2R5IGZyb20gXCIuLi8uLi92aWV3cy9hdXRoL0F1dGhCb2R5XCI7XG5pbXBvcnQgQXV0aEhlYWRlciBmcm9tIFwiLi4vLi4vdmlld3MvYXV0aC9BdXRoSGVhZGVyXCI7XG5cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9sb2dnZXJcIjtcblxuLy8gVGhlc2UgYXJlIHVzZWQgaW4gc2V2ZXJhbCBwbGFjZXMsIGFuZCBjb21lIGZyb20gdGhlIGpzLXNkaydzIGF1dG9kaXNjb3Zlcnlcbi8vIHN0dWZmLiBXZSBkZWZpbmUgdGhlbSBoZXJlIHNvIHRoYXQgdGhleSdsbCBiZSBwaWNrZWQgdXAgYnkgaTE4bi5cbl90ZChcIkludmFsaWQgaG9tZXNlcnZlciBkaXNjb3ZlcnkgcmVzcG9uc2VcIik7XG5fdGQoXCJGYWlsZWQgdG8gZ2V0IGF1dG9kaXNjb3ZlcnkgY29uZmlndXJhdGlvbiBmcm9tIHNlcnZlclwiKTtcbl90ZChcIkludmFsaWQgYmFzZV91cmwgZm9yIG0uaG9tZXNlcnZlclwiKTtcbl90ZChcIkhvbWVzZXJ2ZXIgVVJMIGRvZXMgbm90IGFwcGVhciB0byBiZSBhIHZhbGlkIE1hdHJpeCBob21lc2VydmVyXCIpO1xuX3RkKFwiSW52YWxpZCBpZGVudGl0eSBzZXJ2ZXIgZGlzY292ZXJ5IHJlc3BvbnNlXCIpO1xuX3RkKFwiSW52YWxpZCBiYXNlX3VybCBmb3IgbS5pZGVudGl0eV9zZXJ2ZXJcIik7XG5fdGQoXCJJZGVudGl0eSBzZXJ2ZXIgVVJMIGRvZXMgbm90IGFwcGVhciB0byBiZSBhIHZhbGlkIGlkZW50aXR5IHNlcnZlclwiKTtcbl90ZChcIkdlbmVyYWwgZmFpbHVyZVwiKTtcblxuaW50ZXJmYWNlIElQcm9wcyB7XG4gICAgc2VydmVyQ29uZmlnOiBWYWxpZGF0ZWRTZXJ2ZXJDb25maWc7XG4gICAgLy8gSWYgdHJ1ZSwgdGhlIGNvbXBvbmVudCB3aWxsIGNvbnNpZGVyIGl0c2VsZiBidXN5LlxuICAgIGJ1c3k/OiBib29sZWFuO1xuICAgIGlzU3luY2luZz86IGJvb2xlYW47XG4gICAgLy8gU2Vjb25kYXJ5IEhTIHdoaWNoIHdlIHRyeSB0byBsb2cgaW50byBpZiB0aGUgdXNlciBpcyB1c2luZ1xuICAgIC8vIHRoZSBkZWZhdWx0IEhTIGJ1dCBsb2dpbiBmYWlscy4gVXNlZnVsIGZvciBtaWdyYXRpbmcgdG8gYVxuICAgIC8vIGRpZmZlcmVudCBob21lc2VydmVyIHdpdGhvdXQgY29uZnVzaW5nIHVzZXJzLlxuICAgIGZhbGxiYWNrSHNVcmw/OiBzdHJpbmc7XG4gICAgZGVmYXVsdERldmljZURpc3BsYXlOYW1lPzogc3RyaW5nO1xuICAgIGZyYWdtZW50QWZ0ZXJMb2dpbj86IHN0cmluZztcbiAgICBkZWZhdWx0VXNlcm5hbWU/OiBzdHJpbmc7XG5cbiAgICAvLyBDYWxsZWQgd2hlbiB0aGUgdXNlciBoYXMgbG9nZ2VkIGluLiBQYXJhbXM6XG4gICAgLy8gLSBUaGUgb2JqZWN0IHJldHVybmVkIGJ5IHRoZSBsb2dpbiBBUElcbiAgICAvLyAtIFRoZSB1c2VyJ3MgcGFzc3dvcmQsIGlmIGFwcGxpY2FibGUsIChtYXkgYmUgY2FjaGVkIGluIG1lbW9yeSBmb3IgYVxuICAgIC8vICAgc2hvcnQgdGltZSBzbyB0aGUgdXNlciBpcyBub3QgcmVxdWlyZWQgdG8gcmUtZW50ZXIgdGhlaXIgcGFzc3dvcmRcbiAgICAvLyAgIGZvciBvcGVyYXRpb25zIGxpa2UgdXBsb2FkaW5nIGNyb3NzLXNpZ25pbmcga2V5cykuXG4gICAgb25Mb2dnZWRJbihkYXRhOiBJTWF0cml4Q2xpZW50Q3JlZHMsIHBhc3N3b3JkOiBzdHJpbmcpOiB2b2lkO1xuXG4gICAgLy8gbG9naW4gc2hvdWxkbid0IGtub3cgb3IgY2FyZSBob3cgcmVnaXN0cmF0aW9uLCBwYXNzd29yZCByZWNvdmVyeSwgZXRjIGlzIGRvbmUuXG4gICAgb25SZWdpc3RlckNsaWNrKCk6IHZvaWQ7XG4gICAgb25Gb3Jnb3RQYXNzd29yZENsaWNrPygpOiB2b2lkO1xuICAgIG9uU2VydmVyQ29uZmlnQ2hhbmdlKGNvbmZpZzogVmFsaWRhdGVkU2VydmVyQ29uZmlnKTogdm9pZDtcbn1cblxuaW50ZXJmYWNlIElTdGF0ZSB7XG4gICAgYnVzeTogYm9vbGVhbjtcbiAgICBidXN5TG9nZ2luZ0luPzogYm9vbGVhbjtcbiAgICBlcnJvclRleHQ/OiBSZWFjdE5vZGU7XG4gICAgbG9naW5JbmNvcnJlY3Q6IGJvb2xlYW47XG4gICAgLy8gY2FuIHdlIGF0dGVtcHQgdG8gbG9nIGluIG9yIGFyZSB0aGVyZSB2YWxpZGF0aW9uIGVycm9ycz9cbiAgICBjYW5UcnlMb2dpbjogYm9vbGVhbjtcblxuICAgIGZsb3dzPzogTG9naW5GbG93W107XG5cbiAgICAvLyB1c2VkIGZvciBwcmVzZXJ2aW5nIGZvcm0gdmFsdWVzIHdoZW4gY2hhbmdpbmcgaG9tZXNlcnZlclxuICAgIHVzZXJuYW1lOiBzdHJpbmc7XG4gICAgcGhvbmVDb3VudHJ5Pzogc3RyaW5nO1xuICAgIHBob25lTnVtYmVyOiBzdHJpbmc7XG5cbiAgICAvLyBXZSBwZXJmb3JtIGxpdmVsaW5lc3MgY2hlY2tzIGxhdGVyLCBidXQgZm9yIG5vdyBzdXBwcmVzcyB0aGUgZXJyb3JzLlxuICAgIC8vIFdlIGFsc28gdHJhY2sgdGhlIHNlcnZlciBkZWFkIGVycm9ycyBpbmRlcGVuZGVudGx5IG9mIHRoZSByZWd1bGFyIGVycm9ycyBzb1xuICAgIC8vIHRoYXQgd2UgY2FuIHJlbmRlciBpdCBkaWZmZXJlbnRseSwgYW5kIG92ZXJyaWRlIGFueSBvdGhlciBlcnJvciB0aGUgdXNlciBtYXlcbiAgICAvLyBiZSBzZWVpbmcuXG4gICAgc2VydmVySXNBbGl2ZTogYm9vbGVhbjtcbiAgICBzZXJ2ZXJFcnJvcklzRmF0YWw6IGJvb2xlYW47XG4gICAgc2VydmVyRGVhZEVycm9yPzogUmVhY3ROb2RlO1xufVxuXG4vKlxuICogQSB3aXJlIGNvbXBvbmVudCB3aGljaCBnbHVlcyB0b2dldGhlciBsb2dpbiBVSSBjb21wb25lbnRzIGFuZCBMb2dpbiBsb2dpY1xuICovXG5AcmVwbGFjZWFibGVDb21wb25lbnQoXCJzdHJ1Y3R1cmVzLmF1dGguTG9naW5Db21wb25lbnRcIilcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvZ2luQ29tcG9uZW50IGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxJUHJvcHMsIElTdGF0ZT4ge1xuICAgIHByaXZhdGUgdW5tb3VudGVkID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBsb2dpbkxvZ2ljOiBMb2dpbjtcblxuICAgIHByaXZhdGUgcmVhZG9ubHkgc3RlcFJlbmRlcmVyTWFwOiBSZWNvcmQ8c3RyaW5nLCAoKSA9PiBSZWFjdE5vZGU+O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBidXN5OiBmYWxzZSxcbiAgICAgICAgICAgIGJ1c3lMb2dnaW5nSW46IG51bGwsXG4gICAgICAgICAgICBlcnJvclRleHQ6IG51bGwsXG4gICAgICAgICAgICBsb2dpbkluY29ycmVjdDogZmFsc2UsXG4gICAgICAgICAgICBjYW5UcnlMb2dpbjogdHJ1ZSxcblxuICAgICAgICAgICAgZmxvd3M6IG51bGwsXG5cbiAgICAgICAgICAgIHVzZXJuYW1lOiBwcm9wcy5kZWZhdWx0VXNlcm5hbWU/IHByb3BzLmRlZmF1bHRVc2VybmFtZTogJycsXG4gICAgICAgICAgICBwaG9uZUNvdW50cnk6IG51bGwsXG4gICAgICAgICAgICBwaG9uZU51bWJlcjogXCJcIixcblxuICAgICAgICAgICAgc2VydmVySXNBbGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgIHNlcnZlckVycm9ySXNGYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBzZXJ2ZXJEZWFkRXJyb3I6IFwiXCIsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbWFwIGZyb20gbG9naW4gc3RlcCB0eXBlIHRvIGEgZnVuY3Rpb24gd2hpY2ggd2lsbCByZW5kZXIgYSBjb250cm9sXG4gICAgICAgIC8vIGxldHRpbmcgeW91IGRvIHRoYXQgbG9naW4gdHlwZVxuICAgICAgICB0aGlzLnN0ZXBSZW5kZXJlck1hcCA9IHtcbiAgICAgICAgICAgICdtLmxvZ2luLnBhc3N3b3JkJzogdGhpcy5yZW5kZXJQYXNzd29yZFN0ZXAsXG5cbiAgICAgICAgICAgIC8vIENBUyBhbmQgU1NPIGFyZSB0aGUgc2FtZSB0aGluZywgbW9kdWxvIHRoZSB1cmwgd2UgbGluayB0b1xuICAgICAgICAgICAgJ20ubG9naW4uY2FzJzogKCkgPT4gdGhpcy5yZW5kZXJTc29TdGVwKFwiY2FzXCIpLFxuICAgICAgICAgICAgJ20ubG9naW4uc3NvJzogKCkgPT4gdGhpcy5yZW5kZXJTc29TdGVwKFwic3NvXCIpLFxuICAgICAgICB9O1xuXG4gICAgICAgIENvdW50bHlBbmFseXRpY3MuaW5zdGFuY2UudHJhY2soXCJvbmJvYXJkaW5nX2xvZ2luX2JlZ2luXCIpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFtSRUFDVC1XQVJOSU5HXSBSZXBsYWNlIHdpdGggYXBwcm9wcmlhdGUgbGlmZWN5Y2xlIGV2ZW50XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgdGhpcy5pbml0TG9naW5Mb2dpYyh0aGlzLnByb3BzLnNlcnZlckNvbmZpZyk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMudW5tb3VudGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBbUkVBQ1QtV0FSTklOR10gUmVwbGFjZSB3aXRoIGFwcHJvcHJpYXRlIGxpZmVjeWNsZSBldmVudFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzKSB7XG4gICAgICAgIGlmIChuZXdQcm9wcy5zZXJ2ZXJDb25maWcuaHNVcmwgPT09IHRoaXMucHJvcHMuc2VydmVyQ29uZmlnLmhzVXJsICYmXG4gICAgICAgICAgICBuZXdQcm9wcy5zZXJ2ZXJDb25maWcuaXNVcmwgPT09IHRoaXMucHJvcHMuc2VydmVyQ29uZmlnLmlzVXJsKSByZXR1cm47XG5cbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgd2UgZW5kIHVwIGFjdHVhbGx5IGxvZ2dpbmcgaW4gdG8gdGhlIHJpZ2h0IHBsYWNlXG4gICAgICAgIHRoaXMuaW5pdExvZ2luTG9naWMobmV3UHJvcHMuc2VydmVyQ29uZmlnKTtcbiAgICB9XG5cbiAgICBpc0J1c3kgPSAoKSA9PiB0aGlzLnN0YXRlLmJ1c3kgfHwgdGhpcy5wcm9wcy5idXN5O1xuXG4gICAgb25QYXNzd29yZExvZ2luID0gYXN5bmMgKHVzZXJuYW1lLCBwaG9uZUNvdW50cnksIHBob25lTnVtYmVyLCBwYXNzd29yZCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuc3RhdGUuc2VydmVySXNBbGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGJ1c3k6IHRydWUgfSk7XG4gICAgICAgICAgICAvLyBEbyBhIHF1aWNrIGxpdmVsaW5lc3MgY2hlY2sgb24gdGhlIFVSTHNcbiAgICAgICAgICAgIGxldCBhbGl2ZUFnYWluID0gdHJ1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgQXV0b0Rpc2NvdmVyeVV0aWxzLnZhbGlkYXRlU2VydmVyQ29uZmlnV2l0aFN0YXRpY1VybHMoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuc2VydmVyQ29uZmlnLmhzVXJsLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnNlcnZlckNvbmZpZy5pc1VybCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBzZXJ2ZXJJc0FsaXZlOiB0cnVlLCBlcnJvclRleHQ6IFwiXCIgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcG9uZW50U3RhdGUgPSBBdXRvRGlzY292ZXJ5VXRpbHMuYXV0aENvbXBvbmVudFN0YXRlRm9yRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGJ1c3k6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBidXN5TG9nZ2luZ0luOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgLi4uY29tcG9uZW50U3RhdGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYWxpdmVBZ2FpbiA9ICFjb21wb25lbnRTdGF0ZS5zZXJ2ZXJFcnJvcklzRmF0YWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgcGVvcGxlIGZyb20gc3VibWl0dGluZyB0aGVpciBwYXNzd29yZCB3aGVuIHNvbWV0aGluZyBpc24ndCByaWdodC5cbiAgICAgICAgICAgIGlmICghYWxpdmVBZ2Fpbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgYnVzeTogdHJ1ZSxcbiAgICAgICAgICAgIGJ1c3lMb2dnaW5nSW46IHRydWUsXG4gICAgICAgICAgICBlcnJvclRleHQ6IG51bGwsXG4gICAgICAgICAgICBsb2dpbkluY29ycmVjdDogZmFsc2UsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubG9naW5Mb2dpYy5sb2dpblZpYVBhc3N3b3JkKFxuICAgICAgICAgICAgdXNlcm5hbWUsIHBob25lQ291bnRyeSwgcGhvbmVOdW1iZXIsIHBhc3N3b3JkLFxuICAgICAgICApLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBzZXJ2ZXJJc0FsaXZlOiB0cnVlIH0pOyAvLyBpdCBtdXN0IGJlLCB3ZSBsb2dnZWQgaW4uXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uTG9nZ2VkSW4oZGF0YSwgcGFzc3dvcmQpO1xuICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnVubW91bnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlcnJvclRleHQ7XG5cbiAgICAgICAgICAgIC8vIFNvbWUgZXJyb3Igc3RyaW5ncyBvbmx5IGFwcGx5IGZvciBsb2dnaW5nIGluXG4gICAgICAgICAgICBjb25zdCB1c2luZ0VtYWlsID0gdXNlcm5hbWUuaW5kZXhPZihcIkBcIikgPiAwO1xuICAgICAgICAgICAgaWYgKGVycm9yLmh0dHBTdGF0dXMgPT09IDQwMCAmJiB1c2luZ0VtYWlsKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JUZXh0ID0gX3QoJ1RoaXMgaG9tZXNlcnZlciBkb2VzIG5vdCBzdXBwb3J0IGxvZ2luIHVzaW5nIGVtYWlsIGFkZHJlc3MuJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yLmVycmNvZGUgPT09ICdNX1JFU09VUkNFX0xJTUlUX0VYQ0VFREVEJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yVG9wID0gbWVzc2FnZUZvclJlc291cmNlTGltaXRFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuZGF0YS5saW1pdF90eXBlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvci5kYXRhLmFkbWluX2NvbnRhY3QsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtb250aGx5X2FjdGl2ZV91c2VyJzogX3RkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVGhpcyBob21lc2VydmVyIGhhcyBoaXQgaXRzIE1vbnRobHkgQWN0aXZlIFVzZXIgbGltaXQuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2hzX2Jsb2NrZWQnOiBfdGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJUaGlzIGhvbWVzZXJ2ZXIgaGFzIGJlZW4gYmxvY2tlZCBieSBpdCdzIGFkbWluaXN0cmF0b3IuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgJyc6IF90ZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlRoaXMgaG9tZXNlcnZlciBoYXMgZXhjZWVkZWQgb25lIG9mIGl0cyByZXNvdXJjZSBsaW1pdHMuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JEZXRhaWwgPSBtZXNzYWdlRm9yUmVzb3VyY2VMaW1pdEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBlcnJvci5kYXRhLmxpbWl0X3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmRhdGEuYWRtaW5fY29udGFjdCxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgJyc6IF90ZChcIlBsZWFzZSA8YT5jb250YWN0IHlvdXIgc2VydmljZSBhZG1pbmlzdHJhdG9yPC9hPiB0byBjb250aW51ZSB1c2luZyB0aGlzIHNlcnZpY2UuXCIpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZXJyb3JUZXh0ID0gKFxuICAgICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj57IGVycm9yVG9wIH08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXhfTG9naW5fc21hbGxFcnJvclwiPnsgZXJyb3JEZXRhaWwgfTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvci5odHRwU3RhdHVzID09PSA0MDEgfHwgZXJyb3IuaHR0cFN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmVycmNvZGUgPT09ICdNX1VTRVJfREVBQ1RJVkFURUQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yVGV4dCA9IF90KCdUaGlzIGFjY291bnQgaGFzIGJlZW4gZGVhY3RpdmF0ZWQuJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChTZGtDb25maWcuZ2V0KClbJ2Rpc2FibGVfY3VzdG9tX3VybHMnXSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvclRleHQgPSAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+eyBfdCgnSW5jb3JyZWN0IHVzZXJuYW1lIGFuZC9vciBwYXNzd29yZC4nKSB9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJteF9Mb2dpbl9zbWFsbEVycm9yXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgX3QoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnUGxlYXNlIG5vdGUgeW91IGFyZSBsb2dnaW5nIGludG8gdGhlICUoaHMpcyBzZXJ2ZXIsIG5vdCBtYXRyaXgub3JnLicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGhzOiB0aGlzLnByb3BzLnNlcnZlckNvbmZpZy5oc05hbWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnJvclRleHQgPSBfdCgnSW5jb3JyZWN0IHVzZXJuYW1lIGFuZC9vciBwYXNzd29yZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG90aGVyIGVycm9ycywgbm90IHNwZWNpZmljIHRvIGRvaW5nIGEgcGFzc3dvcmQgbG9naW5cbiAgICAgICAgICAgICAgICBlcnJvclRleHQgPSB0aGlzLmVycm9yVGV4dEZyb21FcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGJ1c3k6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGJ1c3lMb2dnaW5nSW46IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yVGV4dDogZXJyb3JUZXh0LFxuICAgICAgICAgICAgICAgIC8vIDQwMSB3b3VsZCBiZSB0aGUgc2Vuc2libGUgc3RhdHVzIGNvZGUgZm9yICdpbmNvcnJlY3QgcGFzc3dvcmQnXG4gICAgICAgICAgICAgICAgLy8gYnV0IHRoZSBsb2dpbiBBUEkgZ2l2ZXMgYSA0MDMgaHR0cHM6Ly9tYXRyaXgub3JnL2ppcmEvYnJvd3NlL1NZTi03NDRcbiAgICAgICAgICAgICAgICAvLyBtZW50aW9ucyB0aGlzIChhbHRob3VnaCB0aGUgYnVnIGlzIGZvciBVSSBhdXRoIHdoaWNoIGlzIG5vdCB0aGlzKVxuICAgICAgICAgICAgICAgIC8vIFdlIHRyZWF0IGJvdGggYXMgYW4gaW5jb3JyZWN0IHBhc3N3b3JkXG4gICAgICAgICAgICAgICAgbG9naW5JbmNvcnJlY3Q6IGVycm9yLmh0dHBTdGF0dXMgPT09IDQwMSB8fCBlcnJvci5odHRwU3RhdHVzID09PSA0MDMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIG9uVXNlcm5hbWVDaGFuZ2VkID0gdXNlcm5hbWUgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgdXNlcm5hbWU6IHVzZXJuYW1lIH0pO1xuICAgIH07XG5cbiAgICBvblVzZXJuYW1lQmx1ciA9IGFzeW5jIHVzZXJuYW1lID0+IHtcbiAgICAgICAgY29uc3QgZG9XZWxsa25vd25Mb29rdXAgPSB1c2VybmFtZVswXSA9PT0gXCJAXCI7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgdXNlcm5hbWU6IHVzZXJuYW1lLFxuICAgICAgICAgICAgYnVzeTogZG9XZWxsa25vd25Mb29rdXAsXG4gICAgICAgICAgICBlcnJvclRleHQ6IG51bGwsXG4gICAgICAgICAgICBjYW5UcnlMb2dpbjogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkb1dlbGxrbm93bkxvb2t1cCkge1xuICAgICAgICAgICAgY29uc3Qgc2VydmVyTmFtZSA9IHVzZXJuYW1lLnNwbGl0KCc6Jykuc2xpY2UoMSkuam9pbignOicpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBBdXRvRGlzY292ZXJ5VXRpbHMudmFsaWRhdGVTZXJ2ZXJOYW1lKHNlcnZlck5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25TZXJ2ZXJDb25maWdDaGFuZ2UocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAvLyBXZSdkIGxpa2UgdG8gcmVseSBvbiBuZXcgcHJvcHMgY29taW5nIGluIHZpYSBgb25TZXJ2ZXJDb25maWdDaGFuZ2VgXG4gICAgICAgICAgICAgICAgLy8gc28gdGhhdCB3ZSBrbm93IHRoZSBzZXJ2ZXJzIGhhdmUgZGVmaW5pdGVseSB1cGRhdGVkIGJlZm9yZSBjbGVhcmluZ1xuICAgICAgICAgICAgICAgIC8vIHRoZSBidXN5IHN0YXRlLiBJbiB0aGUgY2FzZSBvZiBhIGZ1bGwgTVhJRCB0aGF0IHJlc29sdmVzIHRvIHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgLy8gSFMgYXMgRWxlbWVudCdzIGRlZmF1bHQgSFMgdGhvdWdoLCB0aGVyZSBtYXkgbm90IGJlIGFueSBzZXJ2ZXIgY2hhbmdlLlxuICAgICAgICAgICAgICAgIC8vIFRvIGF2b2lkIHRoaXMgdHJhcCwgd2UgY2xlYXIgYnVzeSBoZXJlLiBGb3IgY2FzZXMgd2hlcmUgdGhlIHNlcnZlclxuICAgICAgICAgICAgICAgIC8vIGFjdHVhbGx5IGhhcyBjaGFuZ2VkLCBgaW5pdExvZ2luTG9naWNgIHdpbGwgYmUgY2FsbGVkIGFuZCBtYW5hZ2VzXG4gICAgICAgICAgICAgICAgLy8gYnVzeSBzdGF0ZSBmb3IgaXRzIG93biBsaXZlbmVzcyBjaGVjay5cbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgYnVzeTogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiUHJvYmxlbSBwYXJzaW5nIFVSTCBvciB1bmhhbmRsZWQgZXJyb3IgZG9pbmcgLndlbGwta25vd24gZGlzY292ZXJ5OlwiLCBlKTtcblxuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gX3QoXCJGYWlsZWQgdG8gcGVyZm9ybSBob21lc2VydmVyIGRpc2NvdmVyeVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoZS50cmFuc2xhdGVkTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gZS50cmFuc2xhdGVkTWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgZXJyb3JUZXh0OiBSZWFjdE5vZGUgPSBtZXNzYWdlO1xuICAgICAgICAgICAgICAgIGxldCBkaXNjb3ZlcnlTdGF0ZSA9IHt9O1xuICAgICAgICAgICAgICAgIGlmIChBdXRvRGlzY292ZXJ5VXRpbHMuaXNMaXZlbGluZXNzRXJyb3IoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JUZXh0ID0gdGhpcy5zdGF0ZS5lcnJvclRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGRpc2NvdmVyeVN0YXRlID0gQXV0b0Rpc2NvdmVyeVV0aWxzLmF1dGhDb21wb25lbnRTdGF0ZUZvckVycm9yKGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBidXN5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JUZXh0LFxuICAgICAgICAgICAgICAgICAgICAuLi5kaXNjb3ZlcnlTdGF0ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBvblBob25lQ291bnRyeUNoYW5nZWQgPSBwaG9uZUNvdW50cnkgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgcGhvbmVDb3VudHJ5OiBwaG9uZUNvdW50cnkgfSk7XG4gICAgfTtcblxuICAgIG9uUGhvbmVOdW1iZXJDaGFuZ2VkID0gcGhvbmVOdW1iZXIgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHBob25lTnVtYmVyOiBwaG9uZU51bWJlcixcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIG9uUmVnaXN0ZXJDbGljayA9IGV2ID0+IHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHRoaXMucHJvcHMub25SZWdpc3RlckNsaWNrKCk7XG4gICAgfTtcblxuICAgIG9uVHJ5UmVnaXN0ZXJDbGljayA9IGV2ID0+IHtcbiAgICAgICAgY29uc3QgaGFzUGFzc3dvcmRGbG93ID0gdGhpcy5zdGF0ZS5mbG93cz8uZmluZChmbG93ID0+IGZsb3cudHlwZSA9PT0gXCJtLmxvZ2luLnBhc3N3b3JkXCIpO1xuICAgICAgICBjb25zdCBzc29GbG93ID0gdGhpcy5zdGF0ZS5mbG93cz8uZmluZChmbG93ID0+IGZsb3cudHlwZSA9PT0gXCJtLmxvZ2luLnNzb1wiIHx8IGZsb3cudHlwZSA9PT0gXCJtLmxvZ2luLmNhc1wiKTtcbiAgICAgICAgLy8gSWYgaGFzIG5vIHBhc3N3b3JkIGZsb3cgYnV0IGFuIFNTTyBmbG93IGd1ZXNzIHRoYXQgdGhlIHVzZXIgd2FudHMgdG8gcmVnaXN0ZXIgd2l0aCBTU08uXG4gICAgICAgIC8vIFRPRE86IGluc3RlYWQgaGlkZSB0aGUgUmVnaXN0ZXIgYnV0dG9uIGlmIHJlZ2lzdHJhdGlvbiBpcyBkaXNhYmxlZCBieSBjaGVja2luZyB3aXRoIHRoZSBzZXJ2ZXIsXG4gICAgICAgIC8vIGhhcyBubyBzcGVjaWZpYyBlcnJDb2RlIGN1cnJlbnRseSBhbmQgdXNlcyBNX0ZPUkJJRERFTi5cbiAgICAgICAgaWYgKHNzb0Zsb3cgJiYgIWhhc1Bhc3N3b3JkRmxvdykge1xuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgY29uc3Qgc3NvS2luZCA9IHNzb0Zsb3cudHlwZSA9PT0gJ20ubG9naW4uc3NvJyA/ICdzc28nIDogJ2Nhcyc7XG4gICAgICAgICAgICBQbGF0Zm9ybVBlZy5nZXQoKS5zdGFydFNpbmdsZVNpZ25Pbih0aGlzLmxvZ2luTG9naWMuY3JlYXRlVGVtcG9yYXJ5Q2xpZW50KCksIHNzb0tpbmQsXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5mcmFnbWVudEFmdGVyTG9naW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRG9uJ3QgaW50ZXJjZXB0IC0ganVzdCBnbyB0aHJvdWdoIHRvIHRoZSByZWdpc3RlciBwYWdlXG4gICAgICAgICAgICB0aGlzLm9uUmVnaXN0ZXJDbGljayhldik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBhc3luYyBpbml0TG9naW5Mb2dpYyh7IGhzVXJsLCBpc1VybCB9OiBWYWxpZGF0ZWRTZXJ2ZXJDb25maWcpIHtcbiAgICAgICAgbGV0IGlzRGVmYXVsdFNlcnZlciA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5zZXJ2ZXJDb25maWcuaXNEZWZhdWx0XG4gICAgICAgICAgICAmJiBoc1VybCA9PT0gdGhpcy5wcm9wcy5zZXJ2ZXJDb25maWcuaHNVcmxcbiAgICAgICAgICAgICYmIGlzVXJsID09PSB0aGlzLnByb3BzLnNlcnZlckNvbmZpZy5pc1VybCkge1xuICAgICAgICAgICAgaXNEZWZhdWx0U2VydmVyID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZhbGxiYWNrSHNVcmwgPSBpc0RlZmF1bHRTZXJ2ZXIgPyB0aGlzLnByb3BzLmZhbGxiYWNrSHNVcmwgOiBudWxsO1xuXG4gICAgICAgIGNvbnN0IGxvZ2luTG9naWMgPSBuZXcgTG9naW4oaHNVcmwsIGlzVXJsLCBmYWxsYmFja0hzVXJsLCB7XG4gICAgICAgICAgICBkZWZhdWx0RGV2aWNlRGlzcGxheU5hbWU6IHRoaXMucHJvcHMuZGVmYXVsdERldmljZURpc3BsYXlOYW1lLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sb2dpbkxvZ2ljID0gbG9naW5Mb2dpYztcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGJ1c3k6IHRydWUsXG4gICAgICAgICAgICBsb2dpbkluY29ycmVjdDogZmFsc2UsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIERvIGEgcXVpY2sgbGl2ZWxpbmVzcyBjaGVjayBvbiB0aGUgVVJMc1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyB3YXJuaW5nIH0gPVxuICAgICAgICAgICAgICAgIGF3YWl0IEF1dG9EaXNjb3ZlcnlVdGlscy52YWxpZGF0ZVNlcnZlckNvbmZpZ1dpdGhTdGF0aWNVcmxzKGhzVXJsLCBpc1VybCk7XG4gICAgICAgICAgICBpZiAod2FybmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAuLi5BdXRvRGlzY292ZXJ5VXRpbHMuYXV0aENvbXBvbmVudFN0YXRlRm9yRXJyb3Iod2FybmluZyksXG4gICAgICAgICAgICAgICAgICAgIGVycm9yVGV4dDogXCJcIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlcklzQWxpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yVGV4dDogXCJcIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgYnVzeTogZmFsc2UsXG4gICAgICAgICAgICAgICAgLi4uQXV0b0Rpc2NvdmVyeVV0aWxzLmF1dGhDb21wb25lbnRTdGF0ZUZvckVycm9yKGUpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBsb2dpbkxvZ2ljLmdldEZsb3dzKCkudGhlbigoZmxvd3MpID0+IHtcbiAgICAgICAgICAgIC8vIGxvb2sgZm9yIGEgZmxvdyB3aGVyZSB3ZSB1bmRlcnN0YW5kIGFsbCBvZiB0aGUgc3RlcHMuXG4gICAgICAgICAgICBjb25zdCBzdXBwb3J0ZWRGbG93cyA9IGZsb3dzLmZpbHRlcih0aGlzLmlzU3VwcG9ydGVkRmxvdyk7XG5cbiAgICAgICAgICAgIGlmIChzdXBwb3J0ZWRGbG93cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGZsb3dzOiBzdXBwb3J0ZWRGbG93cyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHdlIGdvdCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0IHdpdGhvdXQgZmluZGluZyBhIHN1aXRhYmxlIGZsb3cuXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBlcnJvclRleHQ6IF90KFwiVGhpcyBob21lc2VydmVyIGRvZXNuJ3Qgb2ZmZXIgYW55IGxvZ2luIGZsb3dzIHdoaWNoIGFyZSBzdXBwb3J0ZWQgYnkgdGhpcyBjbGllbnQuXCIpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIChlcnIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGVycm9yVGV4dDogdGhpcy5lcnJvclRleHRGcm9tRXJyb3IoZXJyKSxcbiAgICAgICAgICAgICAgICBsb2dpbkluY29ycmVjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2FuVHJ5TG9naW46IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgYnVzeTogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc1N1cHBvcnRlZEZsb3cgPSAoZmxvdzogTG9naW5GbG93KTogYm9vbGVhbiA9PiB7XG4gICAgICAgIC8vIHRlY2huaWNhbGx5IHRoZSBmbG93IGNhbiBoYXZlIG11bHRpcGxlIHN0ZXBzLCBidXQgbm8gb25lIGRvZXMgdGhpc1xuICAgICAgICAvLyBmb3IgbG9naW4gYW5kIGxvZ2luTG9naWMgZG9lc24ndCBzdXBwb3J0IGl0IHNvIHdlIGNhbiBpZ25vcmUgaXQuXG4gICAgICAgIGlmICghdGhpcy5zdGVwUmVuZGVyZXJNYXBbZmxvdy50eXBlXSkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIlNraXBwaW5nIGZsb3dcIiwgZmxvdywgXCJkdWUgdG8gdW5zdXBwb3J0ZWQgbG9naW4gdHlwZVwiLCBmbG93LnR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBwcml2YXRlIGVycm9yVGV4dEZyb21FcnJvcihlcnI6IE1hdHJpeEVycm9yKTogUmVhY3ROb2RlIHtcbiAgICAgICAgbGV0IGVyckNvZGUgPSBlcnIuZXJyY29kZTtcbiAgICAgICAgaWYgKCFlcnJDb2RlICYmIGVyci5odHRwU3RhdHVzKSB7XG4gICAgICAgICAgICBlcnJDb2RlID0gXCJIVFRQIFwiICsgZXJyLmh0dHBTdGF0dXM7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZXJyb3JUZXh0OiBSZWFjdE5vZGUgPSBfdChcIlRoZXJlIHdhcyBhIHByb2JsZW0gY29tbXVuaWNhdGluZyB3aXRoIHRoZSBob21lc2VydmVyLCBcIiArXG4gICAgICAgICAgICBcInBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuXCIpICsgKGVyckNvZGUgPyBcIiAoXCIgKyBlcnJDb2RlICsgXCIpXCIgOiBcIlwiKTtcblxuICAgICAgICBpZiAoZXJyLmNvcnMgPT09ICdyZWplY3RlZCcpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonICYmXG4gICAgICAgICAgICAgICAgKHRoaXMucHJvcHMuc2VydmVyQ29uZmlnLmhzVXJsLnN0YXJ0c1dpdGgoXCJodHRwOlwiKSB8fFxuICAgICAgICAgICAgICAgICAhdGhpcy5wcm9wcy5zZXJ2ZXJDb25maWcuaHNVcmwuc3RhcnRzV2l0aChcImh0dHBcIikpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBlcnJvclRleHQgPSA8c3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgeyBfdChcIkNhbid0IGNvbm5lY3QgdG8gaG9tZXNlcnZlciB2aWEgSFRUUCB3aGVuIGFuIEhUVFBTIFVSTCBpcyBpbiB5b3VyIGJyb3dzZXIgYmFyLiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkVpdGhlciB1c2UgSFRUUFMgb3IgPGE+ZW5hYmxlIHVuc2FmZSBzY3JpcHRzPC9hPi5cIiwge30sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhJzogKHN1YikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWw9XCJub3JlZmVycmVyIG5vb3BlbmVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZj1cImh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vc2VhcmNoPyZxPWVuYWJsZSUyMHVuc2FmZSUyMHNjcmlwdHNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBzdWIgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYT47XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KSB9XG4gICAgICAgICAgICAgICAgPC9zcGFuPjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3JUZXh0ID0gPHNwYW4+XG4gICAgICAgICAgICAgICAgICAgIHsgX3QoXCJDYW4ndCBjb25uZWN0IHRvIGhvbWVzZXJ2ZXIgLSBwbGVhc2UgY2hlY2sgeW91ciBjb25uZWN0aXZpdHksIGVuc3VyZSB5b3VyIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiPGE+aG9tZXNlcnZlcidzIFNTTCBjZXJ0aWZpY2F0ZTwvYT4gaXMgdHJ1c3RlZCwgYW5kIHRoYXQgYSBicm93c2VyIGV4dGVuc2lvbiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcImlzIG5vdCBibG9ja2luZyByZXF1ZXN0cy5cIiwge30sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhJzogKHN1YikgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub3JlZmVycmVyIG5vb3BlbmVyXCIgaHJlZj17dGhpcy5wcm9wcy5zZXJ2ZXJDb25maWcuaHNVcmx9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHN1YiB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hPixcbiAgICAgICAgICAgICAgICAgICAgfSkgfVxuICAgICAgICAgICAgICAgIDwvc3Bhbj47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXJyb3JUZXh0O1xuICAgIH1cblxuICAgIHJlbmRlckxvZ2luQ29tcG9uZW50Rm9yRmxvd3MoKSB7XG4gICAgICAgIGlmICghdGhpcy5zdGF0ZS5mbG93cykgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgaWRlYWwgb3JkZXIgd2Ugd2FudCB0byBzaG93IHRoZSBmbG93cyBpblxuICAgICAgICBjb25zdCBvcmRlciA9IFtcbiAgICAgICAgICAgIFwibS5sb2dpbi5wYXNzd29yZFwiLFxuICAgICAgICAgICAgXCJtLmxvZ2luLnNzb1wiLFxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IGZsb3dzID0gb3JkZXIubWFwKHR5cGUgPT4gdGhpcy5zdGF0ZS5mbG93cy5maW5kKGZsb3cgPT4gZmxvdy50eXBlID09PSB0eXBlKSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgICByZXR1cm4gPFJlYWN0LkZyYWdtZW50PlxuICAgICAgICAgICAgeyBmbG93cy5tYXAoZmxvdyA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcFJlbmRlcmVyID0gdGhpcy5zdGVwUmVuZGVyZXJNYXBbZmxvdy50eXBlXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gPFJlYWN0LkZyYWdtZW50IGtleT17Zmxvdy50eXBlfT57IHN0ZXBSZW5kZXJlcigpIH08L1JlYWN0LkZyYWdtZW50PjtcbiAgICAgICAgICAgIH0pIH1cbiAgICAgICAgPC9SZWFjdC5GcmFnbWVudD47XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZW5kZXJQYXNzd29yZFN0ZXAgPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8UGFzc3dvcmRMb2dpblxuICAgICAgICAgICAgICAgIG9uU3VibWl0PXt0aGlzLm9uUGFzc3dvcmRMb2dpbn1cbiAgICAgICAgICAgICAgICB1c2VybmFtZT17dGhpcy5zdGF0ZS51c2VybmFtZX1cbiAgICAgICAgICAgICAgICBwaG9uZUNvdW50cnk9e3RoaXMuc3RhdGUucGhvbmVDb3VudHJ5fVxuICAgICAgICAgICAgICAgIHBob25lTnVtYmVyPXt0aGlzLnN0YXRlLnBob25lTnVtYmVyfVxuICAgICAgICAgICAgICAgIG9uVXNlcm5hbWVDaGFuZ2VkPXt0aGlzLm9uVXNlcm5hbWVDaGFuZ2VkfVxuICAgICAgICAgICAgICAgIG9uVXNlcm5hbWVCbHVyPXt0aGlzLm9uVXNlcm5hbWVCbHVyfVxuICAgICAgICAgICAgICAgIG9uUGhvbmVDb3VudHJ5Q2hhbmdlZD17dGhpcy5vblBob25lQ291bnRyeUNoYW5nZWR9XG4gICAgICAgICAgICAgICAgb25QaG9uZU51bWJlckNoYW5nZWQ9e3RoaXMub25QaG9uZU51bWJlckNoYW5nZWR9XG4gICAgICAgICAgICAgICAgb25Gb3Jnb3RQYXNzd29yZENsaWNrPXt0aGlzLnByb3BzLm9uRm9yZ290UGFzc3dvcmRDbGlja31cbiAgICAgICAgICAgICAgICBsb2dpbkluY29ycmVjdD17dGhpcy5zdGF0ZS5sb2dpbkluY29ycmVjdH1cbiAgICAgICAgICAgICAgICBzZXJ2ZXJDb25maWc9e3RoaXMucHJvcHMuc2VydmVyQ29uZmlnfVxuICAgICAgICAgICAgICAgIGRpc2FibGVTdWJtaXQ9e3RoaXMuaXNCdXN5KCl9XG4gICAgICAgICAgICAgICAgYnVzeT17dGhpcy5wcm9wcy5pc1N5bmNpbmcgfHwgdGhpcy5zdGF0ZS5idXN5TG9nZ2luZ0lufVxuICAgICAgICAgICAgLz5cbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSByZW5kZXJTc29TdGVwID0gbG9naW5UeXBlID0+IHtcbiAgICAgICAgY29uc3QgZmxvdyA9IHRoaXMuc3RhdGUuZmxvd3MuZmluZChmbG93ID0+IGZsb3cudHlwZSA9PT0gXCJtLmxvZ2luLlwiICsgbG9naW5UeXBlKSBhcyBJU1NPRmxvdztcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPFNTT0J1dHRvbnNcbiAgICAgICAgICAgICAgICBtYXRyaXhDbGllbnQ9e3RoaXMubG9naW5Mb2dpYy5jcmVhdGVUZW1wb3JhcnlDbGllbnQoKX1cbiAgICAgICAgICAgICAgICBmbG93PXtmbG93fVxuICAgICAgICAgICAgICAgIGxvZ2luVHlwZT17bG9naW5UeXBlfVxuICAgICAgICAgICAgICAgIGZyYWdtZW50QWZ0ZXJMb2dpbj17dGhpcy5wcm9wcy5mcmFnbWVudEFmdGVyTG9naW59XG4gICAgICAgICAgICAgICAgcHJpbWFyeT17IXRoaXMuc3RhdGUuZmxvd3MuZmluZChmbG93ID0+IGZsb3cudHlwZSA9PT0gXCJtLmxvZ2luLnBhc3N3b3JkXCIpfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmlzQnVzeSgpICYmICF0aGlzLnN0YXRlLmJ1c3lMb2dnaW5nSW4gP1xuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJteF9Mb2dpbl9sb2FkZXJcIj48U3Bpbm5lciAvPjwvZGl2PiA6IG51bGw7XG5cbiAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gdGhpcy5zdGF0ZS5lcnJvclRleHQ7XG5cbiAgICAgICAgbGV0IGVycm9yVGV4dFNlY3Rpb247XG4gICAgICAgIGlmIChlcnJvclRleHQpIHtcbiAgICAgICAgICAgIGVycm9yVGV4dFNlY3Rpb24gPSAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJteF9Mb2dpbl9lcnJvclwiPlxuICAgICAgICAgICAgICAgICAgICB7IGVycm9yVGV4dCB9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHNlcnZlckRlYWRTZWN0aW9uO1xuICAgICAgICBpZiAoIXRoaXMuc3RhdGUuc2VydmVySXNBbGl2ZSkge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NlcyA9IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgICAgIFwibXhfTG9naW5fZXJyb3JcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm14X0xvZ2luX3NlcnZlckVycm9yXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJteF9Mb2dpbl9zZXJ2ZXJFcnJvck5vbkZhdGFsXCI6ICF0aGlzLnN0YXRlLnNlcnZlckVycm9ySXNGYXRhbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VydmVyRGVhZFNlY3Rpb24gPSAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzZXN9PlxuICAgICAgICAgICAgICAgICAgICB7IHRoaXMuc3RhdGUuc2VydmVyRGVhZEVycm9yIH1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZm9vdGVyO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5pc1N5bmNpbmcgfHwgdGhpcy5zdGF0ZS5idXN5TG9nZ2luZ0luKSB7XG4gICAgICAgICAgICBmb290ZXIgPSA8ZGl2IGNsYXNzTmFtZT1cIm14X0F1dGhCb2R5X3BhZGRlZEZvb3RlclwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXhfQXV0aEJvZHlfcGFkZGVkRm9vdGVyX3RpdGxlXCI+XG4gICAgICAgICAgICAgICAgICAgIDxJbmxpbmVTcGlubmVyIHc9ezIwfSBoPXsyMH0gLz5cbiAgICAgICAgICAgICAgICAgICAgeyB0aGlzLnByb3BzLmlzU3luY2luZyA/IF90KFwiU3luY2luZy4uLlwiKSA6IF90KFwiU2lnbmluZyBJbi4uLlwiKSB9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgeyB0aGlzLnByb3BzLmlzU3luY2luZyAmJiA8ZGl2IGNsYXNzTmFtZT1cIm14X0F1dGhCb2R5X3BhZGRlZEZvb3Rlcl9zdWJ0aXRsZVwiPlxuICAgICAgICAgICAgICAgICAgICB7IF90KFwiSWYgeW91J3ZlIGpvaW5lZCBsb3RzIG9mIHJvb21zLCB0aGlzIG1pZ2h0IHRha2UgYSB3aGlsZVwiKSB9XG4gICAgICAgICAgICAgICAgPC9kaXY+IH1cbiAgICAgICAgICAgIDwvZGl2PjtcbiAgICAgICAgfSBlbHNlIGlmIChTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFVJRmVhdHVyZS5SZWdpc3RyYXRpb24pKSB7XG4gICAgICAgICAgICBmb290ZXIgPSAoXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwibXhfQXV0aEJvZHlfY2hhbmdlRmxvd1wiPlxuICAgICAgICAgICAgICAgICAgICB7IF90KFwiTmV3PyA8YT5DcmVhdGUgYWNjb3VudDwvYT5cIiwge30sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGE6IHN1YiA9PiA8YSBvbkNsaWNrPXt0aGlzLm9uVHJ5UmVnaXN0ZXJDbGlja30gaHJlZj1cIiNcIj57IHN1YiB9PC9hPixcbiAgICAgICAgICAgICAgICAgICAgfSkgfVxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPEF1dGhQYWdlPlxuICAgICAgICAgICAgICAgIDxBdXRoSGVhZGVyIGRpc2FibGVMYW5ndWFnZVNlbGVjdG9yPXt0aGlzLnByb3BzLmlzU3luY2luZyB8fCB0aGlzLnN0YXRlLmJ1c3lMb2dnaW5nSW59IC8+XG4gICAgICAgICAgICAgICAgPEF1dGhCb2R5PlxuICAgICAgICAgICAgICAgICAgICA8aDI+XG4gICAgICAgICAgICAgICAgICAgICAgICB7IF90KCdTaWduIGluJykgfVxuICAgICAgICAgICAgICAgICAgICAgICAgeyBsb2FkZXIgfVxuICAgICAgICAgICAgICAgICAgICA8L2gyPlxuICAgICAgICAgICAgICAgICAgICB7IGVycm9yVGV4dFNlY3Rpb24gfVxuICAgICAgICAgICAgICAgICAgICB7IHNlcnZlckRlYWRTZWN0aW9uIH1cbiAgICAgICAgICAgICAgICAgICAgPFNlcnZlclBpY2tlclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyQ29uZmlnPXt0aGlzLnByb3BzLnNlcnZlckNvbmZpZ31cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2VydmVyQ29uZmlnQ2hhbmdlPXt0aGlzLnByb3BzLm9uU2VydmVyQ29uZmlnQ2hhbmdlfVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICB7IHRoaXMucmVuZGVyTG9naW5Db21wb25lbnRGb3JGbG93cygpIH1cbiAgICAgICAgICAgICAgICAgICAgeyBmb290ZXIgfVxuICAgICAgICAgICAgICAgIDwvQXV0aEJvZHk+XG4gICAgICAgICAgICA8L0F1dGhQYWdlPlxuICAgICAgICApO1xuICAgIH1cbn1cbiJdfQ==