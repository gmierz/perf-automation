"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.shouldFormContinuation = shouldFormContinuation;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _event = require("matrix-js-sdk/src/@types/event");

var _shouldHideEvent = _interopRequireDefault(require("../../shouldHideEvent"));

var _DateUtils = require("../../DateUtils");

var _MatrixClientPeg = require("../../MatrixClientPeg");

var _SettingsStore = _interopRequireDefault(require("../../settings/SettingsStore"));

var _RoomContext = _interopRequireWildcard(require("../../contexts/RoomContext"));

var _Layout = require("../../settings/enums/Layout");

var _languageHandler = require("../../languageHandler");

var _EventTile = _interopRequireWildcard(require("../views/rooms/EventTile"));

var _TextForEvent = require("../../TextForEvent");

var _IRCTimelineProfileResizer = _interopRequireDefault(require("../views/elements/IRCTimelineProfileResizer"));

var _DMRoomMap = _interopRequireDefault(require("../../utils/DMRoomMap"));

var _NewRoomIntro = _interopRequireDefault(require("../views/rooms/NewRoomIntro"));

var _replaceableComponent = require("../../utils/replaceableComponent");

var _dispatcher = _interopRequireDefault(require("../../dispatcher/dispatcher"));

var _CallEventGrouper = _interopRequireDefault(require("./CallEventGrouper"));

var _WhoIsTypingTile = _interopRequireDefault(require("../views/rooms/WhoIsTypingTile"));

var _ScrollPanel = _interopRequireDefault(require("./ScrollPanel"));

var _EventListSummary = _interopRequireDefault(require("../views/elements/EventListSummary"));

var _MemberEventListSummary = _interopRequireDefault(require("../views/elements/MemberEventListSummary"));

var _DateSeparator = _interopRequireDefault(require("../views/messages/DateSeparator"));

var _ErrorBoundary = _interopRequireDefault(require("../views/elements/ErrorBoundary"));

var _Spinner = _interopRequireDefault(require("../views/elements/Spinner"));

var _TileErrorBoundary = _interopRequireDefault(require("../views/messages/TileErrorBoundary"));

var _logger = require("matrix-js-sdk/src/logger");

var _actions = require("../../dispatcher/actions");

var _dec, _class, _class2, _temp;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const CONTINUATION_MAX_INTERVAL = 5 * 60 * 1000; // 5 minutes

const continuedTypes = [_event.EventType.Sticker, _event.EventType.RoomMessage];
const groupedEvents = [_event.EventType.RoomMember, _event.EventType.RoomThirdPartyInvite, _event.EventType.RoomServerAcl, _event.EventType.RoomPinnedEvents]; // check if there is a previous event and it has the same sender as this event
// and the types are the same/is in continuedTypes and the time between them is <= CONTINUATION_MAX_INTERVAL

function shouldFormContinuation(prevEvent, mxEvent, showHiddenEvents, timelineRenderingType) {
  if (timelineRenderingType === _RoomContext.TimelineRenderingType.ThreadsList) return false; // sanity check inputs

  if (!prevEvent || !prevEvent.sender || !mxEvent.sender) return false; // check if within the max continuation period

  if (mxEvent.getTs() - prevEvent.getTs() > CONTINUATION_MAX_INTERVAL) return false; // As we summarise redactions, do not continue a redacted event onto a non-redacted one and vice-versa

  if (mxEvent.isRedacted() !== prevEvent.isRedacted()) return false; // Some events should appear as continuations from previous events of different types.

  if (mxEvent.getType() !== prevEvent.getType() && (!continuedTypes.includes(mxEvent.getType()) || !continuedTypes.includes(prevEvent.getType()))) return false; // Check if the sender is the same and hasn't changed their displayname/avatar between these events

  if (mxEvent.sender.userId !== prevEvent.sender.userId || mxEvent.sender.name !== prevEvent.sender.name || mxEvent.sender.getMxcAvatarUrl() !== prevEvent.sender.getMxcAvatarUrl()) return false; // if we don't have tile for previous event then it was shown by showHiddenEvents and has no SenderProfile

  if (!(0, _EventTile.haveTileForEvent)(prevEvent, showHiddenEvents)) return false;
  return true;
}

let MessagePanel = (
/* (almost) stateless UI component which builds the event tiles in the room timeline.
 */
_dec = (0, _replaceableComponent.replaceableComponent)("structures.MessagePanel"), _dec(_class = (_temp = _class2 = class MessagePanel extends _react.default.Component {
  // opaque readreceipt info for each userId; used by ReadReceiptMarker
  // to manage its animations
  // Track read receipts by event ID. For each _shown_ event ID, we store
  // the list of read receipts to display:
  //   [
  //       {
  //           userId: string,
  //           member: RoomMember,
  //           ts: number,
  //       },
  //   ]
  // This is recomputed on each render. It's only stored on the component
  // for ease of passing the data around since it's computed in one pass
  // over all events.
  // Track read receipts by user ID. For each user ID we've ever shown a
  // a read receipt for, we store an object:
  //   {
  //       lastShownEventId: string,
  //       receipt: {
  //           userId: string,
  //           member: RoomMember,
  //           ts: number,
  //       },
  //   }
  // so that we can always keep receipts displayed by reverting back to
  // the last shown event for that user ID when needed. This may feel like
  // it duplicates the receipt storage in the room, but at this layer, we
  // are tracking _shown_ event IDs, which the JS SDK knows nothing about.
  // This is recomputed on each render, using the data from the previous
  // render as our fallback for any user IDs we can't match a receipt to a
  // displayed event in the current render cycle.
  // A map of <callId, CallEventGrouper>
  constructor(props, context) {
    super(props, context);
    (0, _defineProperty2.default)(this, "context", void 0);
    (0, _defineProperty2.default)(this, "readReceiptMap", {});
    (0, _defineProperty2.default)(this, "readReceiptsByEvent", {});
    (0, _defineProperty2.default)(this, "readReceiptsByUserId", {});
    (0, _defineProperty2.default)(this, "showHiddenEventsInTimeline", void 0);
    (0, _defineProperty2.default)(this, "isMounted", false);
    (0, _defineProperty2.default)(this, "readMarkerNode", /*#__PURE__*/(0, _react.createRef)());
    (0, _defineProperty2.default)(this, "whoIsTyping", /*#__PURE__*/(0, _react.createRef)());
    (0, _defineProperty2.default)(this, "scrollPanel", /*#__PURE__*/(0, _react.createRef)());
    (0, _defineProperty2.default)(this, "showTypingNotificationsWatcherRef", void 0);
    (0, _defineProperty2.default)(this, "eventNodes", void 0);
    (0, _defineProperty2.default)(this, "callEventGroupers", new Map());
    (0, _defineProperty2.default)(this, "membersCount", 0);
    (0, _defineProperty2.default)(this, "calculateRoomMembersCount", () => {
      var _this$props$room;

      this.membersCount = ((_this$props$room = this.props.room) === null || _this$props$room === void 0 ? void 0 : _this$props$room.getMembers().length) || 0;
    });
    (0, _defineProperty2.default)(this, "onShowTypingNotificationsChange", () => {
      this.setState({
        showTypingNotifications: _SettingsStore.default.getValue("showTypingNotifications")
      });
    });
    (0, _defineProperty2.default)(this, "isUnmounting", () => {
      return !this.isMounted;
    });
    (0, _defineProperty2.default)(this, "collectGhostReadMarker", node => {
      if (node) {
        // now the element has appeared, change the style which will trigger the CSS transition
        requestAnimationFrame(() => {
          node.style.width = '10%';
          node.style.opacity = '0';
        });
      }
    });
    (0, _defineProperty2.default)(this, "onGhostTransitionEnd", ev => {
      // we can now clean up the ghost element
      const finishedEventId = ev.target.dataset.eventid;
      this.setState({
        ghostReadMarkers: this.state.ghostReadMarkers.filter(eid => eid !== finishedEventId)
      });
    });
    (0, _defineProperty2.default)(this, "collectEventNode", (eventId, node) => {
      var _node$ref;

      this.eventNodes[eventId] = node === null || node === void 0 ? void 0 : (_node$ref = node.ref) === null || _node$ref === void 0 ? void 0 : _node$ref.current;
    });
    (0, _defineProperty2.default)(this, "onHeightChanged", () => {
      const scrollPanel = this.scrollPanel.current;

      if (scrollPanel) {
        scrollPanel.checkScroll();
      }
    });
    (0, _defineProperty2.default)(this, "onTypingShown", () => {
      const scrollPanel = this.scrollPanel.current; // this will make the timeline grow, so checkScroll

      scrollPanel.checkScroll();

      if (scrollPanel && scrollPanel.getScrollState().stuckAtBottom) {
        scrollPanel.preventShrinking();
      }
    });
    (0, _defineProperty2.default)(this, "onTypingHidden", () => {
      const scrollPanel = this.scrollPanel.current;

      if (scrollPanel) {
        // as hiding the typing notifications doesn't
        // update the scrollPanel, we tell it to apply
        // the shrinking prevention once the typing notifs are hidden
        scrollPanel.updatePreventShrinking(); // order is important here as checkScroll will scroll down to
        // reveal added padding to balance the notifs disappearing.

        scrollPanel.checkScroll();
      }
    });
    this.state = {
      // previous positions the read marker has been in, so we can
      // display 'ghost' read markers that are animating away
      ghostReadMarkers: [],
      showTypingNotifications: _SettingsStore.default.getValue("showTypingNotifications")
    }; // Cache hidden events setting on mount since Settings is expensive to
    // query, and we check this in a hot code path. This is also cached in
    // our RoomContext, however we still need a fallback for roomless MessagePanels.

    this.showHiddenEventsInTimeline = _SettingsStore.default.getValue("showHiddenEventsInTimeline");
    this.showTypingNotificationsWatcherRef = _SettingsStore.default.watchSetting("showTypingNotifications", null, this.onShowTypingNotificationsChange);
  }

  componentDidMount() {
    var _this$props$room2;

    this.calculateRoomMembersCount();
    (_this$props$room2 = this.props.room) === null || _this$props$room2 === void 0 ? void 0 : _this$props$room2.on("RoomState.members", this.calculateRoomMembersCount);
    this.isMounted = true;
  }

  componentWillUnmount() {
    var _this$props$room3;

    this.isMounted = false;
    (_this$props$room3 = this.props.room) === null || _this$props$room3 === void 0 ? void 0 : _this$props$room3.off("RoomState.members", this.calculateRoomMembersCount);

    _SettingsStore.default.unwatchSetting(this.showTypingNotificationsWatcherRef);
  }

  componentDidUpdate(prevProps, prevState) {
    if (prevProps.readMarkerVisible && this.props.readMarkerEventId !== prevProps.readMarkerEventId) {
      const ghostReadMarkers = this.state.ghostReadMarkers;
      ghostReadMarkers.push(prevProps.readMarkerEventId);
      this.setState({
        ghostReadMarkers
      });
    }

    const pendingEditItem = this.pendingEditItem;

    if (!this.props.editState && this.props.room && pendingEditItem) {
      _dispatcher.default.dispatch({
        action: _actions.Action.EditEvent,
        event: this.props.room.findEventById(pendingEditItem),
        timelineRenderingType: this.context.timelineRenderingType
      });
    }
  }

  /* get the DOM node representing the given event */
  getNodeForEventId(eventId) {
    if (!this.eventNodes) {
      return undefined;
    }

    return this.eventNodes[eventId];
  }
  /* return true if the content is fully scrolled down right now; else false.
   */


  isAtBottom() {
    var _this$scrollPanel$cur;

    return (_this$scrollPanel$cur = this.scrollPanel.current) === null || _this$scrollPanel$cur === void 0 ? void 0 : _this$scrollPanel$cur.isAtBottom();
  }
  /* get the current scroll state. See ScrollPanel.getScrollState for
   * details.
   *
   * returns null if we are not mounted.
   */


  getScrollState() {
    var _this$scrollPanel$cur2;

    return ((_this$scrollPanel$cur2 = this.scrollPanel.current) === null || _this$scrollPanel$cur2 === void 0 ? void 0 : _this$scrollPanel$cur2.getScrollState()) ?? null;
  } // returns one of:
  //
  //  null: there is no read marker
  //  -1: read marker is above the window
  //   0: read marker is within the window
  //  +1: read marker is below the window


  getReadMarkerPosition() {
    const readMarker = this.readMarkerNode.current;
    const messageWrapper = this.scrollPanel.current;

    if (!readMarker || !messageWrapper) {
      return null;
    }

    const wrapperRect = _reactDom.default.findDOMNode(messageWrapper).getBoundingClientRect();

    const readMarkerRect = readMarker.getBoundingClientRect(); // the read-marker pretends to have zero height when it is actually
    // two pixels high; +2 here to account for that.

    if (readMarkerRect.bottom + 2 < wrapperRect.top) {
      return -1;
    } else if (readMarkerRect.top < wrapperRect.bottom) {
      return 0;
    } else {
      return 1;
    }
  }
  /* jump to the top of the content.
   */


  scrollToTop() {
    if (this.scrollPanel.current) {
      this.scrollPanel.current.scrollToTop();
    }
  }
  /* jump to the bottom of the content.
   */


  scrollToBottom() {
    if (this.scrollPanel.current) {
      this.scrollPanel.current.scrollToBottom();
    }
  }
  /**
   * Page up/down.
   *
   * @param {number} mult: -1 to page up, +1 to page down
   */


  scrollRelative(mult) {
    if (this.scrollPanel.current) {
      this.scrollPanel.current.scrollRelative(mult);
    }
  }
  /**
   * Scroll up/down in response to a scroll key
   *
   * @param {KeyboardEvent} ev: the keyboard event to handle
   */


  handleScrollKey(ev) {
    if (this.scrollPanel.current) {
      this.scrollPanel.current.handleScrollKey(ev);
    }
  }
  /* jump to the given event id.
   *
   * offsetBase gives the reference point for the pixelOffset. 0 means the
   * top of the container, 1 means the bottom, and fractional values mean
   * somewhere in the middle. If omitted, it defaults to 0.
   *
   * pixelOffset gives the number of pixels *above* the offsetBase that the
   * node (specifically, the bottom of it) will be positioned. If omitted, it
   * defaults to 0.
   */


  scrollToEvent(eventId, pixelOffset, offsetBase) {
    if (this.scrollPanel.current) {
      this.scrollPanel.current.scrollToToken(eventId, pixelOffset, offsetBase);
    }
  }

  scrollToEventIfNeeded(eventId) {
    const node = this.eventNodes[eventId];

    if (node) {
      node.scrollIntoView({
        block: "nearest",
        behavior: "instant"
      });
    }
  }
  /* check the scroll state and send out pagination requests if necessary.
   */


  checkFillState() {
    if (this.scrollPanel.current) {
      this.scrollPanel.current.checkFillState();
    }
  }

  get showHiddenEvents() {
    var _this$context;

    return ((_this$context = this.context) === null || _this$context === void 0 ? void 0 : _this$context.showHiddenEventsInTimeline) ?? this.showHiddenEventsInTimeline;
  } // TODO: Implement granular (per-room) hide options


  shouldShowEvent(mxEv) {
    if (_MatrixClientPeg.MatrixClientPeg.get().isUserIgnored(mxEv.getSender())) {
      return false; // ignored = no show (only happens if the ignore happens after an event was received)
    }

    if (this.showHiddenEvents) {
      return true;
    }

    if (!(0, _EventTile.haveTileForEvent)(mxEv, this.showHiddenEvents)) {
      return false; // no tile = no show
    } // Always show highlighted event


    if (this.props.highlightedEventId === mxEv.getId()) return true; // Checking if the message has a "parentEventId" as we do not
    // want to hide the root event of the thread

    if (mxEv.isThreadRelation && this.props.hideThreadedMessages && _SettingsStore.default.getValue("feature_thread")) {
      return false;
    }

    return !(0, _shouldHideEvent.default)(mxEv, this.context);
  }

  readMarkerForEvent(eventId, isLastEvent) {
    const visible = !isLastEvent && this.props.readMarkerVisible;

    if (this.props.readMarkerEventId === eventId) {
      let hr; // if the read marker comes at the end of the timeline (except
      // for local echoes, which are excluded from RMs, because they
      // don't have useful event ids), we don't want to show it, but
      // we still want to create the <li/> for it so that the
      // algorithms which depend on its position on the screen aren't
      // confused.

      if (visible) {
        hr = /*#__PURE__*/_react.default.createElement("hr", {
          className: "mx_RoomView_myReadMarker",
          style: {
            opacity: 1,
            width: '99%'
          }
        });
      }

      return /*#__PURE__*/_react.default.createElement("li", {
        key: "readMarker_" + eventId,
        ref: this.readMarkerNode,
        className: "mx_RoomView_myReadMarker_container",
        "data-scroll-tokens": eventId
      }, hr);
    } else if (this.state.ghostReadMarkers.includes(eventId)) {
      // We render 'ghost' read markers in the DOM while they
      // transition away. This allows the actual read marker
      // to be in the right place straight away without having
      // to wait for the transition to finish.
      // There are probably much simpler ways to do this transition,
      // possibly using react-transition-group which handles keeping
      // elements in the DOM whilst they transition out, although our
      // case is a little more complex because only some of the items
      // transition (ie. the read markers do but the event tiles do not)
      // and TransitionGroup requires that all its children are Transitions.
      const hr = /*#__PURE__*/_react.default.createElement("hr", {
        className: "mx_RoomView_myReadMarker",
        ref: this.collectGhostReadMarker,
        onTransitionEnd: this.onGhostTransitionEnd,
        "data-eventid": eventId
      }); // give it a key which depends on the event id. That will ensure that
      // we get a new DOM node (restarting the animation) when the ghost
      // moves to a different event.


      return /*#__PURE__*/_react.default.createElement("li", {
        key: "_readuptoghost_" + eventId,
        className: "mx_RoomView_myReadMarker_container"
      }, hr);
    }

    return null;
  }

  getNextEventInfo(arr, i) {
    const nextEvent = i < arr.length - 1 ? arr[i + 1] : null; // The next event with tile is used to to determine the 'last successful' flag
    // when rendering the tile. The shouldShowEvent function is pretty quick at what
    // it does, so this should have no significant cost even when a room is used for
    // not-chat purposes.

    const nextTile = arr.slice(i + 1).find(e => this.shouldShowEvent(e));
    return {
      nextEvent,
      nextTile
    };
  }

  get pendingEditItem() {
    if (!this.props.room) {
      return undefined;
    }

    try {
      return localStorage.getItem(`mx_edit_room_${this.props.room.roomId}_${this.context.timelineRenderingType}`);
    } catch (err) {
      _logger.logger.error(err);

      return undefined;
    }
  }

  getEventTiles() {
    this.eventNodes = {};
    let i; // first figure out which is the last event in the list which we're
    // actually going to show; this allows us to behave slightly
    // differently for the last event in the list. (eg show timestamp)
    //
    // we also need to figure out which is the last event we show which isn't
    // a local echo, to manage the read-marker.

    let lastShownEvent;
    let lastShownNonLocalEchoIndex = -1;

    for (i = this.props.events.length - 1; i >= 0; i--) {
      const mxEv = this.props.events[i];

      if (!this.shouldShowEvent(mxEv)) {
        continue;
      }

      if (lastShownEvent === undefined) {
        lastShownEvent = mxEv;
      }

      if (mxEv.status) {
        // this is a local echo
        continue;
      }

      lastShownNonLocalEchoIndex = i;
      break;
    }

    const ret = [];
    let prevEvent = null; // the last event we showed
    // Note: the EventTile might still render a "sent/sending receipt" independent of
    // this information. When not providing read receipt information, the tile is likely
    // to assume that sent receipts are to be shown more often.

    this.readReceiptsByEvent = {};

    if (this.props.showReadReceipts) {
      this.readReceiptsByEvent = this.getReadReceiptsByShownEvent();
    }

    let grouper = null;

    for (i = 0; i < this.props.events.length; i++) {
      const mxEv = this.props.events[i];
      const eventId = mxEv.getId();
      const last = mxEv === lastShownEvent;
      const {
        nextEvent,
        nextTile
      } = this.getNextEventInfo(this.props.events, i);

      if (mxEv.getType().indexOf("m.call.") === 0 || mxEv.getType().indexOf("org.matrix.call.") === 0) {
        const callId = mxEv.getContent().call_id;

        if (this.callEventGroupers.has(callId)) {
          this.callEventGroupers.get(callId).add(mxEv);
        } else {
          const callEventGrouper = new _CallEventGrouper.default();
          callEventGrouper.add(mxEv);
          this.callEventGroupers.set(callId, callEventGrouper);
        }
      }

      if (grouper) {
        if (grouper.shouldGroup(mxEv)) {
          grouper.add(mxEv, this.showHiddenEvents);
          continue;
        } else {
          // not part of group, so get the group tiles, close the
          // group, and continue like a normal event
          ret.push(...grouper.getTiles());
          prevEvent = grouper.getNewPrevEvent();
          grouper = null;
        }
      }

      for (const Grouper of groupers) {
        if (Grouper.canStartGroup(this, mxEv) && !this.props.disableGrouping) {
          grouper = new Grouper(this, mxEv, prevEvent, lastShownEvent, this.props.layout, nextEvent, nextTile);
        }
      }

      if (!grouper) {
        const wantTile = this.shouldShowEvent(mxEv);
        const isGrouped = false;

        if (wantTile) {
          // make sure we unpack the array returned by getTilesForEvent,
          // otherwise react will auto-generate keys and we will end up
          // replacing all of the DOM elements every time we paginate.
          ret.push(...this.getTilesForEvent(prevEvent, mxEv, last, isGrouped, nextEvent, nextTile));
          prevEvent = mxEv;
        }

        const readMarker = this.readMarkerForEvent(eventId, i >= lastShownNonLocalEchoIndex);
        if (readMarker) ret.push(readMarker);
      }
    }

    if (grouper) {
      ret.push(...grouper.getTiles());
    }

    return ret;
  }

  getTilesForEvent(prevEvent, mxEv, last = false, isGrouped = false, nextEvent, nextEventWithTile) {
    const ret = [];
    const isEditing = this.props.editState && this.props.editState.getEvent().getId() === mxEv.getId(); // local echoes have a fake date, which could even be yesterday. Treat them
    // as 'today' for the date separators.

    let ts1 = mxEv.getTs();
    let eventDate = mxEv.getDate();

    if (mxEv.status) {
      eventDate = new Date();
      ts1 = eventDate.getTime();
    } // do we need a date separator since the last event?


    const wantsDateSeparator = this.wantsDateSeparator(prevEvent, eventDate);

    if (wantsDateSeparator && !isGrouped) {
      const dateSeparator = /*#__PURE__*/_react.default.createElement("li", {
        key: ts1
      }, /*#__PURE__*/_react.default.createElement(_DateSeparator.default, {
        key: ts1,
        ts: ts1
      }));

      ret.push(dateSeparator);
    }

    let willWantDateSeparator = false;
    let lastInSection = true;

    if (nextEventWithTile) {
      willWantDateSeparator = this.wantsDateSeparator(mxEv, nextEventWithTile.getDate() || new Date());
      lastInSection = willWantDateSeparator || mxEv.getSender() !== nextEventWithTile.getSender();
    } // is this a continuation of the previous message?


    const continuation = !wantsDateSeparator && shouldFormContinuation(prevEvent, mxEv, this.showHiddenEvents, this.context.timelineRenderingType);
    const eventId = mxEv.getId();
    const highlight = eventId === this.props.highlightedEventId;
    const readReceipts = this.readReceiptsByEvent[eventId];
    let isLastSuccessful = false;

    const isSentState = s => !s || s === 'sent';

    const isSent = isSentState(mxEv.getAssociatedStatus());
    const hasNextEvent = nextEvent && this.shouldShowEvent(nextEvent);

    if (!hasNextEvent && isSent) {
      isLastSuccessful = true;
    } else if (hasNextEvent && isSent && !isSentState(nextEvent.getAssociatedStatus())) {
      isLastSuccessful = true;
    } // This is a bit nuanced, but if our next event is hidden but a future event is not
    // hidden then we're not the last successful.


    if (nextEventWithTile && nextEventWithTile !== nextEvent && isSentState(nextEventWithTile.getAssociatedStatus())) {
      isLastSuccessful = false;
    } // We only want to consider "last successful" if the event is sent by us, otherwise of course
    // it's successful: we received it.


    isLastSuccessful = isLastSuccessful && mxEv.getSender() === _MatrixClientPeg.MatrixClientPeg.get().getUserId();
    const callEventGrouper = this.callEventGroupers.get(mxEv.getContent().call_id); // use txnId as key if available so that we don't remount during sending

    ret.push( /*#__PURE__*/_react.default.createElement(_TileErrorBoundary.default, {
      key: mxEv.getTxnId() || eventId,
      mxEvent: mxEv
    }, /*#__PURE__*/_react.default.createElement(_EventTile.default, {
      as: "li",
      ref: this.collectEventNode.bind(this, eventId),
      alwaysShowTimestamps: this.props.alwaysShowTimestamps,
      mxEvent: mxEv,
      continuation: continuation,
      isRedacted: mxEv.isRedacted(),
      replacingEventId: mxEv.replacingEventId(),
      editState: isEditing && this.props.editState,
      onHeightChanged: this.onHeightChanged,
      readReceipts: readReceipts,
      readReceiptMap: this.readReceiptMap,
      showUrlPreview: this.props.showUrlPreview,
      checkUnmounting: this.isUnmounting,
      eventSendStatus: mxEv.getAssociatedStatus(),
      tileShape: this.props.tileShape,
      isTwelveHour: this.props.isTwelveHour,
      permalinkCreator: this.props.permalinkCreator,
      last: last,
      lastInSection: lastInSection,
      lastSuccessful: isLastSuccessful,
      isSelectedEvent: highlight,
      getRelationsForEvent: this.props.getRelationsForEvent,
      showReactions: this.props.showReactions,
      layout: this.props.layout,
      enableFlair: this.props.enableFlair,
      showReadReceipts: this.props.showReadReceipts,
      callEventGrouper: callEventGrouper,
      hideSender: this.membersCount <= 2 && this.props.layout === _Layout.Layout.Bubble,
      timelineRenderingType: this.context.timelineRenderingType
    })));
    return ret;
  }

  wantsDateSeparator(prevEvent, nextEventDate) {
    if (this.context.timelineRenderingType === _RoomContext.TimelineRenderingType.ThreadsList) {
      return false;
    }

    if (prevEvent == null) {
      // first event in the panel: depends if we could back-paginate from
      // here.
      return !this.props.suppressFirstDateSeparator;
    }

    return (0, _DateUtils.wantsDateSeparator)(prevEvent.getDate(), nextEventDate);
  } // Get a list of read receipts that should be shown next to this event
  // Receipts are objects which have a 'userId', 'roomMember' and 'ts'.


  getReadReceiptsForEvent(event) {
    const myUserId = _MatrixClientPeg.MatrixClientPeg.get().credentials.userId; // get list of read receipts, sorted most recent first


    const {
      room
    } = this.props;

    if (!room) {
      return null;
    }

    const receipts = [];
    room.getReceiptsForEvent(event).forEach(r => {
      if (!r.userId || r.type !== "m.read" || r.userId === myUserId) {
        return; // ignore non-read receipts and receipts from self.
      }

      if (_MatrixClientPeg.MatrixClientPeg.get().isUserIgnored(r.userId)) {
        return; // ignore ignored users
      }

      const member = room.getMember(r.userId);
      receipts.push({
        userId: r.userId,
        roomMember: member,
        ts: r.data ? r.data.ts : 0
      });
    });
    return receipts;
  } // Get an object that maps from event ID to a list of read receipts that
  // should be shown next to that event. If a hidden event has read receipts,
  // they are folded into the receipts of the last shown event.


  getReadReceiptsByShownEvent() {
    const receiptsByEvent = {};
    const receiptsByUserId = {};
    let lastShownEventId;

    for (const event of this.props.events) {
      if (this.shouldShowEvent(event)) {
        lastShownEventId = event.getId();
      }

      if (!lastShownEventId) {
        continue;
      }

      const existingReceipts = receiptsByEvent[lastShownEventId] || [];
      const newReceipts = this.getReadReceiptsForEvent(event);
      receiptsByEvent[lastShownEventId] = existingReceipts.concat(newReceipts); // Record these receipts along with their last shown event ID for
      // each associated user ID.

      for (const receipt of newReceipts) {
        receiptsByUserId[receipt.userId] = {
          lastShownEventId,
          receipt
        };
      }
    } // It's possible in some cases (for example, when a read receipt
    // advances before we have paginated in the new event that it's marking
    // received) that we can temporarily not have a matching event for
    // someone which had one in the last. By looking through our previous
    // mapping of receipts by user ID, we can cover recover any receipts
    // that would have been lost by using the same event ID from last time.


    for (const userId in this.readReceiptsByUserId) {
      if (receiptsByUserId[userId]) {
        continue;
      }

      const {
        lastShownEventId,
        receipt
      } = this.readReceiptsByUserId[userId];
      const existingReceipts = receiptsByEvent[lastShownEventId] || [];
      receiptsByEvent[lastShownEventId] = existingReceipts.concat(receipt);
      receiptsByUserId[userId] = {
        lastShownEventId,
        receipt
      };
    }

    this.readReceiptsByUserId = receiptsByUserId; // After grouping receipts by shown events, do another pass to sort each
    // receipt list.

    for (const eventId in receiptsByEvent) {
      receiptsByEvent[eventId].sort((r1, r2) => {
        return r2.ts - r1.ts;
      });
    }

    return receiptsByEvent;
  }

  updateTimelineMinHeight() {
    const scrollPanel = this.scrollPanel.current;

    if (scrollPanel) {
      const isAtBottom = scrollPanel.isAtBottom();
      const whoIsTyping = this.whoIsTyping.current;
      const isTypingVisible = whoIsTyping && whoIsTyping.isVisible(); // when messages get added to the timeline,
      // but somebody else is still typing,
      // update the min-height, so once the last
      // person stops typing, no jumping occurs

      if (isAtBottom && isTypingVisible) {
        scrollPanel.preventShrinking();
      }
    }
  }

  onTimelineReset() {
    const scrollPanel = this.scrollPanel.current;

    if (scrollPanel) {
      scrollPanel.clearPreventShrinking();
    }
  }

  render() {
    let topSpinner;
    let bottomSpinner;

    if (this.props.backPaginating) {
      topSpinner = /*#__PURE__*/_react.default.createElement("li", {
        key: "_topSpinner"
      }, /*#__PURE__*/_react.default.createElement(_Spinner.default, null));
    }

    if (this.props.forwardPaginating) {
      bottomSpinner = /*#__PURE__*/_react.default.createElement("li", {
        key: "_bottomSpinner"
      }, /*#__PURE__*/_react.default.createElement(_Spinner.default, null));
    }

    const style = this.props.hidden ? {
      display: 'none'
    } : {};
    let whoIsTyping;

    if (this.props.room && !this.props.tileShape && this.state.showTypingNotifications) {
      whoIsTyping = /*#__PURE__*/_react.default.createElement(_WhoIsTypingTile.default, {
        room: this.props.room,
        onShown: this.onTypingShown,
        onHidden: this.onTypingHidden,
        ref: this.whoIsTyping
      });
    }

    let ircResizer = null;

    if (this.props.layout == _Layout.Layout.IRC) {
      ircResizer = /*#__PURE__*/_react.default.createElement(_IRCTimelineProfileResizer.default, {
        minWidth: 20,
        maxWidth: 600,
        roomId: this.props.room ? this.props.room.roomId : null
      });
    }

    return /*#__PURE__*/_react.default.createElement(_ErrorBoundary.default, null, /*#__PURE__*/_react.default.createElement(_ScrollPanel.default, {
      ref: this.scrollPanel,
      className: this.props.className,
      onScroll: this.props.onScroll,
      onUserScroll: this.props.onUserScroll,
      onFillRequest: this.props.onFillRequest,
      onUnfillRequest: this.props.onUnfillRequest,
      style: style,
      stickyBottom: this.props.stickyBottom,
      resizeNotifier: this.props.resizeNotifier,
      fixedChildren: ircResizer
    }, topSpinner, this.getEventTiles(), whoIsTyping, bottomSpinner));
  }

}, (0, _defineProperty2.default)(_class2, "contextType", _RoomContext.default), (0, _defineProperty2.default)(_class2, "defaultProps", {
  disableGrouping: false
}), _temp)) || _class);
exports.default = MessagePanel;

class BaseGrouper {
  // events that we include in the group but then eject out and place above the group.
  constructor(panel, event, prevEvent, lastShownEvent, layout, nextEvent, nextEventTile) {
    this.panel = panel;
    this.event = event;
    this.prevEvent = prevEvent;
    this.lastShownEvent = lastShownEvent;
    this.layout = layout;
    this.nextEvent = nextEvent;
    this.nextEventTile = nextEventTile;
    (0, _defineProperty2.default)(this, "events", []);
    (0, _defineProperty2.default)(this, "ejectedEvents", []);
    (0, _defineProperty2.default)(this, "readMarker", void 0);
    this.readMarker = panel.readMarkerForEvent(event.getId(), event === lastShownEvent);
  }

}
/* Grouper classes determine when events can be grouped together in a summary.
 * Groupers should have the following methods:
 * - canStartGroup (static): determines if a new group should be started with the
 *   given event
 * - shouldGroup: determines if the given event should be added to an existing group
 * - add: adds an event to an existing group (should only be called if shouldGroup
 *   return true)
 * - getTiles: returns the tiles that represent the group
 * - getNewPrevEvent: returns the event that should be used as the new prevEvent
 *   when determining things such as whether a date separator is necessary
 */
// Wrap initial room creation events into an EventListSummary
// Grouping only events sent by the same user that sent the `m.room.create` and only until
// the first non-state event or membership event which is not regarding the sender of the `m.room.create` event


(0, _defineProperty2.default)(BaseGrouper, "canStartGroup", (panel, ev) => true);

class CreationGrouper extends BaseGrouper {
  shouldGroup(ev) {
    const panel = this.panel;
    const createEvent = this.event;

    if (!panel.shouldShowEvent(ev)) {
      return true;
    }

    if (panel.wantsDateSeparator(this.event, ev.getDate())) {
      return false;
    }

    if (ev.getType() === _event.EventType.RoomMember && (ev.getStateKey() !== createEvent.getSender() || ev.getContent()["membership"] !== "join")) {
      return false;
    }

    if (ev.isState() && ev.getSender() === createEvent.getSender()) {
      return true;
    }

    return false;
  }

  add(ev) {
    const panel = this.panel;
    this.readMarker = this.readMarker || panel.readMarkerForEvent(ev.getId(), ev === this.lastShownEvent);

    if (!panel.shouldShowEvent(ev)) {
      return;
    }

    if (ev.getType() === _event.EventType.RoomEncryption) {
      this.ejectedEvents.push(ev);
    } else {
      this.events.push(ev);
    }
  }

  getTiles() {
    // If we don't have any events to group, don't even try to group them. The logic
    // below assumes that we have a group of events to deal with, but we might not if
    // the events we were supposed to group were redacted.
    if (!this.events || !this.events.length) return [];
    const panel = this.panel;
    const ret = [];
    const isGrouped = true;
    const createEvent = this.event;
    const lastShownEvent = this.lastShownEvent;

    if (panel.wantsDateSeparator(this.prevEvent, createEvent.getDate())) {
      const ts = createEvent.getTs();
      ret.push( /*#__PURE__*/_react.default.createElement("li", {
        key: ts + '~'
      }, /*#__PURE__*/_react.default.createElement(_DateSeparator.default, {
        key: ts + '~',
        ts: ts
      })));
    } // If this m.room.create event should be shown (room upgrade) then show it before the summary


    if (panel.shouldShowEvent(createEvent)) {
      // pass in the createEvent as prevEvent as well so no extra DateSeparator is rendered
      ret.push(...panel.getTilesForEvent(createEvent, createEvent));
    }

    for (const ejected of this.ejectedEvents) {
      ret.push(...panel.getTilesForEvent(createEvent, ejected, createEvent === lastShownEvent, isGrouped));
    }

    const eventTiles = this.events.map(e => {
      // In order to prevent DateSeparators from appearing in the expanded form
      // of EventListSummary, render each member event as if the previous
      // one was itself. This way, the timestamp of the previous event === the
      // timestamp of the current event, and no DateSeparator is inserted.
      return panel.getTilesForEvent(e, e, e === lastShownEvent, isGrouped);
    }).reduce((a, b) => a.concat(b), []); // Get sender profile from the latest event in the summary as the m.room.create doesn't contain one

    const ev = this.events[this.events.length - 1];
    let summaryText;
    const roomId = ev.getRoomId();
    const creator = ev.sender ? ev.sender.name : ev.getSender();

    if (_DMRoomMap.default.shared().getUserIdForRoomId(roomId)) {
      summaryText = (0, _languageHandler._t)("%(creator)s created this DM.", {
        creator
      });
    } else {
      summaryText = (0, _languageHandler._t)("%(creator)s created and configured the room.", {
        creator
      });
    }

    ret.push( /*#__PURE__*/_react.default.createElement(_NewRoomIntro.default, {
      key: "newroomintro"
    }));
    ret.push( /*#__PURE__*/_react.default.createElement(_EventListSummary.default, {
      key: "roomcreationsummary",
      events: this.events,
      onToggle: panel.onHeightChanged // Update scroll state
      ,
      summaryMembers: [ev.sender],
      summaryText: summaryText,
      layout: this.layout
    }, eventTiles));

    if (this.readMarker) {
      ret.push(this.readMarker);
    }

    return ret;
  }

  getNewPrevEvent() {
    return this.event;
  }

}

(0, _defineProperty2.default)(CreationGrouper, "canStartGroup", function (panel, ev) {
  return ev.getType() === _event.EventType.RoomCreate;
});

class RedactionGrouper extends BaseGrouper {
  constructor(panel, ev, prevEvent, lastShownEvent, layout, nextEvent, nextEventTile) {
    super(panel, ev, prevEvent, lastShownEvent, layout, nextEvent, nextEventTile);
    this.events = [ev];
  }

  shouldGroup(ev) {
    // absorb hidden events so that they do not break up streams of messages & redaction events being grouped
    if (!this.panel.shouldShowEvent(ev)) {
      return true;
    }

    if (this.panel.wantsDateSeparator(this.events[0], ev.getDate())) {
      return false;
    }

    return ev.isRedacted();
  }

  add(ev) {
    this.readMarker = this.readMarker || this.panel.readMarkerForEvent(ev.getId(), ev === this.lastShownEvent);

    if (!this.panel.shouldShowEvent(ev)) {
      return;
    }

    this.events.push(ev);
  }

  getTiles() {
    if (!this.events || !this.events.length) return [];
    const isGrouped = true;
    const panel = this.panel;
    const ret = [];
    const lastShownEvent = this.lastShownEvent;

    if (panel.wantsDateSeparator(this.prevEvent, this.events[0].getDate())) {
      const ts = this.events[0].getTs();
      ret.push( /*#__PURE__*/_react.default.createElement("li", {
        key: ts + '~'
      }, /*#__PURE__*/_react.default.createElement(_DateSeparator.default, {
        key: ts + '~',
        ts: ts
      })));
    }

    const key = "redactioneventlistsummary-" + (this.prevEvent ? this.events[0].getId() : "initial");
    const senders = new Set();
    let eventTiles = this.events.map((e, i) => {
      senders.add(e.sender);
      const prevEvent = i === 0 ? this.prevEvent : this.events[i - 1];
      return panel.getTilesForEvent(prevEvent, e, e === lastShownEvent, isGrouped, this.nextEvent, this.nextEventTile);
    }).reduce((a, b) => a.concat(b), []);

    if (eventTiles.length === 0) {
      eventTiles = null;
    }

    ret.push( /*#__PURE__*/_react.default.createElement(_EventListSummary.default, {
      key: key,
      threshold: 2,
      events: this.events,
      onToggle: panel.onHeightChanged // Update scroll state
      ,
      summaryMembers: Array.from(senders),
      summaryText: (0, _languageHandler._t)("%(count)s messages deleted.", {
        count: eventTiles.length
      }),
      layout: this.layout
    }, eventTiles));

    if (this.readMarker) {
      ret.push(this.readMarker);
    }

    return ret;
  }

  getNewPrevEvent() {
    return this.events[this.events.length - 1];
  }

} // Wrap consecutive member events in a ListSummary, ignore if redacted


(0, _defineProperty2.default)(RedactionGrouper, "canStartGroup", function (panel, ev) {
  return panel.shouldShowEvent(ev) && ev.isRedacted();
});

class MemberGrouper extends BaseGrouper {
  constructor(panel, event, prevEvent, lastShownEvent, layout) {
    super(panel, event, prevEvent, lastShownEvent, layout);
    this.panel = panel;
    this.event = event;
    this.prevEvent = prevEvent;
    this.lastShownEvent = lastShownEvent;
    this.layout = layout;
    this.events = [event];
  }

  shouldGroup(ev) {
    if (this.panel.wantsDateSeparator(this.events[0], ev.getDate())) {
      return false;
    }

    return groupedEvents.includes(ev.getType());
  }

  add(ev, showHiddenEvents) {
    if (ev.getType() === _event.EventType.RoomMember) {
      // We can ignore any events that don't actually have a message to display
      if (!(0, _TextForEvent.hasText)(ev, showHiddenEvents)) return;
    }

    this.readMarker = this.readMarker || this.panel.readMarkerForEvent(ev.getId(), ev === this.lastShownEvent);
    this.events.push(ev);
  }

  getTiles() {
    // If we don't have any events to group, don't even try to group them. The logic
    // below assumes that we have a group of events to deal with, but we might not if
    // the events we were supposed to group were redacted.
    if (!this.events || !this.events.length) return [];
    const isGrouped = true;
    const panel = this.panel;
    const lastShownEvent = this.lastShownEvent;
    const ret = [];

    if (panel.wantsDateSeparator(this.prevEvent, this.events[0].getDate())) {
      const ts = this.events[0].getTs();
      ret.push( /*#__PURE__*/_react.default.createElement("li", {
        key: ts + '~'
      }, /*#__PURE__*/_react.default.createElement(_DateSeparator.default, {
        key: ts + '~',
        ts: ts
      })));
    } // Ensure that the key of the MemberEventListSummary does not change with new
    // member events. This will prevent it from being re-created unnecessarily, and
    // instead will allow new props to be provided. In turn, the shouldComponentUpdate
    // method on MELS can be used to prevent unnecessary renderings.
    //
    // Whilst back-paginating with a MELS at the top of the panel, prevEvent will be null,
    // so use the key "membereventlistsummary-initial". Otherwise, use the ID of the first
    // membership event, which will not change during forward pagination.


    const key = "membereventlistsummary-" + (this.prevEvent ? this.events[0].getId() : "initial");
    let highlightInMels;
    let eventTiles = this.events.map(e => {
      if (e.getId() === panel.props.highlightedEventId) {
        highlightInMels = true;
      } // In order to prevent DateSeparators from appearing in the expanded form
      // of MemberEventListSummary, render each member event as if the previous
      // one was itself. This way, the timestamp of the previous event === the
      // timestamp of the current event, and no DateSeparator is inserted.


      return panel.getTilesForEvent(e, e, e === lastShownEvent, isGrouped);
    }).reduce((a, b) => a.concat(b), []);

    if (eventTiles.length === 0) {
      eventTiles = null;
    }

    ret.push( /*#__PURE__*/_react.default.createElement(_MemberEventListSummary.default, {
      key: key,
      events: this.events,
      onToggle: panel.onHeightChanged // Update scroll state
      ,
      startExpanded: highlightInMels,
      layout: this.layout
    }, eventTiles));

    if (this.readMarker) {
      ret.push(this.readMarker);
    }

    return ret;
  }

  getNewPrevEvent() {
    return this.events[0];
  }

} // all the grouper classes that we use


(0, _defineProperty2.default)(MemberGrouper, "canStartGroup", function (panel, ev) {
  return panel.shouldShowEvent(ev) && groupedEvents.includes(ev.getType());
});
const groupers = [CreationGrouper, MemberGrouper, RedactionGrouper];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3N0cnVjdHVyZXMvTWVzc2FnZVBhbmVsLnRzeCJdLCJuYW1lcyI6WyJDT05USU5VQVRJT05fTUFYX0lOVEVSVkFMIiwiY29udGludWVkVHlwZXMiLCJFdmVudFR5cGUiLCJTdGlja2VyIiwiUm9vbU1lc3NhZ2UiLCJncm91cGVkRXZlbnRzIiwiUm9vbU1lbWJlciIsIlJvb21UaGlyZFBhcnR5SW52aXRlIiwiUm9vbVNlcnZlckFjbCIsIlJvb21QaW5uZWRFdmVudHMiLCJzaG91bGRGb3JtQ29udGludWF0aW9uIiwicHJldkV2ZW50IiwibXhFdmVudCIsInNob3dIaWRkZW5FdmVudHMiLCJ0aW1lbGluZVJlbmRlcmluZ1R5cGUiLCJUaW1lbGluZVJlbmRlcmluZ1R5cGUiLCJUaHJlYWRzTGlzdCIsInNlbmRlciIsImdldFRzIiwiaXNSZWRhY3RlZCIsImdldFR5cGUiLCJpbmNsdWRlcyIsInVzZXJJZCIsIm5hbWUiLCJnZXRNeGNBdmF0YXJVcmwiLCJNZXNzYWdlUGFuZWwiLCJSZWFjdCIsIkNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJjb250ZXh0IiwiTWFwIiwibWVtYmVyc0NvdW50Iiwicm9vbSIsImdldE1lbWJlcnMiLCJsZW5ndGgiLCJzZXRTdGF0ZSIsInNob3dUeXBpbmdOb3RpZmljYXRpb25zIiwiU2V0dGluZ3NTdG9yZSIsImdldFZhbHVlIiwiaXNNb3VudGVkIiwibm9kZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInN0eWxlIiwid2lkdGgiLCJvcGFjaXR5IiwiZXYiLCJmaW5pc2hlZEV2ZW50SWQiLCJ0YXJnZXQiLCJkYXRhc2V0IiwiZXZlbnRpZCIsImdob3N0UmVhZE1hcmtlcnMiLCJzdGF0ZSIsImZpbHRlciIsImVpZCIsImV2ZW50SWQiLCJldmVudE5vZGVzIiwicmVmIiwiY3VycmVudCIsInNjcm9sbFBhbmVsIiwiY2hlY2tTY3JvbGwiLCJnZXRTY3JvbGxTdGF0ZSIsInN0dWNrQXRCb3R0b20iLCJwcmV2ZW50U2hyaW5raW5nIiwidXBkYXRlUHJldmVudFNocmlua2luZyIsInNob3dIaWRkZW5FdmVudHNJblRpbWVsaW5lIiwic2hvd1R5cGluZ05vdGlmaWNhdGlvbnNXYXRjaGVyUmVmIiwid2F0Y2hTZXR0aW5nIiwib25TaG93VHlwaW5nTm90aWZpY2F0aW9uc0NoYW5nZSIsImNvbXBvbmVudERpZE1vdW50IiwiY2FsY3VsYXRlUm9vbU1lbWJlcnNDb3VudCIsIm9uIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJvZmYiLCJ1bndhdGNoU2V0dGluZyIsImNvbXBvbmVudERpZFVwZGF0ZSIsInByZXZQcm9wcyIsInByZXZTdGF0ZSIsInJlYWRNYXJrZXJWaXNpYmxlIiwicmVhZE1hcmtlckV2ZW50SWQiLCJwdXNoIiwicGVuZGluZ0VkaXRJdGVtIiwiZWRpdFN0YXRlIiwiZGVmYXVsdERpc3BhdGNoZXIiLCJkaXNwYXRjaCIsImFjdGlvbiIsIkFjdGlvbiIsIkVkaXRFdmVudCIsImV2ZW50IiwiZmluZEV2ZW50QnlJZCIsImdldE5vZGVGb3JFdmVudElkIiwidW5kZWZpbmVkIiwiaXNBdEJvdHRvbSIsImdldFJlYWRNYXJrZXJQb3NpdGlvbiIsInJlYWRNYXJrZXIiLCJyZWFkTWFya2VyTm9kZSIsIm1lc3NhZ2VXcmFwcGVyIiwid3JhcHBlclJlY3QiLCJSZWFjdERPTSIsImZpbmRET01Ob2RlIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicmVhZE1hcmtlclJlY3QiLCJib3R0b20iLCJ0b3AiLCJzY3JvbGxUb1RvcCIsInNjcm9sbFRvQm90dG9tIiwic2Nyb2xsUmVsYXRpdmUiLCJtdWx0IiwiaGFuZGxlU2Nyb2xsS2V5Iiwic2Nyb2xsVG9FdmVudCIsInBpeGVsT2Zmc2V0Iiwib2Zmc2V0QmFzZSIsInNjcm9sbFRvVG9rZW4iLCJzY3JvbGxUb0V2ZW50SWZOZWVkZWQiLCJzY3JvbGxJbnRvVmlldyIsImJsb2NrIiwiYmVoYXZpb3IiLCJjaGVja0ZpbGxTdGF0ZSIsInNob3VsZFNob3dFdmVudCIsIm14RXYiLCJNYXRyaXhDbGllbnRQZWciLCJnZXQiLCJpc1VzZXJJZ25vcmVkIiwiZ2V0U2VuZGVyIiwiaGlnaGxpZ2h0ZWRFdmVudElkIiwiZ2V0SWQiLCJpc1RocmVhZFJlbGF0aW9uIiwiaGlkZVRocmVhZGVkTWVzc2FnZXMiLCJyZWFkTWFya2VyRm9yRXZlbnQiLCJpc0xhc3RFdmVudCIsInZpc2libGUiLCJociIsImNvbGxlY3RHaG9zdFJlYWRNYXJrZXIiLCJvbkdob3N0VHJhbnNpdGlvbkVuZCIsImdldE5leHRFdmVudEluZm8iLCJhcnIiLCJpIiwibmV4dEV2ZW50IiwibmV4dFRpbGUiLCJzbGljZSIsImZpbmQiLCJlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInJvb21JZCIsImVyciIsImxvZ2dlciIsImVycm9yIiwiZ2V0RXZlbnRUaWxlcyIsImxhc3RTaG93bkV2ZW50IiwibGFzdFNob3duTm9uTG9jYWxFY2hvSW5kZXgiLCJldmVudHMiLCJzdGF0dXMiLCJyZXQiLCJyZWFkUmVjZWlwdHNCeUV2ZW50Iiwic2hvd1JlYWRSZWNlaXB0cyIsImdldFJlYWRSZWNlaXB0c0J5U2hvd25FdmVudCIsImdyb3VwZXIiLCJsYXN0IiwiaW5kZXhPZiIsImNhbGxJZCIsImdldENvbnRlbnQiLCJjYWxsX2lkIiwiY2FsbEV2ZW50R3JvdXBlcnMiLCJoYXMiLCJhZGQiLCJjYWxsRXZlbnRHcm91cGVyIiwiQ2FsbEV2ZW50R3JvdXBlciIsInNldCIsInNob3VsZEdyb3VwIiwiZ2V0VGlsZXMiLCJnZXROZXdQcmV2RXZlbnQiLCJHcm91cGVyIiwiZ3JvdXBlcnMiLCJjYW5TdGFydEdyb3VwIiwiZGlzYWJsZUdyb3VwaW5nIiwibGF5b3V0Iiwid2FudFRpbGUiLCJpc0dyb3VwZWQiLCJnZXRUaWxlc0ZvckV2ZW50IiwibmV4dEV2ZW50V2l0aFRpbGUiLCJpc0VkaXRpbmciLCJnZXRFdmVudCIsInRzMSIsImV2ZW50RGF0ZSIsImdldERhdGUiLCJEYXRlIiwiZ2V0VGltZSIsIndhbnRzRGF0ZVNlcGFyYXRvciIsImRhdGVTZXBhcmF0b3IiLCJ3aWxsV2FudERhdGVTZXBhcmF0b3IiLCJsYXN0SW5TZWN0aW9uIiwiY29udGludWF0aW9uIiwiaGlnaGxpZ2h0IiwicmVhZFJlY2VpcHRzIiwiaXNMYXN0U3VjY2Vzc2Z1bCIsImlzU2VudFN0YXRlIiwicyIsImlzU2VudCIsImdldEFzc29jaWF0ZWRTdGF0dXMiLCJoYXNOZXh0RXZlbnQiLCJnZXRVc2VySWQiLCJnZXRUeG5JZCIsImNvbGxlY3RFdmVudE5vZGUiLCJiaW5kIiwiYWx3YXlzU2hvd1RpbWVzdGFtcHMiLCJyZXBsYWNpbmdFdmVudElkIiwib25IZWlnaHRDaGFuZ2VkIiwicmVhZFJlY2VpcHRNYXAiLCJzaG93VXJsUHJldmlldyIsImlzVW5tb3VudGluZyIsInRpbGVTaGFwZSIsImlzVHdlbHZlSG91ciIsInBlcm1hbGlua0NyZWF0b3IiLCJnZXRSZWxhdGlvbnNGb3JFdmVudCIsInNob3dSZWFjdGlvbnMiLCJlbmFibGVGbGFpciIsIkxheW91dCIsIkJ1YmJsZSIsIm5leHRFdmVudERhdGUiLCJzdXBwcmVzc0ZpcnN0RGF0ZVNlcGFyYXRvciIsImdldFJlYWRSZWNlaXB0c0ZvckV2ZW50IiwibXlVc2VySWQiLCJjcmVkZW50aWFscyIsInJlY2VpcHRzIiwiZ2V0UmVjZWlwdHNGb3JFdmVudCIsImZvckVhY2giLCJyIiwidHlwZSIsIm1lbWJlciIsImdldE1lbWJlciIsInJvb21NZW1iZXIiLCJ0cyIsImRhdGEiLCJyZWNlaXB0c0J5RXZlbnQiLCJyZWNlaXB0c0J5VXNlcklkIiwibGFzdFNob3duRXZlbnRJZCIsImV4aXN0aW5nUmVjZWlwdHMiLCJuZXdSZWNlaXB0cyIsImNvbmNhdCIsInJlY2VpcHQiLCJyZWFkUmVjZWlwdHNCeVVzZXJJZCIsInNvcnQiLCJyMSIsInIyIiwidXBkYXRlVGltZWxpbmVNaW5IZWlnaHQiLCJ3aG9Jc1R5cGluZyIsImlzVHlwaW5nVmlzaWJsZSIsImlzVmlzaWJsZSIsIm9uVGltZWxpbmVSZXNldCIsImNsZWFyUHJldmVudFNocmlua2luZyIsInJlbmRlciIsInRvcFNwaW5uZXIiLCJib3R0b21TcGlubmVyIiwiYmFja1BhZ2luYXRpbmciLCJmb3J3YXJkUGFnaW5hdGluZyIsImhpZGRlbiIsImRpc3BsYXkiLCJvblR5cGluZ1Nob3duIiwib25UeXBpbmdIaWRkZW4iLCJpcmNSZXNpemVyIiwiSVJDIiwiY2xhc3NOYW1lIiwib25TY3JvbGwiLCJvblVzZXJTY3JvbGwiLCJvbkZpbGxSZXF1ZXN0Iiwib25VbmZpbGxSZXF1ZXN0Iiwic3RpY2t5Qm90dG9tIiwicmVzaXplTm90aWZpZXIiLCJSb29tQ29udGV4dCIsIkJhc2VHcm91cGVyIiwicGFuZWwiLCJuZXh0RXZlbnRUaWxlIiwiQ3JlYXRpb25Hcm91cGVyIiwiY3JlYXRlRXZlbnQiLCJnZXRTdGF0ZUtleSIsImlzU3RhdGUiLCJSb29tRW5jcnlwdGlvbiIsImVqZWN0ZWRFdmVudHMiLCJlamVjdGVkIiwiZXZlbnRUaWxlcyIsIm1hcCIsInJlZHVjZSIsImEiLCJiIiwic3VtbWFyeVRleHQiLCJnZXRSb29tSWQiLCJjcmVhdG9yIiwiRE1Sb29tTWFwIiwic2hhcmVkIiwiZ2V0VXNlcklkRm9yUm9vbUlkIiwiUm9vbUNyZWF0ZSIsIlJlZGFjdGlvbkdyb3VwZXIiLCJrZXkiLCJzZW5kZXJzIiwiU2V0IiwiQXJyYXkiLCJmcm9tIiwiY291bnQiLCJNZW1iZXJHcm91cGVyIiwiaGlnaGxpZ2h0SW5NZWxzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFnQkE7O0FBQ0E7O0FBRUE7O0FBS0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBR0E7O0FBQ0E7Ozs7Ozs7O0FBRUEsTUFBTUEseUJBQXlCLEdBQUcsSUFBSSxFQUFKLEdBQVMsSUFB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QUMzRSxTQUFPaU8sS0FBSyxDQUFDekosZUFBTixDQUFzQnhFLEVBQXRCLEtBQTZCekMsYUFBYSxDQUFDZ0IsUUFBZCxDQUF1QnlCLEVBQUUsQ0FBQzFCLE9BQUgsRUFBdkIsQ0FBcEM7QUFDSCxDO0FBdUdMLE1BQU15SixRQUFRLEdBQUcsQ0FBQ29HLGVBQUQsRUFBa0IwQixhQUFsQixFQUFpQ1AsZ0JBQWpDLENBQWpCIiwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE2IC0gMjAyMSBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVSZWYsIEtleWJvYXJkRXZlbnQsIFJlYWN0Tm9kZSwgU3ludGhldGljRXZlbnQsIFRyYW5zaXRpb25FdmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsgUm9vbSB9IGZyb20gJ21hdHJpeC1qcy1zZGsvc3JjL21vZGVscy9yb29tJztcbmltcG9ydCB7IEV2ZW50VHlwZSB9IGZyb20gJ21hdHJpeC1qcy1zZGsvc3JjL0B0eXBlcy9ldmVudCc7XG5pbXBvcnQgeyBNYXRyaXhFdmVudCB9IGZyb20gJ21hdHJpeC1qcy1zZGsvc3JjL21vZGVscy9ldmVudCc7XG5pbXBvcnQgeyBSZWxhdGlvbnMgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvbW9kZWxzL3JlbGF0aW9uc1wiO1xuaW1wb3J0IHsgUm9vbU1lbWJlciB9IGZyb20gJ21hdHJpeC1qcy1zZGsvc3JjL21vZGVscy9yb29tLW1lbWJlcic7XG5cbmltcG9ydCBzaG91bGRIaWRlRXZlbnQgZnJvbSAnLi4vLi4vc2hvdWxkSGlkZUV2ZW50JztcbmltcG9ydCB7IHdhbnRzRGF0ZVNlcGFyYXRvciB9IGZyb20gJy4uLy4uL0RhdGVVdGlscyc7XG5pbXBvcnQgeyBNYXRyaXhDbGllbnRQZWcgfSBmcm9tICcuLi8uLi9NYXRyaXhDbGllbnRQZWcnO1xuaW1wb3J0IFNldHRpbmdzU3RvcmUgZnJvbSAnLi4vLi4vc2V0dGluZ3MvU2V0dGluZ3NTdG9yZSc7XG5pbXBvcnQgUm9vbUNvbnRleHQsIHsgVGltZWxpbmVSZW5kZXJpbmdUeXBlIH0gZnJvbSBcIi4uLy4uL2NvbnRleHRzL1Jvb21Db250ZXh0XCI7XG5pbXBvcnQgeyBMYXlvdXQgfSBmcm9tIFwiLi4vLi4vc2V0dGluZ3MvZW51bXMvTGF5b3V0XCI7XG5pbXBvcnQgeyBfdCB9IGZyb20gXCIuLi8uLi9sYW5ndWFnZUhhbmRsZXJcIjtcbmltcG9ydCBFdmVudFRpbGUsIHsgaGF2ZVRpbGVGb3JFdmVudCwgSVJlYWRSZWNlaXB0UHJvcHMsIFRpbGVTaGFwZSB9IGZyb20gXCIuLi92aWV3cy9yb29tcy9FdmVudFRpbGVcIjtcbmltcG9ydCB7IGhhc1RleHQgfSBmcm9tIFwiLi4vLi4vVGV4dEZvckV2ZW50XCI7XG5pbXBvcnQgSVJDVGltZWxpbmVQcm9maWxlUmVzaXplciBmcm9tIFwiLi4vdmlld3MvZWxlbWVudHMvSVJDVGltZWxpbmVQcm9maWxlUmVzaXplclwiO1xuaW1wb3J0IERNUm9vbU1hcCBmcm9tIFwiLi4vLi4vdXRpbHMvRE1Sb29tTWFwXCI7XG5pbXBvcnQgTmV3Um9vbUludHJvIGZyb20gXCIuLi92aWV3cy9yb29tcy9OZXdSb29tSW50cm9cIjtcbmltcG9ydCB7IHJlcGxhY2VhYmxlQ29tcG9uZW50IH0gZnJvbSBcIi4uLy4uL3V0aWxzL3JlcGxhY2VhYmxlQ29tcG9uZW50XCI7XG5pbXBvcnQgZGVmYXVsdERpc3BhdGNoZXIgZnJvbSAnLi4vLi4vZGlzcGF0Y2hlci9kaXNwYXRjaGVyJztcbmltcG9ydCBDYWxsRXZlbnRHcm91cGVyIGZyb20gXCIuL0NhbGxFdmVudEdyb3VwZXJcIjtcbmltcG9ydCBXaG9Jc1R5cGluZ1RpbGUgZnJvbSAnLi4vdmlld3Mvcm9vbXMvV2hvSXNUeXBpbmdUaWxlJztcbmltcG9ydCBTY3JvbGxQYW5lbCwgeyBJU2Nyb2xsU3RhdGUgfSBmcm9tIFwiLi9TY3JvbGxQYW5lbFwiO1xuaW1wb3J0IEV2ZW50TGlzdFN1bW1hcnkgZnJvbSAnLi4vdmlld3MvZWxlbWVudHMvRXZlbnRMaXN0U3VtbWFyeSc7XG5pbXBvcnQgTWVtYmVyRXZlbnRMaXN0U3VtbWFyeSBmcm9tICcuLi92aWV3cy9lbGVtZW50cy9NZW1iZXJFdmVudExpc3RTdW1tYXJ5JztcbmltcG9ydCBEYXRlU2VwYXJhdG9yIGZyb20gJy4uL3ZpZXdzL21lc3NhZ2VzL0RhdGVTZXBhcmF0b3InO1xuaW1wb3J0IEVycm9yQm91bmRhcnkgZnJvbSAnLi4vdmlld3MvZWxlbWVudHMvRXJyb3JCb3VuZGFyeSc7XG5pbXBvcnQgUmVzaXplTm90aWZpZXIgZnJvbSBcIi4uLy4uL3V0aWxzL1Jlc2l6ZU5vdGlmaWVyXCI7XG5pbXBvcnQgU3Bpbm5lciBmcm9tIFwiLi4vdmlld3MvZWxlbWVudHMvU3Bpbm5lclwiO1xuaW1wb3J0IFRpbGVFcnJvckJvdW5kYXJ5IGZyb20gJy4uL3ZpZXdzL21lc3NhZ2VzL1RpbGVFcnJvckJvdW5kYXJ5JztcbmltcG9ydCB7IFJvb21QZXJtYWxpbmtDcmVhdG9yIH0gZnJvbSBcIi4uLy4uL3V0aWxzL3Blcm1hbGlua3MvUGVybWFsaW5rc1wiO1xuaW1wb3J0IEVkaXRvclN0YXRlVHJhbnNmZXIgZnJvbSBcIi4uLy4uL3V0aWxzL0VkaXRvclN0YXRlVHJhbnNmZXJcIjtcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ21hdHJpeC1qcy1zZGsvc3JjL2xvZ2dlcic7XG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tICcuLi8uLi9kaXNwYXRjaGVyL2FjdGlvbnMnO1xuXG5jb25zdCBDT05USU5VQVRJT05fTUFYX0lOVEVSVkFMID0gNSAqIDYwICogMTAwMDsgLy8gNSBtaW51dGVzXG5jb25zdCBjb250aW51ZWRUeXBlcyA9IFtFdmVudFR5cGUuU3RpY2tlciwgRXZlbnRUeXBlLlJvb21NZXNzYWdlXTtcbmNvbnN0IGdyb3VwZWRFdmVudHMgPSBbXG4gICAgRXZlbnRUeXBlLlJvb21NZW1iZXIsXG4gICAgRXZlbnRUeXBlLlJvb21UaGlyZFBhcnR5SW52aXRlLFxuICAgIEV2ZW50VHlwZS5Sb29tU2VydmVyQWNsLFxuICAgIEV2ZW50VHlwZS5Sb29tUGlubmVkRXZlbnRzLFxuXTtcblxuLy8gY2hlY2sgaWYgdGhlcmUgaXMgYSBwcmV2aW91cyBldmVudCBhbmQgaXQgaGFzIHRoZSBzYW1lIHNlbmRlciBhcyB0aGlzIGV2ZW50XG4vLyBhbmQgdGhlIHR5cGVzIGFyZSB0aGUgc2FtZS9pcyBpbiBjb250aW51ZWRUeXBlcyBhbmQgdGhlIHRpbWUgYmV0d2VlbiB0aGVtIGlzIDw9IENPTlRJTlVBVElPTl9NQVhfSU5URVJWQUxcbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRGb3JtQ29udGludWF0aW9uKFxuICAgIHByZXZFdmVudDogTWF0cml4RXZlbnQsXG4gICAgbXhFdmVudDogTWF0cml4RXZlbnQsXG4gICAgc2hvd0hpZGRlbkV2ZW50czogYm9vbGVhbixcbiAgICB0aW1lbGluZVJlbmRlcmluZ1R5cGU/OiBUaW1lbGluZVJlbmRlcmluZ1R5cGUsXG4pOiBib29sZWFuIHtcbiAgICBpZiAodGltZWxpbmVSZW5kZXJpbmdUeXBlID09PSBUaW1lbGluZVJlbmRlcmluZ1R5cGUuVGhyZWFkc0xpc3QpIHJldHVybiBmYWxzZTtcbiAgICAvLyBzYW5pdHkgY2hlY2sgaW5wdXRzXG4gICAgaWYgKCFwcmV2RXZlbnQgfHwgIXByZXZFdmVudC5zZW5kZXIgfHwgIW14RXZlbnQuc2VuZGVyKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gY2hlY2sgaWYgd2l0aGluIHRoZSBtYXggY29udGludWF0aW9uIHBlcmlvZFxuICAgIGlmIChteEV2ZW50LmdldFRzKCkgLSBwcmV2RXZlbnQuZ2V0VHMoKSA+IENPTlRJTlVBVElPTl9NQVhfSU5URVJWQUwpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIEFzIHdlIHN1bW1hcmlzZSByZWRhY3Rpb25zLCBkbyBub3QgY29udGludWUgYSByZWRhY3RlZCBldmVudCBvbnRvIGEgbm9uLXJlZGFjdGVkIG9uZSBhbmQgdmljZS12ZXJzYVxuICAgIGlmIChteEV2ZW50LmlzUmVkYWN0ZWQoKSAhPT0gcHJldkV2ZW50LmlzUmVkYWN0ZWQoKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gU29tZSBldmVudHMgc2hvdWxkIGFwcGVhciBhcyBjb250aW51YXRpb25zIGZyb20gcHJldmlvdXMgZXZlbnRzIG9mIGRpZmZlcmVudCB0eXBlcy5cbiAgICBpZiAobXhFdmVudC5nZXRUeXBlKCkgIT09IHByZXZFdmVudC5nZXRUeXBlKCkgJiZcbiAgICAgICAgKCFjb250aW51ZWRUeXBlcy5pbmNsdWRlcyhteEV2ZW50LmdldFR5cGUoKSBhcyBFdmVudFR5cGUpIHx8XG4gICAgICAgICAgICAhY29udGludWVkVHlwZXMuaW5jbHVkZXMocHJldkV2ZW50LmdldFR5cGUoKSBhcyBFdmVudFR5cGUpKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHNlbmRlciBpcyB0aGUgc2FtZSBhbmQgaGFzbid0IGNoYW5nZWQgdGhlaXIgZGlzcGxheW5hbWUvYXZhdGFyIGJldHdlZW4gdGhlc2UgZXZlbnRzXG4gICAgaWYgKG14RXZlbnQuc2VuZGVyLnVzZXJJZCAhPT0gcHJldkV2ZW50LnNlbmRlci51c2VySWQgfHxcbiAgICAgICAgbXhFdmVudC5zZW5kZXIubmFtZSAhPT0gcHJldkV2ZW50LnNlbmRlci5uYW1lIHx8XG4gICAgICAgIG14RXZlbnQuc2VuZGVyLmdldE14Y0F2YXRhclVybCgpICE9PSBwcmV2RXZlbnQuc2VuZGVyLmdldE14Y0F2YXRhclVybCgpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBpZiB3ZSBkb24ndCBoYXZlIHRpbGUgZm9yIHByZXZpb3VzIGV2ZW50IHRoZW4gaXQgd2FzIHNob3duIGJ5IHNob3dIaWRkZW5FdmVudHMgYW5kIGhhcyBubyBTZW5kZXJQcm9maWxlXG4gICAgaWYgKCFoYXZlVGlsZUZvckV2ZW50KHByZXZFdmVudCwgc2hvd0hpZGRlbkV2ZW50cykpIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5pbnRlcmZhY2UgSVByb3BzIHtcbiAgICAvLyB0aGUgbGlzdCBvZiBNYXRyaXhFdmVudHMgdG8gZGlzcGxheVxuICAgIGV2ZW50czogTWF0cml4RXZlbnRbXTtcblxuICAgIC8vIHRydWUgdG8gZ2l2ZSB0aGUgY29tcG9uZW50IGEgJ2Rpc3BsYXk6IG5vbmUnIHN0eWxlLlxuICAgIGhpZGRlbj86IGJvb2xlYW47XG5cbiAgICAvLyB0cnVlIHRvIHNob3cgYSBzcGlubmVyIGF0IHRoZSB0b3Agb2YgdGhlIHRpbWVsaW5lIHRvIGluZGljYXRlXG4gICAgLy8gYmFjay1wYWdpbmF0aW9uIGluIHByb2dyZXNzXG4gICAgYmFja1BhZ2luYXRpbmc/OiBib29sZWFuO1xuXG4gICAgLy8gdHJ1ZSB0byBzaG93IGEgc3Bpbm5lciBhdCB0aGUgZW5kIG9mIHRoZSB0aW1lbGluZSB0byBpbmRpY2F0ZVxuICAgIC8vIGZvcndhcmQtcGFnaW5hdGlvbiBpbiBwcm9ncmVzc1xuICAgIGZvcndhcmRQYWdpbmF0aW5nPzogYm9vbGVhbjtcblxuICAgIC8vIElEIG9mIGFuIGV2ZW50IHRvIGhpZ2hsaWdodC4gSWYgdW5kZWZpbmVkLCBubyBldmVudCB3aWxsIGJlIGhpZ2hsaWdodGVkLlxuICAgIGhpZ2hsaWdodGVkRXZlbnRJZD86IHN0cmluZztcblxuICAgIC8vIFRoZSByb29tIHRoZXNlIGV2ZW50cyBhcmUgYWxsIGluIHRvZ2V0aGVyLCBpZiBhbnkuXG4gICAgLy8gKFRoZSBub3RpZmljYXRpb24gcGFuZWwgd29uJ3QgaGF2ZSBhIHJvb20gaGVyZSwgZm9yIGV4YW1wbGUuKVxuICAgIHJvb20/OiBSb29tO1xuXG4gICAgLy8gU2hvdWxkIHdlIHNob3cgVVJMIFByZXZpZXdzXG4gICAgc2hvd1VybFByZXZpZXc/OiBib29sZWFuO1xuXG4gICAgLy8gZXZlbnQgYWZ0ZXIgd2hpY2ggd2Ugc2hvdWxkIHNob3cgYSByZWFkIG1hcmtlclxuICAgIHJlYWRNYXJrZXJFdmVudElkPzogc3RyaW5nO1xuXG4gICAgLy8gd2hldGhlciB0aGUgcmVhZCBtYXJrZXIgc2hvdWxkIGJlIHZpc2libGVcbiAgICByZWFkTWFya2VyVmlzaWJsZT86IGJvb2xlYW47XG5cbiAgICAvLyB0aGUgdXNlcmlkIG9mIG91ciB1c2VyLiBUaGlzIGlzIHVzZWQgdG8gc3VwcHJlc3MgdGhlIHJlYWQgbWFya2VyXG4gICAgLy8gZm9yIHBlbmRpbmcgbWVzc2FnZXMuXG4gICAgb3VyVXNlcklkPzogc3RyaW5nO1xuXG4gICAgLy8gdHJ1ZSB0byBzdXBwcmVzcyB0aGUgZGF0ZSBhdCB0aGUgc3RhcnQgb2YgdGhlIHRpbWVsaW5lXG4gICAgc3VwcHJlc3NGaXJzdERhdGVTZXBhcmF0b3I/OiBib29sZWFuO1xuXG4gICAgLy8gd2hldGhlciB0byBzaG93IHJlYWQgcmVjZWlwdHNcbiAgICBzaG93UmVhZFJlY2VpcHRzPzogYm9vbGVhbjtcblxuICAgIC8vIHRydWUgaWYgdXBkYXRlcyB0byB0aGUgZXZlbnQgbGlzdCBzaG91bGQgY2F1c2UgdGhlIHNjcm9sbCBwYW5lbCB0b1xuICAgIC8vIHNjcm9sbCBkb3duIHdoZW4gd2UgYXJlIGF0IHRoZSBib3R0b20gb2YgdGhlIHdpbmRvdy4gU2VlIFNjcm9sbFBhbmVsXG4gICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICBzdGlja3lCb3R0b20/OiBib29sZWFuO1xuXG4gICAgLy8gY2xhc3NOYW1lIGZvciB0aGUgcGFuZWxcbiAgICBjbGFzc05hbWU6IHN0cmluZztcblxuICAgIC8vIHNoYXBlIHBhcmFtZXRlciB0byBiZSBwYXNzZWQgdG8gRXZlbnRUaWxlc1xuICAgIHRpbGVTaGFwZT86IFRpbGVTaGFwZTtcblxuICAgIC8vIHNob3cgdHdlbHZlIGhvdXIgdGltZXN0YW1wc1xuICAgIGlzVHdlbHZlSG91cj86IGJvb2xlYW47XG5cbiAgICAvLyBzaG93IHRpbWVzdGFtcHMgYWx3YXlzXG4gICAgYWx3YXlzU2hvd1RpbWVzdGFtcHM/OiBib29sZWFuO1xuXG4gICAgLy8gd2hldGhlciB0byBzaG93IHJlYWN0aW9ucyBmb3IgYW4gZXZlbnRcbiAgICBzaG93UmVhY3Rpb25zPzogYm9vbGVhbjtcblxuICAgIC8vIHdoaWNoIGxheW91dCB0byB1c2VcbiAgICBsYXlvdXQ/OiBMYXlvdXQ7XG5cbiAgICAvLyB3aGV0aGVyIG9yIG5vdCB0byBzaG93IGZsYWlyIGF0IGFsbFxuICAgIGVuYWJsZUZsYWlyPzogYm9vbGVhbjtcblxuICAgIHJlc2l6ZU5vdGlmaWVyOiBSZXNpemVOb3RpZmllcjtcbiAgICBwZXJtYWxpbmtDcmVhdG9yPzogUm9vbVBlcm1hbGlua0NyZWF0b3I7XG4gICAgZWRpdFN0YXRlPzogRWRpdG9yU3RhdGVUcmFuc2ZlcjtcblxuICAgIC8vIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHRoZSBwYW5lbCBpcyBzY3JvbGxlZC5cbiAgICBvblNjcm9sbD8oZXZlbnQ6IEV2ZW50KTogdm9pZDtcblxuICAgIC8vIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGludGVyYWN0cyB3aXRoIHRoZSByb29tIHRpbWVsaW5lXG4gICAgb25Vc2VyU2Nyb2xsKGV2ZW50OiBTeW50aGV0aWNFdmVudCk6IHZvaWQ7XG5cbiAgICAvLyBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBtb3JlIGNvbnRlbnQgaXMgbmVlZGVkLlxuICAgIG9uRmlsbFJlcXVlc3Q/KGJhY2t3YXJkczogYm9vbGVhbik6IFByb21pc2U8Ym9vbGVhbj47XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gdG8gYWNjZXNzIHJlbGF0aW9ucyBmb3IgYW4gZXZlbnRcbiAgICBvblVuZmlsbFJlcXVlc3Q/KGJhY2t3YXJkczogYm9vbGVhbiwgc2Nyb2xsVG9rZW46IHN0cmluZyk6IHZvaWQ7XG5cbiAgICBnZXRSZWxhdGlvbnNGb3JFdmVudD8oZXZlbnRJZDogc3RyaW5nLCByZWxhdGlvblR5cGU6IHN0cmluZywgZXZlbnRUeXBlOiBzdHJpbmcpOiBSZWxhdGlvbnM7XG5cbiAgICBoaWRlVGhyZWFkZWRNZXNzYWdlcz86IGJvb2xlYW47XG4gICAgZGlzYWJsZUdyb3VwaW5nPzogYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIElTdGF0ZSB7XG4gICAgZ2hvc3RSZWFkTWFya2Vyczogc3RyaW5nW107XG4gICAgc2hvd1R5cGluZ05vdGlmaWNhdGlvbnM6IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBJUmVhZFJlY2VpcHRGb3JVc2VyIHtcbiAgICBsYXN0U2hvd25FdmVudElkOiBzdHJpbmc7XG4gICAgcmVjZWlwdDogSVJlYWRSZWNlaXB0UHJvcHM7XG59XG5cbi8qIChhbG1vc3QpIHN0YXRlbGVzcyBVSSBjb21wb25lbnQgd2hpY2ggYnVpbGRzIHRoZSBldmVudCB0aWxlcyBpbiB0aGUgcm9vbSB0aW1lbGluZS5cbiAqL1xuQHJlcGxhY2VhYmxlQ29tcG9uZW50KFwic3RydWN0dXJlcy5NZXNzYWdlUGFuZWxcIilcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lc3NhZ2VQYW5lbCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxJUHJvcHMsIElTdGF0ZT4ge1xuICAgIHN0YXRpYyBjb250ZXh0VHlwZSA9IFJvb21Db250ZXh0O1xuICAgIHB1YmxpYyBjb250ZXh0ITogUmVhY3QuQ29udGV4dFR5cGU8dHlwZW9mIFJvb21Db250ZXh0PjtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGRpc2FibGVHcm91cGluZzogZmFsc2UsXG4gICAgfTtcblxuICAgIC8vIG9wYXF1ZSByZWFkcmVjZWlwdCBpbmZvIGZvciBlYWNoIHVzZXJJZDsgdXNlZCBieSBSZWFkUmVjZWlwdE1hcmtlclxuICAgIC8vIHRvIG1hbmFnZSBpdHMgYW5pbWF0aW9uc1xuICAgIHByaXZhdGUgcmVhZG9ubHkgcmVhZFJlY2VpcHRNYXA6IFJlY29yZDxzdHJpbmcsIG9iamVjdD4gPSB7fTtcblxuICAgIC8vIFRyYWNrIHJlYWQgcmVjZWlwdHMgYnkgZXZlbnQgSUQuIEZvciBlYWNoIF9zaG93bl8gZXZlbnQgSUQsIHdlIHN0b3JlXG4gICAgLy8gdGhlIGxpc3Qgb2YgcmVhZCByZWNlaXB0cyB0byBkaXNwbGF5OlxuICAgIC8vICAgW1xuICAgIC8vICAgICAgIHtcbiAgICAvLyAgICAgICAgICAgdXNlcklkOiBzdHJpbmcsXG4gICAgLy8gICAgICAgICAgIG1lbWJlcjogUm9vbU1lbWJlcixcbiAgICAvLyAgICAgICAgICAgdHM6IG51bWJlcixcbiAgICAvLyAgICAgICB9LFxuICAgIC8vICAgXVxuICAgIC8vIFRoaXMgaXMgcmVjb21wdXRlZCBvbiBlYWNoIHJlbmRlci4gSXQncyBvbmx5IHN0b3JlZCBvbiB0aGUgY29tcG9uZW50XG4gICAgLy8gZm9yIGVhc2Ugb2YgcGFzc2luZyB0aGUgZGF0YSBhcm91bmQgc2luY2UgaXQncyBjb21wdXRlZCBpbiBvbmUgcGFzc1xuICAgIC8vIG92ZXIgYWxsIGV2ZW50cy5cbiAgICBwcml2YXRlIHJlYWRSZWNlaXB0c0J5RXZlbnQ6IFJlY29yZDxzdHJpbmcsIElSZWFkUmVjZWlwdFByb3BzW10+ID0ge307XG5cbiAgICAvLyBUcmFjayByZWFkIHJlY2VpcHRzIGJ5IHVzZXIgSUQuIEZvciBlYWNoIHVzZXIgSUQgd2UndmUgZXZlciBzaG93biBhXG4gICAgLy8gYSByZWFkIHJlY2VpcHQgZm9yLCB3ZSBzdG9yZSBhbiBvYmplY3Q6XG4gICAgLy8gICB7XG4gICAgLy8gICAgICAgbGFzdFNob3duRXZlbnRJZDogc3RyaW5nLFxuICAgIC8vICAgICAgIHJlY2VpcHQ6IHtcbiAgICAvLyAgICAgICAgICAgdXNlcklkOiBzdHJpbmcsXG4gICAgLy8gICAgICAgICAgIG1lbWJlcjogUm9vbU1lbWJlcixcbiAgICAvLyAgICAgICAgICAgdHM6IG51bWJlcixcbiAgICAvLyAgICAgICB9LFxuICAgIC8vICAgfVxuICAgIC8vIHNvIHRoYXQgd2UgY2FuIGFsd2F5cyBrZWVwIHJlY2VpcHRzIGRpc3BsYXllZCBieSByZXZlcnRpbmcgYmFjayB0b1xuICAgIC8vIHRoZSBsYXN0IHNob3duIGV2ZW50IGZvciB0aGF0IHVzZXIgSUQgd2hlbiBuZWVkZWQuIFRoaXMgbWF5IGZlZWwgbGlrZVxuICAgIC8vIGl0IGR1cGxpY2F0ZXMgdGhlIHJlY2VpcHQgc3RvcmFnZSBpbiB0aGUgcm9vbSwgYnV0IGF0IHRoaXMgbGF5ZXIsIHdlXG4gICAgLy8gYXJlIHRyYWNraW5nIF9zaG93bl8gZXZlbnQgSURzLCB3aGljaCB0aGUgSlMgU0RLIGtub3dzIG5vdGhpbmcgYWJvdXQuXG4gICAgLy8gVGhpcyBpcyByZWNvbXB1dGVkIG9uIGVhY2ggcmVuZGVyLCB1c2luZyB0aGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91c1xuICAgIC8vIHJlbmRlciBhcyBvdXIgZmFsbGJhY2sgZm9yIGFueSB1c2VyIElEcyB3ZSBjYW4ndCBtYXRjaCBhIHJlY2VpcHQgdG8gYVxuICAgIC8vIGRpc3BsYXllZCBldmVudCBpbiB0aGUgY3VycmVudCByZW5kZXIgY3ljbGUuXG4gICAgcHJpdmF0ZSByZWFkUmVjZWlwdHNCeVVzZXJJZDogUmVjb3JkPHN0cmluZywgSVJlYWRSZWNlaXB0Rm9yVXNlcj4gPSB7fTtcblxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2hvd0hpZGRlbkV2ZW50c0luVGltZWxpbmU6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBpc01vdW50ZWQgPSBmYWxzZTtcblxuICAgIHByaXZhdGUgcmVhZE1hcmtlck5vZGUgPSBjcmVhdGVSZWY8SFRNTExJRWxlbWVudD4oKTtcbiAgICBwcml2YXRlIHdob0lzVHlwaW5nID0gY3JlYXRlUmVmPFdob0lzVHlwaW5nVGlsZT4oKTtcbiAgICBwcml2YXRlIHNjcm9sbFBhbmVsID0gY3JlYXRlUmVmPFNjcm9sbFBhbmVsPigpO1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSBzaG93VHlwaW5nTm90aWZpY2F0aW9uc1dhdGNoZXJSZWY6IHN0cmluZztcbiAgICBwcml2YXRlIGV2ZW50Tm9kZXM6IFJlY29yZDxzdHJpbmcsIEhUTUxFbGVtZW50PjtcblxuICAgIC8vIEEgbWFwIG9mIDxjYWxsSWQsIENhbGxFdmVudEdyb3VwZXI+XG4gICAgcHJpdmF0ZSBjYWxsRXZlbnRHcm91cGVycyA9IG5ldyBNYXA8c3RyaW5nLCBDYWxsRXZlbnRHcm91cGVyPigpO1xuXG4gICAgcHJpdmF0ZSBtZW1iZXJzQ291bnQgPSAwO1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIocHJvcHMsIGNvbnRleHQpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICAvLyBwcmV2aW91cyBwb3NpdGlvbnMgdGhlIHJlYWQgbWFya2VyIGhhcyBiZWVuIGluLCBzbyB3ZSBjYW5cbiAgICAgICAgICAgIC8vIGRpc3BsYXkgJ2dob3N0JyByZWFkIG1hcmtlcnMgdGhhdCBhcmUgYW5pbWF0aW5nIGF3YXlcbiAgICAgICAgICAgIGdob3N0UmVhZE1hcmtlcnM6IFtdLFxuICAgICAgICAgICAgc2hvd1R5cGluZ05vdGlmaWNhdGlvbnM6IFNldHRpbmdzU3RvcmUuZ2V0VmFsdWUoXCJzaG93VHlwaW5nTm90aWZpY2F0aW9uc1wiKSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDYWNoZSBoaWRkZW4gZXZlbnRzIHNldHRpbmcgb24gbW91bnQgc2luY2UgU2V0dGluZ3MgaXMgZXhwZW5zaXZlIHRvXG4gICAgICAgIC8vIHF1ZXJ5LCBhbmQgd2UgY2hlY2sgdGhpcyBpbiBhIGhvdCBjb2RlIHBhdGguIFRoaXMgaXMgYWxzbyBjYWNoZWQgaW5cbiAgICAgICAgLy8gb3VyIFJvb21Db250ZXh0LCBob3dldmVyIHdlIHN0aWxsIG5lZWQgYSBmYWxsYmFjayBmb3Igcm9vbWxlc3MgTWVzc2FnZVBhbmVscy5cbiAgICAgICAgdGhpcy5zaG93SGlkZGVuRXZlbnRzSW5UaW1lbGluZSA9IFNldHRpbmdzU3RvcmUuZ2V0VmFsdWUoXCJzaG93SGlkZGVuRXZlbnRzSW5UaW1lbGluZVwiKTtcblxuICAgICAgICB0aGlzLnNob3dUeXBpbmdOb3RpZmljYXRpb25zV2F0Y2hlclJlZiA9XG4gICAgICAgICAgICBTZXR0aW5nc1N0b3JlLndhdGNoU2V0dGluZyhcInNob3dUeXBpbmdOb3RpZmljYXRpb25zXCIsIG51bGwsIHRoaXMub25TaG93VHlwaW5nTm90aWZpY2F0aW9uc0NoYW5nZSk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlUm9vbU1lbWJlcnNDb3VudCgpO1xuICAgICAgICB0aGlzLnByb3BzLnJvb20/Lm9uKFwiUm9vbVN0YXRlLm1lbWJlcnNcIiwgdGhpcy5jYWxjdWxhdGVSb29tTWVtYmVyc0NvdW50KTtcbiAgICAgICAgdGhpcy5pc01vdW50ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLmlzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByb3BzLnJvb20/Lm9mZihcIlJvb21TdGF0ZS5tZW1iZXJzXCIsIHRoaXMuY2FsY3VsYXRlUm9vbU1lbWJlcnNDb3VudCk7XG4gICAgICAgIFNldHRpbmdzU3RvcmUudW53YXRjaFNldHRpbmcodGhpcy5zaG93VHlwaW5nTm90aWZpY2F0aW9uc1dhdGNoZXJSZWYpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgICBpZiAocHJldlByb3BzLnJlYWRNYXJrZXJWaXNpYmxlICYmIHRoaXMucHJvcHMucmVhZE1hcmtlckV2ZW50SWQgIT09IHByZXZQcm9wcy5yZWFkTWFya2VyRXZlbnRJZCkge1xuICAgICAgICAgICAgY29uc3QgZ2hvc3RSZWFkTWFya2VycyA9IHRoaXMuc3RhdGUuZ2hvc3RSZWFkTWFya2VycztcbiAgICAgICAgICAgIGdob3N0UmVhZE1hcmtlcnMucHVzaChwcmV2UHJvcHMucmVhZE1hcmtlckV2ZW50SWQpO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgZ2hvc3RSZWFkTWFya2VycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGVuZGluZ0VkaXRJdGVtID0gdGhpcy5wZW5kaW5nRWRpdEl0ZW07XG4gICAgICAgIGlmICghdGhpcy5wcm9wcy5lZGl0U3RhdGUgJiYgdGhpcy5wcm9wcy5yb29tICYmIHBlbmRpbmdFZGl0SXRlbSkge1xuICAgICAgICAgICAgZGVmYXVsdERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogQWN0aW9uLkVkaXRFdmVudCxcbiAgICAgICAgICAgICAgICBldmVudDogdGhpcy5wcm9wcy5yb29tLmZpbmRFdmVudEJ5SWQocGVuZGluZ0VkaXRJdGVtKSxcbiAgICAgICAgICAgICAgICB0aW1lbGluZVJlbmRlcmluZ1R5cGU6IHRoaXMuY29udGV4dC50aW1lbGluZVJlbmRlcmluZ1R5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgY2FsY3VsYXRlUm9vbU1lbWJlcnNDb3VudCA9ICgpOiB2b2lkID0+IHtcbiAgICAgICAgdGhpcy5tZW1iZXJzQ291bnQgPSB0aGlzLnByb3BzLnJvb20/LmdldE1lbWJlcnMoKS5sZW5ndGggfHwgMDtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvblNob3dUeXBpbmdOb3RpZmljYXRpb25zQ2hhbmdlID0gKCk6IHZvaWQgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHNob3dUeXBpbmdOb3RpZmljYXRpb25zOiBTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFwic2hvd1R5cGluZ05vdGlmaWNhdGlvbnNcIiksXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKiBnZXQgdGhlIERPTSBub2RlIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gZXZlbnQgKi9cbiAgICBwdWJsaWMgZ2V0Tm9kZUZvckV2ZW50SWQoZXZlbnRJZDogc3RyaW5nKTogSFRNTEVsZW1lbnQge1xuICAgICAgICBpZiAoIXRoaXMuZXZlbnROb2Rlcykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50Tm9kZXNbZXZlbnRJZF07XG4gICAgfVxuXG4gICAgLyogcmV0dXJuIHRydWUgaWYgdGhlIGNvbnRlbnQgaXMgZnVsbHkgc2Nyb2xsZWQgZG93biByaWdodCBub3c7IGVsc2UgZmFsc2UuXG4gICAgICovXG4gICAgcHVibGljIGlzQXRCb3R0b20oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFBhbmVsLmN1cnJlbnQ/LmlzQXRCb3R0b20oKTtcbiAgICB9XG5cbiAgICAvKiBnZXQgdGhlIGN1cnJlbnQgc2Nyb2xsIHN0YXRlLiBTZWUgU2Nyb2xsUGFuZWwuZ2V0U2Nyb2xsU3RhdGUgZm9yXG4gICAgICogZGV0YWlscy5cbiAgICAgKlxuICAgICAqIHJldHVybnMgbnVsbCBpZiB3ZSBhcmUgbm90IG1vdW50ZWQuXG4gICAgICovXG4gICAgcHVibGljIGdldFNjcm9sbFN0YXRlKCk6IElTY3JvbGxTdGF0ZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFBhbmVsLmN1cnJlbnQ/LmdldFNjcm9sbFN0YXRlKCkgPz8gbnVsbDtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIG9uZSBvZjpcbiAgICAvL1xuICAgIC8vICBudWxsOiB0aGVyZSBpcyBubyByZWFkIG1hcmtlclxuICAgIC8vICAtMTogcmVhZCBtYXJrZXIgaXMgYWJvdmUgdGhlIHdpbmRvd1xuICAgIC8vICAgMDogcmVhZCBtYXJrZXIgaXMgd2l0aGluIHRoZSB3aW5kb3dcbiAgICAvLyAgKzE6IHJlYWQgbWFya2VyIGlzIGJlbG93IHRoZSB3aW5kb3dcbiAgICBwdWJsaWMgZ2V0UmVhZE1hcmtlclBvc2l0aW9uKCk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IHJlYWRNYXJrZXIgPSB0aGlzLnJlYWRNYXJrZXJOb2RlLmN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VXcmFwcGVyID0gdGhpcy5zY3JvbGxQYW5lbC5jdXJyZW50O1xuXG4gICAgICAgIGlmICghcmVhZE1hcmtlciB8fCAhbWVzc2FnZVdyYXBwZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgd3JhcHBlclJlY3QgPSAoUmVhY3RET00uZmluZERPTU5vZGUobWVzc2FnZVdyYXBwZXIpIGFzIEhUTUxFbGVtZW50KS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgcmVhZE1hcmtlclJlY3QgPSByZWFkTWFya2VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIC8vIHRoZSByZWFkLW1hcmtlciBwcmV0ZW5kcyB0byBoYXZlIHplcm8gaGVpZ2h0IHdoZW4gaXQgaXMgYWN0dWFsbHlcbiAgICAgICAgLy8gdHdvIHBpeGVscyBoaWdoOyArMiBoZXJlIHRvIGFjY291bnQgZm9yIHRoYXQuXG4gICAgICAgIGlmIChyZWFkTWFya2VyUmVjdC5ib3R0b20gKyAyIDwgd3JhcHBlclJlY3QudG9wKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAocmVhZE1hcmtlclJlY3QudG9wIDwgd3JhcHBlclJlY3QuYm90dG9tKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoganVtcCB0byB0aGUgdG9wIG9mIHRoZSBjb250ZW50LlxuICAgICAqL1xuICAgIHB1YmxpYyBzY3JvbGxUb1RvcCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsUGFuZWwuY3VycmVudCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxQYW5lbC5jdXJyZW50LnNjcm9sbFRvVG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBqdW1wIHRvIHRoZSBib3R0b20gb2YgdGhlIGNvbnRlbnQuXG4gICAgICovXG4gICAgcHVibGljIHNjcm9sbFRvQm90dG9tKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5zY3JvbGxQYW5lbC5jdXJyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFBhbmVsLmN1cnJlbnQuc2Nyb2xsVG9Cb3R0b20oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhZ2UgdXAvZG93bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0OiAtMSB0byBwYWdlIHVwLCArMSB0byBwYWdlIGRvd25cbiAgICAgKi9cbiAgICBwdWJsaWMgc2Nyb2xsUmVsYXRpdmUobXVsdDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFBhbmVsLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUGFuZWwuY3VycmVudC5zY3JvbGxSZWxhdGl2ZShtdWx0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjcm9sbCB1cC9kb3duIGluIHJlc3BvbnNlIHRvIGEgc2Nyb2xsIGtleVxuICAgICAqXG4gICAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldjogdGhlIGtleWJvYXJkIGV2ZW50IHRvIGhhbmRsZVxuICAgICAqL1xuICAgIHB1YmxpYyBoYW5kbGVTY3JvbGxLZXkoZXY6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsUGFuZWwuY3VycmVudCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxQYW5lbC5jdXJyZW50LmhhbmRsZVNjcm9sbEtleShldik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBqdW1wIHRvIHRoZSBnaXZlbiBldmVudCBpZC5cbiAgICAgKlxuICAgICAqIG9mZnNldEJhc2UgZ2l2ZXMgdGhlIHJlZmVyZW5jZSBwb2ludCBmb3IgdGhlIHBpeGVsT2Zmc2V0LiAwIG1lYW5zIHRoZVxuICAgICAqIHRvcCBvZiB0aGUgY29udGFpbmVyLCAxIG1lYW5zIHRoZSBib3R0b20sIGFuZCBmcmFjdGlvbmFsIHZhbHVlcyBtZWFuXG4gICAgICogc29tZXdoZXJlIGluIHRoZSBtaWRkbGUuIElmIG9taXR0ZWQsIGl0IGRlZmF1bHRzIHRvIDAuXG4gICAgICpcbiAgICAgKiBwaXhlbE9mZnNldCBnaXZlcyB0aGUgbnVtYmVyIG9mIHBpeGVscyAqYWJvdmUqIHRoZSBvZmZzZXRCYXNlIHRoYXQgdGhlXG4gICAgICogbm9kZSAoc3BlY2lmaWNhbGx5LCB0aGUgYm90dG9tIG9mIGl0KSB3aWxsIGJlIHBvc2l0aW9uZWQuIElmIG9taXR0ZWQsIGl0XG4gICAgICogZGVmYXVsdHMgdG8gMC5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2Nyb2xsVG9FdmVudChldmVudElkOiBzdHJpbmcsIHBpeGVsT2Zmc2V0OiBudW1iZXIsIG9mZnNldEJhc2U6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5zY3JvbGxQYW5lbC5jdXJyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFBhbmVsLmN1cnJlbnQuc2Nyb2xsVG9Ub2tlbihldmVudElkLCBwaXhlbE9mZnNldCwgb2Zmc2V0QmFzZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgc2Nyb2xsVG9FdmVudElmTmVlZGVkKGV2ZW50SWQ6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5ldmVudE5vZGVzW2V2ZW50SWRdO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZS5zY3JvbGxJbnRvVmlldyh7XG4gICAgICAgICAgICAgICAgYmxvY2s6IFwibmVhcmVzdFwiLFxuICAgICAgICAgICAgICAgIGJlaGF2aW9yOiBcImluc3RhbnRcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogY2hlY2sgdGhlIHNjcm9sbCBzdGF0ZSBhbmQgc2VuZCBvdXQgcGFnaW5hdGlvbiByZXF1ZXN0cyBpZiBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgcHVibGljIGNoZWNrRmlsbFN0YXRlKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5zY3JvbGxQYW5lbC5jdXJyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFBhbmVsLmN1cnJlbnQuY2hlY2tGaWxsU3RhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaXNVbm1vdW50aW5nID0gKCk6IGJvb2xlYW4gPT4ge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNNb3VudGVkO1xuICAgIH07XG5cbiAgICBwcml2YXRlIGdldCBzaG93SGlkZGVuRXZlbnRzKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0Py5zaG93SGlkZGVuRXZlbnRzSW5UaW1lbGluZSA/PyB0aGlzLnNob3dIaWRkZW5FdmVudHNJblRpbWVsaW5lO1xuICAgIH1cblxuICAgIC8vIFRPRE86IEltcGxlbWVudCBncmFudWxhciAocGVyLXJvb20pIGhpZGUgb3B0aW9uc1xuICAgIHB1YmxpYyBzaG91bGRTaG93RXZlbnQobXhFdjogTWF0cml4RXZlbnQpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKE1hdHJpeENsaWVudFBlZy5nZXQoKS5pc1VzZXJJZ25vcmVkKG14RXYuZ2V0U2VuZGVyKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGlnbm9yZWQgPSBubyBzaG93IChvbmx5IGhhcHBlbnMgaWYgdGhlIGlnbm9yZSBoYXBwZW5zIGFmdGVyIGFuIGV2ZW50IHdhcyByZWNlaXZlZClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNob3dIaWRkZW5FdmVudHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoYXZlVGlsZUZvckV2ZW50KG14RXYsIHRoaXMuc2hvd0hpZGRlbkV2ZW50cykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gbm8gdGlsZSA9IG5vIHNob3dcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsd2F5cyBzaG93IGhpZ2hsaWdodGVkIGV2ZW50XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmhpZ2hsaWdodGVkRXZlbnRJZCA9PT0gbXhFdi5nZXRJZCgpKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAvLyBDaGVja2luZyBpZiB0aGUgbWVzc2FnZSBoYXMgYSBcInBhcmVudEV2ZW50SWRcIiBhcyB3ZSBkbyBub3RcbiAgICAgICAgLy8gd2FudCB0byBoaWRlIHRoZSByb290IGV2ZW50IG9mIHRoZSB0aHJlYWRcbiAgICAgICAgaWYgKG14RXYuaXNUaHJlYWRSZWxhdGlvbiAmJiB0aGlzLnByb3BzLmhpZGVUaHJlYWRlZE1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgJiYgU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZShcImZlYXR1cmVfdGhyZWFkXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gIXNob3VsZEhpZGVFdmVudChteEV2LCB0aGlzLmNvbnRleHQpO1xuICAgIH1cblxuICAgIHB1YmxpYyByZWFkTWFya2VyRm9yRXZlbnQoZXZlbnRJZDogc3RyaW5nLCBpc0xhc3RFdmVudDogYm9vbGVhbik6IFJlYWN0Tm9kZSB7XG4gICAgICAgIGNvbnN0IHZpc2libGUgPSAhaXNMYXN0RXZlbnQgJiYgdGhpcy5wcm9wcy5yZWFkTWFya2VyVmlzaWJsZTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5yZWFkTWFya2VyRXZlbnRJZCA9PT0gZXZlbnRJZCkge1xuICAgICAgICAgICAgbGV0IGhyO1xuICAgICAgICAgICAgLy8gaWYgdGhlIHJlYWQgbWFya2VyIGNvbWVzIGF0IHRoZSBlbmQgb2YgdGhlIHRpbWVsaW5lIChleGNlcHRcbiAgICAgICAgICAgIC8vIGZvciBsb2NhbCBlY2hvZXMsIHdoaWNoIGFyZSBleGNsdWRlZCBmcm9tIFJNcywgYmVjYXVzZSB0aGV5XG4gICAgICAgICAgICAvLyBkb24ndCBoYXZlIHVzZWZ1bCBldmVudCBpZHMpLCB3ZSBkb24ndCB3YW50IHRvIHNob3cgaXQsIGJ1dFxuICAgICAgICAgICAgLy8gd2Ugc3RpbGwgd2FudCB0byBjcmVhdGUgdGhlIDxsaS8+IGZvciBpdCBzbyB0aGF0IHRoZVxuICAgICAgICAgICAgLy8gYWxnb3JpdGhtcyB3aGljaCBkZXBlbmQgb24gaXRzIHBvc2l0aW9uIG9uIHRoZSBzY3JlZW4gYXJlbid0XG4gICAgICAgICAgICAvLyBjb25mdXNlZC5cbiAgICAgICAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgaHIgPSA8aHIgY2xhc3NOYW1lPVwibXhfUm9vbVZpZXdfbXlSZWFkTWFya2VyXCJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3sgb3BhY2l0eTogMSwgd2lkdGg6ICc5OSUnIH19XG4gICAgICAgICAgICAgICAgLz47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPGxpIGtleT17XCJyZWFkTWFya2VyX1wiK2V2ZW50SWR9XG4gICAgICAgICAgICAgICAgICAgIHJlZj17dGhpcy5yZWFkTWFya2VyTm9kZX1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibXhfUm9vbVZpZXdfbXlSZWFkTWFya2VyX2NvbnRhaW5lclwiXG4gICAgICAgICAgICAgICAgICAgIGRhdGEtc2Nyb2xsLXRva2Vucz17ZXZlbnRJZH1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIHsgaHIgfVxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuZ2hvc3RSZWFkTWFya2Vycy5pbmNsdWRlcyhldmVudElkKSkge1xuICAgICAgICAgICAgLy8gV2UgcmVuZGVyICdnaG9zdCcgcmVhZCBtYXJrZXJzIGluIHRoZSBET00gd2hpbGUgdGhleVxuICAgICAgICAgICAgLy8gdHJhbnNpdGlvbiBhd2F5LiBUaGlzIGFsbG93cyB0aGUgYWN0dWFsIHJlYWQgbWFya2VyXG4gICAgICAgICAgICAvLyB0byBiZSBpbiB0aGUgcmlnaHQgcGxhY2Ugc3RyYWlnaHQgYXdheSB3aXRob3V0IGhhdmluZ1xuICAgICAgICAgICAgLy8gdG8gd2FpdCBmb3IgdGhlIHRyYW5zaXRpb24gdG8gZmluaXNoLlxuICAgICAgICAgICAgLy8gVGhlcmUgYXJlIHByb2JhYmx5IG11Y2ggc2ltcGxlciB3YXlzIHRvIGRvIHRoaXMgdHJhbnNpdGlvbixcbiAgICAgICAgICAgIC8vIHBvc3NpYmx5IHVzaW5nIHJlYWN0LXRyYW5zaXRpb24tZ3JvdXAgd2hpY2ggaGFuZGxlcyBrZWVwaW5nXG4gICAgICAgICAgICAvLyBlbGVtZW50cyBpbiB0aGUgRE9NIHdoaWxzdCB0aGV5IHRyYW5zaXRpb24gb3V0LCBhbHRob3VnaCBvdXJcbiAgICAgICAgICAgIC8vIGNhc2UgaXMgYSBsaXR0bGUgbW9yZSBjb21wbGV4IGJlY2F1c2Ugb25seSBzb21lIG9mIHRoZSBpdGVtc1xuICAgICAgICAgICAgLy8gdHJhbnNpdGlvbiAoaWUuIHRoZSByZWFkIG1hcmtlcnMgZG8gYnV0IHRoZSBldmVudCB0aWxlcyBkbyBub3QpXG4gICAgICAgICAgICAvLyBhbmQgVHJhbnNpdGlvbkdyb3VwIHJlcXVpcmVzIHRoYXQgYWxsIGl0cyBjaGlsZHJlbiBhcmUgVHJhbnNpdGlvbnMuXG4gICAgICAgICAgICBjb25zdCBociA9IDxociBjbGFzc05hbWU9XCJteF9Sb29tVmlld19teVJlYWRNYXJrZXJcIlxuICAgICAgICAgICAgICAgIHJlZj17dGhpcy5jb2xsZWN0R2hvc3RSZWFkTWFya2VyfVxuICAgICAgICAgICAgICAgIG9uVHJhbnNpdGlvbkVuZD17dGhpcy5vbkdob3N0VHJhbnNpdGlvbkVuZH1cbiAgICAgICAgICAgICAgICBkYXRhLWV2ZW50aWQ9e2V2ZW50SWR9XG4gICAgICAgICAgICAvPjtcblxuICAgICAgICAgICAgLy8gZ2l2ZSBpdCBhIGtleSB3aGljaCBkZXBlbmRzIG9uIHRoZSBldmVudCBpZC4gVGhhdCB3aWxsIGVuc3VyZSB0aGF0XG4gICAgICAgICAgICAvLyB3ZSBnZXQgYSBuZXcgRE9NIG5vZGUgKHJlc3RhcnRpbmcgdGhlIGFuaW1hdGlvbikgd2hlbiB0aGUgZ2hvc3RcbiAgICAgICAgICAgIC8vIG1vdmVzIHRvIGEgZGlmZmVyZW50IGV2ZW50LlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8bGlcbiAgICAgICAgICAgICAgICAgICAga2V5PXtcIl9yZWFkdXB0b2dob3N0X1wiK2V2ZW50SWR9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIm14X1Jvb21WaWV3X215UmVhZE1hcmtlcl9jb250YWluZXJcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgeyBociB9XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNvbGxlY3RHaG9zdFJlYWRNYXJrZXIgPSAobm9kZTogSFRNTEVsZW1lbnQpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIC8vIG5vdyB0aGUgZWxlbWVudCBoYXMgYXBwZWFyZWQsIGNoYW5nZSB0aGUgc3R5bGUgd2hpY2ggd2lsbCB0cmlnZ2VyIHRoZSBDU1MgdHJhbnNpdGlvblxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICBub2RlLnN0eWxlLndpZHRoID0gJzEwJSc7XG4gICAgICAgICAgICAgICAgbm9kZS5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbkdob3N0VHJhbnNpdGlvbkVuZCA9IChldjogVHJhbnNpdGlvbkV2ZW50KTogdm9pZCA9PiB7XG4gICAgICAgIC8vIHdlIGNhbiBub3cgY2xlYW4gdXAgdGhlIGdob3N0IGVsZW1lbnRcbiAgICAgICAgY29uc3QgZmluaXNoZWRFdmVudElkID0gKGV2LnRhcmdldCBhcyBIVE1MRWxlbWVudCkuZGF0YXNldC5ldmVudGlkO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGdob3N0UmVhZE1hcmtlcnM6IHRoaXMuc3RhdGUuZ2hvc3RSZWFkTWFya2Vycy5maWx0ZXIoZWlkID0+IGVpZCAhPT0gZmluaXNoZWRFdmVudElkKSxcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgZ2V0TmV4dEV2ZW50SW5mbyhhcnI6IE1hdHJpeEV2ZW50W10sIGk6IG51bWJlcik6IHsgbmV4dEV2ZW50OiBNYXRyaXhFdmVudCwgbmV4dFRpbGU6IE1hdHJpeEV2ZW50IH0ge1xuICAgICAgICBjb25zdCBuZXh0RXZlbnQgPSBpIDwgYXJyLmxlbmd0aCAtIDFcbiAgICAgICAgICAgID8gYXJyW2kgKyAxXVxuICAgICAgICAgICAgOiBudWxsO1xuXG4gICAgICAgIC8vIFRoZSBuZXh0IGV2ZW50IHdpdGggdGlsZSBpcyB1c2VkIHRvIHRvIGRldGVybWluZSB0aGUgJ2xhc3Qgc3VjY2Vzc2Z1bCcgZmxhZ1xuICAgICAgICAvLyB3aGVuIHJlbmRlcmluZyB0aGUgdGlsZS4gVGhlIHNob3VsZFNob3dFdmVudCBmdW5jdGlvbiBpcyBwcmV0dHkgcXVpY2sgYXQgd2hhdFxuICAgICAgICAvLyBpdCBkb2VzLCBzbyB0aGlzIHNob3VsZCBoYXZlIG5vIHNpZ25pZmljYW50IGNvc3QgZXZlbiB3aGVuIGEgcm9vbSBpcyB1c2VkIGZvclxuICAgICAgICAvLyBub3QtY2hhdCBwdXJwb3Nlcy5cbiAgICAgICAgY29uc3QgbmV4dFRpbGUgPSBhcnIuc2xpY2UoaSArIDEpLmZpbmQoZSA9PiB0aGlzLnNob3VsZFNob3dFdmVudChlKSk7XG5cbiAgICAgICAgcmV0dXJuIHsgbmV4dEV2ZW50LCBuZXh0VGlsZSB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0IHBlbmRpbmdFZGl0SXRlbSgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgICAgICBpZiAoIXRoaXMucHJvcHMucm9vbSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGBteF9lZGl0X3Jvb21fJHt0aGlzLnByb3BzLnJvb20ucm9vbUlkfV8ke3RoaXMuY29udGV4dC50aW1lbGluZVJlbmRlcmluZ1R5cGV9YCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByaXZhdGUgZ2V0RXZlbnRUaWxlcygpOiBSZWFjdE5vZGVbXSB7XG4gICAgICAgIHRoaXMuZXZlbnROb2RlcyA9IHt9O1xuXG4gICAgICAgIGxldCBpO1xuXG4gICAgICAgIC8vIGZpcnN0IGZpZ3VyZSBvdXQgd2hpY2ggaXMgdGhlIGxhc3QgZXZlbnQgaW4gdGhlIGxpc3Qgd2hpY2ggd2UncmVcbiAgICAgICAgLy8gYWN0dWFsbHkgZ29pbmcgdG8gc2hvdzsgdGhpcyBhbGxvd3MgdXMgdG8gYmVoYXZlIHNsaWdodGx5XG4gICAgICAgIC8vIGRpZmZlcmVudGx5IGZvciB0aGUgbGFzdCBldmVudCBpbiB0aGUgbGlzdC4gKGVnIHNob3cgdGltZXN0YW1wKVxuICAgICAgICAvL1xuICAgICAgICAvLyB3ZSBhbHNvIG5lZWQgdG8gZmlndXJlIG91dCB3aGljaCBpcyB0aGUgbGFzdCBldmVudCB3ZSBzaG93IHdoaWNoIGlzbid0XG4gICAgICAgIC8vIGEgbG9jYWwgZWNobywgdG8gbWFuYWdlIHRoZSByZWFkLW1hcmtlci5cbiAgICAgICAgbGV0IGxhc3RTaG93bkV2ZW50O1xuXG4gICAgICAgIGxldCBsYXN0U2hvd25Ob25Mb2NhbEVjaG9JbmRleCA9IC0xO1xuICAgICAgICBmb3IgKGkgPSB0aGlzLnByb3BzLmV2ZW50cy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IG14RXYgPSB0aGlzLnByb3BzLmV2ZW50c1tpXTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRTaG93RXZlbnQobXhFdikpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxhc3RTaG93bkV2ZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsYXN0U2hvd25FdmVudCA9IG14RXY7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChteEV2LnN0YXR1cykge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBsb2NhbCBlY2hvXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3RTaG93bk5vbkxvY2FsRWNob0luZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmV0ID0gW107XG5cbiAgICAgICAgbGV0IHByZXZFdmVudCA9IG51bGw7IC8vIHRoZSBsYXN0IGV2ZW50IHdlIHNob3dlZFxuXG4gICAgICAgIC8vIE5vdGU6IHRoZSBFdmVudFRpbGUgbWlnaHQgc3RpbGwgcmVuZGVyIGEgXCJzZW50L3NlbmRpbmcgcmVjZWlwdFwiIGluZGVwZW5kZW50IG9mXG4gICAgICAgIC8vIHRoaXMgaW5mb3JtYXRpb24uIFdoZW4gbm90IHByb3ZpZGluZyByZWFkIHJlY2VpcHQgaW5mb3JtYXRpb24sIHRoZSB0aWxlIGlzIGxpa2VseVxuICAgICAgICAvLyB0byBhc3N1bWUgdGhhdCBzZW50IHJlY2VpcHRzIGFyZSB0byBiZSBzaG93biBtb3JlIG9mdGVuLlxuICAgICAgICB0aGlzLnJlYWRSZWNlaXB0c0J5RXZlbnQgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuc2hvd1JlYWRSZWNlaXB0cykge1xuICAgICAgICAgICAgdGhpcy5yZWFkUmVjZWlwdHNCeUV2ZW50ID0gdGhpcy5nZXRSZWFkUmVjZWlwdHNCeVNob3duRXZlbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBncm91cGVyOiBCYXNlR3JvdXBlciA9IG51bGw7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMucHJvcHMuZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBteEV2ID0gdGhpcy5wcm9wcy5ldmVudHNbaV07XG4gICAgICAgICAgICBjb25zdCBldmVudElkID0gbXhFdi5nZXRJZCgpO1xuICAgICAgICAgICAgY29uc3QgbGFzdCA9IChteEV2ID09PSBsYXN0U2hvd25FdmVudCk7XG4gICAgICAgICAgICBjb25zdCB7IG5leHRFdmVudCwgbmV4dFRpbGUgfSA9IHRoaXMuZ2V0TmV4dEV2ZW50SW5mbyh0aGlzLnByb3BzLmV2ZW50cywgaSk7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBteEV2LmdldFR5cGUoKS5pbmRleE9mKFwibS5jYWxsLlwiKSA9PT0gMCB8fFxuICAgICAgICAgICAgICAgIG14RXYuZ2V0VHlwZSgpLmluZGV4T2YoXCJvcmcubWF0cml4LmNhbGwuXCIpID09PSAwXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsSWQgPSBteEV2LmdldENvbnRlbnQoKS5jYWxsX2lkO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbGxFdmVudEdyb3VwZXJzLmhhcyhjYWxsSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbEV2ZW50R3JvdXBlcnMuZ2V0KGNhbGxJZCkuYWRkKG14RXYpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxFdmVudEdyb3VwZXIgPSBuZXcgQ2FsbEV2ZW50R3JvdXBlcigpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsRXZlbnRHcm91cGVyLmFkZChteEV2KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsRXZlbnRHcm91cGVycy5zZXQoY2FsbElkLCBjYWxsRXZlbnRHcm91cGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChncm91cGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwZXIuc2hvdWxkR3JvdXAobXhFdikpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBlci5hZGQobXhFdiwgdGhpcy5zaG93SGlkZGVuRXZlbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IHBhcnQgb2YgZ3JvdXAsIHNvIGdldCB0aGUgZ3JvdXAgdGlsZXMsIGNsb3NlIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBncm91cCwgYW5kIGNvbnRpbnVlIGxpa2UgYSBub3JtYWwgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goLi4uZ3JvdXBlci5nZXRUaWxlcygpKTtcbiAgICAgICAgICAgICAgICAgICAgcHJldkV2ZW50ID0gZ3JvdXBlci5nZXROZXdQcmV2RXZlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IEdyb3VwZXIgb2YgZ3JvdXBlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoR3JvdXBlci5jYW5TdGFydEdyb3VwKHRoaXMsIG14RXYpICYmICF0aGlzLnByb3BzLmRpc2FibGVHcm91cGluZykge1xuICAgICAgICAgICAgICAgICAgICBncm91cGVyID0gbmV3IEdyb3VwZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXhFdixcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZFdmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RTaG93bkV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5sYXlvdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0RXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0VGlsZSxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWdyb3VwZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3YW50VGlsZSA9IHRoaXMuc2hvdWxkU2hvd0V2ZW50KG14RXYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzR3JvdXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICh3YW50VGlsZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UgdW5wYWNrIHRoZSBhcnJheSByZXR1cm5lZCBieSBnZXRUaWxlc0ZvckV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgcmVhY3Qgd2lsbCBhdXRvLWdlbmVyYXRlIGtleXMgYW5kIHdlIHdpbGwgZW5kIHVwXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcGxhY2luZyBhbGwgb2YgdGhlIERPTSBlbGVtZW50cyBldmVyeSB0aW1lIHdlIHBhZ2luYXRlLlxuICAgICAgICAgICAgICAgICAgICByZXQucHVzaCguLi50aGlzLmdldFRpbGVzRm9yRXZlbnQocHJldkV2ZW50LCBteEV2LCBsYXN0LCBpc0dyb3VwZWQsIG5leHRFdmVudCwgbmV4dFRpbGUpKTtcbiAgICAgICAgICAgICAgICAgICAgcHJldkV2ZW50ID0gbXhFdjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZWFkTWFya2VyID0gdGhpcy5yZWFkTWFya2VyRm9yRXZlbnQoZXZlbnRJZCwgaSA+PSBsYXN0U2hvd25Ob25Mb2NhbEVjaG9JbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlYWRNYXJrZXIpIHJldC5wdXNoKHJlYWRNYXJrZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdyb3VwZXIpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKC4uLmdyb3VwZXIuZ2V0VGlsZXMoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRUaWxlc0ZvckV2ZW50KFxuICAgICAgICBwcmV2RXZlbnQ6IE1hdHJpeEV2ZW50LFxuICAgICAgICBteEV2OiBNYXRyaXhFdmVudCxcbiAgICAgICAgbGFzdCA9IGZhbHNlLFxuICAgICAgICBpc0dyb3VwZWQgPSBmYWxzZSxcbiAgICAgICAgbmV4dEV2ZW50PzogTWF0cml4RXZlbnQsXG4gICAgICAgIG5leHRFdmVudFdpdGhUaWxlPzogTWF0cml4RXZlbnQsXG4gICAgKTogUmVhY3ROb2RlW10ge1xuICAgICAgICBjb25zdCByZXQgPSBbXTtcblxuICAgICAgICBjb25zdCBpc0VkaXRpbmcgPSB0aGlzLnByb3BzLmVkaXRTdGF0ZSAmJlxuICAgICAgICAgICAgdGhpcy5wcm9wcy5lZGl0U3RhdGUuZ2V0RXZlbnQoKS5nZXRJZCgpID09PSBteEV2LmdldElkKCk7XG4gICAgICAgIC8vIGxvY2FsIGVjaG9lcyBoYXZlIGEgZmFrZSBkYXRlLCB3aGljaCBjb3VsZCBldmVuIGJlIHllc3RlcmRheS4gVHJlYXQgdGhlbVxuICAgICAgICAvLyBhcyAndG9kYXknIGZvciB0aGUgZGF0ZSBzZXBhcmF0b3JzLlxuICAgICAgICBsZXQgdHMxID0gbXhFdi5nZXRUcygpO1xuICAgICAgICBsZXQgZXZlbnREYXRlID0gbXhFdi5nZXREYXRlKCk7XG4gICAgICAgIGlmIChteEV2LnN0YXR1cykge1xuICAgICAgICAgICAgZXZlbnREYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIHRzMSA9IGV2ZW50RGF0ZS5nZXRUaW1lKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkbyB3ZSBuZWVkIGEgZGF0ZSBzZXBhcmF0b3Igc2luY2UgdGhlIGxhc3QgZXZlbnQ/XG4gICAgICAgIGNvbnN0IHdhbnRzRGF0ZVNlcGFyYXRvciA9IHRoaXMud2FudHNEYXRlU2VwYXJhdG9yKHByZXZFdmVudCwgZXZlbnREYXRlKTtcbiAgICAgICAgaWYgKHdhbnRzRGF0ZVNlcGFyYXRvciAmJiAhaXNHcm91cGVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRlU2VwYXJhdG9yID0gPGxpIGtleT17dHMxfT48RGF0ZVNlcGFyYXRvciBrZXk9e3RzMX0gdHM9e3RzMX0gLz48L2xpPjtcbiAgICAgICAgICAgIHJldC5wdXNoKGRhdGVTZXBhcmF0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHdpbGxXYW50RGF0ZVNlcGFyYXRvciA9IGZhbHNlO1xuICAgICAgICBsZXQgbGFzdEluU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIGlmIChuZXh0RXZlbnRXaXRoVGlsZSkge1xuICAgICAgICAgICAgd2lsbFdhbnREYXRlU2VwYXJhdG9yID0gdGhpcy53YW50c0RhdGVTZXBhcmF0b3IobXhFdiwgbmV4dEV2ZW50V2l0aFRpbGUuZ2V0RGF0ZSgpIHx8IG5ldyBEYXRlKCkpO1xuICAgICAgICAgICAgbGFzdEluU2VjdGlvbiA9IHdpbGxXYW50RGF0ZVNlcGFyYXRvciB8fCBteEV2LmdldFNlbmRlcigpICE9PSBuZXh0RXZlbnRXaXRoVGlsZS5nZXRTZW5kZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlzIHRoaXMgYSBjb250aW51YXRpb24gb2YgdGhlIHByZXZpb3VzIG1lc3NhZ2U/XG4gICAgICAgIGNvbnN0IGNvbnRpbnVhdGlvbiA9ICF3YW50c0RhdGVTZXBhcmF0b3IgJiZcbiAgICAgICAgICAgIHNob3VsZEZvcm1Db250aW51YXRpb24ocHJldkV2ZW50LCBteEV2LCB0aGlzLnNob3dIaWRkZW5FdmVudHMsIHRoaXMuY29udGV4dC50aW1lbGluZVJlbmRlcmluZ1R5cGUpO1xuXG4gICAgICAgIGNvbnN0IGV2ZW50SWQgPSBteEV2LmdldElkKCk7XG4gICAgICAgIGNvbnN0IGhpZ2hsaWdodCA9IChldmVudElkID09PSB0aGlzLnByb3BzLmhpZ2hsaWdodGVkRXZlbnRJZCk7XG5cbiAgICAgICAgY29uc3QgcmVhZFJlY2VpcHRzID0gdGhpcy5yZWFkUmVjZWlwdHNCeUV2ZW50W2V2ZW50SWRdO1xuXG4gICAgICAgIGxldCBpc0xhc3RTdWNjZXNzZnVsID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGlzU2VudFN0YXRlID0gcyA9PiAhcyB8fCBzID09PSAnc2VudCc7XG4gICAgICAgIGNvbnN0IGlzU2VudCA9IGlzU2VudFN0YXRlKG14RXYuZ2V0QXNzb2NpYXRlZFN0YXR1cygpKTtcbiAgICAgICAgY29uc3QgaGFzTmV4dEV2ZW50ID0gbmV4dEV2ZW50ICYmIHRoaXMuc2hvdWxkU2hvd0V2ZW50KG5leHRFdmVudCk7XG4gICAgICAgIGlmICghaGFzTmV4dEV2ZW50ICYmIGlzU2VudCkge1xuICAgICAgICAgICAgaXNMYXN0U3VjY2Vzc2Z1bCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFzTmV4dEV2ZW50ICYmIGlzU2VudCAmJiAhaXNTZW50U3RhdGUobmV4dEV2ZW50LmdldEFzc29jaWF0ZWRTdGF0dXMoKSkpIHtcbiAgICAgICAgICAgIGlzTGFzdFN1Y2Nlc3NmdWwgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyBpcyBhIGJpdCBudWFuY2VkLCBidXQgaWYgb3VyIG5leHQgZXZlbnQgaXMgaGlkZGVuIGJ1dCBhIGZ1dHVyZSBldmVudCBpcyBub3RcbiAgICAgICAgLy8gaGlkZGVuIHRoZW4gd2UncmUgbm90IHRoZSBsYXN0IHN1Y2Nlc3NmdWwuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIG5leHRFdmVudFdpdGhUaWxlICYmXG4gICAgICAgICAgICBuZXh0RXZlbnRXaXRoVGlsZSAhPT0gbmV4dEV2ZW50ICYmXG4gICAgICAgICAgICBpc1NlbnRTdGF0ZShuZXh0RXZlbnRXaXRoVGlsZS5nZXRBc3NvY2lhdGVkU3RhdHVzKCkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgaXNMYXN0U3VjY2Vzc2Z1bCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2Ugb25seSB3YW50IHRvIGNvbnNpZGVyIFwibGFzdCBzdWNjZXNzZnVsXCIgaWYgdGhlIGV2ZW50IGlzIHNlbnQgYnkgdXMsIG90aGVyd2lzZSBvZiBjb3Vyc2VcbiAgICAgICAgLy8gaXQncyBzdWNjZXNzZnVsOiB3ZSByZWNlaXZlZCBpdC5cbiAgICAgICAgaXNMYXN0U3VjY2Vzc2Z1bCA9IGlzTGFzdFN1Y2Nlc3NmdWwgJiYgbXhFdi5nZXRTZW5kZXIoKSA9PT0gTWF0cml4Q2xpZW50UGVnLmdldCgpLmdldFVzZXJJZCgpO1xuXG4gICAgICAgIGNvbnN0IGNhbGxFdmVudEdyb3VwZXIgPSB0aGlzLmNhbGxFdmVudEdyb3VwZXJzLmdldChteEV2LmdldENvbnRlbnQoKS5jYWxsX2lkKTtcbiAgICAgICAgLy8gdXNlIHR4bklkIGFzIGtleSBpZiBhdmFpbGFibGUgc28gdGhhdCB3ZSBkb24ndCByZW1vdW50IGR1cmluZyBzZW5kaW5nXG4gICAgICAgIHJldC5wdXNoKFxuICAgICAgICAgICAgPFRpbGVFcnJvckJvdW5kYXJ5IGtleT17bXhFdi5nZXRUeG5JZCgpIHx8IGV2ZW50SWR9IG14RXZlbnQ9e214RXZ9PlxuICAgICAgICAgICAgICAgIDxFdmVudFRpbGVcbiAgICAgICAgICAgICAgICAgICAgYXM9XCJsaVwiXG4gICAgICAgICAgICAgICAgICAgIHJlZj17dGhpcy5jb2xsZWN0RXZlbnROb2RlLmJpbmQodGhpcywgZXZlbnRJZCl9XG4gICAgICAgICAgICAgICAgICAgIGFsd2F5c1Nob3dUaW1lc3RhbXBzPXt0aGlzLnByb3BzLmFsd2F5c1Nob3dUaW1lc3RhbXBzfVxuICAgICAgICAgICAgICAgICAgICBteEV2ZW50PXtteEV2fVxuICAgICAgICAgICAgICAgICAgICBjb250aW51YXRpb249e2NvbnRpbnVhdGlvbn1cbiAgICAgICAgICAgICAgICAgICAgaXNSZWRhY3RlZD17bXhFdi5pc1JlZGFjdGVkKCl9XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2luZ0V2ZW50SWQ9e214RXYucmVwbGFjaW5nRXZlbnRJZCgpfVxuICAgICAgICAgICAgICAgICAgICBlZGl0U3RhdGU9e2lzRWRpdGluZyAmJiB0aGlzLnByb3BzLmVkaXRTdGF0ZX1cbiAgICAgICAgICAgICAgICAgICAgb25IZWlnaHRDaGFuZ2VkPXt0aGlzLm9uSGVpZ2h0Q2hhbmdlZH1cbiAgICAgICAgICAgICAgICAgICAgcmVhZFJlY2VpcHRzPXtyZWFkUmVjZWlwdHN9XG4gICAgICAgICAgICAgICAgICAgIHJlYWRSZWNlaXB0TWFwPXt0aGlzLnJlYWRSZWNlaXB0TWFwfVxuICAgICAgICAgICAgICAgICAgICBzaG93VXJsUHJldmlldz17dGhpcy5wcm9wcy5zaG93VXJsUHJldmlld31cbiAgICAgICAgICAgICAgICAgICAgY2hlY2tVbm1vdW50aW5nPXt0aGlzLmlzVW5tb3VudGluZ31cbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTZW5kU3RhdHVzPXtteEV2LmdldEFzc29jaWF0ZWRTdGF0dXMoKX1cbiAgICAgICAgICAgICAgICAgICAgdGlsZVNoYXBlPXt0aGlzLnByb3BzLnRpbGVTaGFwZX1cbiAgICAgICAgICAgICAgICAgICAgaXNUd2VsdmVIb3VyPXt0aGlzLnByb3BzLmlzVHdlbHZlSG91cn1cbiAgICAgICAgICAgICAgICAgICAgcGVybWFsaW5rQ3JlYXRvcj17dGhpcy5wcm9wcy5wZXJtYWxpbmtDcmVhdG9yfVxuICAgICAgICAgICAgICAgICAgICBsYXN0PXtsYXN0fVxuICAgICAgICAgICAgICAgICAgICBsYXN0SW5TZWN0aW9uPXtsYXN0SW5TZWN0aW9ufVxuICAgICAgICAgICAgICAgICAgICBsYXN0U3VjY2Vzc2Z1bD17aXNMYXN0U3VjY2Vzc2Z1bH1cbiAgICAgICAgICAgICAgICAgICAgaXNTZWxlY3RlZEV2ZW50PXtoaWdobGlnaHR9XG4gICAgICAgICAgICAgICAgICAgIGdldFJlbGF0aW9uc0ZvckV2ZW50PXt0aGlzLnByb3BzLmdldFJlbGF0aW9uc0ZvckV2ZW50fVxuICAgICAgICAgICAgICAgICAgICBzaG93UmVhY3Rpb25zPXt0aGlzLnByb3BzLnNob3dSZWFjdGlvbnN9XG4gICAgICAgICAgICAgICAgICAgIGxheW91dD17dGhpcy5wcm9wcy5sYXlvdXR9XG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZUZsYWlyPXt0aGlzLnByb3BzLmVuYWJsZUZsYWlyfVxuICAgICAgICAgICAgICAgICAgICBzaG93UmVhZFJlY2VpcHRzPXt0aGlzLnByb3BzLnNob3dSZWFkUmVjZWlwdHN9XG4gICAgICAgICAgICAgICAgICAgIGNhbGxFdmVudEdyb3VwZXI9e2NhbGxFdmVudEdyb3VwZXJ9XG4gICAgICAgICAgICAgICAgICAgIGhpZGVTZW5kZXI9e3RoaXMubWVtYmVyc0NvdW50IDw9IDIgJiYgdGhpcy5wcm9wcy5sYXlvdXQgPT09IExheW91dC5CdWJibGV9XG4gICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lUmVuZGVyaW5nVHlwZT17dGhpcy5jb250ZXh0LnRpbWVsaW5lUmVuZGVyaW5nVHlwZX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9UaWxlRXJyb3JCb3VuZGFyeT4sXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBwdWJsaWMgd2FudHNEYXRlU2VwYXJhdG9yKHByZXZFdmVudDogTWF0cml4RXZlbnQsIG5leHRFdmVudERhdGU6IERhdGUpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC50aW1lbGluZVJlbmRlcmluZ1R5cGUgPT09IFRpbWVsaW5lUmVuZGVyaW5nVHlwZS5UaHJlYWRzTGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2RXZlbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gZmlyc3QgZXZlbnQgaW4gdGhlIHBhbmVsOiBkZXBlbmRzIGlmIHdlIGNvdWxkIGJhY2stcGFnaW5hdGUgZnJvbVxuICAgICAgICAgICAgLy8gaGVyZS5cbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5wcm9wcy5zdXBwcmVzc0ZpcnN0RGF0ZVNlcGFyYXRvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2FudHNEYXRlU2VwYXJhdG9yKHByZXZFdmVudC5nZXREYXRlKCksIG5leHRFdmVudERhdGUpO1xuICAgIH1cblxuICAgIC8vIEdldCBhIGxpc3Qgb2YgcmVhZCByZWNlaXB0cyB0aGF0IHNob3VsZCBiZSBzaG93biBuZXh0IHRvIHRoaXMgZXZlbnRcbiAgICAvLyBSZWNlaXB0cyBhcmUgb2JqZWN0cyB3aGljaCBoYXZlIGEgJ3VzZXJJZCcsICdyb29tTWVtYmVyJyBhbmQgJ3RzJy5cbiAgICBwcml2YXRlIGdldFJlYWRSZWNlaXB0c0ZvckV2ZW50KGV2ZW50OiBNYXRyaXhFdmVudCk6IElSZWFkUmVjZWlwdFByb3BzW10ge1xuICAgICAgICBjb25zdCBteVVzZXJJZCA9IE1hdHJpeENsaWVudFBlZy5nZXQoKS5jcmVkZW50aWFscy51c2VySWQ7XG5cbiAgICAgICAgLy8gZ2V0IGxpc3Qgb2YgcmVhZCByZWNlaXB0cywgc29ydGVkIG1vc3QgcmVjZW50IGZpcnN0XG4gICAgICAgIGNvbnN0IHsgcm9vbSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKCFyb29tKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWNlaXB0czogSVJlYWRSZWNlaXB0UHJvcHNbXSA9IFtdO1xuICAgICAgICByb29tLmdldFJlY2VpcHRzRm9yRXZlbnQoZXZlbnQpLmZvckVhY2goKHIpID0+IHtcbiAgICAgICAgICAgIGlmICghci51c2VySWQgfHwgci50eXBlICE9PSBcIm0ucmVhZFwiIHx8IHIudXNlcklkID09PSBteVVzZXJJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gaWdub3JlIG5vbi1yZWFkIHJlY2VpcHRzIGFuZCByZWNlaXB0cyBmcm9tIHNlbGYuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTWF0cml4Q2xpZW50UGVnLmdldCgpLmlzVXNlcklnbm9yZWQoci51c2VySWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBpZ25vcmUgaWdub3JlZCB1c2Vyc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWVtYmVyID0gcm9vbS5nZXRNZW1iZXIoci51c2VySWQpO1xuICAgICAgICAgICAgcmVjZWlwdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdXNlcklkOiByLnVzZXJJZCxcbiAgICAgICAgICAgICAgICByb29tTWVtYmVyOiBtZW1iZXIsXG4gICAgICAgICAgICAgICAgdHM6IHIuZGF0YSA/IHIuZGF0YS50cyA6IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZWNlaXB0cztcbiAgICB9XG5cbiAgICAvLyBHZXQgYW4gb2JqZWN0IHRoYXQgbWFwcyBmcm9tIGV2ZW50IElEIHRvIGEgbGlzdCBvZiByZWFkIHJlY2VpcHRzIHRoYXRcbiAgICAvLyBzaG91bGQgYmUgc2hvd24gbmV4dCB0byB0aGF0IGV2ZW50LiBJZiBhIGhpZGRlbiBldmVudCBoYXMgcmVhZCByZWNlaXB0cyxcbiAgICAvLyB0aGV5IGFyZSBmb2xkZWQgaW50byB0aGUgcmVjZWlwdHMgb2YgdGhlIGxhc3Qgc2hvd24gZXZlbnQuXG4gICAgcHJpdmF0ZSBnZXRSZWFkUmVjZWlwdHNCeVNob3duRXZlbnQoKTogUmVjb3JkPHN0cmluZywgSVJlYWRSZWNlaXB0UHJvcHNbXT4ge1xuICAgICAgICBjb25zdCByZWNlaXB0c0J5RXZlbnQgPSB7fTtcbiAgICAgICAgY29uc3QgcmVjZWlwdHNCeVVzZXJJZCA9IHt9O1xuXG4gICAgICAgIGxldCBsYXN0U2hvd25FdmVudElkO1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIHRoaXMucHJvcHMuZXZlbnRzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zaG91bGRTaG93RXZlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgbGFzdFNob3duRXZlbnRJZCA9IGV2ZW50LmdldElkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxhc3RTaG93bkV2ZW50SWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdSZWNlaXB0cyA9IHJlY2VpcHRzQnlFdmVudFtsYXN0U2hvd25FdmVudElkXSB8fCBbXTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1JlY2VpcHRzID0gdGhpcy5nZXRSZWFkUmVjZWlwdHNGb3JFdmVudChldmVudCk7XG4gICAgICAgICAgICByZWNlaXB0c0J5RXZlbnRbbGFzdFNob3duRXZlbnRJZF0gPSBleGlzdGluZ1JlY2VpcHRzLmNvbmNhdChuZXdSZWNlaXB0cyk7XG5cbiAgICAgICAgICAgIC8vIFJlY29yZCB0aGVzZSByZWNlaXB0cyBhbG9uZyB3aXRoIHRoZWlyIGxhc3Qgc2hvd24gZXZlbnQgSUQgZm9yXG4gICAgICAgICAgICAvLyBlYWNoIGFzc29jaWF0ZWQgdXNlciBJRC5cbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVjZWlwdCBvZiBuZXdSZWNlaXB0cykge1xuICAgICAgICAgICAgICAgIHJlY2VpcHRzQnlVc2VySWRbcmVjZWlwdC51c2VySWRdID0ge1xuICAgICAgICAgICAgICAgICAgICBsYXN0U2hvd25FdmVudElkLFxuICAgICAgICAgICAgICAgICAgICByZWNlaXB0LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJdCdzIHBvc3NpYmxlIGluIHNvbWUgY2FzZXMgKGZvciBleGFtcGxlLCB3aGVuIGEgcmVhZCByZWNlaXB0XG4gICAgICAgIC8vIGFkdmFuY2VzIGJlZm9yZSB3ZSBoYXZlIHBhZ2luYXRlZCBpbiB0aGUgbmV3IGV2ZW50IHRoYXQgaXQncyBtYXJraW5nXG4gICAgICAgIC8vIHJlY2VpdmVkKSB0aGF0IHdlIGNhbiB0ZW1wb3JhcmlseSBub3QgaGF2ZSBhIG1hdGNoaW5nIGV2ZW50IGZvclxuICAgICAgICAvLyBzb21lb25lIHdoaWNoIGhhZCBvbmUgaW4gdGhlIGxhc3QuIEJ5IGxvb2tpbmcgdGhyb3VnaCBvdXIgcHJldmlvdXNcbiAgICAgICAgLy8gbWFwcGluZyBvZiByZWNlaXB0cyBieSB1c2VyIElELCB3ZSBjYW4gY292ZXIgcmVjb3ZlciBhbnkgcmVjZWlwdHNcbiAgICAgICAgLy8gdGhhdCB3b3VsZCBoYXZlIGJlZW4gbG9zdCBieSB1c2luZyB0aGUgc2FtZSBldmVudCBJRCBmcm9tIGxhc3QgdGltZS5cbiAgICAgICAgZm9yIChjb25zdCB1c2VySWQgaW4gdGhpcy5yZWFkUmVjZWlwdHNCeVVzZXJJZCkge1xuICAgICAgICAgICAgaWYgKHJlY2VpcHRzQnlVc2VySWRbdXNlcklkXSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBsYXN0U2hvd25FdmVudElkLCByZWNlaXB0IH0gPSB0aGlzLnJlYWRSZWNlaXB0c0J5VXNlcklkW3VzZXJJZF07XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1JlY2VpcHRzID0gcmVjZWlwdHNCeUV2ZW50W2xhc3RTaG93bkV2ZW50SWRdIHx8IFtdO1xuICAgICAgICAgICAgcmVjZWlwdHNCeUV2ZW50W2xhc3RTaG93bkV2ZW50SWRdID0gZXhpc3RpbmdSZWNlaXB0cy5jb25jYXQocmVjZWlwdCk7XG4gICAgICAgICAgICByZWNlaXB0c0J5VXNlcklkW3VzZXJJZF0gPSB7IGxhc3RTaG93bkV2ZW50SWQsIHJlY2VpcHQgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlYWRSZWNlaXB0c0J5VXNlcklkID0gcmVjZWlwdHNCeVVzZXJJZDtcblxuICAgICAgICAvLyBBZnRlciBncm91cGluZyByZWNlaXB0cyBieSBzaG93biBldmVudHMsIGRvIGFub3RoZXIgcGFzcyB0byBzb3J0IGVhY2hcbiAgICAgICAgLy8gcmVjZWlwdCBsaXN0LlxuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50SWQgaW4gcmVjZWlwdHNCeUV2ZW50KSB7XG4gICAgICAgICAgICByZWNlaXB0c0J5RXZlbnRbZXZlbnRJZF0uc29ydCgocjEsIHIyKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIyLnRzIC0gcjEudHM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWNlaXB0c0J5RXZlbnQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjb2xsZWN0RXZlbnROb2RlID0gKGV2ZW50SWQ6IHN0cmluZywgbm9kZTogRXZlbnRUaWxlKTogdm9pZCA9PiB7XG4gICAgICAgIHRoaXMuZXZlbnROb2Rlc1tldmVudElkXSA9IG5vZGU/LnJlZj8uY3VycmVudDtcbiAgICB9O1xuXG4gICAgLy8gb25jZSBkeW5hbWljIGNvbnRlbnQgaW4gdGhlIGV2ZW50cyBsb2FkLCBtYWtlIHRoZSBzY3JvbGxQYW5lbCBjaGVjayB0aGVcbiAgICAvLyBzY3JvbGwgb2Zmc2V0cy5cbiAgICBwdWJsaWMgb25IZWlnaHRDaGFuZ2VkID0gKCk6IHZvaWQgPT4ge1xuICAgICAgICBjb25zdCBzY3JvbGxQYW5lbCA9IHRoaXMuc2Nyb2xsUGFuZWwuY3VycmVudDtcbiAgICAgICAgaWYgKHNjcm9sbFBhbmVsKSB7XG4gICAgICAgICAgICBzY3JvbGxQYW5lbC5jaGVja1Njcm9sbCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25UeXBpbmdTaG93biA9ICgpOiB2b2lkID0+IHtcbiAgICAgICAgY29uc3Qgc2Nyb2xsUGFuZWwgPSB0aGlzLnNjcm9sbFBhbmVsLmN1cnJlbnQ7XG4gICAgICAgIC8vIHRoaXMgd2lsbCBtYWtlIHRoZSB0aW1lbGluZSBncm93LCBzbyBjaGVja1Njcm9sbFxuICAgICAgICBzY3JvbGxQYW5lbC5jaGVja1Njcm9sbCgpO1xuICAgICAgICBpZiAoc2Nyb2xsUGFuZWwgJiYgc2Nyb2xsUGFuZWwuZ2V0U2Nyb2xsU3RhdGUoKS5zdHVja0F0Qm90dG9tKSB7XG4gICAgICAgICAgICBzY3JvbGxQYW5lbC5wcmV2ZW50U2hyaW5raW5nKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvblR5cGluZ0hpZGRlbiA9ICgpOiB2b2lkID0+IHtcbiAgICAgICAgY29uc3Qgc2Nyb2xsUGFuZWwgPSB0aGlzLnNjcm9sbFBhbmVsLmN1cnJlbnQ7XG4gICAgICAgIGlmIChzY3JvbGxQYW5lbCkge1xuICAgICAgICAgICAgLy8gYXMgaGlkaW5nIHRoZSB0eXBpbmcgbm90aWZpY2F0aW9ucyBkb2Vzbid0XG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHNjcm9sbFBhbmVsLCB3ZSB0ZWxsIGl0IHRvIGFwcGx5XG4gICAgICAgICAgICAvLyB0aGUgc2hyaW5raW5nIHByZXZlbnRpb24gb25jZSB0aGUgdHlwaW5nIG5vdGlmcyBhcmUgaGlkZGVuXG4gICAgICAgICAgICBzY3JvbGxQYW5lbC51cGRhdGVQcmV2ZW50U2hyaW5raW5nKCk7XG4gICAgICAgICAgICAvLyBvcmRlciBpcyBpbXBvcnRhbnQgaGVyZSBhcyBjaGVja1Njcm9sbCB3aWxsIHNjcm9sbCBkb3duIHRvXG4gICAgICAgICAgICAvLyByZXZlYWwgYWRkZWQgcGFkZGluZyB0byBiYWxhbmNlIHRoZSBub3RpZnMgZGlzYXBwZWFyaW5nLlxuICAgICAgICAgICAgc2Nyb2xsUGFuZWwuY2hlY2tTY3JvbGwoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwdWJsaWMgdXBkYXRlVGltZWxpbmVNaW5IZWlnaHQoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHNjcm9sbFBhbmVsID0gdGhpcy5zY3JvbGxQYW5lbC5jdXJyZW50O1xuXG4gICAgICAgIGlmIChzY3JvbGxQYW5lbCkge1xuICAgICAgICAgICAgY29uc3QgaXNBdEJvdHRvbSA9IHNjcm9sbFBhbmVsLmlzQXRCb3R0b20oKTtcbiAgICAgICAgICAgIGNvbnN0IHdob0lzVHlwaW5nID0gdGhpcy53aG9Jc1R5cGluZy5jdXJyZW50O1xuICAgICAgICAgICAgY29uc3QgaXNUeXBpbmdWaXNpYmxlID0gd2hvSXNUeXBpbmcgJiYgd2hvSXNUeXBpbmcuaXNWaXNpYmxlKCk7XG4gICAgICAgICAgICAvLyB3aGVuIG1lc3NhZ2VzIGdldCBhZGRlZCB0byB0aGUgdGltZWxpbmUsXG4gICAgICAgICAgICAvLyBidXQgc29tZWJvZHkgZWxzZSBpcyBzdGlsbCB0eXBpbmcsXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIG1pbi1oZWlnaHQsIHNvIG9uY2UgdGhlIGxhc3RcbiAgICAgICAgICAgIC8vIHBlcnNvbiBzdG9wcyB0eXBpbmcsIG5vIGp1bXBpbmcgb2NjdXJzXG4gICAgICAgICAgICBpZiAoaXNBdEJvdHRvbSAmJiBpc1R5cGluZ1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxQYW5lbC5wcmV2ZW50U2hyaW5raW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgb25UaW1lbGluZVJlc2V0KCk6IHZvaWQge1xuICAgICAgICBjb25zdCBzY3JvbGxQYW5lbCA9IHRoaXMuc2Nyb2xsUGFuZWwuY3VycmVudDtcbiAgICAgICAgaWYgKHNjcm9sbFBhbmVsKSB7XG4gICAgICAgICAgICBzY3JvbGxQYW5lbC5jbGVhclByZXZlbnRTaHJpbmtpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHRvcFNwaW5uZXI7XG4gICAgICAgIGxldCBib3R0b21TcGlubmVyO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5iYWNrUGFnaW5hdGluZykge1xuICAgICAgICAgICAgdG9wU3Bpbm5lciA9IDxsaSBrZXk9XCJfdG9wU3Bpbm5lclwiPjxTcGlubmVyIC8+PC9saT47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZm9yd2FyZFBhZ2luYXRpbmcpIHtcbiAgICAgICAgICAgIGJvdHRvbVNwaW5uZXIgPSA8bGkga2V5PVwiX2JvdHRvbVNwaW5uZXJcIj48U3Bpbm5lciAvPjwvbGk+O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3R5bGUgPSB0aGlzLnByb3BzLmhpZGRlbiA/IHsgZGlzcGxheTogJ25vbmUnIH0gOiB7fTtcblxuICAgICAgICBsZXQgd2hvSXNUeXBpbmc7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnJvb20gJiYgIXRoaXMucHJvcHMudGlsZVNoYXBlICYmIHRoaXMuc3RhdGUuc2hvd1R5cGluZ05vdGlmaWNhdGlvbnMpIHtcbiAgICAgICAgICAgIHdob0lzVHlwaW5nID0gKDxXaG9Jc1R5cGluZ1RpbGVcbiAgICAgICAgICAgICAgICByb29tPXt0aGlzLnByb3BzLnJvb219XG4gICAgICAgICAgICAgICAgb25TaG93bj17dGhpcy5vblR5cGluZ1Nob3dufVxuICAgICAgICAgICAgICAgIG9uSGlkZGVuPXt0aGlzLm9uVHlwaW5nSGlkZGVufVxuICAgICAgICAgICAgICAgIHJlZj17dGhpcy53aG9Jc1R5cGluZ30gLz5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaXJjUmVzaXplciA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmxheW91dCA9PSBMYXlvdXQuSVJDKSB7XG4gICAgICAgICAgICBpcmNSZXNpemVyID0gPElSQ1RpbWVsaW5lUHJvZmlsZVJlc2l6ZXJcbiAgICAgICAgICAgICAgICBtaW5XaWR0aD17MjB9XG4gICAgICAgICAgICAgICAgbWF4V2lkdGg9ezYwMH1cbiAgICAgICAgICAgICAgICByb29tSWQ9e3RoaXMucHJvcHMucm9vbSA/IHRoaXMucHJvcHMucm9vbS5yb29tSWQgOiBudWxsfVxuICAgICAgICAgICAgLz47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPEVycm9yQm91bmRhcnk+XG4gICAgICAgICAgICAgICAgPFNjcm9sbFBhbmVsXG4gICAgICAgICAgICAgICAgICAgIHJlZj17dGhpcy5zY3JvbGxQYW5lbH1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXt0aGlzLnByb3BzLmNsYXNzTmFtZX1cbiAgICAgICAgICAgICAgICAgICAgb25TY3JvbGw9e3RoaXMucHJvcHMub25TY3JvbGx9XG4gICAgICAgICAgICAgICAgICAgIG9uVXNlclNjcm9sbD17dGhpcy5wcm9wcy5vblVzZXJTY3JvbGx9XG4gICAgICAgICAgICAgICAgICAgIG9uRmlsbFJlcXVlc3Q9e3RoaXMucHJvcHMub25GaWxsUmVxdWVzdH1cbiAgICAgICAgICAgICAgICAgICAgb25VbmZpbGxSZXF1ZXN0PXt0aGlzLnByb3BzLm9uVW5maWxsUmVxdWVzdH1cbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3N0eWxlfVxuICAgICAgICAgICAgICAgICAgICBzdGlja3lCb3R0b209e3RoaXMucHJvcHMuc3RpY2t5Qm90dG9tfVxuICAgICAgICAgICAgICAgICAgICByZXNpemVOb3RpZmllcj17dGhpcy5wcm9wcy5yZXNpemVOb3RpZmllcn1cbiAgICAgICAgICAgICAgICAgICAgZml4ZWRDaGlsZHJlbj17aXJjUmVzaXplcn1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIHsgdG9wU3Bpbm5lciB9XG4gICAgICAgICAgICAgICAgICAgIHsgdGhpcy5nZXRFdmVudFRpbGVzKCkgfVxuICAgICAgICAgICAgICAgICAgICB7IHdob0lzVHlwaW5nIH1cbiAgICAgICAgICAgICAgICAgICAgeyBib3R0b21TcGlubmVyIH1cbiAgICAgICAgICAgICAgICA8L1Njcm9sbFBhbmVsPlxuICAgICAgICAgICAgPC9FcnJvckJvdW5kYXJ5PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuYWJzdHJhY3QgY2xhc3MgQmFzZUdyb3VwZXIge1xuICAgIHN0YXRpYyBjYW5TdGFydEdyb3VwID0gKHBhbmVsOiBNZXNzYWdlUGFuZWwsIGV2OiBNYXRyaXhFdmVudCk6IGJvb2xlYW4gPT4gdHJ1ZTtcblxuICAgIHB1YmxpYyBldmVudHM6IE1hdHJpeEV2ZW50W10gPSBbXTtcbiAgICAvLyBldmVudHMgdGhhdCB3ZSBpbmNsdWRlIGluIHRoZSBncm91cCBidXQgdGhlbiBlamVjdCBvdXQgYW5kIHBsYWNlIGFib3ZlIHRoZSBncm91cC5cbiAgICBwdWJsaWMgZWplY3RlZEV2ZW50czogTWF0cml4RXZlbnRbXSA9IFtdO1xuICAgIHB1YmxpYyByZWFkTWFya2VyOiBSZWFjdE5vZGU7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHVibGljIHJlYWRvbmx5IHBhbmVsOiBNZXNzYWdlUGFuZWwsXG4gICAgICAgIHB1YmxpYyByZWFkb25seSBldmVudDogTWF0cml4RXZlbnQsXG4gICAgICAgIHB1YmxpYyByZWFkb25seSBwcmV2RXZlbnQ6IE1hdHJpeEV2ZW50LFxuICAgICAgICBwdWJsaWMgcmVhZG9ubHkgbGFzdFNob3duRXZlbnQ6IE1hdHJpeEV2ZW50LFxuICAgICAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgbGF5b3V0OiBMYXlvdXQsXG4gICAgICAgIHB1YmxpYyByZWFkb25seSBuZXh0RXZlbnQ/OiBNYXRyaXhFdmVudCxcbiAgICAgICAgcHVibGljIHJlYWRvbmx5IG5leHRFdmVudFRpbGU/OiBNYXRyaXhFdmVudCxcbiAgICApIHtcbiAgICAgICAgdGhpcy5yZWFkTWFya2VyID0gcGFuZWwucmVhZE1hcmtlckZvckV2ZW50KGV2ZW50LmdldElkKCksIGV2ZW50ID09PSBsYXN0U2hvd25FdmVudCk7XG4gICAgfVxuXG4gICAgcHVibGljIGFic3RyYWN0IHNob3VsZEdyb3VwKGV2OiBNYXRyaXhFdmVudCk6IGJvb2xlYW47XG4gICAgcHVibGljIGFic3RyYWN0IGFkZChldjogTWF0cml4RXZlbnQsIHNob3dIaWRkZW5FdmVudHM/OiBib29sZWFuKTogdm9pZDtcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0VGlsZXMoKTogUmVhY3ROb2RlW107XG4gICAgcHVibGljIGFic3RyYWN0IGdldE5ld1ByZXZFdmVudCgpOiBNYXRyaXhFdmVudDtcbn1cblxuLyogR3JvdXBlciBjbGFzc2VzIGRldGVybWluZSB3aGVuIGV2ZW50cyBjYW4gYmUgZ3JvdXBlZCB0b2dldGhlciBpbiBhIHN1bW1hcnkuXG4gKiBHcm91cGVycyBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XG4gKiAtIGNhblN0YXJ0R3JvdXAgKHN0YXRpYyk6IGRldGVybWluZXMgaWYgYSBuZXcgZ3JvdXAgc2hvdWxkIGJlIHN0YXJ0ZWQgd2l0aCB0aGVcbiAqICAgZ2l2ZW4gZXZlbnRcbiAqIC0gc2hvdWxkR3JvdXA6IGRldGVybWluZXMgaWYgdGhlIGdpdmVuIGV2ZW50IHNob3VsZCBiZSBhZGRlZCB0byBhbiBleGlzdGluZyBncm91cFxuICogLSBhZGQ6IGFkZHMgYW4gZXZlbnQgdG8gYW4gZXhpc3RpbmcgZ3JvdXAgKHNob3VsZCBvbmx5IGJlIGNhbGxlZCBpZiBzaG91bGRHcm91cFxuICogICByZXR1cm4gdHJ1ZSlcbiAqIC0gZ2V0VGlsZXM6IHJldHVybnMgdGhlIHRpbGVzIHRoYXQgcmVwcmVzZW50IHRoZSBncm91cFxuICogLSBnZXROZXdQcmV2RXZlbnQ6IHJldHVybnMgdGhlIGV2ZW50IHRoYXQgc2hvdWxkIGJlIHVzZWQgYXMgdGhlIG5ldyBwcmV2RXZlbnRcbiAqICAgd2hlbiBkZXRlcm1pbmluZyB0aGluZ3Mgc3VjaCBhcyB3aGV0aGVyIGEgZGF0ZSBzZXBhcmF0b3IgaXMgbmVjZXNzYXJ5XG4gKi9cblxuLy8gV3JhcCBpbml0aWFsIHJvb20gY3JlYXRpb24gZXZlbnRzIGludG8gYW4gRXZlbnRMaXN0U3VtbWFyeVxuLy8gR3JvdXBpbmcgb25seSBldmVudHMgc2VudCBieSB0aGUgc2FtZSB1c2VyIHRoYXQgc2VudCB0aGUgYG0ucm9vbS5jcmVhdGVgIGFuZCBvbmx5IHVudGlsXG4vLyB0aGUgZmlyc3Qgbm9uLXN0YXRlIGV2ZW50IG9yIG1lbWJlcnNoaXAgZXZlbnQgd2hpY2ggaXMgbm90IHJlZ2FyZGluZyB0aGUgc2VuZGVyIG9mIHRoZSBgbS5yb29tLmNyZWF0ZWAgZXZlbnRcbmNsYXNzIENyZWF0aW9uR3JvdXBlciBleHRlbmRzIEJhc2VHcm91cGVyIHtcbiAgICBzdGF0aWMgY2FuU3RhcnRHcm91cCA9IGZ1bmN0aW9uKHBhbmVsOiBNZXNzYWdlUGFuZWwsIGV2OiBNYXRyaXhFdmVudCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZXYuZ2V0VHlwZSgpID09PSBFdmVudFR5cGUuUm9vbUNyZWF0ZTtcbiAgICB9O1xuXG4gICAgcHVibGljIHNob3VsZEdyb3VwKGV2OiBNYXRyaXhFdmVudCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBwYW5lbCA9IHRoaXMucGFuZWw7XG4gICAgICAgIGNvbnN0IGNyZWF0ZUV2ZW50ID0gdGhpcy5ldmVudDtcbiAgICAgICAgaWYgKCFwYW5lbC5zaG91bGRTaG93RXZlbnQoZXYpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFuZWwud2FudHNEYXRlU2VwYXJhdG9yKHRoaXMuZXZlbnQsIGV2LmdldERhdGUoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXYuZ2V0VHlwZSgpID09PSBFdmVudFR5cGUuUm9vbU1lbWJlclxuICAgICAgICAgICAgJiYgKGV2LmdldFN0YXRlS2V5KCkgIT09IGNyZWF0ZUV2ZW50LmdldFNlbmRlcigpIHx8IGV2LmdldENvbnRlbnQoKVtcIm1lbWJlcnNoaXBcIl0gIT09IFwiam9pblwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldi5pc1N0YXRlKCkgJiYgZXYuZ2V0U2VuZGVyKCkgPT09IGNyZWF0ZUV2ZW50LmdldFNlbmRlcigpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcHVibGljIGFkZChldjogTWF0cml4RXZlbnQpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgcGFuZWwgPSB0aGlzLnBhbmVsO1xuICAgICAgICB0aGlzLnJlYWRNYXJrZXIgPSB0aGlzLnJlYWRNYXJrZXIgfHwgcGFuZWwucmVhZE1hcmtlckZvckV2ZW50KFxuICAgICAgICAgICAgZXYuZ2V0SWQoKSxcbiAgICAgICAgICAgIGV2ID09PSB0aGlzLmxhc3RTaG93bkV2ZW50LFxuICAgICAgICApO1xuICAgICAgICBpZiAoIXBhbmVsLnNob3VsZFNob3dFdmVudChldikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXYuZ2V0VHlwZSgpID09PSBFdmVudFR5cGUuUm9vbUVuY3J5cHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZWplY3RlZEV2ZW50cy5wdXNoKGV2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnB1c2goZXYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGdldFRpbGVzKCk6IFJlYWN0Tm9kZVtdIHtcbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgZXZlbnRzIHRvIGdyb3VwLCBkb24ndCBldmVuIHRyeSB0byBncm91cCB0aGVtLiBUaGUgbG9naWNcbiAgICAgICAgLy8gYmVsb3cgYXNzdW1lcyB0aGF0IHdlIGhhdmUgYSBncm91cCBvZiBldmVudHMgdG8gZGVhbCB3aXRoLCBidXQgd2UgbWlnaHQgbm90IGlmXG4gICAgICAgIC8vIHRoZSBldmVudHMgd2Ugd2VyZSBzdXBwb3NlZCB0byBncm91cCB3ZXJlIHJlZGFjdGVkLlxuICAgICAgICBpZiAoIXRoaXMuZXZlbnRzIHx8ICF0aGlzLmV2ZW50cy5sZW5ndGgpIHJldHVybiBbXTtcblxuICAgICAgICBjb25zdCBwYW5lbCA9IHRoaXMucGFuZWw7XG4gICAgICAgIGNvbnN0IHJldCA9IFtdO1xuICAgICAgICBjb25zdCBpc0dyb3VwZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBjcmVhdGVFdmVudCA9IHRoaXMuZXZlbnQ7XG4gICAgICAgIGNvbnN0IGxhc3RTaG93bkV2ZW50ID0gdGhpcy5sYXN0U2hvd25FdmVudDtcblxuICAgICAgICBpZiAocGFuZWwud2FudHNEYXRlU2VwYXJhdG9yKHRoaXMucHJldkV2ZW50LCBjcmVhdGVFdmVudC5nZXREYXRlKCkpKSB7XG4gICAgICAgICAgICBjb25zdCB0cyA9IGNyZWF0ZUV2ZW50LmdldFRzKCk7XG4gICAgICAgICAgICByZXQucHVzaChcbiAgICAgICAgICAgICAgICA8bGkga2V5PXt0cysnfid9PjxEYXRlU2VwYXJhdG9yIGtleT17dHMrJ34nfSB0cz17dHN9IC8+PC9saT4sXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhpcyBtLnJvb20uY3JlYXRlIGV2ZW50IHNob3VsZCBiZSBzaG93biAocm9vbSB1cGdyYWRlKSB0aGVuIHNob3cgaXQgYmVmb3JlIHRoZSBzdW1tYXJ5XG4gICAgICAgIGlmIChwYW5lbC5zaG91bGRTaG93RXZlbnQoY3JlYXRlRXZlbnQpKSB7XG4gICAgICAgICAgICAvLyBwYXNzIGluIHRoZSBjcmVhdGVFdmVudCBhcyBwcmV2RXZlbnQgYXMgd2VsbCBzbyBubyBleHRyYSBEYXRlU2VwYXJhdG9yIGlzIHJlbmRlcmVkXG4gICAgICAgICAgICByZXQucHVzaCguLi5wYW5lbC5nZXRUaWxlc0ZvckV2ZW50KGNyZWF0ZUV2ZW50LCBjcmVhdGVFdmVudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBlamVjdGVkIG9mIHRoaXMuZWplY3RlZEV2ZW50cykge1xuICAgICAgICAgICAgcmV0LnB1c2goLi4ucGFuZWwuZ2V0VGlsZXNGb3JFdmVudChcbiAgICAgICAgICAgICAgICBjcmVhdGVFdmVudCwgZWplY3RlZCwgY3JlYXRlRXZlbnQgPT09IGxhc3RTaG93bkV2ZW50LCBpc0dyb3VwZWQsXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGV2ZW50VGlsZXMgPSB0aGlzLmV2ZW50cy5tYXAoKGUpID0+IHtcbiAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIHByZXZlbnQgRGF0ZVNlcGFyYXRvcnMgZnJvbSBhcHBlYXJpbmcgaW4gdGhlIGV4cGFuZGVkIGZvcm1cbiAgICAgICAgICAgIC8vIG9mIEV2ZW50TGlzdFN1bW1hcnksIHJlbmRlciBlYWNoIG1lbWJlciBldmVudCBhcyBpZiB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgIC8vIG9uZSB3YXMgaXRzZWxmLiBUaGlzIHdheSwgdGhlIHRpbWVzdGFtcCBvZiB0aGUgcHJldmlvdXMgZXZlbnQgPT09IHRoZVxuICAgICAgICAgICAgLy8gdGltZXN0YW1wIG9mIHRoZSBjdXJyZW50IGV2ZW50LCBhbmQgbm8gRGF0ZVNlcGFyYXRvciBpcyBpbnNlcnRlZC5cbiAgICAgICAgICAgIHJldHVybiBwYW5lbC5nZXRUaWxlc0ZvckV2ZW50KGUsIGUsIGUgPT09IGxhc3RTaG93bkV2ZW50LCBpc0dyb3VwZWQpO1xuICAgICAgICB9KS5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpLCBbXSk7XG4gICAgICAgIC8vIEdldCBzZW5kZXIgcHJvZmlsZSBmcm9tIHRoZSBsYXRlc3QgZXZlbnQgaW4gdGhlIHN1bW1hcnkgYXMgdGhlIG0ucm9vbS5jcmVhdGUgZG9lc24ndCBjb250YWluIG9uZVxuICAgICAgICBjb25zdCBldiA9IHRoaXMuZXZlbnRzW3RoaXMuZXZlbnRzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGxldCBzdW1tYXJ5VGV4dDtcbiAgICAgICAgY29uc3Qgcm9vbUlkID0gZXYuZ2V0Um9vbUlkKCk7XG4gICAgICAgIGNvbnN0IGNyZWF0b3IgPSBldi5zZW5kZXIgPyBldi5zZW5kZXIubmFtZSA6IGV2LmdldFNlbmRlcigpO1xuICAgICAgICBpZiAoRE1Sb29tTWFwLnNoYXJlZCgpLmdldFVzZXJJZEZvclJvb21JZChyb29tSWQpKSB7XG4gICAgICAgICAgICBzdW1tYXJ5VGV4dCA9IF90KFwiJShjcmVhdG9yKXMgY3JlYXRlZCB0aGlzIERNLlwiLCB7IGNyZWF0b3IgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdW1tYXJ5VGV4dCA9IF90KFwiJShjcmVhdG9yKXMgY3JlYXRlZCBhbmQgY29uZmlndXJlZCB0aGUgcm9vbS5cIiwgeyBjcmVhdG9yIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0LnB1c2goPE5ld1Jvb21JbnRybyBrZXk9XCJuZXdyb29taW50cm9cIiAvPik7XG5cbiAgICAgICAgcmV0LnB1c2goXG4gICAgICAgICAgICA8RXZlbnRMaXN0U3VtbWFyeVxuICAgICAgICAgICAgICAgIGtleT1cInJvb21jcmVhdGlvbnN1bW1hcnlcIlxuICAgICAgICAgICAgICAgIGV2ZW50cz17dGhpcy5ldmVudHN9XG4gICAgICAgICAgICAgICAgb25Ub2dnbGU9e3BhbmVsLm9uSGVpZ2h0Q2hhbmdlZH0gLy8gVXBkYXRlIHNjcm9sbCBzdGF0ZVxuICAgICAgICAgICAgICAgIHN1bW1hcnlNZW1iZXJzPXtbZXYuc2VuZGVyXX1cbiAgICAgICAgICAgICAgICBzdW1tYXJ5VGV4dD17c3VtbWFyeVRleHR9XG4gICAgICAgICAgICAgICAgbGF5b3V0PXt0aGlzLmxheW91dH1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7IGV2ZW50VGlsZXMgfVxuICAgICAgICAgICAgPC9FdmVudExpc3RTdW1tYXJ5PixcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodGhpcy5yZWFkTWFya2VyKSB7XG4gICAgICAgICAgICByZXQucHVzaCh0aGlzLnJlYWRNYXJrZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0TmV3UHJldkV2ZW50KCk6IE1hdHJpeEV2ZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnQ7XG4gICAgfVxufVxuXG5jbGFzcyBSZWRhY3Rpb25Hcm91cGVyIGV4dGVuZHMgQmFzZUdyb3VwZXIge1xuICAgIHN0YXRpYyBjYW5TdGFydEdyb3VwID0gZnVuY3Rpb24ocGFuZWw6IE1lc3NhZ2VQYW5lbCwgZXY6IE1hdHJpeEV2ZW50KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBwYW5lbC5zaG91bGRTaG93RXZlbnQoZXYpICYmIGV2LmlzUmVkYWN0ZWQoKTtcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHBhbmVsOiBNZXNzYWdlUGFuZWwsXG4gICAgICAgIGV2OiBNYXRyaXhFdmVudCxcbiAgICAgICAgcHJldkV2ZW50OiBNYXRyaXhFdmVudCxcbiAgICAgICAgbGFzdFNob3duRXZlbnQ6IE1hdHJpeEV2ZW50LFxuICAgICAgICBsYXlvdXQ6IExheW91dCxcbiAgICAgICAgbmV4dEV2ZW50OiBNYXRyaXhFdmVudCxcbiAgICAgICAgbmV4dEV2ZW50VGlsZTogTWF0cml4RXZlbnQsXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKHBhbmVsLCBldiwgcHJldkV2ZW50LCBsYXN0U2hvd25FdmVudCwgbGF5b3V0LCBuZXh0RXZlbnQsIG5leHRFdmVudFRpbGUpO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IFtldl07XG4gICAgfVxuXG4gICAgcHVibGljIHNob3VsZEdyb3VwKGV2OiBNYXRyaXhFdmVudCk6IGJvb2xlYW4ge1xuICAgICAgICAvLyBhYnNvcmIgaGlkZGVuIGV2ZW50cyBzbyB0aGF0IHRoZXkgZG8gbm90IGJyZWFrIHVwIHN0cmVhbXMgb2YgbWVzc2FnZXMgJiByZWRhY3Rpb24gZXZlbnRzIGJlaW5nIGdyb3VwZWRcbiAgICAgICAgaWYgKCF0aGlzLnBhbmVsLnNob3VsZFNob3dFdmVudChldikpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhbmVsLndhbnRzRGF0ZVNlcGFyYXRvcih0aGlzLmV2ZW50c1swXSwgZXYuZ2V0RGF0ZSgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldi5pc1JlZGFjdGVkKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGFkZChldjogTWF0cml4RXZlbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5yZWFkTWFya2VyID0gdGhpcy5yZWFkTWFya2VyIHx8IHRoaXMucGFuZWwucmVhZE1hcmtlckZvckV2ZW50KFxuICAgICAgICAgICAgZXYuZ2V0SWQoKSxcbiAgICAgICAgICAgIGV2ID09PSB0aGlzLmxhc3RTaG93bkV2ZW50LFxuICAgICAgICApO1xuICAgICAgICBpZiAoIXRoaXMucGFuZWwuc2hvdWxkU2hvd0V2ZW50KGV2KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRzLnB1c2goZXYpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRUaWxlcygpOiBSZWFjdE5vZGVbXSB7XG4gICAgICAgIGlmICghdGhpcy5ldmVudHMgfHwgIXRoaXMuZXZlbnRzLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIGNvbnN0IGlzR3JvdXBlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHBhbmVsID0gdGhpcy5wYW5lbDtcbiAgICAgICAgY29uc3QgcmV0ID0gW107XG4gICAgICAgIGNvbnN0IGxhc3RTaG93bkV2ZW50ID0gdGhpcy5sYXN0U2hvd25FdmVudDtcblxuICAgICAgICBpZiAocGFuZWwud2FudHNEYXRlU2VwYXJhdG9yKHRoaXMucHJldkV2ZW50LCB0aGlzLmV2ZW50c1swXS5nZXREYXRlKCkpKSB7XG4gICAgICAgICAgICBjb25zdCB0cyA9IHRoaXMuZXZlbnRzWzBdLmdldFRzKCk7XG4gICAgICAgICAgICByZXQucHVzaChcbiAgICAgICAgICAgICAgICA8bGkga2V5PXt0cysnfid9PjxEYXRlU2VwYXJhdG9yIGtleT17dHMrJ34nfSB0cz17dHN9IC8+PC9saT4sXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qga2V5ID0gXCJyZWRhY3Rpb25ldmVudGxpc3RzdW1tYXJ5LVwiICsgKFxuICAgICAgICAgICAgdGhpcy5wcmV2RXZlbnQgPyB0aGlzLmV2ZW50c1swXS5nZXRJZCgpIDogXCJpbml0aWFsXCJcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBzZW5kZXJzID0gbmV3IFNldDxSb29tTWVtYmVyPigpO1xuICAgICAgICBsZXQgZXZlbnRUaWxlcyA9IHRoaXMuZXZlbnRzLm1hcCgoZSwgaSkgPT4ge1xuICAgICAgICAgICAgc2VuZGVycy5hZGQoZS5zZW5kZXIpO1xuICAgICAgICAgICAgY29uc3QgcHJldkV2ZW50ID0gaSA9PT0gMCA/IHRoaXMucHJldkV2ZW50IDogdGhpcy5ldmVudHNbaSAtIDFdO1xuICAgICAgICAgICAgcmV0dXJuIHBhbmVsLmdldFRpbGVzRm9yRXZlbnQoXG4gICAgICAgICAgICAgICAgcHJldkV2ZW50LCBlLCBlID09PSBsYXN0U2hvd25FdmVudCwgaXNHcm91cGVkLCB0aGlzLm5leHRFdmVudCwgdGhpcy5uZXh0RXZlbnRUaWxlKTtcbiAgICAgICAgfSkucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pO1xuXG4gICAgICAgIGlmIChldmVudFRpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZXZlbnRUaWxlcyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXQucHVzaChcbiAgICAgICAgICAgIDxFdmVudExpc3RTdW1tYXJ5XG4gICAgICAgICAgICAgICAga2V5PXtrZXl9XG4gICAgICAgICAgICAgICAgdGhyZXNob2xkPXsyfVxuICAgICAgICAgICAgICAgIGV2ZW50cz17dGhpcy5ldmVudHN9XG4gICAgICAgICAgICAgICAgb25Ub2dnbGU9e3BhbmVsLm9uSGVpZ2h0Q2hhbmdlZH0gLy8gVXBkYXRlIHNjcm9sbCBzdGF0ZVxuICAgICAgICAgICAgICAgIHN1bW1hcnlNZW1iZXJzPXtBcnJheS5mcm9tKHNlbmRlcnMpfVxuICAgICAgICAgICAgICAgIHN1bW1hcnlUZXh0PXtfdChcIiUoY291bnQpcyBtZXNzYWdlcyBkZWxldGVkLlwiLCB7IGNvdW50OiBldmVudFRpbGVzLmxlbmd0aCB9KX1cbiAgICAgICAgICAgICAgICBsYXlvdXQ9e3RoaXMubGF5b3V0fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHsgZXZlbnRUaWxlcyB9XG4gICAgICAgICAgICA8L0V2ZW50TGlzdFN1bW1hcnk+LFxuICAgICAgICApO1xuXG4gICAgICAgIGlmICh0aGlzLnJlYWRNYXJrZXIpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKHRoaXMucmVhZE1hcmtlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXROZXdQcmV2RXZlbnQoKTogTWF0cml4RXZlbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5ldmVudHNbdGhpcy5ldmVudHMubGVuZ3RoIC0gMV07XG4gICAgfVxufVxuXG4vLyBXcmFwIGNvbnNlY3V0aXZlIG1lbWJlciBldmVudHMgaW4gYSBMaXN0U3VtbWFyeSwgaWdub3JlIGlmIHJlZGFjdGVkXG5jbGFzcyBNZW1iZXJHcm91cGVyIGV4dGVuZHMgQmFzZUdyb3VwZXIge1xuICAgIHN0YXRpYyBjYW5TdGFydEdyb3VwID0gZnVuY3Rpb24ocGFuZWw6IE1lc3NhZ2VQYW5lbCwgZXY6IE1hdHJpeEV2ZW50KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBwYW5lbC5zaG91bGRTaG93RXZlbnQoZXYpICYmIGdyb3VwZWRFdmVudHMuaW5jbHVkZXMoZXYuZ2V0VHlwZSgpIGFzIEV2ZW50VHlwZSk7XG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwdWJsaWMgcmVhZG9ubHkgcGFuZWw6IE1lc3NhZ2VQYW5lbCxcbiAgICAgICAgcHVibGljIHJlYWRvbmx5IGV2ZW50OiBNYXRyaXhFdmVudCxcbiAgICAgICAgcHVibGljIHJlYWRvbmx5IHByZXZFdmVudDogTWF0cml4RXZlbnQsXG4gICAgICAgIHB1YmxpYyByZWFkb25seSBsYXN0U2hvd25FdmVudDogTWF0cml4RXZlbnQsXG4gICAgICAgIHByb3RlY3RlZCByZWFkb25seSBsYXlvdXQ6IExheW91dCxcbiAgICApIHtcbiAgICAgICAgc3VwZXIocGFuZWwsIGV2ZW50LCBwcmV2RXZlbnQsIGxhc3RTaG93bkV2ZW50LCBsYXlvdXQpO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IFtldmVudF07XG4gICAgfVxuXG4gICAgcHVibGljIHNob3VsZEdyb3VwKGV2OiBNYXRyaXhFdmVudCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodGhpcy5wYW5lbC53YW50c0RhdGVTZXBhcmF0b3IodGhpcy5ldmVudHNbMF0sIGV2LmdldERhdGUoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JvdXBlZEV2ZW50cy5pbmNsdWRlcyhldi5nZXRUeXBlKCkgYXMgRXZlbnRUeXBlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYWRkKGV2OiBNYXRyaXhFdmVudCwgc2hvd0hpZGRlbkV2ZW50cz86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgaWYgKGV2LmdldFR5cGUoKSA9PT0gRXZlbnRUeXBlLlJvb21NZW1iZXIpIHtcbiAgICAgICAgICAgIC8vIFdlIGNhbiBpZ25vcmUgYW55IGV2ZW50cyB0aGF0IGRvbid0IGFjdHVhbGx5IGhhdmUgYSBtZXNzYWdlIHRvIGRpc3BsYXlcbiAgICAgICAgICAgIGlmICghaGFzVGV4dChldiwgc2hvd0hpZGRlbkV2ZW50cykpIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlYWRNYXJrZXIgPSB0aGlzLnJlYWRNYXJrZXIgfHwgdGhpcy5wYW5lbC5yZWFkTWFya2VyRm9yRXZlbnQoXG4gICAgICAgICAgICBldi5nZXRJZCgpLFxuICAgICAgICAgICAgZXYgPT09IHRoaXMubGFzdFNob3duRXZlbnQsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZXZlbnRzLnB1c2goZXYpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRUaWxlcygpOiBSZWFjdE5vZGVbXSB7XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IGV2ZW50cyB0byBncm91cCwgZG9uJ3QgZXZlbiB0cnkgdG8gZ3JvdXAgdGhlbS4gVGhlIGxvZ2ljXG4gICAgICAgIC8vIGJlbG93IGFzc3VtZXMgdGhhdCB3ZSBoYXZlIGEgZ3JvdXAgb2YgZXZlbnRzIHRvIGRlYWwgd2l0aCwgYnV0IHdlIG1pZ2h0IG5vdCBpZlxuICAgICAgICAvLyB0aGUgZXZlbnRzIHdlIHdlcmUgc3VwcG9zZWQgdG8gZ3JvdXAgd2VyZSByZWRhY3RlZC5cbiAgICAgICAgaWYgKCF0aGlzLmV2ZW50cyB8fCAhdGhpcy5ldmVudHMubGVuZ3RoKSByZXR1cm4gW107XG5cbiAgICAgICAgY29uc3QgaXNHcm91cGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcGFuZWwgPSB0aGlzLnBhbmVsO1xuICAgICAgICBjb25zdCBsYXN0U2hvd25FdmVudCA9IHRoaXMubGFzdFNob3duRXZlbnQ7XG4gICAgICAgIGNvbnN0IHJldCA9IFtdO1xuXG4gICAgICAgIGlmIChwYW5lbC53YW50c0RhdGVTZXBhcmF0b3IodGhpcy5wcmV2RXZlbnQsIHRoaXMuZXZlbnRzWzBdLmdldERhdGUoKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRzID0gdGhpcy5ldmVudHNbMF0uZ2V0VHMoKTtcbiAgICAgICAgICAgIHJldC5wdXNoKFxuICAgICAgICAgICAgICAgIDxsaSBrZXk9e3RzKyd+J30+PERhdGVTZXBhcmF0b3Iga2V5PXt0cysnfid9IHRzPXt0c30gLz48L2xpPixcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUga2V5IG9mIHRoZSBNZW1iZXJFdmVudExpc3RTdW1tYXJ5IGRvZXMgbm90IGNoYW5nZSB3aXRoIG5ld1xuICAgICAgICAvLyBtZW1iZXIgZXZlbnRzLiBUaGlzIHdpbGwgcHJldmVudCBpdCBmcm9tIGJlaW5nIHJlLWNyZWF0ZWQgdW5uZWNlc3NhcmlseSwgYW5kXG4gICAgICAgIC8vIGluc3RlYWQgd2lsbCBhbGxvdyBuZXcgcHJvcHMgdG8gYmUgcHJvdmlkZWQuIEluIHR1cm4sIHRoZSBzaG91bGRDb21wb25lbnRVcGRhdGVcbiAgICAgICAgLy8gbWV0aG9kIG9uIE1FTFMgY2FuIGJlIHVzZWQgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSByZW5kZXJpbmdzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBXaGlsc3QgYmFjay1wYWdpbmF0aW5nIHdpdGggYSBNRUxTIGF0IHRoZSB0b3Agb2YgdGhlIHBhbmVsLCBwcmV2RXZlbnQgd2lsbCBiZSBudWxsLFxuICAgICAgICAvLyBzbyB1c2UgdGhlIGtleSBcIm1lbWJlcmV2ZW50bGlzdHN1bW1hcnktaW5pdGlhbFwiLiBPdGhlcndpc2UsIHVzZSB0aGUgSUQgb2YgdGhlIGZpcnN0XG4gICAgICAgIC8vIG1lbWJlcnNoaXAgZXZlbnQsIHdoaWNoIHdpbGwgbm90IGNoYW5nZSBkdXJpbmcgZm9yd2FyZCBwYWdpbmF0aW9uLlxuICAgICAgICBjb25zdCBrZXkgPSBcIm1lbWJlcmV2ZW50bGlzdHN1bW1hcnktXCIgKyAoXG4gICAgICAgICAgICB0aGlzLnByZXZFdmVudCA/IHRoaXMuZXZlbnRzWzBdLmdldElkKCkgOiBcImluaXRpYWxcIlxuICAgICAgICApO1xuXG4gICAgICAgIGxldCBoaWdobGlnaHRJbk1lbHM7XG4gICAgICAgIGxldCBldmVudFRpbGVzID0gdGhpcy5ldmVudHMubWFwKChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZS5nZXRJZCgpID09PSBwYW5lbC5wcm9wcy5oaWdobGlnaHRlZEV2ZW50SWQpIHtcbiAgICAgICAgICAgICAgICBoaWdobGlnaHRJbk1lbHMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW4gb3JkZXIgdG8gcHJldmVudCBEYXRlU2VwYXJhdG9ycyBmcm9tIGFwcGVhcmluZyBpbiB0aGUgZXhwYW5kZWQgZm9ybVxuICAgICAgICAgICAgLy8gb2YgTWVtYmVyRXZlbnRMaXN0U3VtbWFyeSwgcmVuZGVyIGVhY2ggbWVtYmVyIGV2ZW50IGFzIGlmIHRoZSBwcmV2aW91c1xuICAgICAgICAgICAgLy8gb25lIHdhcyBpdHNlbGYuIFRoaXMgd2F5LCB0aGUgdGltZXN0YW1wIG9mIHRoZSBwcmV2aW91cyBldmVudCA9PT0gdGhlXG4gICAgICAgICAgICAvLyB0aW1lc3RhbXAgb2YgdGhlIGN1cnJlbnQgZXZlbnQsIGFuZCBubyBEYXRlU2VwYXJhdG9yIGlzIGluc2VydGVkLlxuICAgICAgICAgICAgcmV0dXJuIHBhbmVsLmdldFRpbGVzRm9yRXZlbnQoZSwgZSwgZSA9PT0gbGFzdFNob3duRXZlbnQsIGlzR3JvdXBlZCk7XG4gICAgICAgIH0pLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKTtcblxuICAgICAgICBpZiAoZXZlbnRUaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGV2ZW50VGlsZXMgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0LnB1c2goXG4gICAgICAgICAgICA8TWVtYmVyRXZlbnRMaXN0U3VtbWFyeVxuICAgICAgICAgICAgICAgIGtleT17a2V5fVxuICAgICAgICAgICAgICAgIGV2ZW50cz17dGhpcy5ldmVudHN9XG4gICAgICAgICAgICAgICAgb25Ub2dnbGU9e3BhbmVsLm9uSGVpZ2h0Q2hhbmdlZH0gLy8gVXBkYXRlIHNjcm9sbCBzdGF0ZVxuICAgICAgICAgICAgICAgIHN0YXJ0RXhwYW5kZWQ9e2hpZ2hsaWdodEluTWVsc31cbiAgICAgICAgICAgICAgICBsYXlvdXQ9e3RoaXMubGF5b3V0fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHsgZXZlbnRUaWxlcyB9XG4gICAgICAgICAgICA8L01lbWJlckV2ZW50TGlzdFN1bW1hcnk+LFxuICAgICAgICApO1xuXG4gICAgICAgIGlmICh0aGlzLnJlYWRNYXJrZXIpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKHRoaXMucmVhZE1hcmtlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXROZXdQcmV2RXZlbnQoKTogTWF0cml4RXZlbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5ldmVudHNbMF07XG4gICAgfVxufVxuXG4vLyBhbGwgdGhlIGdyb3VwZXIgY2xhc3NlcyB0aGF0IHdlIHVzZVxuY29uc3QgZ3JvdXBlcnMgPSBbQ3JlYXRpb25Hcm91cGVyLCBNZW1iZXJHcm91cGVyLCBSZWRhY3Rpb25Hcm91cGVyXTtcbiJdfQ==