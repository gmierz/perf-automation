"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _room = require("matrix-js-sdk/src/models/room");

var _eventTimeline = require("matrix-js-sdk/src/models/event-timeline");

var _timelineWindow = require("matrix-js-sdk/src/timeline-window");

var _event = require("matrix-js-sdk/src/@types/event");

var _SettingsStore = _interopRequireDefault(require("../../settings/SettingsStore"));

var _languageHandler = require("../../languageHandler");

var _MatrixClientPeg = require("../../MatrixClientPeg");

var _RoomContext = _interopRequireDefault(require("../../contexts/RoomContext"));

var _UserActivity = _interopRequireDefault(require("../../UserActivity"));

var _Modal = _interopRequireDefault(require("../../Modal"));

var _dispatcher = _interopRequireDefault(require("../../dispatcher/dispatcher"));

var _actions = require("../../dispatcher/actions");

var _Keyboard = require("../../Keyboard");

var _Timer = _interopRequireDefault(require("../../utils/Timer"));

var _shouldHideEvent = _interopRequireDefault(require("../../shouldHideEvent"));

var _EventTile = require("../views/rooms/EventTile");

var _UIFeature = require("../../settings/UIFeature");

var _replaceableComponent = require("../../utils/replaceableComponent");

var _arrays = require("../../utils/arrays");

var _MessagePanel = _interopRequireDefault(require("./MessagePanel"));

var _Spinner = _interopRequireDefault(require("../views/elements/Spinner"));

var _ErrorDialog = _interopRequireDefault(require("../views/dialogs/ErrorDialog"));

var _lodash = require("lodash");

var _logger = require("matrix-js-sdk/src/logger");

var _dec, _class, _class2, _temp;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const PAGINATE_SIZE = 20;
const INITIAL_SIZE = 20;
const READ_RECEIPT_INTERVAL_MS = 500;
const READ_MARKER_DEBOUNCE_MS = 100;
const DEBUG = false;

let debuglog = function (...s) {};

if (DEBUG) {
  // using bind means that we get to keep useful line numbers in the console
  debuglog = _logger.logger.log.bind(console);
}

/*
 * Component which shows the event timeline in a room view.
 *
 * Also responsible for handling and sending read receipts.
 */
let TimelinePanel = (_dec = (0, _replaceableComponent.replaceableComponent)("structures.TimelinePanel"), _dec(_class = (_temp = _class2 = class TimelinePanel extends _react.default.Component {
  // a map from room id to read marker event timestamp
  constructor(props, context) {
    super(props, context);
    (0, _defineProperty2.default)(this, "lastRRSentEventId", undefined);
    (0, _defineProperty2.default)(this, "lastRMSentEventId", undefined);
    (0, _defineProperty2.default)(this, "messagePanel", /*#__PURE__*/(0, _react.createRef)());
    (0, _defineProperty2.default)(this, "dispatcherRef", void 0);
    (0, _defineProperty2.default)(this, "timelineWindow", void 0);
    (0, _defineProperty2.default)(this, "unmounted", false);
    (0, _defineProperty2.default)(this, "readReceiptActivityTimer", void 0);
    (0, _defineProperty2.default)(this, "readMarkerActivityTimer", void 0);
    (0, _defineProperty2.default)(this, "onMessageListUnfillRequest", (backwards, scrollToken) => {
      // If backwards, unpaginate from the back (i.e. the start of the timeline)
      const dir = backwards ? _eventTimeline.EventTimeline.BACKWARDS : _eventTimeline.EventTimeline.FORWARDS;
      debuglog("TimelinePanel: unpaginating events in direction", dir); // All tiles are inserted by MessagePanel to have a scrollToken === eventId, and
      // this particular event should be the first or last to be unpaginated.

      const eventId = scrollToken;
      const marker = this.state.events.findIndex(ev => {
        return ev.getId() === eventId;
      });
      const count = backwards ? marker + 1 : this.state.events.length - marker;

      if (count > 0) {
        debuglog("TimelinePanel: Unpaginating", count, "in direction", dir);
        this.timelineWindow.unpaginate(count, backwards);
        const {
          events,
          liveEvents,
          firstVisibleEventIndex
        } = this.getEvents();
        const newState = {
          events,
          liveEvents,
          firstVisibleEventIndex
        }; // We can now paginate in the unpaginated direction

        if (backwards) {
          newState.canBackPaginate = true;
        } else {
          newState.canForwardPaginate = true;
        }

        this.setState(newState);
      }
    });
    (0, _defineProperty2.default)(this, "onPaginationRequest", (timelineWindow, direction, size) => {
      if (this.props.onPaginationRequest) {
        return this.props.onPaginationRequest(timelineWindow, direction, size);
      } else {
        return timelineWindow.paginate(direction, size);
      }
    });
    (0, _defineProperty2.default)(this, "onMessageListFillRequest", backwards => {
      if (!this.shouldPaginate()) return Promise.resolve(false);
      const dir = backwards ? _eventTimeline.EventTimeline.BACKWARDS : _eventTimeline.EventTimeline.FORWARDS;
      const canPaginateKey = backwards ? 'canBackPaginate' : 'canForwardPaginate';
      const paginatingKey = backwards ? 'backPaginating' : 'forwardPaginating';

      if (!this.state[canPaginateKey]) {
        debuglog("TimelinePanel: have given up", dir, "paginating this timeline");
        return Promise.resolve(false);
      }

      if (!this.timelineWindow.canPaginate(dir)) {
        debuglog("TimelinePanel: can't", dir, "paginate any further");
        this.setState({
          [canPaginateKey]: false
        });
        return Promise.resolve(false);
      }

      if (backwards && this.state.firstVisibleEventIndex !== 0) {
        debuglog("TimelinePanel: won't", dir, "paginate past first visible event");
        return Promise.resolve(false);
      }

      debuglog("TimelinePanel: Initiating paginate; backwards:" + backwards);
      this.setState({
        [paginatingKey]: true
      });
      return this.onPaginationRequest(this.timelineWindow, dir, PAGINATE_SIZE).then(r => {
        if (this.unmounted) {
          return;
        }

        debuglog("TimelinePanel: paginate complete backwards:" + backwards + "; success:" + r);
        const {
          events,
          liveEvents,
          firstVisibleEventIndex
        } = this.getEvents();
        const newState = {
          [paginatingKey]: false,
          [canPaginateKey]: r,
          events,
          liveEvents,
          firstVisibleEventIndex
        }; // moving the window in this direction may mean that we can now
        // paginate in the other where we previously could not.

        const otherDirection = backwards ? _eventTimeline.EventTimeline.FORWARDS : _eventTimeline.EventTimeline.BACKWARDS;
        const canPaginateOtherWayKey = backwards ? 'canForwardPaginate' : 'canBackPaginate';

        if (!this.state[canPaginateOtherWayKey] && this.timelineWindow.canPaginate(otherDirection)) {
          debuglog('TimelinePanel: can now', otherDirection, 'paginate again');
          newState[canPaginateOtherWayKey] = true;
        } // Don't resolve until the setState has completed: we need to let
        // the component update before we consider the pagination completed,
        // otherwise we'll end up paginating in all the history the js-sdk
        // has in memory because we never gave the component a chance to scroll
        // itself into the right place


        return new Promise(resolve => {
          this.setState(newState, () => {
            // we can continue paginating in the given direction if:
            // - timelineWindow.paginate says we can
            // - we're paginating forwards, or we won't be trying to
            //   paginate backwards past the first visible event
            resolve(r && (!backwards || firstVisibleEventIndex === 0));
          });
        });
      });
    });
    (0, _defineProperty2.default)(this, "onMessageListScroll", e => {
      var _this$props$onScroll, _this$props;

      (_this$props$onScroll = (_this$props = this.props).onScroll) === null || _this$props$onScroll === void 0 ? void 0 : _this$props$onScroll.call(_this$props, e);

      if (this.props.manageReadMarkers) {
        this.doManageReadMarkers();
      }
    });
    (0, _defineProperty2.default)(this, "doManageReadMarkers", (0, _lodash.debounce)(() => {
      var _this$readMarkerActiv;

      const rmPosition = this.getReadMarkerPosition(); // we hide the read marker when it first comes onto the screen, but if
      // it goes back off the top of the screen (presumably because the user
      // clicks on the 'jump to bottom' button), we need to re-enable it.

      if (rmPosition < 0) {
        this.setState({
          readMarkerVisible: true
        });
      } // if read marker position goes between 0 and -1/1,
      // (and user is active), switch timeout


      const timeout = this.readMarkerTimeout(rmPosition); // NO-OP when timeout already has set to the given value

      (_this$readMarkerActiv = this.readMarkerActivityTimer) === null || _this$readMarkerActiv === void 0 ? void 0 : _this$readMarkerActiv.changeTimeout(timeout);
    }, READ_MARKER_DEBOUNCE_MS, {
      leading: false,
      trailing: true
    }));
    (0, _defineProperty2.default)(this, "onAction", payload => {
      switch (payload.action) {
        case "ignore_state_changed":
          this.forceUpdate();
          break;
      }
    });
    (0, _defineProperty2.default)(this, "onRoomTimeline", (ev, room, toStartOfTimeline, removed, data) => {
      // ignore events for other timeline sets
      if (data.timeline.getTimelineSet() !== this.props.timelineSet) return; // ignore anything but real-time updates at the end of the room:
      // updates from pagination will happen when the paginate completes.

      if (toStartOfTimeline || !data || !data.liveEvent) return;
      if (!this.messagePanel.current) return;

      if (!this.messagePanel.current.getScrollState().stuckAtBottom) {
        // we won't load this event now, because we don't want to push any
        // events off the other end of the timeline. But we need to note
        // that we can now paginate.
        this.setState({
          canForwardPaginate: true
        });
        return;
      } // tell the timeline window to try to advance itself, but not to make
      // an http request to do so.
      //
      // we deliberately avoid going via the ScrollPanel for this call - the
      // ScrollPanel might already have an active pagination promise, which
      // will fail, but would stop us passing the pagination request to the
      // timeline window.
      //
      // see https://github.com/vector-im/vector-web/issues/1035


      this.timelineWindow.paginate(_eventTimeline.EventTimeline.FORWARDS, 1, false).then(() => {
        if (this.unmounted) {
          return;
        }

        const {
          events,
          liveEvents,
          firstVisibleEventIndex
        } = this.getEvents();
        const lastLiveEvent = liveEvents[liveEvents.length - 1];
        const updatedState = {
          events,
          liveEvents,
          firstVisibleEventIndex
        };
        let callRMUpdated;

        if (this.props.manageReadMarkers) {
          // when a new event arrives when the user is not watching the
          // window, but the window is in its auto-scroll mode, make sure the
          // read marker is visible.
          //
          // We ignore events we have sent ourselves; we don't want to see the
          // read-marker when a remote echo of an event we have just sent takes
          // more than the timeout on userActiveRecently.
          //
          const myUserId = _MatrixClientPeg.MatrixClientPeg.get().credentials.userId;

          callRMUpdated = false;

          if (ev.getSender() !== myUserId && !_UserActivity.default.sharedInstance().userActiveRecently()) {
            updatedState.readMarkerVisible = true;
          } else if (lastLiveEvent && this.getReadMarkerPosition() === 0) {
            // we know we're stuckAtBottom, so we can advance the RM
            // immediately, to save a later render cycle
            this.setReadMarker(lastLiveEvent.getId(), lastLiveEvent.getTs(), true);
            updatedState.readMarkerVisible = false;
            updatedState.readMarkerEventId = lastLiveEvent.getId();
            callRMUpdated = true;
          }
        }

        this.setState(updatedState, () => {
          this.messagePanel.current.updateTimelineMinHeight();

          if (callRMUpdated) {
            var _this$props$onReadMar, _this$props2;

            (_this$props$onReadMar = (_this$props2 = this.props).onReadMarkerUpdated) === null || _this$props$onReadMar === void 0 ? void 0 : _this$props$onReadMar.call(_this$props2);
          }
        });
      });
    });
    (0, _defineProperty2.default)(this, "onRoomTimelineReset", (room, timelineSet) => {
      if (timelineSet !== this.props.timelineSet) return;

      if (this.messagePanel.current && this.messagePanel.current.isAtBottom()) {
        this.loadTimeline();
      }
    });
    (0, _defineProperty2.default)(this, "canResetTimeline", () => {
      var _this$messagePanel;

      return (_this$messagePanel = this.messagePanel) === null || _this$messagePanel === void 0 ? void 0 : _this$messagePanel.current.isAtBottom();
    });
    (0, _defineProperty2.default)(this, "onRoomRedaction", (ev, room) => {
      if (this.unmounted) return; // ignore events for other rooms

      if (room !== this.props.timelineSet.room) return; // we could skip an update if the event isn't in our timeline,
      // but that's probably an early optimisation.

      this.forceUpdate();
    });
    (0, _defineProperty2.default)(this, "onEventReplaced", (replacedEvent, room) => {
      if (this.unmounted) return; // ignore events for other rooms

      if (room !== this.props.timelineSet.room) return; // we could skip an update if the event isn't in our timeline,
      // but that's probably an early optimisation.

      this.forceUpdate();
    });
    (0, _defineProperty2.default)(this, "onRoomReceipt", (ev, room) => {
      if (this.unmounted) return; // ignore events for other rooms

      if (room !== this.props.timelineSet.room) return;
      this.forceUpdate();
    });
    (0, _defineProperty2.default)(this, "onLocalEchoUpdated", (ev, room, oldEventId) => {
      if (this.unmounted) return; // ignore events for other rooms

      if (room !== this.props.timelineSet.room) return;
      this.reloadEvents();
    });
    (0, _defineProperty2.default)(this, "onAccountData", (ev, room) => {
      if (this.unmounted) return; // ignore events for other rooms

      if (room !== this.props.timelineSet.room) return;
      if (ev.getType() !== _event.EventType.FullyRead) return; // XXX: roomReadMarkerTsMap not updated here so it is now inconsistent. Replace
      // this mechanism of determining where the RM is relative to the view-port with
      // one supported by the server (the client needs more than an event ID).

      this.setState({
        readMarkerEventId: ev.getContent().event_id
      }, this.props.onReadMarkerUpdated);
    });
    (0, _defineProperty2.default)(this, "onEventDecrypted", ev => {
      // Can be null for the notification timeline, etc.
      if (!this.props.timelineSet.room) return; // Need to update as we don't display event tiles for events that
      // haven't yet been decrypted. The event will have just been updated
      // in place so we just need to re-render.
      // TODO: We should restrict this to only events in our timeline,
      // but possibly the event tile itself should just update when this
      // happens to save us re-rendering the whole timeline.

      if (ev.getRoomId() === this.props.timelineSet.room.roomId) {
        this.forceUpdate();
      }
    });
    (0, _defineProperty2.default)(this, "onSync", (clientSyncState, prevState, data) => {
      this.setState({
        clientSyncState
      });
    });
    (0, _defineProperty2.default)(this, "sendReadReceipt", () => {
      if (_SettingsStore.default.getValue("lowBandwidth")) return;
      if (!this.messagePanel.current) return;
      if (!this.props.manageReadReceipts) return; // This happens on user_activity_end which is delayed, and it's
      // very possible have logged out within that timeframe, so check
      // we still have a client.

      const cli = _MatrixClientPeg.MatrixClientPeg.get(); // if no client or client is guest don't send RR or RM


      if (!cli || cli.isGuest()) return;
      let shouldSendRR = true;
      const currentRREventId = this.getCurrentReadReceipt(true);
      const currentRREventIndex = this.indexForEventId(currentRREventId); // We want to avoid sending out read receipts when we are looking at
      // events in the past which are before the latest RR.
      //
      // For now, let's apply a heuristic: if (a) the event corresponding to
      // the latest RR (either from the server, or sent by ourselves) doesn't
      // appear in our timeline, and (b) we could forward-paginate the event
      // timeline, then don't send any more RRs.
      //
      // This isn't watertight, as we could be looking at a section of
      // timeline which is *after* the latest RR (so we should actually send
      // RRs) - but that is a bit of a niche case. It will sort itself out when
      // the user eventually hits the live timeline.
      //

      if (currentRREventId && currentRREventIndex === null && this.timelineWindow.canPaginate(_eventTimeline.EventTimeline.FORWARDS)) {
        shouldSendRR = false;
      }

      const lastReadEventIndex = this.getLastDisplayedEventIndex({
        ignoreOwn: true
      });

      if (lastReadEventIndex === null) {
        shouldSendRR = false;
      }

      let lastReadEvent = this.state.events[lastReadEventIndex];
      shouldSendRR = shouldSendRR && // Only send a RR if the last read event is ahead in the timeline relative to
      // the current RR event.
      lastReadEventIndex > currentRREventIndex && // Only send a RR if the last RR set != the one we would send
      this.lastRRSentEventId != lastReadEvent.getId(); // Only send a RM if the last RM sent != the one we would send

      const shouldSendRM = this.lastRMSentEventId != this.state.readMarkerEventId; // we also remember the last read receipt we sent to avoid spamming the
      // same one at the server repeatedly

      if (shouldSendRR || shouldSendRM) {
        if (shouldSendRR) {
          this.lastRRSentEventId = lastReadEvent.getId();
        } else {
          lastReadEvent = null;
        }

        this.lastRMSentEventId = this.state.readMarkerEventId;
        const roomId = this.props.timelineSet.room.roomId;

        const hiddenRR = _SettingsStore.default.getValue("feature_hidden_read_receipts", roomId);

        debuglog('TimelinePanel: Sending Read Markers for ', this.props.timelineSet.room.roomId, 'rm', this.state.readMarkerEventId, lastReadEvent ? 'rr ' + lastReadEvent.getId() : '', ' hidden:' + hiddenRR);

        _MatrixClientPeg.MatrixClientPeg.get().setRoomReadMarkers(roomId, this.state.readMarkerEventId, lastReadEvent, // Could be null, in which case no RR is sent
        {
          hidden: hiddenRR
        }).catch(e => {
          // /read_markers API is not implemented on this HS, fallback to just RR
          if (e.errcode === 'M_UNRECOGNIZED' && lastReadEvent) {
            return _MatrixClientPeg.MatrixClientPeg.get().sendReadReceipt(lastReadEvent, {}).catch(e => {
              _logger.logger.error(e);

              this.lastRRSentEventId = undefined;
            });
          } else {
            _logger.logger.error(e);
          } // it failed, so allow retries next time the user is active


          this.lastRRSentEventId = undefined;
          this.lastRMSentEventId = undefined;
        }); // do a quick-reset of our unreadNotificationCount to avoid having
        // to wait from the remote echo from the homeserver.
        // we only do this if we're right at the end, because we're just assuming
        // that sending an RR for the latest message will set our notif counter
        // to zero: it may not do this if we send an RR for somewhere before the end.


        if (this.isAtEndOfLiveTimeline()) {
          this.props.timelineSet.room.setUnreadNotificationCount(_room.NotificationCountType.Total, 0);
          this.props.timelineSet.room.setUnreadNotificationCount(_room.NotificationCountType.Highlight, 0);

          _dispatcher.default.dispatch({
            action: 'on_room_read',
            roomId: this.props.timelineSet.room.roomId
          });
        }
      }
    });
    (0, _defineProperty2.default)(this, "updateReadMarker", () => {
      if (!this.props.manageReadMarkers) return;

      if (this.getReadMarkerPosition() === 1) {
        // the read marker is at an event below the viewport,
        // we don't want to rewind it.
        return;
      } // move the RM to *after* the message at the bottom of the screen. This
      // avoids a problem whereby we never advance the RM if there is a huge
      // message which doesn't fit on the screen.


      const lastDisplayedIndex = this.getLastDisplayedEventIndex({
        allowPartial: true
      });

      if (lastDisplayedIndex === null) {
        return;
      }

      const lastDisplayedEvent = this.state.events[lastDisplayedIndex];
      this.setReadMarker(lastDisplayedEvent.getId(), lastDisplayedEvent.getTs()); // the read-marker should become invisible, so that if the user scrolls
      // down, they don't see it.

      if (this.state.readMarkerVisible) {
        this.setState({
          readMarkerVisible: false
        });
      } // Send the updated read marker (along with read receipt) to the server


      this.sendReadReceipt();
    });
    (0, _defineProperty2.default)(this, "jumpToLiveTimeline", () => {
      // if we can't forward-paginate the existing timeline, then there
      // is no point reloading it - just jump straight to the bottom.
      //
      // Otherwise, reload the timeline rather than trying to paginate
      // through all of space-time.
      if (this.timelineWindow.canPaginate(_eventTimeline.EventTimeline.FORWARDS)) {
        this.loadTimeline();
      } else {
        var _this$messagePanel$cu;

        (_this$messagePanel$cu = this.messagePanel.current) === null || _this$messagePanel$cu === void 0 ? void 0 : _this$messagePanel$cu.scrollToBottom();
      }
    });
    (0, _defineProperty2.default)(this, "scrollToEventIfNeeded", eventId => {
      var _this$messagePanel$cu2;

      (_this$messagePanel$cu2 = this.messagePanel.current) === null || _this$messagePanel$cu2 === void 0 ? void 0 : _this$messagePanel$cu2.scrollToEventIfNeeded(eventId);
    });
    (0, _defineProperty2.default)(this, "jumpToReadMarker", () => {
      if (!this.props.manageReadMarkers) return;
      if (!this.messagePanel.current) return;
      if (!this.state.readMarkerEventId) return; // we may not have loaded the event corresponding to the read-marker
      // into the timelineWindow. In that case, attempts to scroll to it
      // will fail.
      //
      // a quick way to figure out if we've loaded the relevant event is
      // simply to check if the messagepanel knows where the read-marker is.

      const ret = this.messagePanel.current.getReadMarkerPosition();

      if (ret !== null) {
        // The messagepanel knows where the RM is, so we must have loaded
        // the relevant event.
        this.messagePanel.current.scrollToEvent(this.state.readMarkerEventId, 0, 1 / 3);
        return;
      } // Looks like we haven't loaded the event corresponding to the read-marker.
      // As with jumpToLiveTimeline, we want to reload the timeline around the
      // read-marker.


      this.loadTimeline(this.state.readMarkerEventId, 0, 1 / 3);
    });
    (0, _defineProperty2.default)(this, "forgetReadMarker", () => {
      if (!this.props.manageReadMarkers) return;
      const rmId = this.getCurrentReadReceipt(); // see if we know the timestamp for the rr event

      const tl = this.props.timelineSet.getTimelineForEvent(rmId);
      let rmTs;

      if (tl) {
        const event = tl.getEvents().find(e => {
          return e.getId() == rmId;
        });

        if (event) {
          rmTs = event.getTs();
        }
      }

      this.setReadMarker(rmId, rmTs);
    });
    (0, _defineProperty2.default)(this, "isAtEndOfLiveTimeline", () => {
      var _this$messagePanel$cu3;

      return ((_this$messagePanel$cu3 = this.messagePanel.current) === null || _this$messagePanel$cu3 === void 0 ? void 0 : _this$messagePanel$cu3.isAtBottom()) && this.timelineWindow && !this.timelineWindow.canPaginate(_eventTimeline.EventTimeline.FORWARDS);
    });
    (0, _defineProperty2.default)(this, "getScrollState", () => {
      if (!this.messagePanel.current) {
        return null;
      }

      return this.messagePanel.current.getScrollState();
    });
    (0, _defineProperty2.default)(this, "getReadMarkerPosition", () => {
      if (!this.props.manageReadMarkers) return null;
      if (!this.messagePanel.current) return null;
      const ret = this.messagePanel.current.getReadMarkerPosition();

      if (ret !== null) {
        return ret;
      } // the messagePanel doesn't know where the read marker is.
      // if we know the timestamp of the read marker, make a guess based on that.


      const rmTs = TimelinePanel.roomReadMarkerTsMap[this.props.timelineSet.room.roomId];

      if (rmTs && this.state.events.length > 0) {
        if (rmTs < this.state.events[0].getTs()) {
          return -1;
        } else {
          return 1;
        }
      }

      return null;
    });
    (0, _defineProperty2.default)(this, "canJumpToReadMarker", () => {
      // 1. Do not show jump bar if neither the RM nor the RR are set.
      // 3. We want to show the bar if the read-marker is off the top of the screen.
      // 4. Also, if pos === null, the event might not be paginated - show the unread bar
      const pos = this.getReadMarkerPosition();
      const ret = this.state.readMarkerEventId !== null && ( // 1.
      pos < 0 || pos === null); // 3., 4.

      return ret;
    });
    (0, _defineProperty2.default)(this, "handleScrollKey", ev => {
      if (!this.messagePanel.current) {
        return;
      } // jump to the live timeline on ctrl-end, rather than the end of the
      // timeline window.


      if (ev.ctrlKey && !ev.shiftKey && !ev.altKey && !ev.metaKey && ev.key === _Keyboard.Key.END) {
        this.jumpToLiveTimeline();
      } else {
        this.messagePanel.current.handleScrollKey(ev);
      }
    });
    (0, _defineProperty2.default)(this, "getRelationsForEvent", (eventId, relationType, eventType) => this.props.timelineSet.getRelationsForEvent(eventId, relationType, eventType));
    debuglog("TimelinePanel: mounting"); // XXX: we could track RM per TimelineSet rather than per Room.
    // but for now we just do it per room for simplicity.

    let initialReadMarker = null;

    if (this.props.manageReadMarkers) {
      const readmarker = this.props.timelineSet.room.getAccountData('m.fully_read');

      if (readmarker) {
        initialReadMarker = readmarker.getContent().event_id;
      } else {
        initialReadMarker = this.getCurrentReadReceipt();
      }
    }

    this.state = {
      events: [],
      liveEvents: [],
      timelineLoading: true,
      firstVisibleEventIndex: 0,
      canBackPaginate: false,
      canForwardPaginate: false,
      readMarkerVisible: true,
      readMarkerEventId: initialReadMarker,
      backPaginating: false,
      forwardPaginating: false,
      clientSyncState: _MatrixClientPeg.MatrixClientPeg.get().getSyncState(),
      isTwelveHour: _SettingsStore.default.getValue("showTwelveHourTimestamps"),
      alwaysShowTimestamps: _SettingsStore.default.getValue("alwaysShowTimestamps"),
      readMarkerInViewThresholdMs: _SettingsStore.default.getValue("readMarkerInViewThresholdMs"),
      readMarkerOutOfViewThresholdMs: _SettingsStore.default.getValue("readMarkerOutOfViewThresholdMs")
    };
    this.dispatcherRef = _dispatcher.default.register(this.onAction);

    const _cli = _MatrixClientPeg.MatrixClientPeg.get();

    _cli.on("Room.timeline", this.onRoomTimeline);

    _cli.on("Room.timelineReset", this.onRoomTimelineReset);

    _cli.on("Room.redaction", this.onRoomRedaction); // same event handler as Room.redaction as for both we just do forceUpdate


    _cli.on("Room.redactionCancelled", this.onRoomRedaction);

    _cli.on("Room.receipt", this.onRoomReceipt);

    _cli.on("Room.localEchoUpdated", this.onLocalEchoUpdated);

    _cli.on("Room.accountData", this.onAccountData);

    _cli.on("Event.decrypted", this.onEventDecrypted);

    _cli.on("Event.replaced", this.onEventReplaced);

    _cli.on("sync", this.onSync);
  } // TODO: [REACT-WARNING] Move into constructor
  // eslint-disable-next-line


  UNSAFE_componentWillMount() {
    if (this.props.manageReadReceipts) {
      this.updateReadReceiptOnUserActivity();
    }

    if (this.props.manageReadMarkers) {
      this.updateReadMarkerOnUserActivity();
    }

    this.initTimeline(this.props);
  } // TODO: [REACT-WARNING] Replace with appropriate lifecycle event
  // eslint-disable-next-line


  UNSAFE_componentWillReceiveProps(newProps) {
    if (newProps.timelineSet !== this.props.timelineSet) {
      // throw new Error("changing timelineSet on a TimelinePanel is not supported");
      // regrettably, this does happen; in particular, when joining a
      // room with /join. In that case, there are two Rooms in
      // circulation - one which is created by the MatrixClient.joinRoom
      // call and used to create the RoomView, and a second which is
      // created by the sync loop once the room comes back down the /sync
      // pipe. Once the latter happens, our room is replaced with the new one.
      //
      // for now, just warn about this. But we're going to end up paginating
      // both rooms separately, and it's all bad.
      _logger.logger.warn("Replacing timelineSet on a TimelinePanel - confusion may ensue");
    }

    const differentEventId = newProps.eventId != this.props.eventId;
    const differentHighlightedEventId = newProps.highlightedEventId != this.props.highlightedEventId;

    if (differentEventId || differentHighlightedEventId) {
      _logger.logger.log("TimelinePanel switching to eventId " + newProps.eventId + " (was " + this.props.eventId + ")");

      return this.initTimeline(newProps);
    }
  }

  componentWillUnmount() {
    // set a boolean to say we've been unmounted, which any pending
    // promises can use to throw away their results.
    //
    // (We could use isMounted, but facebook have deprecated that.)
    this.unmounted = true;

    if (this.readReceiptActivityTimer) {
      this.readReceiptActivityTimer.abort();
      this.readReceiptActivityTimer = null;
    }

    if (this.readMarkerActivityTimer) {
      this.readMarkerActivityTimer.abort();
      this.readMarkerActivityTimer = null;
    }

    _dispatcher.default.unregister(this.dispatcherRef);

    const client = _MatrixClientPeg.MatrixClientPeg.get();

    if (client) {
      client.removeListener("Room.timeline", this.onRoomTimeline);
      client.removeListener("Room.timelineReset", this.onRoomTimelineReset);
      client.removeListener("Room.redaction", this.onRoomRedaction);
      client.removeListener("Room.redactionCancelled", this.onRoomRedaction);
      client.removeListener("Room.receipt", this.onRoomReceipt);
      client.removeListener("Room.localEchoUpdated", this.onLocalEchoUpdated);
      client.removeListener("Room.accountData", this.onAccountData);
      client.removeListener("Event.decrypted", this.onEventDecrypted);
      client.removeListener("Event.replaced", this.onEventReplaced);
      client.removeListener("sync", this.onSync);
    }
  }

  readMarkerTimeout(readMarkerPosition) {
    var _this$context, _this$context2;

    return readMarkerPosition === 0 ? ((_this$context = this.context) === null || _this$context === void 0 ? void 0 : _this$context.readMarkerInViewThresholdMs) ?? this.state.readMarkerInViewThresholdMs : ((_this$context2 = this.context) === null || _this$context2 === void 0 ? void 0 : _this$context2.readMarkerOutOfViewThresholdMs) ?? this.state.readMarkerOutOfViewThresholdMs;
  }

  async updateReadMarkerOnUserActivity() {
    const initialTimeout = this.readMarkerTimeout(this.getReadMarkerPosition());
    this.readMarkerActivityTimer = new _Timer.default(initialTimeout);

    while (this.readMarkerActivityTimer) {
      //unset on unmount
      _UserActivity.default.sharedInstance().timeWhileActiveRecently(this.readMarkerActivityTimer);

      try {
        await this.readMarkerActivityTimer.finished();
      } catch (e) {
        continue;
        /* aborted */
      } // outside of try/catch to not swallow errors


      this.updateReadMarker();
    }
  }

  async updateReadReceiptOnUserActivity() {
    this.readReceiptActivityTimer = new _Timer.default(READ_RECEIPT_INTERVAL_MS);

    while (this.readReceiptActivityTimer) {
      //unset on unmount
      _UserActivity.default.sharedInstance().timeWhileActiveNow(this.readReceiptActivityTimer);

      try {
        await this.readReceiptActivityTimer.finished();
      } catch (e) {
        continue;
        /* aborted */
      } // outside of try/catch to not swallow errors


      this.sendReadReceipt();
    }
  }

  // advance the read marker past any events we sent ourselves.
  advanceReadMarkerPastMyEvents() {
    if (!this.props.manageReadMarkers) return; // we call `timelineWindow.getEvents()` rather than using
    // `this.state.liveEvents`, because React batches the update to the
    // latter, so it may not have been updated yet.

    const events = this.timelineWindow.getEvents(); // first find where the current RM is

    let i;

    for (i = 0; i < events.length; i++) {
      if (events[i].getId() == this.state.readMarkerEventId) {
        break;
      }
    }

    if (i >= events.length) {
      return;
    } // now think about advancing it


    const myUserId = _MatrixClientPeg.MatrixClientPeg.get().credentials.userId;

    for (i++; i < events.length; i++) {
      const ev = events[i];

      if (ev.getSender() !== myUserId) {
        break;
      }
    } // i is now the first unread message which we didn't send ourselves.


    i--;
    const ev = events[i];
    this.setReadMarker(ev.getId(), ev.getTs());
  }
  /* jump down to the bottom of this room, where new events are arriving
   */


  initTimeline(props) {
    const initialEvent = props.eventId;
    const pixelOffset = props.eventPixelOffset; // if a pixelOffset is given, it is relative to the bottom of the
    // container. If not, put the event in the middle of the container.

    let offsetBase = 1;

    if (pixelOffset == null) {
      offsetBase = 0.5;
    }

    return this.loadTimeline(initialEvent, pixelOffset, offsetBase);
  }
  /**
   * (re)-load the event timeline, and initialise the scroll state, centered
   * around the given event.
   *
   * @param {string?}  eventId the event to focus on. If undefined, will
   *    scroll to the bottom of the room.
   *
   * @param {number?} pixelOffset   offset to position the given event at
   *    (pixels from the offsetBase). If omitted, defaults to 0.
   *
   * @param {number?} offsetBase the reference point for the pixelOffset. 0
   *     means the top of the container, 1 means the bottom, and fractional
   *     values mean somewhere in the middle. If omitted, it defaults to 0.
   */


  loadTimeline(eventId, pixelOffset, offsetBase) {
    this.timelineWindow = new _timelineWindow.TimelineWindow(_MatrixClientPeg.MatrixClientPeg.get(), this.props.timelineSet, {
      windowLimit: this.props.timelineCap
    });

    const onLoaded = () => {
      if (this.unmounted) return; // clear the timeline min-height when
      // (re)loading the timeline

      if (this.messagePanel.current) {
        this.messagePanel.current.onTimelineReset();
      }

      this.reloadEvents(); // If we switched away from the room while there were pending
      // outgoing events, the read-marker will be before those events.
      // We need to skip over any which have subsequently been sent.

      this.advanceReadMarkerPastMyEvents();
      this.setState({
        canBackPaginate: this.timelineWindow.canPaginate(_eventTimeline.EventTimeline.BACKWARDS),
        canForwardPaginate: this.timelineWindow.canPaginate(_eventTimeline.EventTimeline.FORWARDS),
        timelineLoading: false
      }, () => {
        // initialise the scroll state of the message panel
        if (!this.messagePanel.current) {
          // this shouldn't happen - we know we're mounted because
          // we're in a setState callback, and we know
          // timelineLoading is now false, so render() should have
          // mounted the message panel.
          _logger.logger.log("can't initialise scroll state because " + "messagePanel didn't load");

          return;
        }

        if (eventId) {
          this.messagePanel.current.scrollToEvent(eventId, pixelOffset, offsetBase);
        } else {
          this.messagePanel.current.scrollToBottom();
        }

        if (this.props.sendReadReceiptOnLoad) {
          this.sendReadReceipt();
        }
      });
    };

    const onError = error => {
      if (this.unmounted) return;
      this.setState({
        timelineLoading: false
      });

      _logger.logger.error(`Error loading timeline panel at ${eventId}: ${error}`);

      let onFinished; // if we were given an event ID, then when the user closes the
      // dialog, let's jump to the end of the timeline. If we weren't,
      // something has gone badly wrong and rather than causing a loop of
      // undismissable dialogs, let's just give up.

      if (eventId) {
        onFinished = () => {
          // go via the dispatcher so that the URL is updated
          _dispatcher.default.dispatch({
            action: _actions.Action.ViewRoom,
            room_id: this.props.timelineSet.room.roomId
          });
        };
      }

      let message;

      if (error.errcode == 'M_FORBIDDEN') {
        message = (0, _languageHandler._t)("Tried to load a specific point in this room's timeline, but you " + "do not have permission to view the message in question.");
      } else {
        message = (0, _languageHandler._t)("Tried to load a specific point in this room's timeline, but was " + "unable to find it.");
      }

      _Modal.default.createTrackedDialog('Failed to load timeline position', '', _ErrorDialog.default, {
        title: (0, _languageHandler._t)("Failed to load timeline position"),
        description: message,
        onFinished: onFinished
      });
    }; // if we already have the event in question, TimelineWindow.load
    // returns a resolved promise.
    //
    // In this situation, we don't really want to defer the update of the
    // state to the next event loop, because it makes room-switching feel
    // quite slow. So we detect that situation and shortcut straight to
    // calling _reloadEvents and updating the state.


    const timeline = this.props.timelineSet.getTimelineForEvent(eventId);

    if (timeline) {
      // This is a hot-path optimization by skipping a promise tick
      // by repeating a no-op sync branch in TimelineSet.getTimelineForEvent & MatrixClient.getEventTimeline
      this.timelineWindow.load(eventId, INITIAL_SIZE); // in this branch this method will happen in sync time

      onLoaded();
    } else {
      const prom = this.timelineWindow.load(eventId, INITIAL_SIZE);
      this.setState({
        events: [],
        liveEvents: [],
        canBackPaginate: false,
        canForwardPaginate: false,
        timelineLoading: true
      });
      prom.then(onLoaded, onError);
    }
  } // handle the completion of a timeline load or localEchoUpdate, by
  // reloading the events from the timelinewindow and pending event list into
  // the state.


  reloadEvents() {
    // we might have switched rooms since the load started - just bin
    // the results if so.
    if (this.unmounted) return;
    this.setState(this.getEvents());
  } // Force refresh the timeline before threads support pending events


  refreshTimeline() {
    this.loadTimeline();
    this.reloadEvents();
  } // get the list of events from the timeline window and the pending event list


  getEvents() {
    const events = this.timelineWindow.getEvents(); // `arrayFastClone` performs a shallow copy of the array
    // we want the last event to be decrypted first but displayed last
    // `reverse` is destructive and unfortunately mutates the "events" array

    (0, _arrays.arrayFastClone)(events).reverse().forEach(event => {
      const client = _MatrixClientPeg.MatrixClientPeg.get();

      client.decryptEventIfNeeded(event);
    });
    const firstVisibleEventIndex = this.checkForPreJoinUISI(events); // Hold onto the live events separately. The read receipt and read marker
    // should use this list, so that they don't advance into pending events.

    const liveEvents = [...events]; // if we're at the end of the live timeline, append the pending events

    if (!this.timelineWindow.canPaginate(_eventTimeline.EventTimeline.FORWARDS)) {
      events.push(...this.props.timelineSet.getPendingEvents());
    }

    return {
      events,
      liveEvents,
      firstVisibleEventIndex
    };
  }
  /**
   * Check for undecryptable messages that were sent while the user was not in
   * the room.
   *
   * @param {Array<MatrixEvent>} events The timeline events to check
   *
   * @return {Number} The index within `events` of the event after the most recent
   * undecryptable event that was sent while the user was not in the room.  If no
   * such events were found, then it returns 0.
   */


  checkForPreJoinUISI(events) {
    const room = this.props.timelineSet.room;

    if (events.length === 0 || !room || !_MatrixClientPeg.MatrixClientPeg.get().isRoomEncrypted(room.roomId)) {
      return 0;
    }

    const userId = _MatrixClientPeg.MatrixClientPeg.get().credentials.userId; // get the user's membership at the last event by getting the timeline
    // that the event belongs to, and traversing the timeline looking for
    // that event, while keeping track of the user's membership


    let i;
    let userMembership = "leave";

    for (i = events.length - 1; i >= 0; i--) {
      const timeline = room.getTimelineForEvent(events[i].getId());

      if (!timeline) {
        // Somehow, it seems to be possible for live events to not have
        // a timeline, even though that should not happen. :(
        // https://github.com/vector-im/element-web/issues/12120
        _logger.logger.warn(`Event ${events[i].getId()} in room ${room.roomId} is live, ` + `but it does not have a timeline`);

        continue;
      }

      const userMembershipEvent = timeline.getState(_eventTimeline.EventTimeline.FORWARDS).getMember(userId);
      userMembership = userMembershipEvent ? userMembershipEvent.membership : "leave";
      const timelineEvents = timeline.getEvents();

      for (let j = timelineEvents.length - 1; j >= 0; j--) {
        const event = timelineEvents[j];

        if (event.getId() === events[i].getId()) {
          break;
        } else if (event.getStateKey() === userId && event.getType() === "m.room.member") {
          const prevContent = event.getPrevContent();
          userMembership = prevContent.membership || "leave";
        }
      }

      break;
    } // now go through the rest of the events and find the first undecryptable
    // one that was sent when the user wasn't in the room


    for (; i >= 0; i--) {
      const event = events[i];

      if (event.getStateKey() === userId && event.getType() === "m.room.member") {
        const prevContent = event.getPrevContent();
        userMembership = prevContent.membership || "leave";
      } else if (userMembership === "leave" && (event.isDecryptionFailure() || event.isBeingDecrypted())) {
        // reached an undecryptable message when the user wasn't in
        // the room -- don't try to load any more
        // Note: for now, we assume that events that are being decrypted are
        // not decryptable
        return i + 1;
      }
    }

    return 0;
  }

  indexForEventId(evId) {
    for (let i = 0; i < this.state.events.length; ++i) {
      if (evId == this.state.events[i].getId()) {
        return i;
      }
    }

    return null;
  }

  getLastDisplayedEventIndex(opts = {}) {
    const ignoreOwn = opts.ignoreOwn || false;
    const allowPartial = opts.allowPartial || false;
    const messagePanel = this.messagePanel.current;
    if (!messagePanel) return null;

    const messagePanelNode = _reactDom.default.findDOMNode(messagePanel);

    if (!messagePanelNode) return null; // sometimes this happens for fresh rooms/post-sync

    const wrapperRect = messagePanelNode.getBoundingClientRect();

    const myUserId = _MatrixClientPeg.MatrixClientPeg.get().credentials.userId;

    const isNodeInView = node => {
      if (node) {
        const boundingRect = node.getBoundingClientRect();

        if (allowPartial && boundingRect.top < wrapperRect.bottom || !allowPartial && boundingRect.bottom < wrapperRect.bottom) {
          return true;
        }
      }

      return false;
    }; // We keep track of how many of the adjacent events didn't have a tile
    // but should have the read receipt moved past them, so
    // we can include those once we find the last displayed (visible) event.
    // The counter is not started for events we don't want
    // to send a read receipt for (our own events, local echos).


    let adjacentInvisibleEventCount = 0; // Use `liveEvents` here because we don't want the read marker or read
    // receipt to advance into pending events.

    for (let i = this.state.liveEvents.length - 1; i >= 0; --i) {
      var _this$context3;

      const ev = this.state.liveEvents[i];
      const node = messagePanel.getNodeForEventId(ev.getId());
      const isInView = isNodeInView(node); // when we've reached the first visible event, and the previous
      // events were all invisible (with the first one not being ignored),
      // return the index of the first invisible event.

      if (isInView && adjacentInvisibleEventCount !== 0) {
        return i + adjacentInvisibleEventCount;
      }

      if (node && !isInView) {
        // has node but not in view, so reset adjacent invisible events
        adjacentInvisibleEventCount = 0;
      }

      const shouldIgnore = !!ev.status || // local echo
      ignoreOwn && ev.getSender() === myUserId; // own message

      const isWithoutTile = !(0, _EventTile.haveTileForEvent)(ev, (_this$context3 = this.context) === null || _this$context3 === void 0 ? void 0 : _this$context3.showHiddenEventsInTimeline) || (0, _shouldHideEvent.default)(ev, this.context);

      if (isWithoutTile || !node) {
        // don't start counting if the event should be ignored,
        // but continue counting if we were already so the offset
        // to the previous invisble event that didn't need to be ignored
        // doesn't get messed up
        if (!shouldIgnore || shouldIgnore && adjacentInvisibleEventCount !== 0) {
          ++adjacentInvisibleEventCount;
        }

        continue;
      }

      if (shouldIgnore) {
        continue;
      }

      if (isInView) {
        return i;
      }
    }

    return null;
  }
  /**
   * Get the id of the event corresponding to our user's latest read-receipt.
   *
   * @param {Boolean} ignoreSynthesized If true, return only receipts that
   *                                    have been sent by the server, not
   *                                    implicit ones generated by the JS
   *                                    SDK.
   * @return {String} the event ID
   */


  getCurrentReadReceipt(ignoreSynthesized = false) {
    const client = _MatrixClientPeg.MatrixClientPeg.get(); // the client can be null on logout


    if (client == null) {
      return null;
    }

    const myUserId = client.credentials.userId;
    return this.props.timelineSet.room.getEventReadUpTo(myUserId, ignoreSynthesized);
  }

  setReadMarker(eventId, eventTs, inhibitSetState = false) {
    const roomId = this.props.timelineSet.room.roomId; // don't update the state (and cause a re-render) if there is
    // no change to the RM.

    if (eventId === this.state.readMarkerEventId) {
      return;
    } // in order to later figure out if the read marker is
    // above or below the visible timeline, we stash the timestamp.


    TimelinePanel.roomReadMarkerTsMap[roomId] = eventTs;

    if (inhibitSetState) {
      return;
    } // Do the local echo of the RM
    // run the render cycle before calling the callback, so that
    // getReadMarkerPosition() returns the right thing.


    this.setState({
      readMarkerEventId: eventId
    }, this.props.onReadMarkerUpdated);
  }

  shouldPaginate() {
    // don't try to paginate while events in the timeline are
    // still being decrypted. We don't render events while they're
    // being decrypted, so they don't take up space in the timeline.
    // This means we can pull quite a lot of events into the timeline
    // and end up trying to render a lot of events.
    return !this.state.events.some(e => {
      return e.isBeingDecrypted();
    });
  }

  render() {
    var _this$context4, _this$context5;

    // just show a spinner while the timeline loads.
    //
    // put it in a div of the right class (mx_RoomView_messagePanel) so
    // that the order in the roomview flexbox is correct, and
    // mx_RoomView_messageListWrapper to position the inner div in the
    // right place.
    //
    // Note that the click-on-search-result functionality relies on the
    // fact that the messagePanel is hidden while the timeline reloads,
    // but that the RoomHeader (complete with search term) continues to
    // exist.
    if (this.state.timelineLoading) {
      return /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_RoomView_messagePanelSpinner"
      }, /*#__PURE__*/_react.default.createElement(_Spinner.default, null));
    }

    if (this.state.events.length == 0 && !this.state.canBackPaginate && this.props.empty) {
      return /*#__PURE__*/_react.default.createElement("div", {
        className: this.props.className + " mx_RoomView_messageListWrapper"
      }, /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_RoomView_empty"
      }, this.props.empty));
    } // give the messagepanel a stickybottom if we're at the end of the
    // live timeline, so that the arrival of new events triggers a
    // scroll.
    //
    // Make sure that stickyBottom is *false* if we can paginate
    // forwards, otherwise if somebody hits the bottom of the loaded
    // events when viewing historical messages, we get stuck in a loop
    // of paginating our way through the entire history of the room.


    const stickyBottom = !this.timelineWindow.canPaginate(_eventTimeline.EventTimeline.FORWARDS); // If the state is PREPARED or CATCHUP, we're still waiting for the js-sdk to sync with
    // the HS and fetch the latest events, so we are effectively forward paginating.

    const forwardPaginating = this.state.forwardPaginating || ['PREPARED', 'CATCHUP'].includes(this.state.clientSyncState);
    const events = this.state.firstVisibleEventIndex ? this.state.events.slice(this.state.firstVisibleEventIndex) : this.state.events;
    return /*#__PURE__*/_react.default.createElement(_MessagePanel.default, {
      ref: this.messagePanel,
      room: this.props.timelineSet.room,
      permalinkCreator: this.props.permalinkCreator,
      hidden: this.props.hidden,
      backPaginating: this.state.backPaginating,
      forwardPaginating: forwardPaginating,
      events: events,
      highlightedEventId: this.props.highlightedEventId,
      readMarkerEventId: this.state.readMarkerEventId,
      readMarkerVisible: this.state.readMarkerVisible,
      suppressFirstDateSeparator: this.state.canBackPaginate,
      showUrlPreview: this.props.showUrlPreview,
      showReadReceipts: this.props.showReadReceipts,
      ourUserId: _MatrixClientPeg.MatrixClientPeg.get().credentials.userId,
      stickyBottom: stickyBottom,
      onScroll: this.onMessageListScroll,
      onUserScroll: this.props.onUserScroll,
      onFillRequest: this.onMessageListFillRequest,
      onUnfillRequest: this.onMessageListUnfillRequest,
      isTwelveHour: ((_this$context4 = this.context) === null || _this$context4 === void 0 ? void 0 : _this$context4.showTwelveHourTimestamps) ?? this.state.isTwelveHour,
      alwaysShowTimestamps: this.props.alwaysShowTimestamps ?? ((_this$context5 = this.context) === null || _this$context5 === void 0 ? void 0 : _this$context5.alwaysShowTimestamps) ?? this.state.alwaysShowTimestamps,
      className: this.props.className,
      tileShape: this.props.tileShape,
      resizeNotifier: this.props.resizeNotifier,
      getRelationsForEvent: this.getRelationsForEvent,
      editState: this.props.editState,
      showReactions: this.props.showReactions,
      layout: this.props.layout,
      enableFlair: _SettingsStore.default.getValue(_UIFeature.UIFeature.Flair),
      hideThreadedMessages: this.props.hideThreadedMessages,
      disableGrouping: this.props.disableGrouping
    });
  }

}, (0, _defineProperty2.default)(_class2, "contextType", _RoomContext.default), (0, _defineProperty2.default)(_class2, "roomReadMarkerTsMap", {}), (0, _defineProperty2.default)(_class2, "defaultProps", {
  // By default, disable the timelineCap in favour of unpaginating based on
  // event tile heights. (See _unpaginateEvents)
  timelineCap: Number.MAX_VALUE,
  className: 'mx_RoomView_messagePanel',
  sendReadReceiptOnLoad: true,
  hideThreadedMessages: true,
  disableGrouping: false
}), _temp)) || _class);
var _default = TimelinePanel;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3N0cnVjdHVyZXMvVGltZWxpbmVQYW5lbC50c3giXSwibmFtZXMiOlsiUEFHSU5BVEVfU0laRSIsIklOSVRJQUxfU0laRSIsIlJFQURfUkVDRUlQVF9JTlRFUlZBTF9NUyIsIlJFQURfTUFSS0VSX0RFQk9VTkNFX01TIiwiREVCVUciLCJkZWJ1Z2xvZyIsInMiLCJsb2dnZXIiLCJsb2ciLCJiaW5kIiwiY29uc29sZSIsIlRpbWVsaW5lUGFuZWwiLCJSZWFjdCIsIkNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJjb250ZXh0IiwidW5kZWZpbmVkIiwiYmFja3dhcmRzIiwic2Nyb2xsVG9rZW4iLCJkaXIiLCJFdmVudFRpbWVsaW5lIiwiQkFDS1dBUkRTIiwiRk9SV0FSRFMiLCJldmVudElkIiwibWFya2VyIiwic3RhdGUiLCJldmVudHMiLCJmaW5kSW5kZXgiLCJldiIsImdldElkIiwiY291bnQiLCJsZW5ndGgiLCJ0aW1lbGluZVdpbmRvdyIsInVucGFnaW5hdGUiLCJsaXZlRXZlbnRzIiwiZmlyc3RWaXNpYmxlRXZlbnRJbmRleCIsImdldEV2ZW50cyIsIm5ld1N0YXRlIiwiY2FuQmFja1BhZ2luYXRlIiwiY2FuRm9yd2FyZFBhZ2luYXRlIiwic2V0U3RhdGUiLCJkaXJlY3Rpb24iLCJzaXplIiwib25QYWdpbmF0aW9uUmVxdWVzdCIsInBhZ2luYXRlIiwic2hvdWxkUGFnaW5hdGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNhblBhZ2luYXRlS2V5IiwicGFnaW5hdGluZ0tleSIsImNhblBhZ2luYXRlIiwidGhlbiIsInIiLCJ1bm1vdW50ZWQiLCJvdGhlckRpcmVjdGlvbiIsImNhblBhZ2luYXRlT3RoZXJXYXlLZXkiLCJlIiwib25TY3JvbGwiLCJtYW5hZ2VSZWFkTWFya2VycyIsImRvTWFuYWdlUmVhZE1hcmtlcnMiLCJybVBvc2l0aW9uIiwiZ2V0UmVhZE1hcmtlclBvc2l0aW9uIiwicmVhZE1hcmtlclZpc2libGUiLCJ0aW1lb3V0IiwicmVhZE1hcmtlclRpbWVvdXQiLCJyZWFkTWFya2VyQWN0aXZpdHlUaW1lciIsImNoYW5nZVRpbWVvdXQiLCJsZWFkaW5nIiwidHJhaWxpbmciLCJwYXlsb2FkIiwiYWN0aW9uIiwiZm9yY2VVcGRhdGUiLCJyb29tIiwidG9TdGFydE9mVGltZWxpbmUiLCJyZW1vdmVkIiwiZGF0YSIsInRpbWVsaW5lIiwiZ2V0VGltZWxpbmVTZXQiLCJ0aW1lbGluZVNldCIsImxpdmVFdmVudCIsIm1lc3NhZ2VQYW5lbCIsImN1cnJlbnQiLCJnZXRTY3JvbGxTdGF0ZSIsInN0dWNrQXRCb3R0b20iLCJsYXN0TGl2ZUV2ZW50IiwidXBkYXRlZFN0YXRlIiwiY2FsbFJNVXBkYXRlZCIsIm15VXNlcklkIiwiTWF0cml4Q2xpZW50UGVnIiwiZ2V0IiwiY3JlZGVudGlhbHMiLCJ1c2VySWQiLCJnZXRTZW5kZXIiLCJVc2VyQWN0aXZpdHkiLCJzaGFyZWRJbnN0YW5jZSIsInVzZXJBY3RpdmVSZWNlbnRseSIsInNldFJlYWRNYXJrZXIiLCJnZXRUcyIsInJlYWRNYXJrZXJFdmVudElkIiwidXBkYXRlVGltZWxpbmVNaW5IZWlnaHQiLCJvblJlYWRNYXJrZXJVcGRhdGVkIiwiaXNBdEJvdHRvbSIsImxvYWRUaW1lbGluZSIsInJlcGxhY2VkRXZlbnQiLCJvbGRFdmVudElkIiwicmVsb2FkRXZlbnRzIiwiZ2V0VHlwZSIsIkV2ZW50VHlwZSIsIkZ1bGx5UmVhZCIsImdldENvbnRlbnQiLCJldmVudF9pZCIsImdldFJvb21JZCIsInJvb21JZCIsImNsaWVudFN5bmNTdGF0ZSIsInByZXZTdGF0ZSIsIlNldHRpbmdzU3RvcmUiLCJnZXRWYWx1ZSIsIm1hbmFnZVJlYWRSZWNlaXB0cyIsImNsaSIsImlzR3Vlc3QiLCJzaG91bGRTZW5kUlIiLCJjdXJyZW50UlJFdmVudElkIiwiZ2V0Q3VycmVudFJlYWRSZWNlaXB0IiwiY3VycmVudFJSRXZlbnRJbmRleCIsImluZGV4Rm9yRXZlbnRJZCIsImxhc3RSZWFkRXZlbnRJbmRleCIsImdldExhc3REaXNwbGF5ZWRFdmVudEluZGV4IiwiaWdub3JlT3duIiwibGFzdFJlYWRFdmVudCIsImxhc3RSUlNlbnRFdmVudElkIiwic2hvdWxkU2VuZFJNIiwibGFzdFJNU2VudEV2ZW50SWQiLCJoaWRkZW5SUiIsInNldFJvb21SZWFkTWFya2VycyIsImhpZGRlbiIsImNhdGNoIiwiZXJyY29kZSIsInNlbmRSZWFkUmVjZWlwdCIsImVycm9yIiwiaXNBdEVuZE9mTGl2ZVRpbWVsaW5lIiwic2V0VW5yZWFkTm90aWZpY2F0aW9uQ291bnQiLCJOb3RpZmljYXRpb25Db3VudFR5cGUiLCJUb3RhbCIsIkhpZ2hsaWdodCIsImRpcyIsImRpc3BhdGNoIiwibGFzdERpc3BsYXllZEluZGV4IiwiYWxsb3dQYXJ0aWFsIiwibGFzdERpc3BsYXllZEV2ZW50Iiwic2Nyb2xsVG9Cb3R0b20iLCJzY3JvbGxUb0V2ZW50SWZOZWVkZWQiLCJyZXQiLCJzY3JvbGxUb0V2ZW50Iiwicm1JZCIsInRsIiwiZ2V0VGltZWxpbmVGb3JFdmVudCIsInJtVHMiLCJldmVudCIsImZpbmQiLCJyb29tUmVhZE1hcmtlclRzTWFwIiwicG9zIiwiY3RybEtleSIsInNoaWZ0S2V5IiwiYWx0S2V5IiwibWV0YUtleSIsImtleSIsIktleSIsIkVORCIsImp1bXBUb0xpdmVUaW1lbGluZSIsImhhbmRsZVNjcm9sbEtleSIsInJlbGF0aW9uVHlwZSIsImV2ZW50VHlwZSIsImdldFJlbGF0aW9uc0ZvckV2ZW50IiwiaW5pdGlhbFJlYWRNYXJrZXIiLCJyZWFkbWFya2VyIiwiZ2V0QWNjb3VudERhdGEiLCJ0aW1lbGluZUxvYWRpbmciLCJiYWNrUGFnaW5hdGluZyIsImZvcndhcmRQYWdpbmF0aW5nIiwiZ2V0U3luY1N0YXRlIiwiaXNUd2VsdmVIb3VyIiwiYWx3YXlzU2hvd1RpbWVzdGFtcHMiLCJyZWFkTWFya2VySW5WaWV3VGhyZXNob2xkTXMiLCJyZWFkTWFya2VyT3V0T2ZWaWV3VGhyZXNob2xkTXMiLCJkaXNwYXRjaGVyUmVmIiwicmVnaXN0ZXIiLCJvbkFjdGlvbiIsIm9uIiwib25Sb29tVGltZWxpbmUiLCJvblJvb21UaW1lbGluZVJlc2V0Iiwib25Sb29tUmVkYWN0aW9uIiwib25Sb29tUmVjZWlwdCIsIm9uTG9jYWxFY2hvVXBkYXRlZCIsIm9uQWNjb3VudERhdGEiLCJvbkV2ZW50RGVjcnlwdGVkIiwib25FdmVudFJlcGxhY2VkIiwib25TeW5jIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCIsInVwZGF0ZVJlYWRSZWNlaXB0T25Vc2VyQWN0aXZpdHkiLCJ1cGRhdGVSZWFkTWFya2VyT25Vc2VyQWN0aXZpdHkiLCJpbml0VGltZWxpbmUiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIm5ld1Byb3BzIiwid2FybiIsImRpZmZlcmVudEV2ZW50SWQiLCJkaWZmZXJlbnRIaWdobGlnaHRlZEV2ZW50SWQiLCJoaWdobGlnaHRlZEV2ZW50SWQiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInJlYWRSZWNlaXB0QWN0aXZpdHlUaW1lciIsImFib3J0IiwidW5yZWdpc3RlciIsImNsaWVudCIsInJlbW92ZUxpc3RlbmVyIiwicmVhZE1hcmtlclBvc2l0aW9uIiwiaW5pdGlhbFRpbWVvdXQiLCJUaW1lciIsInRpbWVXaGlsZUFjdGl2ZVJlY2VudGx5IiwiZmluaXNoZWQiLCJ1cGRhdGVSZWFkTWFya2VyIiwidGltZVdoaWxlQWN0aXZlTm93IiwiYWR2YW5jZVJlYWRNYXJrZXJQYXN0TXlFdmVudHMiLCJpIiwiaW5pdGlhbEV2ZW50IiwicGl4ZWxPZmZzZXQiLCJldmVudFBpeGVsT2Zmc2V0Iiwib2Zmc2V0QmFzZSIsIlRpbWVsaW5lV2luZG93Iiwid2luZG93TGltaXQiLCJ0aW1lbGluZUNhcCIsIm9uTG9hZGVkIiwib25UaW1lbGluZVJlc2V0Iiwic2VuZFJlYWRSZWNlaXB0T25Mb2FkIiwib25FcnJvciIsIm9uRmluaXNoZWQiLCJBY3Rpb24iLCJWaWV3Um9vbSIsInJvb21faWQiLCJtZXNzYWdlIiwiTW9kYWwiLCJjcmVhdGVUcmFja2VkRGlhbG9nIiwiRXJyb3JEaWFsb2ciLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwibG9hZCIsInByb20iLCJyZWZyZXNoVGltZWxpbmUiLCJyZXZlcnNlIiwiZm9yRWFjaCIsImRlY3J5cHRFdmVudElmTmVlZGVkIiwiY2hlY2tGb3JQcmVKb2luVUlTSSIsInB1c2giLCJnZXRQZW5kaW5nRXZlbnRzIiwiaXNSb29tRW5jcnlwdGVkIiwidXNlck1lbWJlcnNoaXAiLCJ1c2VyTWVtYmVyc2hpcEV2ZW50IiwiZ2V0U3RhdGUiLCJnZXRNZW1iZXIiLCJtZW1iZXJzaGlwIiwidGltZWxpbmVFdmVudHMiLCJqIiwiZ2V0U3RhdGVLZXkiLCJwcmV2Q29udGVudCIsImdldFByZXZDb250ZW50IiwiaXNEZWNyeXB0aW9uRmFpbHVyZSIsImlzQmVpbmdEZWNyeXB0ZWQiLCJldklkIiwib3B0cyIsIm1lc3NhZ2VQYW5lbE5vZGUiLCJSZWFjdERPTSIsImZpbmRET01Ob2RlIiwid3JhcHBlclJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJpc05vZGVJblZpZXciLCJub2RlIiwiYm91bmRpbmdSZWN0IiwidG9wIiwiYm90dG9tIiwiYWRqYWNlbnRJbnZpc2libGVFdmVudENvdW50IiwiZ2V0Tm9kZUZvckV2ZW50SWQiLCJpc0luVmlldyIsInNob3VsZElnbm9yZSIsInN0YXR1cyIsImlzV2l0aG91dFRpbGUiLCJzaG93SGlkZGVuRXZlbnRzSW5UaW1lbGluZSIsImlnbm9yZVN5bnRoZXNpemVkIiwiZ2V0RXZlbnRSZWFkVXBUbyIsImV2ZW50VHMiLCJpbmhpYml0U2V0U3RhdGUiLCJzb21lIiwicmVuZGVyIiwiZW1wdHkiLCJjbGFzc05hbWUiLCJzdGlja3lCb3R0b20iLCJpbmNsdWRlcyIsInNsaWNlIiwicGVybWFsaW5rQ3JlYXRvciIsInNob3dVcmxQcmV2aWV3Iiwic2hvd1JlYWRSZWNlaXB0cyIsIm9uTWVzc2FnZUxpc3RTY3JvbGwiLCJvblVzZXJTY3JvbGwiLCJvbk1lc3NhZ2VMaXN0RmlsbFJlcXVlc3QiLCJvbk1lc3NhZ2VMaXN0VW5maWxsUmVxdWVzdCIsInNob3dUd2VsdmVIb3VyVGltZXN0YW1wcyIsInRpbGVTaGFwZSIsInJlc2l6ZU5vdGlmaWVyIiwiZWRpdFN0YXRlIiwic2hvd1JlYWN0aW9ucyIsImxheW91dCIsIlVJRmVhdHVyZSIsIkZsYWlyIiwiaGlkZVRocmVhZGVkTWVzc2FnZXMiLCJkaXNhYmxlR3JvdXBpbmciLCJSb29tQ29udGV4dCIsIk51bWJlciIsIk1BWF9WQUxVRSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFnQkE7O0FBQ0E7O0FBQ0E7O0FBR0E7O0FBQ0E7O0FBQ0E7O0FBR0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBS0E7O0FBRUE7O0FBQ0E7O0FBRUE7Ozs7Ozs7O0FBRUEsTUFBTUEsYUFBYSxHQUFHLEVBQXRCO0FBQ0EsTUFBTUMsWUFBWSxHQUFHLEVBQXJCO0FBQ0EsTUFBTUMsd0JBQXdCLEdBQUcsR0FBakM7QUFFQSxNQUFNQyx1QkFBdUIsR0FBRyxHQUFoQztBQUVBLE1BQU1DLEtBQUssR0FBRyxLQUFkOztBQUVBLElBQUlDLFFBQVEsR0FBRyxVQUFTLEdBQUdDLENBQVosRUFBc0IsQ0FBRSxDQUF2Qzs7QUFDQSxJQUFJRixLQUFKLEVBQVc7QUFDUDtBQUNBQyxFQUFBQSxRQUFRLEdBQUdFLGVBQU9DLEdBQVAsQ0FBV0MsSUFBWCxDQUFnQkMsT0FBaEIsQ0FBWDtBQUNIOztBQTZJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0lBRU1DLGEsV0FETCxnREFBcUIsMEJBQXJCLEMsbUNBQUQsTUFDTUEsYUFETixTQUM0QkMsZUFBTUMsU0FEbEMsQ0FDNEQ7QUFHeEQ7QUF1QkFDLEVBQUFBLFdBQVcsQ0FBQ0MsS0FBRCxFQUFRQyxPQUFSLEVBQWlCO0FBQ3hCLFVBQU1ELEtBQU4sRUFB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QUUsS0FBS3JSLEtBQUwsQ0FBV2lTLFNBM0IxQjtBQTRCSSxNQUFBLGNBQWMsRUFBRSxLQUFLalMsS0FBTCxDQUFXa1MsY0E1Qi9CO0FBNkJJLE1BQUEsb0JBQW9CLEVBQUUsS0FBS3BJLG9CQTdCL0I7QUE4QkksTUFBQSxTQUFTLEVBQUUsS0FBSzlKLEtBQUwsQ0FBV21TLFNBOUIxQjtBQStCSSxNQUFBLGFBQWEsRUFBRSxLQUFLblMsS0FBTCxDQUFXb1MsYUEvQjlCO0FBZ0NJLE1BQUEsTUFBTSxFQUFFLEtBQUtwUyxLQUFMLENBQVdxUyxNQWhDdkI7QUFpQ0ksTUFBQSxXQUFXLEVBQUVoTSx1QkFBY0MsUUFBZCxDQUF1QmdNLHFCQUFVQyxLQUFqQyxDQWpDakI7QUFrQ0ksTUFBQSxvQkFBb0IsRUFBRSxLQUFLdlMsS0FBTCxDQUFXd1Msb0JBbENyQztBQW1DSSxNQUFBLGVBQWUsRUFBRSxLQUFLeFMsS0FBTCxDQUFXeVM7QUFuQ2hDLE1BREo7QUF1Q0g7O0FBbnpDdUQsQyx3REFDbkNDLG9CLGlFQUdnQyxFLDBEQUUvQjtBQUNsQjtBQUNBO0FBQ0FwRixFQUFBQSxXQUFXLEVBQUVxRixNQUFNLENBQUNDLFNBSEY7QUFJbEJ2QixFQUFBQSxTQUFTLEVBQUUsMEJBSk87QUFLbEI1RCxFQUFBQSxxQkFBcUIsRUFBRSxJQUxMO0FBTWxCK0UsRUFBQUEsb0JBQW9CLEVBQUUsSUFOSjtBQU9sQkMsRUFBQUEsZUFBZSxFQUFFO0FBUEMsQztlQWd6Q1g3UyxhIiwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE2IC0gMjAyMSBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVSZWYsIFJlYWN0Tm9kZSwgU3ludGhldGljRXZlbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSBcInJlYWN0LWRvbVwiO1xuaW1wb3J0IHsgTm90aWZpY2F0aW9uQ291bnRUeXBlLCBSb29tIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL21vZGVscy9yb29tXCI7XG5pbXBvcnQgeyBNYXRyaXhFdmVudCB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9tb2RlbHMvZXZlbnRcIjtcbmltcG9ydCB7IEV2ZW50VGltZWxpbmVTZXQgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvbW9kZWxzL2V2ZW50LXRpbWVsaW5lLXNldFwiO1xuaW1wb3J0IHsgRGlyZWN0aW9uLCBFdmVudFRpbWVsaW5lIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL21vZGVscy9ldmVudC10aW1lbGluZVwiO1xuaW1wb3J0IHsgVGltZWxpbmVXaW5kb3cgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvdGltZWxpbmUtd2luZG93XCI7XG5pbXBvcnQgeyBFdmVudFR5cGUsIFJlbGF0aW9uVHlwZSB9IGZyb20gJ21hdHJpeC1qcy1zZGsvc3JjL0B0eXBlcy9ldmVudCc7XG5pbXBvcnQgeyBTeW5jU3RhdGUgfSBmcm9tICdtYXRyaXgtanMtc2RrL3NyYy9zeW5jLmFwaSc7XG5cbmltcG9ydCBTZXR0aW5nc1N0b3JlIGZyb20gXCIuLi8uLi9zZXR0aW5ncy9TZXR0aW5nc1N0b3JlXCI7XG5pbXBvcnQgeyBMYXlvdXQgfSBmcm9tIFwiLi4vLi4vc2V0dGluZ3MvZW51bXMvTGF5b3V0XCI7XG5pbXBvcnQgeyBfdCB9IGZyb20gJy4uLy4uL2xhbmd1YWdlSGFuZGxlcic7XG5pbXBvcnQgeyBNYXRyaXhDbGllbnRQZWcgfSBmcm9tIFwiLi4vLi4vTWF0cml4Q2xpZW50UGVnXCI7XG5pbXBvcnQgUm9vbUNvbnRleHQgZnJvbSBcIi4uLy4uL2NvbnRleHRzL1Jvb21Db250ZXh0XCI7XG5pbXBvcnQgVXNlckFjdGl2aXR5IGZyb20gXCIuLi8uLi9Vc2VyQWN0aXZpdHlcIjtcbmltcG9ydCBNb2RhbCBmcm9tIFwiLi4vLi4vTW9kYWxcIjtcbmltcG9ydCBkaXMgZnJvbSBcIi4uLy4uL2Rpc3BhdGNoZXIvZGlzcGF0Y2hlclwiO1xuaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAnLi4vLi4vZGlzcGF0Y2hlci9hY3Rpb25zJztcbmltcG9ydCB7IEtleSB9IGZyb20gJy4uLy4uL0tleWJvYXJkJztcbmltcG9ydCBUaW1lciBmcm9tICcuLi8uLi91dGlscy9UaW1lcic7XG5pbXBvcnQgc2hvdWxkSGlkZUV2ZW50IGZyb20gJy4uLy4uL3Nob3VsZEhpZGVFdmVudCc7XG5pbXBvcnQgeyBoYXZlVGlsZUZvckV2ZW50LCBUaWxlU2hhcGUgfSBmcm9tIFwiLi4vdmlld3Mvcm9vbXMvRXZlbnRUaWxlXCI7XG5pbXBvcnQgeyBVSUZlYXR1cmUgfSBmcm9tIFwiLi4vLi4vc2V0dGluZ3MvVUlGZWF0dXJlXCI7XG5pbXBvcnQgeyByZXBsYWNlYWJsZUNvbXBvbmVudCB9IGZyb20gXCIuLi8uLi91dGlscy9yZXBsYWNlYWJsZUNvbXBvbmVudFwiO1xuaW1wb3J0IHsgYXJyYXlGYXN0Q2xvbmUgfSBmcm9tIFwiLi4vLi4vdXRpbHMvYXJyYXlzXCI7XG5pbXBvcnQgTWVzc2FnZVBhbmVsIGZyb20gXCIuL01lc3NhZ2VQYW5lbFwiO1xuaW1wb3J0IHsgSVNjcm9sbFN0YXRlIH0gZnJvbSBcIi4vU2Nyb2xsUGFuZWxcIjtcbmltcG9ydCB7IEFjdGlvblBheWxvYWQgfSBmcm9tIFwiLi4vLi4vZGlzcGF0Y2hlci9wYXlsb2Fkc1wiO1xuaW1wb3J0IFJlc2l6ZU5vdGlmaWVyIGZyb20gXCIuLi8uLi91dGlscy9SZXNpemVOb3RpZmllclwiO1xuaW1wb3J0IHsgUm9vbVBlcm1hbGlua0NyZWF0b3IgfSBmcm9tIFwiLi4vLi4vdXRpbHMvcGVybWFsaW5rcy9QZXJtYWxpbmtzXCI7XG5pbXBvcnQgU3Bpbm5lciBmcm9tIFwiLi4vdmlld3MvZWxlbWVudHMvU3Bpbm5lclwiO1xuaW1wb3J0IEVkaXRvclN0YXRlVHJhbnNmZXIgZnJvbSAnLi4vLi4vdXRpbHMvRWRpdG9yU3RhdGVUcmFuc2Zlcic7XG5pbXBvcnQgRXJyb3JEaWFsb2cgZnJvbSAnLi4vdmlld3MvZGlhbG9ncy9FcnJvckRpYWxvZyc7XG5pbXBvcnQgeyBkZWJvdW5jZSB9IGZyb20gJ2xvZGFzaCc7XG5cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9sb2dnZXJcIjtcblxuY29uc3QgUEFHSU5BVEVfU0laRSA9IDIwO1xuY29uc3QgSU5JVElBTF9TSVpFID0gMjA7XG5jb25zdCBSRUFEX1JFQ0VJUFRfSU5URVJWQUxfTVMgPSA1MDA7XG5cbmNvbnN0IFJFQURfTUFSS0VSX0RFQk9VTkNFX01TID0gMTAwO1xuXG5jb25zdCBERUJVRyA9IGZhbHNlO1xuXG5sZXQgZGVidWdsb2cgPSBmdW5jdGlvbiguLi5zOiBhbnlbXSkge307XG5pZiAoREVCVUcpIHtcbiAgICAvLyB1c2luZyBiaW5kIG1lYW5zIHRoYXQgd2UgZ2V0IHRvIGtlZXAgdXNlZnVsIGxpbmUgbnVtYmVycyBpbiB0aGUgY29uc29sZVxuICAgIGRlYnVnbG9nID0gbG9nZ2VyLmxvZy5iaW5kKGNvbnNvbGUpO1xufVxuXG5pbnRlcmZhY2UgSVByb3BzIHtcbiAgICAvLyBUaGUganMtc2RrIEV2ZW50VGltZWxpbmVTZXQgb2JqZWN0IGZvciB0aGUgdGltZWxpbmUgc2VxdWVuY2Ugd2UgYXJlXG4gICAgLy8gcmVwcmVzZW50aW5nLiAgVGhpcyBtYXkgb3IgbWF5IG5vdCBoYXZlIGEgcm9vbSwgZGVwZW5kaW5nIG9uIHdoYXQgaXQnc1xuICAgIC8vIGEgdGltZWxpbmUgcmVwcmVzZW50aW5nLiAgSWYgaXQgaGFzIGEgcm9vbSwgd2UgbWFpbnRhaW4gUlJzIGV0YyBmb3JcbiAgICAvLyB0aGF0IHJvb20uXG4gICAgdGltZWxpbmVTZXQ6IEV2ZW50VGltZWxpbmVTZXQ7XG4gICAgc2hvd1JlYWRSZWNlaXB0cz86IGJvb2xlYW47XG4gICAgLy8gRW5hYmxlIG1hbmFnaW5nIFJScyBhbmQgUk1zLiBUaGVzZSByZXF1aXJlIHRoZSB0aW1lbGluZVNldCB0byBoYXZlIGEgcm9vbS5cbiAgICBtYW5hZ2VSZWFkUmVjZWlwdHM/OiBib29sZWFuO1xuICAgIHNlbmRSZWFkUmVjZWlwdE9uTG9hZD86IGJvb2xlYW47XG4gICAgbWFuYWdlUmVhZE1hcmtlcnM/OiBib29sZWFuO1xuXG4gICAgLy8gdHJ1ZSB0byBnaXZlIHRoZSBjb21wb25lbnQgYSAnZGlzcGxheTogbm9uZScgc3R5bGUuXG4gICAgaGlkZGVuPzogYm9vbGVhbjtcblxuICAgIC8vIElEIG9mIGFuIGV2ZW50IHRvIGhpZ2hsaWdodC4gSWYgdW5kZWZpbmVkLCBubyBldmVudCB3aWxsIGJlIGhpZ2hsaWdodGVkLlxuICAgIC8vIHR5cGljYWxseSB0aGlzIHdpbGwgYmUgZWl0aGVyICdldmVudElkJyBvciB1bmRlZmluZWQuXG4gICAgaGlnaGxpZ2h0ZWRFdmVudElkPzogc3RyaW5nO1xuXG4gICAgLy8gaWQgb2YgYW4gZXZlbnQgdG8ganVtcCB0by4gSWYgbm90IGdpdmVuLCB3aWxsIGdvIHRvIHRoZSBlbmQgb2YgdGhlIGxpdmUgdGltZWxpbmUuXG4gICAgZXZlbnRJZD86IHN0cmluZztcblxuICAgIC8vIHdoZXJlIHRvIHBvc2l0aW9uIHRoZSBldmVudCBnaXZlbiBieSBldmVudElkLCBpbiBwaXhlbHMgZnJvbSB0aGUgYm90dG9tIG9mIHRoZSB2aWV3cG9ydC5cbiAgICAvLyBJZiBub3QgZ2l2ZW4sIHdpbGwgdHJ5IHRvIHB1dCB0aGUgZXZlbnQgaGFsZiB3YXkgZG93biB0aGUgdmlld3BvcnQuXG4gICAgZXZlbnRQaXhlbE9mZnNldD86IG51bWJlcjtcblxuICAgIC8vIFNob3VsZCB3ZSBzaG93IFVSTCBQcmV2aWV3c1xuICAgIHNob3dVcmxQcmV2aWV3PzogYm9vbGVhbjtcblxuICAgIC8vIG1heGltdW0gbnVtYmVyIG9mIGV2ZW50cyB0byBzaG93IGluIGEgdGltZWxpbmVcbiAgICB0aW1lbGluZUNhcD86IG51bWJlcjtcblxuICAgIC8vIGNsYXNzbmFtZSB0byB1c2UgZm9yIHRoZSBtZXNzYWdlcGFuZWxcbiAgICBjbGFzc05hbWU/OiBzdHJpbmc7XG5cbiAgICAvLyBzaGFwZSBwcm9wZXJ0eSB0byBiZSBwYXNzZWQgdG8gRXZlbnRUaWxlc1xuICAgIHRpbGVTaGFwZT86IFRpbGVTaGFwZTtcblxuICAgIC8vIHBsYWNlaG9sZGVyIHRvIHVzZSBpZiB0aGUgdGltZWxpbmUgaXMgZW1wdHlcbiAgICBlbXB0eT86IFJlYWN0Tm9kZTtcblxuICAgIC8vIHdoZXRoZXIgdG8gc2hvdyByZWFjdGlvbnMgZm9yIGFuIGV2ZW50XG4gICAgc2hvd1JlYWN0aW9ucz86IGJvb2xlYW47XG5cbiAgICAvLyB3aGljaCBsYXlvdXQgdG8gdXNlXG4gICAgbGF5b3V0PzogTGF5b3V0O1xuXG4gICAgLy8gd2hldGhlciB0byBhbHdheXMgc2hvdyB0aW1lc3RhbXBzIGZvciBhbiBldmVudFxuICAgIGFsd2F5c1Nob3dUaW1lc3RhbXBzPzogYm9vbGVhbjtcblxuICAgIHJlc2l6ZU5vdGlmaWVyPzogUmVzaXplTm90aWZpZXI7XG4gICAgZWRpdFN0YXRlPzogRWRpdG9yU3RhdGVUcmFuc2ZlcjtcbiAgICBwZXJtYWxpbmtDcmVhdG9yPzogUm9vbVBlcm1hbGlua0NyZWF0b3I7XG4gICAgbWVtYmVyc0xvYWRlZD86IGJvb2xlYW47XG5cbiAgICAvLyBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiB0aGUgcGFuZWwgaXMgc2Nyb2xsZWQuXG4gICAgb25TY3JvbGw/KGV2ZW50OiBFdmVudCk6IHZvaWQ7XG5cbiAgICAvLyBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiB0aGUgdXNlciBpbnRlcmFjdHMgd2l0aCB0aGUgcm9vbSB0aW1lbGluZVxuICAgIG9uVXNlclNjcm9sbD8oZXZlbnQ6IFN5bnRoZXRpY0V2ZW50KTogdm9pZDtcblxuICAgIC8vIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHRoZSByZWFkLXVwLXRvIG1hcmsgaXMgdXBkYXRlZC5cbiAgICBvblJlYWRNYXJrZXJVcGRhdGVkPygpOiB2b2lkO1xuXG4gICAgLy8gY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gd2Ugd2lzaCB0byBwYWdpbmF0ZSB0aGUgdGltZWxpbmUgd2luZG93LlxuICAgIG9uUGFnaW5hdGlvblJlcXVlc3Q/KHRpbWVsaW5lV2luZG93OiBUaW1lbGluZVdpbmRvdywgZGlyZWN0aW9uOiBzdHJpbmcsIHNpemU6IG51bWJlcik6IFByb21pc2U8Ym9vbGVhbj47XG5cbiAgICBoaWRlVGhyZWFkZWRNZXNzYWdlcz86IGJvb2xlYW47XG4gICAgZGlzYWJsZUdyb3VwaW5nPzogYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIElTdGF0ZSB7XG4gICAgZXZlbnRzOiBNYXRyaXhFdmVudFtdO1xuICAgIGxpdmVFdmVudHM6IE1hdHJpeEV2ZW50W107XG4gICAgLy8gdHJhY2sgd2hldGhlciBvdXIgcm9vbSB0aW1lbGluZSBpcyBsb2FkaW5nXG4gICAgdGltZWxpbmVMb2FkaW5nOiBib29sZWFuO1xuXG4gICAgLy8gdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBldmVudCB0aGF0IGlzIHRvIGJlIHNob3duXG4gICAgZmlyc3RWaXNpYmxlRXZlbnRJbmRleDogbnVtYmVyO1xuXG4gICAgLy8gY2FuQmFja1BhZ2luYXRlID09IGZhbHNlIG1heSBtZWFuOlxuICAgIC8vXG4gICAgLy8gKiB3ZSBoYXZlbid0IChzdWNjZXNzZnVsbHkpIGxvYWRlZCB0aGUgdGltZWxpbmUgeWV0LCBvcjpcbiAgICAvL1xuICAgIC8vICogd2UgaGF2ZSBnb3QgdG8gdGhlIHBvaW50IHdoZXJlIHRoZSByb29tIHdhcyBjcmVhdGVkLCBvcjpcbiAgICAvL1xuICAgIC8vICogdGhlIHNlcnZlciBpbmRpY2F0ZWQgdGhhdCB0aGVyZSB3ZXJlIG5vIG1vcmUgdmlzaWJsZSBldmVudHNcbiAgICAvLyAgKG5vcm1hbGx5IGltcGx5aW5nIHdlIGdvdCB0byB0aGUgc3RhcnQgb2YgdGhlIHJvb20pLCBvcjpcbiAgICAvL1xuICAgIC8vICogd2UgZ2F2ZSB1cCBhc2tpbmcgdGhlIHNlcnZlciBmb3IgbW9yZSBldmVudHNcbiAgICBjYW5CYWNrUGFnaW5hdGU6IGJvb2xlYW47XG5cbiAgICAvLyBjYW5Gb3J3YXJkUGFnaW5hdGUgPT0gZmFsc2UgbWF5IG1lYW46XG4gICAgLy9cbiAgICAvLyAqIHdlIGhhdmVuJ3QgKHN1Y2Nlc3NmdWxseSkgbG9hZGVkIHRoZSB0aW1lbGluZSB5ZXRcbiAgICAvL1xuICAgIC8vICogd2UgaGF2ZSBnb3QgdG8gdGhlIGVuZCBvZiB0aW1lIGFuZCBhcmUgbm93IHRyYWNraW5nIHRoZSBsaXZlXG4gICAgLy8gICB0aW1lbGluZSwgb3I6XG4gICAgLy9cbiAgICAvLyAqIHRoZSBzZXJ2ZXIgaW5kaWNhdGVkIHRoYXQgdGhlcmUgd2VyZSBubyBtb3JlIHZpc2libGUgZXZlbnRzXG4gICAgLy8gICAobm90IHN1cmUgaWYgdGhpcyBldmVyIGhhcHBlbnMgd2hlbiB3ZSdyZSBub3QgYXQgdGhlIGxpdmVcbiAgICAvLyAgIHRpbWVsaW5lKSwgb3I6XG4gICAgLy9cbiAgICAvLyAqIHdlIGFyZSBsb29raW5nIGF0IHNvbWUgaGlzdG9yaWNhbCBwb2ludCwgYnV0IGdhdmUgdXAgYXNraW5nXG4gICAgLy8gICB0aGUgc2VydmVyIGZvciBtb3JlIGV2ZW50c1xuICAgIGNhbkZvcndhcmRQYWdpbmF0ZTogYm9vbGVhbjtcblxuICAgIC8vIHN0YXJ0IHdpdGggdGhlIHJlYWQtbWFya2VyIHZpc2libGUsIHNvIHRoYXQgd2Ugc2VlIGl0cyBhbmltYXRlZFxuICAgIC8vIGRpc2FwcGVhcmFuY2Ugd2hlbiBzd2l0Y2hpbmcgaW50byB0aGUgcm9vbS5cbiAgICByZWFkTWFya2VyVmlzaWJsZTogYm9vbGVhbjtcblxuICAgIHJlYWRNYXJrZXJFdmVudElkOiBzdHJpbmc7XG5cbiAgICBiYWNrUGFnaW5hdGluZzogYm9vbGVhbjtcbiAgICBmb3J3YXJkUGFnaW5hdGluZzogYm9vbGVhbjtcblxuICAgIC8vIGNhY2hlIG9mIG1hdHJpeENsaWVudC5nZXRTeW5jU3RhdGUoKSAoYnV0IGZyb20gdGhlICdzeW5jJyBldmVudClcbiAgICBjbGllbnRTeW5jU3RhdGU6IFN5bmNTdGF0ZTtcblxuICAgIC8vIHNob3VsZCB0aGUgZXZlbnQgdGlsZXMgaGF2ZSB0d2VsdmUgaG91ciB0aW1lc1xuICAgIGlzVHdlbHZlSG91cjogYm9vbGVhbjtcblxuICAgIC8vIGFsd2F5cyBzaG93IHRpbWVzdGFtcHMgb24gZXZlbnQgdGlsZXM/XG4gICAgYWx3YXlzU2hvd1RpbWVzdGFtcHM6IGJvb2xlYW47XG5cbiAgICAvLyBob3cgbG9uZyB0byBzaG93IHRoZSBSTSBmb3Igd2hlbiBpdCdzIHZpc2libGUgaW4gdGhlIHdpbmRvd1xuICAgIHJlYWRNYXJrZXJJblZpZXdUaHJlc2hvbGRNczogbnVtYmVyO1xuXG4gICAgLy8gaG93IGxvbmcgdG8gc2hvdyB0aGUgUk0gZm9yIHdoZW4gaXQncyBzY3JvbGxlZCBvZmYtc2NyZWVuXG4gICAgcmVhZE1hcmtlck91dE9mVmlld1RocmVzaG9sZE1zOiBudW1iZXI7XG5cbiAgICBlZGl0U3RhdGU/OiBFZGl0b3JTdGF0ZVRyYW5zZmVyO1xufVxuXG5pbnRlcmZhY2UgSUV2ZW50SW5kZXhPcHRzIHtcbiAgICBpZ25vcmVPd24/OiBib29sZWFuO1xuICAgIGFsbG93UGFydGlhbD86IGJvb2xlYW47XG59XG5cbi8qXG4gKiBDb21wb25lbnQgd2hpY2ggc2hvd3MgdGhlIGV2ZW50IHRpbWVsaW5lIGluIGEgcm9vbSB2aWV3LlxuICpcbiAqIEFsc28gcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIGFuZCBzZW5kaW5nIHJlYWQgcmVjZWlwdHMuXG4gKi9cbkByZXBsYWNlYWJsZUNvbXBvbmVudChcInN0cnVjdHVyZXMuVGltZWxpbmVQYW5lbFwiKVxuY2xhc3MgVGltZWxpbmVQYW5lbCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxJUHJvcHMsIElTdGF0ZT4ge1xuICAgIHN0YXRpYyBjb250ZXh0VHlwZSA9IFJvb21Db250ZXh0O1xuXG4gICAgLy8gYSBtYXAgZnJvbSByb29tIGlkIHRvIHJlYWQgbWFya2VyIGV2ZW50IHRpbWVzdGFtcFxuICAgIHN0YXRpYyByb29tUmVhZE1hcmtlclRzTWFwOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICAvLyBCeSBkZWZhdWx0LCBkaXNhYmxlIHRoZSB0aW1lbGluZUNhcCBpbiBmYXZvdXIgb2YgdW5wYWdpbmF0aW5nIGJhc2VkIG9uXG4gICAgICAgIC8vIGV2ZW50IHRpbGUgaGVpZ2h0cy4gKFNlZSBfdW5wYWdpbmF0ZUV2ZW50cylcbiAgICAgICAgdGltZWxpbmVDYXA6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgIGNsYXNzTmFtZTogJ214X1Jvb21WaWV3X21lc3NhZ2VQYW5lbCcsXG4gICAgICAgIHNlbmRSZWFkUmVjZWlwdE9uTG9hZDogdHJ1ZSxcbiAgICAgICAgaGlkZVRocmVhZGVkTWVzc2FnZXM6IHRydWUsXG4gICAgICAgIGRpc2FibGVHcm91cGluZzogZmFsc2UsXG4gICAgfTtcblxuICAgIHByaXZhdGUgbGFzdFJSU2VudEV2ZW50SWQ6IHN0cmluZyA9IHVuZGVmaW5lZDtcbiAgICBwcml2YXRlIGxhc3RSTVNlbnRFdmVudElkOiBzdHJpbmcgPSB1bmRlZmluZWQ7XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IG1lc3NhZ2VQYW5lbCA9IGNyZWF0ZVJlZjxNZXNzYWdlUGFuZWw+KCk7XG4gICAgcHJpdmF0ZSByZWFkb25seSBkaXNwYXRjaGVyUmVmOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSB0aW1lbGluZVdpbmRvdz86IFRpbWVsaW5lV2luZG93O1xuICAgIHByaXZhdGUgdW5tb3VudGVkID0gZmFsc2U7XG4gICAgcHJpdmF0ZSByZWFkUmVjZWlwdEFjdGl2aXR5VGltZXI6IFRpbWVyO1xuICAgIHByaXZhdGUgcmVhZE1hcmtlckFjdGl2aXR5VGltZXI6IFRpbWVyO1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIocHJvcHMsIGNvbnRleHQpO1xuXG4gICAgICAgIGRlYnVnbG9nKFwiVGltZWxpbmVQYW5lbDogbW91bnRpbmdcIik7XG5cbiAgICAgICAgLy8gWFhYOiB3ZSBjb3VsZCB0cmFjayBSTSBwZXIgVGltZWxpbmVTZXQgcmF0aGVyIHRoYW4gcGVyIFJvb20uXG4gICAgICAgIC8vIGJ1dCBmb3Igbm93IHdlIGp1c3QgZG8gaXQgcGVyIHJvb20gZm9yIHNpbXBsaWNpdHkuXG4gICAgICAgIGxldCBpbml0aWFsUmVhZE1hcmtlciA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm1hbmFnZVJlYWRNYXJrZXJzKSB7XG4gICAgICAgICAgICBjb25zdCByZWFkbWFya2VyID0gdGhpcy5wcm9wcy50aW1lbGluZVNldC5yb29tLmdldEFjY291bnREYXRhKCdtLmZ1bGx5X3JlYWQnKTtcbiAgICAgICAgICAgIGlmIChyZWFkbWFya2VyKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbFJlYWRNYXJrZXIgPSByZWFkbWFya2VyLmdldENvbnRlbnQoKS5ldmVudF9pZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbFJlYWRNYXJrZXIgPSB0aGlzLmdldEN1cnJlbnRSZWFkUmVjZWlwdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGV2ZW50czogW10sXG4gICAgICAgICAgICBsaXZlRXZlbnRzOiBbXSxcbiAgICAgICAgICAgIHRpbWVsaW5lTG9hZGluZzogdHJ1ZSxcbiAgICAgICAgICAgIGZpcnN0VmlzaWJsZUV2ZW50SW5kZXg6IDAsXG4gICAgICAgICAgICBjYW5CYWNrUGFnaW5hdGU6IGZhbHNlLFxuICAgICAgICAgICAgY2FuRm9yd2FyZFBhZ2luYXRlOiBmYWxzZSxcbiAgICAgICAgICAgIHJlYWRNYXJrZXJWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgcmVhZE1hcmtlckV2ZW50SWQ6IGluaXRpYWxSZWFkTWFya2VyLFxuICAgICAgICAgICAgYmFja1BhZ2luYXRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgZm9yd2FyZFBhZ2luYXRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgY2xpZW50U3luY1N0YXRlOiBNYXRyaXhDbGllbnRQZWcuZ2V0KCkuZ2V0U3luY1N0YXRlKCksXG4gICAgICAgICAgICBpc1R3ZWx2ZUhvdXI6IFNldHRpbmdzU3RvcmUuZ2V0VmFsdWUoXCJzaG93VHdlbHZlSG91clRpbWVzdGFtcHNcIiksXG4gICAgICAgICAgICBhbHdheXNTaG93VGltZXN0YW1wczogU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZShcImFsd2F5c1Nob3dUaW1lc3RhbXBzXCIpLFxuICAgICAgICAgICAgcmVhZE1hcmtlckluVmlld1RocmVzaG9sZE1zOiBTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFwicmVhZE1hcmtlckluVmlld1RocmVzaG9sZE1zXCIpLFxuICAgICAgICAgICAgcmVhZE1hcmtlck91dE9mVmlld1RocmVzaG9sZE1zOiBTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFwicmVhZE1hcmtlck91dE9mVmlld1RocmVzaG9sZE1zXCIpLFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlclJlZiA9IGRpcy5yZWdpc3Rlcih0aGlzLm9uQWN0aW9uKTtcbiAgICAgICAgY29uc3QgY2xpID0gTWF0cml4Q2xpZW50UGVnLmdldCgpO1xuICAgICAgICBjbGkub24oXCJSb29tLnRpbWVsaW5lXCIsIHRoaXMub25Sb29tVGltZWxpbmUpO1xuICAgICAgICBjbGkub24oXCJSb29tLnRpbWVsaW5lUmVzZXRcIiwgdGhpcy5vblJvb21UaW1lbGluZVJlc2V0KTtcbiAgICAgICAgY2xpLm9uKFwiUm9vbS5yZWRhY3Rpb25cIiwgdGhpcy5vblJvb21SZWRhY3Rpb24pO1xuICAgICAgICAvLyBzYW1lIGV2ZW50IGhhbmRsZXIgYXMgUm9vbS5yZWRhY3Rpb24gYXMgZm9yIGJvdGggd2UganVzdCBkbyBmb3JjZVVwZGF0ZVxuICAgICAgICBjbGkub24oXCJSb29tLnJlZGFjdGlvbkNhbmNlbGxlZFwiLCB0aGlzLm9uUm9vbVJlZGFjdGlvbik7XG4gICAgICAgIGNsaS5vbihcIlJvb20ucmVjZWlwdFwiLCB0aGlzLm9uUm9vbVJlY2VpcHQpO1xuICAgICAgICBjbGkub24oXCJSb29tLmxvY2FsRWNob1VwZGF0ZWRcIiwgdGhpcy5vbkxvY2FsRWNob1VwZGF0ZWQpO1xuICAgICAgICBjbGkub24oXCJSb29tLmFjY291bnREYXRhXCIsIHRoaXMub25BY2NvdW50RGF0YSk7XG4gICAgICAgIGNsaS5vbihcIkV2ZW50LmRlY3J5cHRlZFwiLCB0aGlzLm9uRXZlbnREZWNyeXB0ZWQpO1xuICAgICAgICBjbGkub24oXCJFdmVudC5yZXBsYWNlZFwiLCB0aGlzLm9uRXZlbnRSZXBsYWNlZCk7XG4gICAgICAgIGNsaS5vbihcInN5bmNcIiwgdGhpcy5vblN5bmMpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFtSRUFDVC1XQVJOSU5HXSBNb3ZlIGludG8gY29uc3RydWN0b3JcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5tYW5hZ2VSZWFkUmVjZWlwdHMpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUmVhZFJlY2VpcHRPblVzZXJBY3Rpdml0eSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm1hbmFnZVJlYWRNYXJrZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJlYWRNYXJrZXJPblVzZXJBY3Rpdml0eSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbml0VGltZWxpbmUodGhpcy5wcm9wcyk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogW1JFQUNULVdBUk5JTkddIFJlcGxhY2Ugd2l0aCBhcHByb3ByaWF0ZSBsaWZlY3ljbGUgZXZlbnRcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcykge1xuICAgICAgICBpZiAobmV3UHJvcHMudGltZWxpbmVTZXQgIT09IHRoaXMucHJvcHMudGltZWxpbmVTZXQpIHtcbiAgICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcihcImNoYW5naW5nIHRpbWVsaW5lU2V0IG9uIGEgVGltZWxpbmVQYW5lbCBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuXG4gICAgICAgICAgICAvLyByZWdyZXR0YWJseSwgdGhpcyBkb2VzIGhhcHBlbjsgaW4gcGFydGljdWxhciwgd2hlbiBqb2luaW5nIGFcbiAgICAgICAgICAgIC8vIHJvb20gd2l0aCAvam9pbi4gSW4gdGhhdCBjYXNlLCB0aGVyZSBhcmUgdHdvIFJvb21zIGluXG4gICAgICAgICAgICAvLyBjaXJjdWxhdGlvbiAtIG9uZSB3aGljaCBpcyBjcmVhdGVkIGJ5IHRoZSBNYXRyaXhDbGllbnQuam9pblJvb21cbiAgICAgICAgICAgIC8vIGNhbGwgYW5kIHVzZWQgdG8gY3JlYXRlIHRoZSBSb29tVmlldywgYW5kIGEgc2Vjb25kIHdoaWNoIGlzXG4gICAgICAgICAgICAvLyBjcmVhdGVkIGJ5IHRoZSBzeW5jIGxvb3Agb25jZSB0aGUgcm9vbSBjb21lcyBiYWNrIGRvd24gdGhlIC9zeW5jXG4gICAgICAgICAgICAvLyBwaXBlLiBPbmNlIHRoZSBsYXR0ZXIgaGFwcGVucywgb3VyIHJvb20gaXMgcmVwbGFjZWQgd2l0aCB0aGUgbmV3IG9uZS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBmb3Igbm93LCBqdXN0IHdhcm4gYWJvdXQgdGhpcy4gQnV0IHdlJ3JlIGdvaW5nIHRvIGVuZCB1cCBwYWdpbmF0aW5nXG4gICAgICAgICAgICAvLyBib3RoIHJvb21zIHNlcGFyYXRlbHksIGFuZCBpdCdzIGFsbCBiYWQuXG4gICAgICAgICAgICBsb2dnZXIud2FybihcIlJlcGxhY2luZyB0aW1lbGluZVNldCBvbiBhIFRpbWVsaW5lUGFuZWwgLSBjb25mdXNpb24gbWF5IGVuc3VlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGlmZmVyZW50RXZlbnRJZCA9IG5ld1Byb3BzLmV2ZW50SWQgIT0gdGhpcy5wcm9wcy5ldmVudElkO1xuICAgICAgICBjb25zdCBkaWZmZXJlbnRIaWdobGlnaHRlZEV2ZW50SWQgPSBuZXdQcm9wcy5oaWdobGlnaHRlZEV2ZW50SWQgIT0gdGhpcy5wcm9wcy5oaWdobGlnaHRlZEV2ZW50SWQ7XG4gICAgICAgIGlmIChkaWZmZXJlbnRFdmVudElkIHx8IGRpZmZlcmVudEhpZ2hsaWdodGVkRXZlbnRJZCkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIlRpbWVsaW5lUGFuZWwgc3dpdGNoaW5nIHRvIGV2ZW50SWQgXCIgKyBuZXdQcm9wcy5ldmVudElkICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiICh3YXMgXCIgKyB0aGlzLnByb3BzLmV2ZW50SWQgKyBcIilcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0VGltZWxpbmUobmV3UHJvcHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIC8vIHNldCBhIGJvb2xlYW4gdG8gc2F5IHdlJ3ZlIGJlZW4gdW5tb3VudGVkLCB3aGljaCBhbnkgcGVuZGluZ1xuICAgICAgICAvLyBwcm9taXNlcyBjYW4gdXNlIHRvIHRocm93IGF3YXkgdGhlaXIgcmVzdWx0cy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gKFdlIGNvdWxkIHVzZSBpc01vdW50ZWQsIGJ1dCBmYWNlYm9vayBoYXZlIGRlcHJlY2F0ZWQgdGhhdC4pXG4gICAgICAgIHRoaXMudW5tb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMucmVhZFJlY2VpcHRBY3Rpdml0eVRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRSZWNlaXB0QWN0aXZpdHlUaW1lci5hYm9ydCgpO1xuICAgICAgICAgICAgdGhpcy5yZWFkUmVjZWlwdEFjdGl2aXR5VGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlYWRNYXJrZXJBY3Rpdml0eVRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRNYXJrZXJBY3Rpdml0eVRpbWVyLmFib3J0KCk7XG4gICAgICAgICAgICB0aGlzLnJlYWRNYXJrZXJBY3Rpdml0eVRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpcy51bnJlZ2lzdGVyKHRoaXMuZGlzcGF0Y2hlclJlZik7XG5cbiAgICAgICAgY29uc3QgY2xpZW50ID0gTWF0cml4Q2xpZW50UGVnLmdldCgpO1xuICAgICAgICBpZiAoY2xpZW50KSB7XG4gICAgICAgICAgICBjbGllbnQucmVtb3ZlTGlzdGVuZXIoXCJSb29tLnRpbWVsaW5lXCIsIHRoaXMub25Sb29tVGltZWxpbmUpO1xuICAgICAgICAgICAgY2xpZW50LnJlbW92ZUxpc3RlbmVyKFwiUm9vbS50aW1lbGluZVJlc2V0XCIsIHRoaXMub25Sb29tVGltZWxpbmVSZXNldCk7XG4gICAgICAgICAgICBjbGllbnQucmVtb3ZlTGlzdGVuZXIoXCJSb29tLnJlZGFjdGlvblwiLCB0aGlzLm9uUm9vbVJlZGFjdGlvbik7XG4gICAgICAgICAgICBjbGllbnQucmVtb3ZlTGlzdGVuZXIoXCJSb29tLnJlZGFjdGlvbkNhbmNlbGxlZFwiLCB0aGlzLm9uUm9vbVJlZGFjdGlvbik7XG4gICAgICAgICAgICBjbGllbnQucmVtb3ZlTGlzdGVuZXIoXCJSb29tLnJlY2VpcHRcIiwgdGhpcy5vblJvb21SZWNlaXB0KTtcbiAgICAgICAgICAgIGNsaWVudC5yZW1vdmVMaXN0ZW5lcihcIlJvb20ubG9jYWxFY2hvVXBkYXRlZFwiLCB0aGlzLm9uTG9jYWxFY2hvVXBkYXRlZCk7XG4gICAgICAgICAgICBjbGllbnQucmVtb3ZlTGlzdGVuZXIoXCJSb29tLmFjY291bnREYXRhXCIsIHRoaXMub25BY2NvdW50RGF0YSk7XG4gICAgICAgICAgICBjbGllbnQucmVtb3ZlTGlzdGVuZXIoXCJFdmVudC5kZWNyeXB0ZWRcIiwgdGhpcy5vbkV2ZW50RGVjcnlwdGVkKTtcbiAgICAgICAgICAgIGNsaWVudC5yZW1vdmVMaXN0ZW5lcihcIkV2ZW50LnJlcGxhY2VkXCIsIHRoaXMub25FdmVudFJlcGxhY2VkKTtcbiAgICAgICAgICAgIGNsaWVudC5yZW1vdmVMaXN0ZW5lcihcInN5bmNcIiwgdGhpcy5vblN5bmMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvbk1lc3NhZ2VMaXN0VW5maWxsUmVxdWVzdCA9IChiYWNrd2FyZHM6IGJvb2xlYW4sIHNjcm9sbFRva2VuOiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgICAgICAgLy8gSWYgYmFja3dhcmRzLCB1bnBhZ2luYXRlIGZyb20gdGhlIGJhY2sgKGkuZS4gdGhlIHN0YXJ0IG9mIHRoZSB0aW1lbGluZSlcbiAgICAgICAgY29uc3QgZGlyID0gYmFja3dhcmRzID8gRXZlbnRUaW1lbGluZS5CQUNLV0FSRFMgOiBFdmVudFRpbWVsaW5lLkZPUldBUkRTO1xuICAgICAgICBkZWJ1Z2xvZyhcIlRpbWVsaW5lUGFuZWw6IHVucGFnaW5hdGluZyBldmVudHMgaW4gZGlyZWN0aW9uXCIsIGRpcik7XG5cbiAgICAgICAgLy8gQWxsIHRpbGVzIGFyZSBpbnNlcnRlZCBieSBNZXNzYWdlUGFuZWwgdG8gaGF2ZSBhIHNjcm9sbFRva2VuID09PSBldmVudElkLCBhbmRcbiAgICAgICAgLy8gdGhpcyBwYXJ0aWN1bGFyIGV2ZW50IHNob3VsZCBiZSB0aGUgZmlyc3Qgb3IgbGFzdCB0byBiZSB1bnBhZ2luYXRlZC5cbiAgICAgICAgY29uc3QgZXZlbnRJZCA9IHNjcm9sbFRva2VuO1xuXG4gICAgICAgIGNvbnN0IG1hcmtlciA9IHRoaXMuc3RhdGUuZXZlbnRzLmZpbmRJbmRleChcbiAgICAgICAgICAgIChldikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBldi5nZXRJZCgpID09PSBldmVudElkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBjb3VudCA9IGJhY2t3YXJkcyA/IG1hcmtlciArIDEgOiB0aGlzLnN0YXRlLmV2ZW50cy5sZW5ndGggLSBtYXJrZXI7XG5cbiAgICAgICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgZGVidWdsb2coXCJUaW1lbGluZVBhbmVsOiBVbnBhZ2luYXRpbmdcIiwgY291bnQsIFwiaW4gZGlyZWN0aW9uXCIsIGRpcik7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lV2luZG93LnVucGFnaW5hdGUoY291bnQsIGJhY2t3YXJkcyk7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgZXZlbnRzLCBsaXZlRXZlbnRzLCBmaXJzdFZpc2libGVFdmVudEluZGV4IH0gPSB0aGlzLmdldEV2ZW50cygpO1xuICAgICAgICAgICAgY29uc3QgbmV3U3RhdGU6IFBhcnRpYWw8SVN0YXRlPiA9IHtcbiAgICAgICAgICAgICAgICBldmVudHMsXG4gICAgICAgICAgICAgICAgbGl2ZUV2ZW50cyxcbiAgICAgICAgICAgICAgICBmaXJzdFZpc2libGVFdmVudEluZGV4LFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gV2UgY2FuIG5vdyBwYWdpbmF0ZSBpbiB0aGUgdW5wYWdpbmF0ZWQgZGlyZWN0aW9uXG4gICAgICAgICAgICBpZiAoYmFja3dhcmRzKSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGUuY2FuQmFja1BhZ2luYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGUuY2FuRm9yd2FyZFBhZ2luYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGU8bnVsbD4obmV3U3RhdGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25QYWdpbmF0aW9uUmVxdWVzdCA9IChcbiAgICAgICAgdGltZWxpbmVXaW5kb3c6IFRpbWVsaW5lV2luZG93LFxuICAgICAgICBkaXJlY3Rpb246IERpcmVjdGlvbixcbiAgICAgICAgc2l6ZTogbnVtYmVyLFxuICAgICk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5vblBhZ2luYXRpb25SZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5vblBhZ2luYXRpb25SZXF1ZXN0KHRpbWVsaW5lV2luZG93LCBkaXJlY3Rpb24sIHNpemUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVsaW5lV2luZG93LnBhZ2luYXRlKGRpcmVjdGlvbiwgc2l6ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gc2V0IG9mZiBhIHBhZ2luYXRpb24gcmVxdWVzdC5cbiAgICBwcml2YXRlIG9uTWVzc2FnZUxpc3RGaWxsUmVxdWVzdCA9IChiYWNrd2FyZHM6IGJvb2xlYW4pOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnNob3VsZFBhZ2luYXRlKCkpIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuXG4gICAgICAgIGNvbnN0IGRpciA9IGJhY2t3YXJkcyA/IEV2ZW50VGltZWxpbmUuQkFDS1dBUkRTIDogRXZlbnRUaW1lbGluZS5GT1JXQVJEUztcbiAgICAgICAgY29uc3QgY2FuUGFnaW5hdGVLZXkgPSBiYWNrd2FyZHMgPyAnY2FuQmFja1BhZ2luYXRlJyA6ICdjYW5Gb3J3YXJkUGFnaW5hdGUnO1xuICAgICAgICBjb25zdCBwYWdpbmF0aW5nS2V5ID0gYmFja3dhcmRzID8gJ2JhY2tQYWdpbmF0aW5nJyA6ICdmb3J3YXJkUGFnaW5hdGluZyc7XG5cbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlW2NhblBhZ2luYXRlS2V5XSkge1xuICAgICAgICAgICAgZGVidWdsb2coXCJUaW1lbGluZVBhbmVsOiBoYXZlIGdpdmVuIHVwXCIsIGRpciwgXCJwYWdpbmF0aW5nIHRoaXMgdGltZWxpbmVcIik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy50aW1lbGluZVdpbmRvdy5jYW5QYWdpbmF0ZShkaXIpKSB7XG4gICAgICAgICAgICBkZWJ1Z2xvZyhcIlRpbWVsaW5lUGFuZWw6IGNhbid0XCIsIGRpciwgXCJwYWdpbmF0ZSBhbnkgZnVydGhlclwiKTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGU8bnVsbD4oeyBbY2FuUGFnaW5hdGVLZXldOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJhY2t3YXJkcyAmJiB0aGlzLnN0YXRlLmZpcnN0VmlzaWJsZUV2ZW50SW5kZXggIT09IDApIHtcbiAgICAgICAgICAgIGRlYnVnbG9nKFwiVGltZWxpbmVQYW5lbDogd29uJ3RcIiwgZGlyLCBcInBhZ2luYXRlIHBhc3QgZmlyc3QgdmlzaWJsZSBldmVudFwiKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVidWdsb2coXCJUaW1lbGluZVBhbmVsOiBJbml0aWF0aW5nIHBhZ2luYXRlOyBiYWNrd2FyZHM6XCIrYmFja3dhcmRzKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZTxudWxsPih7IFtwYWdpbmF0aW5nS2V5XTogdHJ1ZSB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5vblBhZ2luYXRpb25SZXF1ZXN0KHRoaXMudGltZWxpbmVXaW5kb3csIGRpciwgUEFHSU5BVEVfU0laRSkudGhlbigocikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMudW5tb3VudGVkKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICBkZWJ1Z2xvZyhcIlRpbWVsaW5lUGFuZWw6IHBhZ2luYXRlIGNvbXBsZXRlIGJhY2t3YXJkczpcIitiYWNrd2FyZHMrXCI7IHN1Y2Nlc3M6XCIrcik7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgZXZlbnRzLCBsaXZlRXZlbnRzLCBmaXJzdFZpc2libGVFdmVudEluZGV4IH0gPSB0aGlzLmdldEV2ZW50cygpO1xuICAgICAgICAgICAgY29uc3QgbmV3U3RhdGU6IFBhcnRpYWw8SVN0YXRlPiA9IHtcbiAgICAgICAgICAgICAgICBbcGFnaW5hdGluZ0tleV06IGZhbHNlLFxuICAgICAgICAgICAgICAgIFtjYW5QYWdpbmF0ZUtleV06IHIsXG4gICAgICAgICAgICAgICAgZXZlbnRzLFxuICAgICAgICAgICAgICAgIGxpdmVFdmVudHMsXG4gICAgICAgICAgICAgICAgZmlyc3RWaXNpYmxlRXZlbnRJbmRleCxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIG1vdmluZyB0aGUgd2luZG93IGluIHRoaXMgZGlyZWN0aW9uIG1heSBtZWFuIHRoYXQgd2UgY2FuIG5vd1xuICAgICAgICAgICAgLy8gcGFnaW5hdGUgaW4gdGhlIG90aGVyIHdoZXJlIHdlIHByZXZpb3VzbHkgY291bGQgbm90LlxuICAgICAgICAgICAgY29uc3Qgb3RoZXJEaXJlY3Rpb24gPSBiYWNrd2FyZHMgPyBFdmVudFRpbWVsaW5lLkZPUldBUkRTIDogRXZlbnRUaW1lbGluZS5CQUNLV0FSRFM7XG4gICAgICAgICAgICBjb25zdCBjYW5QYWdpbmF0ZU90aGVyV2F5S2V5ID0gYmFja3dhcmRzID8gJ2NhbkZvcndhcmRQYWdpbmF0ZScgOiAnY2FuQmFja1BhZ2luYXRlJztcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0ZVtjYW5QYWdpbmF0ZU90aGVyV2F5S2V5XSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVsaW5lV2luZG93LmNhblBhZ2luYXRlKG90aGVyRGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIGRlYnVnbG9nKCdUaW1lbGluZVBhbmVsOiBjYW4gbm93Jywgb3RoZXJEaXJlY3Rpb24sICdwYWdpbmF0ZSBhZ2FpbicpO1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlW2NhblBhZ2luYXRlT3RoZXJXYXlLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRG9uJ3QgcmVzb2x2ZSB1bnRpbCB0aGUgc2V0U3RhdGUgaGFzIGNvbXBsZXRlZDogd2UgbmVlZCB0byBsZXRcbiAgICAgICAgICAgIC8vIHRoZSBjb21wb25lbnQgdXBkYXRlIGJlZm9yZSB3ZSBjb25zaWRlciB0aGUgcGFnaW5hdGlvbiBjb21wbGV0ZWQsXG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UnbGwgZW5kIHVwIHBhZ2luYXRpbmcgaW4gYWxsIHRoZSBoaXN0b3J5IHRoZSBqcy1zZGtcbiAgICAgICAgICAgIC8vIGhhcyBpbiBtZW1vcnkgYmVjYXVzZSB3ZSBuZXZlciBnYXZlIHRoZSBjb21wb25lbnQgYSBjaGFuY2UgdG8gc2Nyb2xsXG4gICAgICAgICAgICAvLyBpdHNlbGYgaW50byB0aGUgcmlnaHQgcGxhY2VcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGU8bnVsbD4obmV3U3RhdGUsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHBhZ2luYXRpbmcgaW4gdGhlIGdpdmVuIGRpcmVjdGlvbiBpZjpcbiAgICAgICAgICAgICAgICAgICAgLy8gLSB0aW1lbGluZVdpbmRvdy5wYWdpbmF0ZSBzYXlzIHdlIGNhblxuICAgICAgICAgICAgICAgICAgICAvLyAtIHdlJ3JlIHBhZ2luYXRpbmcgZm9yd2FyZHMsIG9yIHdlIHdvbid0IGJlIHRyeWluZyB0b1xuICAgICAgICAgICAgICAgICAgICAvLyAgIHBhZ2luYXRlIGJhY2t3YXJkcyBwYXN0IHRoZSBmaXJzdCB2aXNpYmxlIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUociAmJiAoIWJhY2t3YXJkcyB8fCBmaXJzdFZpc2libGVFdmVudEluZGV4ID09PSAwKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25NZXNzYWdlTGlzdFNjcm9sbCA9IGUgPT4ge1xuICAgICAgICB0aGlzLnByb3BzLm9uU2Nyb2xsPy4oZSk7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm1hbmFnZVJlYWRNYXJrZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmRvTWFuYWdlUmVhZE1hcmtlcnMoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgICAqIERlYm91bmNlZCBmdW5jdGlvbiB0byBtYW5hZ2UgcmVhZCBtYXJrZXJzIGJlY2F1c2Ugd2UgZG9uJ3QgbmVlZCB0b1xuICAgICAqIGRvIHRoaXMgb24gZXZlcnkgdGlueSBzY3JvbGwgdXBkYXRlLiBJdCBhbHNvIHNldHMgc3RhdGUgd2hpY2ggY2F1c2VzXG4gICAgICogYSBjb21wb25lbnQgdXBkYXRlLCB3aGljaCBjYW4gaW4gdHVybiByZXNldCB0aGUgc2Nyb2xsIHBvc2l0aW9uLCBzb1xuICAgICAqIGl0J3MgaW1wb3J0YW50IHdlIGFsbG93IHRoZSBicm93c2VyIHRvIHNjcm9sbCBhIGJpdCBiZWZvcmUgcnVubmluZyB0aGlzXG4gICAgICogKGhlbmNlIHRyYWlsaW5nIGVkZ2Ugb25seSBhbmQgZGVib3VuY2UgcmF0aGVyIHRoYW4gdGhyb3R0bGUgYmVjYXVzZVxuICAgICAqIHdlIHJlYWxseSBvbmx5IG5lZWQgdG8gdXBkYXRlIHRoaXMgb25jZSB0aGUgdXNlciBoYXMgZmluaXNoZWQgc2Nyb2xsaW5nLFxuICAgICAqIG5vdCBwZXJpb2RpY2FsbHkgd2hpbGUgdGhleSBzY3JvbGwpLlxuICAgICAqL1xuICAgIHByaXZhdGUgZG9NYW5hZ2VSZWFkTWFya2VycyA9IGRlYm91bmNlKCgpID0+IHtcbiAgICAgICAgY29uc3Qgcm1Qb3NpdGlvbiA9IHRoaXMuZ2V0UmVhZE1hcmtlclBvc2l0aW9uKCk7XG4gICAgICAgIC8vIHdlIGhpZGUgdGhlIHJlYWQgbWFya2VyIHdoZW4gaXQgZmlyc3QgY29tZXMgb250byB0aGUgc2NyZWVuLCBidXQgaWZcbiAgICAgICAgLy8gaXQgZ29lcyBiYWNrIG9mZiB0aGUgdG9wIG9mIHRoZSBzY3JlZW4gKHByZXN1bWFibHkgYmVjYXVzZSB0aGUgdXNlclxuICAgICAgICAvLyBjbGlja3Mgb24gdGhlICdqdW1wIHRvIGJvdHRvbScgYnV0dG9uKSwgd2UgbmVlZCB0byByZS1lbmFibGUgaXQuXG4gICAgICAgIGlmIChybVBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHJlYWRNYXJrZXJWaXNpYmxlOiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgcmVhZCBtYXJrZXIgcG9zaXRpb24gZ29lcyBiZXR3ZWVuIDAgYW5kIC0xLzEsXG4gICAgICAgIC8vIChhbmQgdXNlciBpcyBhY3RpdmUpLCBzd2l0Y2ggdGltZW91dFxuICAgICAgICBjb25zdCB0aW1lb3V0ID0gdGhpcy5yZWFkTWFya2VyVGltZW91dChybVBvc2l0aW9uKTtcbiAgICAgICAgLy8gTk8tT1Agd2hlbiB0aW1lb3V0IGFscmVhZHkgaGFzIHNldCB0byB0aGUgZ2l2ZW4gdmFsdWVcbiAgICAgICAgdGhpcy5yZWFkTWFya2VyQWN0aXZpdHlUaW1lcj8uY2hhbmdlVGltZW91dCh0aW1lb3V0KTtcbiAgICB9LCBSRUFEX01BUktFUl9ERUJPVU5DRV9NUywgeyBsZWFkaW5nOiBmYWxzZSwgdHJhaWxpbmc6IHRydWUgfSk7XG5cbiAgICBwcml2YXRlIG9uQWN0aW9uID0gKHBheWxvYWQ6IEFjdGlvblBheWxvYWQpOiB2b2lkID0+IHtcbiAgICAgICAgc3dpdGNoIChwYXlsb2FkLmFjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBcImlnbm9yZV9zdGF0ZV9jaGFuZ2VkXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25Sb29tVGltZWxpbmUgPSAoXG4gICAgICAgIGV2OiBNYXRyaXhFdmVudCxcbiAgICAgICAgcm9vbTogUm9vbSxcbiAgICAgICAgdG9TdGFydE9mVGltZWxpbmU6IGJvb2xlYW4sXG4gICAgICAgIHJlbW92ZWQ6IGJvb2xlYW4sXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHRpbWVsaW5lOiBFdmVudFRpbWVsaW5lO1xuICAgICAgICAgICAgbGl2ZUV2ZW50PzogYm9vbGVhbjtcbiAgICAgICAgfSxcbiAgICApOiB2b2lkID0+IHtcbiAgICAgICAgLy8gaWdub3JlIGV2ZW50cyBmb3Igb3RoZXIgdGltZWxpbmUgc2V0c1xuICAgICAgICBpZiAoZGF0YS50aW1lbGluZS5nZXRUaW1lbGluZVNldCgpICE9PSB0aGlzLnByb3BzLnRpbWVsaW5lU2V0KSByZXR1cm47XG5cbiAgICAgICAgLy8gaWdub3JlIGFueXRoaW5nIGJ1dCByZWFsLXRpbWUgdXBkYXRlcyBhdCB0aGUgZW5kIG9mIHRoZSByb29tOlxuICAgICAgICAvLyB1cGRhdGVzIGZyb20gcGFnaW5hdGlvbiB3aWxsIGhhcHBlbiB3aGVuIHRoZSBwYWdpbmF0ZSBjb21wbGV0ZXMuXG4gICAgICAgIGlmICh0b1N0YXJ0T2ZUaW1lbGluZSB8fCAhZGF0YSB8fCAhZGF0YS5saXZlRXZlbnQpIHJldHVybjtcblxuICAgICAgICBpZiAoIXRoaXMubWVzc2FnZVBhbmVsLmN1cnJlbnQpIHJldHVybjtcblxuICAgICAgICBpZiAoIXRoaXMubWVzc2FnZVBhbmVsLmN1cnJlbnQuZ2V0U2Nyb2xsU3RhdGUoKS5zdHVja0F0Qm90dG9tKSB7XG4gICAgICAgICAgICAvLyB3ZSB3b24ndCBsb2FkIHRoaXMgZXZlbnQgbm93LCBiZWNhdXNlIHdlIGRvbid0IHdhbnQgdG8gcHVzaCBhbnlcbiAgICAgICAgICAgIC8vIGV2ZW50cyBvZmYgdGhlIG90aGVyIGVuZCBvZiB0aGUgdGltZWxpbmUuIEJ1dCB3ZSBuZWVkIHRvIG5vdGVcbiAgICAgICAgICAgIC8vIHRoYXQgd2UgY2FuIG5vdyBwYWdpbmF0ZS5cbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBjYW5Gb3J3YXJkUGFnaW5hdGU6IHRydWUgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0ZWxsIHRoZSB0aW1lbGluZSB3aW5kb3cgdG8gdHJ5IHRvIGFkdmFuY2UgaXRzZWxmLCBidXQgbm90IHRvIG1ha2VcbiAgICAgICAgLy8gYW4gaHR0cCByZXF1ZXN0IHRvIGRvIHNvLlxuICAgICAgICAvL1xuICAgICAgICAvLyB3ZSBkZWxpYmVyYXRlbHkgYXZvaWQgZ29pbmcgdmlhIHRoZSBTY3JvbGxQYW5lbCBmb3IgdGhpcyBjYWxsIC0gdGhlXG4gICAgICAgIC8vIFNjcm9sbFBhbmVsIG1pZ2h0IGFscmVhZHkgaGF2ZSBhbiBhY3RpdmUgcGFnaW5hdGlvbiBwcm9taXNlLCB3aGljaFxuICAgICAgICAvLyB3aWxsIGZhaWwsIGJ1dCB3b3VsZCBzdG9wIHVzIHBhc3NpbmcgdGhlIHBhZ2luYXRpb24gcmVxdWVzdCB0byB0aGVcbiAgICAgICAgLy8gdGltZWxpbmUgd2luZG93LlxuICAgICAgICAvL1xuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZlY3Rvci1pbS92ZWN0b3Itd2ViL2lzc3Vlcy8xMDM1XG4gICAgICAgIHRoaXMudGltZWxpbmVXaW5kb3cucGFnaW5hdGUoRXZlbnRUaW1lbGluZS5GT1JXQVJEUywgMSwgZmFsc2UpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMudW5tb3VudGVkKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICBjb25zdCB7IGV2ZW50cywgbGl2ZUV2ZW50cywgZmlyc3RWaXNpYmxlRXZlbnRJbmRleCB9ID0gdGhpcy5nZXRFdmVudHMoKTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RMaXZlRXZlbnQgPSBsaXZlRXZlbnRzW2xpdmVFdmVudHMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRTdGF0ZTogUGFydGlhbDxJU3RhdGU+ID0ge1xuICAgICAgICAgICAgICAgIGV2ZW50cyxcbiAgICAgICAgICAgICAgICBsaXZlRXZlbnRzLFxuICAgICAgICAgICAgICAgIGZpcnN0VmlzaWJsZUV2ZW50SW5kZXgsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBsZXQgY2FsbFJNVXBkYXRlZDtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm1hbmFnZVJlYWRNYXJrZXJzKSB7XG4gICAgICAgICAgICAgICAgLy8gd2hlbiBhIG5ldyBldmVudCBhcnJpdmVzIHdoZW4gdGhlIHVzZXIgaXMgbm90IHdhdGNoaW5nIHRoZVxuICAgICAgICAgICAgICAgIC8vIHdpbmRvdywgYnV0IHRoZSB3aW5kb3cgaXMgaW4gaXRzIGF1dG8tc2Nyb2xsIG1vZGUsIG1ha2Ugc3VyZSB0aGVcbiAgICAgICAgICAgICAgICAvLyByZWFkIG1hcmtlciBpcyB2aXNpYmxlLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gV2UgaWdub3JlIGV2ZW50cyB3ZSBoYXZlIHNlbnQgb3Vyc2VsdmVzOyB3ZSBkb24ndCB3YW50IHRvIHNlZSB0aGVcbiAgICAgICAgICAgICAgICAvLyByZWFkLW1hcmtlciB3aGVuIGEgcmVtb3RlIGVjaG8gb2YgYW4gZXZlbnQgd2UgaGF2ZSBqdXN0IHNlbnQgdGFrZXNcbiAgICAgICAgICAgICAgICAvLyBtb3JlIHRoYW4gdGhlIHRpbWVvdXQgb24gdXNlckFjdGl2ZVJlY2VudGx5LlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgY29uc3QgbXlVc2VySWQgPSBNYXRyaXhDbGllbnRQZWcuZ2V0KCkuY3JlZGVudGlhbHMudXNlcklkO1xuICAgICAgICAgICAgICAgIGNhbGxSTVVwZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoZXYuZ2V0U2VuZGVyKCkgIT09IG15VXNlcklkICYmICFVc2VyQWN0aXZpdHkuc2hhcmVkSW5zdGFuY2UoKS51c2VyQWN0aXZlUmVjZW50bHkoKSkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkU3RhdGUucmVhZE1hcmtlclZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdExpdmVFdmVudCAmJiB0aGlzLmdldFJlYWRNYXJrZXJQb3NpdGlvbigpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGtub3cgd2UncmUgc3R1Y2tBdEJvdHRvbSwgc28gd2UgY2FuIGFkdmFuY2UgdGhlIFJNXG4gICAgICAgICAgICAgICAgICAgIC8vIGltbWVkaWF0ZWx5LCB0byBzYXZlIGEgbGF0ZXIgcmVuZGVyIGN5Y2xlXG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRSZWFkTWFya2VyKGxhc3RMaXZlRXZlbnQuZ2V0SWQoKSwgbGFzdExpdmVFdmVudC5nZXRUcygpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZFN0YXRlLnJlYWRNYXJrZXJWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRTdGF0ZS5yZWFkTWFya2VyRXZlbnRJZCA9IGxhc3RMaXZlRXZlbnQuZ2V0SWQoKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbFJNVXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlPG51bGw+KHVwZGF0ZWRTdGF0ZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZVBhbmVsLmN1cnJlbnQudXBkYXRlVGltZWxpbmVNaW5IZWlnaHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbFJNVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uUmVhZE1hcmtlclVwZGF0ZWQ/LigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvblJvb21UaW1lbGluZVJlc2V0ID0gKHJvb206IFJvb20sIHRpbWVsaW5lU2V0OiBFdmVudFRpbWVsaW5lU2V0KTogdm9pZCA9PiB7XG4gICAgICAgIGlmICh0aW1lbGluZVNldCAhPT0gdGhpcy5wcm9wcy50aW1lbGluZVNldCkgcmV0dXJuO1xuXG4gICAgICAgIGlmICh0aGlzLm1lc3NhZ2VQYW5lbC5jdXJyZW50ICYmIHRoaXMubWVzc2FnZVBhbmVsLmN1cnJlbnQuaXNBdEJvdHRvbSgpKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRUaW1lbGluZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHB1YmxpYyBjYW5SZXNldFRpbWVsaW5lID0gKCkgPT4gdGhpcy5tZXNzYWdlUGFuZWw/LmN1cnJlbnQuaXNBdEJvdHRvbSgpO1xuXG4gICAgcHJpdmF0ZSBvblJvb21SZWRhY3Rpb24gPSAoZXY6IE1hdHJpeEV2ZW50LCByb29tOiBSb29tKTogdm9pZCA9PiB7XG4gICAgICAgIGlmICh0aGlzLnVubW91bnRlZCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIGlnbm9yZSBldmVudHMgZm9yIG90aGVyIHJvb21zXG4gICAgICAgIGlmIChyb29tICE9PSB0aGlzLnByb3BzLnRpbWVsaW5lU2V0LnJvb20pIHJldHVybjtcblxuICAgICAgICAvLyB3ZSBjb3VsZCBza2lwIGFuIHVwZGF0ZSBpZiB0aGUgZXZlbnQgaXNuJ3QgaW4gb3VyIHRpbWVsaW5lLFxuICAgICAgICAvLyBidXQgdGhhdCdzIHByb2JhYmx5IGFuIGVhcmx5IG9wdGltaXNhdGlvbi5cbiAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgIH07XG5cbiAgICBwcml2YXRlIG9uRXZlbnRSZXBsYWNlZCA9IChyZXBsYWNlZEV2ZW50OiBNYXRyaXhFdmVudCwgcm9vbTogUm9vbSk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAodGhpcy51bm1vdW50ZWQpIHJldHVybjtcblxuICAgICAgICAvLyBpZ25vcmUgZXZlbnRzIGZvciBvdGhlciByb29tc1xuICAgICAgICBpZiAocm9vbSAhPT0gdGhpcy5wcm9wcy50aW1lbGluZVNldC5yb29tKSByZXR1cm47XG5cbiAgICAgICAgLy8gd2UgY291bGQgc2tpcCBhbiB1cGRhdGUgaWYgdGhlIGV2ZW50IGlzbid0IGluIG91ciB0aW1lbGluZSxcbiAgICAgICAgLy8gYnV0IHRoYXQncyBwcm9iYWJseSBhbiBlYXJseSBvcHRpbWlzYXRpb24uXG4gICAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvblJvb21SZWNlaXB0ID0gKGV2OiBNYXRyaXhFdmVudCwgcm9vbTogUm9vbSk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAodGhpcy51bm1vdW50ZWQpIHJldHVybjtcblxuICAgICAgICAvLyBpZ25vcmUgZXZlbnRzIGZvciBvdGhlciByb29tc1xuICAgICAgICBpZiAocm9vbSAhPT0gdGhpcy5wcm9wcy50aW1lbGluZVNldC5yb29tKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgIH07XG5cbiAgICBwcml2YXRlIG9uTG9jYWxFY2hvVXBkYXRlZCA9IChldjogTWF0cml4RXZlbnQsIHJvb206IFJvb20sIG9sZEV2ZW50SWQ6IHN0cmluZyk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAodGhpcy51bm1vdW50ZWQpIHJldHVybjtcblxuICAgICAgICAvLyBpZ25vcmUgZXZlbnRzIGZvciBvdGhlciByb29tc1xuICAgICAgICBpZiAocm9vbSAhPT0gdGhpcy5wcm9wcy50aW1lbGluZVNldC5yb29tKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5yZWxvYWRFdmVudHMoKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbkFjY291bnREYXRhID0gKGV2OiBNYXRyaXhFdmVudCwgcm9vbTogUm9vbSk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAodGhpcy51bm1vdW50ZWQpIHJldHVybjtcblxuICAgICAgICAvLyBpZ25vcmUgZXZlbnRzIGZvciBvdGhlciByb29tc1xuICAgICAgICBpZiAocm9vbSAhPT0gdGhpcy5wcm9wcy50aW1lbGluZVNldC5yb29tKSByZXR1cm47XG5cbiAgICAgICAgaWYgKGV2LmdldFR5cGUoKSAhPT0gRXZlbnRUeXBlLkZ1bGx5UmVhZCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIFhYWDogcm9vbVJlYWRNYXJrZXJUc01hcCBub3QgdXBkYXRlZCBoZXJlIHNvIGl0IGlzIG5vdyBpbmNvbnNpc3RlbnQuIFJlcGxhY2VcbiAgICAgICAgLy8gdGhpcyBtZWNoYW5pc20gb2YgZGV0ZXJtaW5pbmcgd2hlcmUgdGhlIFJNIGlzIHJlbGF0aXZlIHRvIHRoZSB2aWV3LXBvcnQgd2l0aFxuICAgICAgICAvLyBvbmUgc3VwcG9ydGVkIGJ5IHRoZSBzZXJ2ZXIgKHRoZSBjbGllbnQgbmVlZHMgbW9yZSB0aGFuIGFuIGV2ZW50IElEKS5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICByZWFkTWFya2VyRXZlbnRJZDogZXYuZ2V0Q29udGVudCgpLmV2ZW50X2lkLFxuICAgICAgICB9LCB0aGlzLnByb3BzLm9uUmVhZE1hcmtlclVwZGF0ZWQpO1xuICAgIH07XG5cbiAgICBwcml2YXRlIG9uRXZlbnREZWNyeXB0ZWQgPSAoZXY6IE1hdHJpeEV2ZW50KTogdm9pZCA9PiB7XG4gICAgICAgIC8vIENhbiBiZSBudWxsIGZvciB0aGUgbm90aWZpY2F0aW9uIHRpbWVsaW5lLCBldGMuXG4gICAgICAgIGlmICghdGhpcy5wcm9wcy50aW1lbGluZVNldC5yb29tKSByZXR1cm47XG5cbiAgICAgICAgLy8gTmVlZCB0byB1cGRhdGUgYXMgd2UgZG9uJ3QgZGlzcGxheSBldmVudCB0aWxlcyBmb3IgZXZlbnRzIHRoYXRcbiAgICAgICAgLy8gaGF2ZW4ndCB5ZXQgYmVlbiBkZWNyeXB0ZWQuIFRoZSBldmVudCB3aWxsIGhhdmUganVzdCBiZWVuIHVwZGF0ZWRcbiAgICAgICAgLy8gaW4gcGxhY2Ugc28gd2UganVzdCBuZWVkIHRvIHJlLXJlbmRlci5cbiAgICAgICAgLy8gVE9ETzogV2Ugc2hvdWxkIHJlc3RyaWN0IHRoaXMgdG8gb25seSBldmVudHMgaW4gb3VyIHRpbWVsaW5lLFxuICAgICAgICAvLyBidXQgcG9zc2libHkgdGhlIGV2ZW50IHRpbGUgaXRzZWxmIHNob3VsZCBqdXN0IHVwZGF0ZSB3aGVuIHRoaXNcbiAgICAgICAgLy8gaGFwcGVucyB0byBzYXZlIHVzIHJlLXJlbmRlcmluZyB0aGUgd2hvbGUgdGltZWxpbmUuXG4gICAgICAgIGlmIChldi5nZXRSb29tSWQoKSA9PT0gdGhpcy5wcm9wcy50aW1lbGluZVNldC5yb29tLnJvb21JZCkge1xuICAgICAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25TeW5jID0gKGNsaWVudFN5bmNTdGF0ZTogU3luY1N0YXRlLCBwcmV2U3RhdGU6IFN5bmNTdGF0ZSwgZGF0YTogb2JqZWN0KTogdm9pZCA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBjbGllbnRTeW5jU3RhdGUgfSk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgcmVhZE1hcmtlclRpbWVvdXQocmVhZE1hcmtlclBvc2l0aW9uOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gcmVhZE1hcmtlclBvc2l0aW9uID09PSAwID9cbiAgICAgICAgICAgIHRoaXMuY29udGV4dD8ucmVhZE1hcmtlckluVmlld1RocmVzaG9sZE1zID8/IHRoaXMuc3RhdGUucmVhZE1hcmtlckluVmlld1RocmVzaG9sZE1zIDpcbiAgICAgICAgICAgIHRoaXMuY29udGV4dD8ucmVhZE1hcmtlck91dE9mVmlld1RocmVzaG9sZE1zID8/IHRoaXMuc3RhdGUucmVhZE1hcmtlck91dE9mVmlld1RocmVzaG9sZE1zO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgdXBkYXRlUmVhZE1hcmtlck9uVXNlckFjdGl2aXR5KCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBpbml0aWFsVGltZW91dCA9IHRoaXMucmVhZE1hcmtlclRpbWVvdXQodGhpcy5nZXRSZWFkTWFya2VyUG9zaXRpb24oKSk7XG4gICAgICAgIHRoaXMucmVhZE1hcmtlckFjdGl2aXR5VGltZXIgPSBuZXcgVGltZXIoaW5pdGlhbFRpbWVvdXQpO1xuXG4gICAgICAgIHdoaWxlICh0aGlzLnJlYWRNYXJrZXJBY3Rpdml0eVRpbWVyKSB7IC8vdW5zZXQgb24gdW5tb3VudFxuICAgICAgICAgICAgVXNlckFjdGl2aXR5LnNoYXJlZEluc3RhbmNlKCkudGltZVdoaWxlQWN0aXZlUmVjZW50bHkodGhpcy5yZWFkTWFya2VyQWN0aXZpdHlUaW1lcik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVhZE1hcmtlckFjdGl2aXR5VGltZXIuZmluaXNoZWQoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgY29udGludWU7IC8qIGFib3J0ZWQgKi8gfVxuICAgICAgICAgICAgLy8gb3V0c2lkZSBvZiB0cnkvY2F0Y2ggdG8gbm90IHN3YWxsb3cgZXJyb3JzXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJlYWRNYXJrZXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgdXBkYXRlUmVhZFJlY2VpcHRPblVzZXJBY3Rpdml0eSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgdGhpcy5yZWFkUmVjZWlwdEFjdGl2aXR5VGltZXIgPSBuZXcgVGltZXIoUkVBRF9SRUNFSVBUX0lOVEVSVkFMX01TKTtcbiAgICAgICAgd2hpbGUgKHRoaXMucmVhZFJlY2VpcHRBY3Rpdml0eVRpbWVyKSB7IC8vdW5zZXQgb24gdW5tb3VudFxuICAgICAgICAgICAgVXNlckFjdGl2aXR5LnNoYXJlZEluc3RhbmNlKCkudGltZVdoaWxlQWN0aXZlTm93KHRoaXMucmVhZFJlY2VpcHRBY3Rpdml0eVRpbWVyKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWFkUmVjZWlwdEFjdGl2aXR5VGltZXIuZmluaXNoZWQoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgY29udGludWU7IC8qIGFib3J0ZWQgKi8gfVxuICAgICAgICAgICAgLy8gb3V0c2lkZSBvZiB0cnkvY2F0Y2ggdG8gbm90IHN3YWxsb3cgZXJyb3JzXG4gICAgICAgICAgICB0aGlzLnNlbmRSZWFkUmVjZWlwdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZW5kUmVhZFJlY2VpcHQgPSAoKTogdm9pZCA9PiB7XG4gICAgICAgIGlmIChTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFwibG93QmFuZHdpZHRoXCIpKSByZXR1cm47XG5cbiAgICAgICAgaWYgKCF0aGlzLm1lc3NhZ2VQYW5lbC5jdXJyZW50KSByZXR1cm47XG4gICAgICAgIGlmICghdGhpcy5wcm9wcy5tYW5hZ2VSZWFkUmVjZWlwdHMpIHJldHVybjtcbiAgICAgICAgLy8gVGhpcyBoYXBwZW5zIG9uIHVzZXJfYWN0aXZpdHlfZW5kIHdoaWNoIGlzIGRlbGF5ZWQsIGFuZCBpdCdzXG4gICAgICAgIC8vIHZlcnkgcG9zc2libGUgaGF2ZSBsb2dnZWQgb3V0IHdpdGhpbiB0aGF0IHRpbWVmcmFtZSwgc28gY2hlY2tcbiAgICAgICAgLy8gd2Ugc3RpbGwgaGF2ZSBhIGNsaWVudC5cbiAgICAgICAgY29uc3QgY2xpID0gTWF0cml4Q2xpZW50UGVnLmdldCgpO1xuICAgICAgICAvLyBpZiBubyBjbGllbnQgb3IgY2xpZW50IGlzIGd1ZXN0IGRvbid0IHNlbmQgUlIgb3IgUk1cbiAgICAgICAgaWYgKCFjbGkgfHwgY2xpLmlzR3Vlc3QoKSkgcmV0dXJuO1xuXG4gICAgICAgIGxldCBzaG91bGRTZW5kUlIgPSB0cnVlO1xuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRSUkV2ZW50SWQgPSB0aGlzLmdldEN1cnJlbnRSZWFkUmVjZWlwdCh0cnVlKTtcbiAgICAgICAgY29uc3QgY3VycmVudFJSRXZlbnRJbmRleCA9IHRoaXMuaW5kZXhGb3JFdmVudElkKGN1cnJlbnRSUkV2ZW50SWQpO1xuICAgICAgICAvLyBXZSB3YW50IHRvIGF2b2lkIHNlbmRpbmcgb3V0IHJlYWQgcmVjZWlwdHMgd2hlbiB3ZSBhcmUgbG9va2luZyBhdFxuICAgICAgICAvLyBldmVudHMgaW4gdGhlIHBhc3Qgd2hpY2ggYXJlIGJlZm9yZSB0aGUgbGF0ZXN0IFJSLlxuICAgICAgICAvL1xuICAgICAgICAvLyBGb3Igbm93LCBsZXQncyBhcHBseSBhIGhldXJpc3RpYzogaWYgKGEpIHRoZSBldmVudCBjb3JyZXNwb25kaW5nIHRvXG4gICAgICAgIC8vIHRoZSBsYXRlc3QgUlIgKGVpdGhlciBmcm9tIHRoZSBzZXJ2ZXIsIG9yIHNlbnQgYnkgb3Vyc2VsdmVzKSBkb2Vzbid0XG4gICAgICAgIC8vIGFwcGVhciBpbiBvdXIgdGltZWxpbmUsIGFuZCAoYikgd2UgY291bGQgZm9yd2FyZC1wYWdpbmF0ZSB0aGUgZXZlbnRcbiAgICAgICAgLy8gdGltZWxpbmUsIHRoZW4gZG9uJ3Qgc2VuZCBhbnkgbW9yZSBSUnMuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoaXMgaXNuJ3Qgd2F0ZXJ0aWdodCwgYXMgd2UgY291bGQgYmUgbG9va2luZyBhdCBhIHNlY3Rpb24gb2ZcbiAgICAgICAgLy8gdGltZWxpbmUgd2hpY2ggaXMgKmFmdGVyKiB0aGUgbGF0ZXN0IFJSIChzbyB3ZSBzaG91bGQgYWN0dWFsbHkgc2VuZFxuICAgICAgICAvLyBSUnMpIC0gYnV0IHRoYXQgaXMgYSBiaXQgb2YgYSBuaWNoZSBjYXNlLiBJdCB3aWxsIHNvcnQgaXRzZWxmIG91dCB3aGVuXG4gICAgICAgIC8vIHRoZSB1c2VyIGV2ZW50dWFsbHkgaGl0cyB0aGUgbGl2ZSB0aW1lbGluZS5cbiAgICAgICAgLy9cbiAgICAgICAgaWYgKGN1cnJlbnRSUkV2ZW50SWQgJiYgY3VycmVudFJSRXZlbnRJbmRleCA9PT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMudGltZWxpbmVXaW5kb3cuY2FuUGFnaW5hdGUoRXZlbnRUaW1lbGluZS5GT1JXQVJEUykpIHtcbiAgICAgICAgICAgIHNob3VsZFNlbmRSUiA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGFzdFJlYWRFdmVudEluZGV4ID0gdGhpcy5nZXRMYXN0RGlzcGxheWVkRXZlbnRJbmRleCh7XG4gICAgICAgICAgICBpZ25vcmVPd246IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobGFzdFJlYWRFdmVudEluZGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgICBzaG91bGRTZW5kUlIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGFzdFJlYWRFdmVudCA9IHRoaXMuc3RhdGUuZXZlbnRzW2xhc3RSZWFkRXZlbnRJbmRleF07XG4gICAgICAgIHNob3VsZFNlbmRSUiA9IHNob3VsZFNlbmRSUiAmJlxuICAgICAgICAgICAgLy8gT25seSBzZW5kIGEgUlIgaWYgdGhlIGxhc3QgcmVhZCBldmVudCBpcyBhaGVhZCBpbiB0aGUgdGltZWxpbmUgcmVsYXRpdmUgdG9cbiAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IFJSIGV2ZW50LlxuICAgICAgICAgICAgbGFzdFJlYWRFdmVudEluZGV4ID4gY3VycmVudFJSRXZlbnRJbmRleCAmJlxuICAgICAgICAgICAgLy8gT25seSBzZW5kIGEgUlIgaWYgdGhlIGxhc3QgUlIgc2V0ICE9IHRoZSBvbmUgd2Ugd291bGQgc2VuZFxuICAgICAgICAgICAgdGhpcy5sYXN0UlJTZW50RXZlbnRJZCAhPSBsYXN0UmVhZEV2ZW50LmdldElkKCk7XG5cbiAgICAgICAgLy8gT25seSBzZW5kIGEgUk0gaWYgdGhlIGxhc3QgUk0gc2VudCAhPSB0aGUgb25lIHdlIHdvdWxkIHNlbmRcbiAgICAgICAgY29uc3Qgc2hvdWxkU2VuZFJNID1cbiAgICAgICAgICAgIHRoaXMubGFzdFJNU2VudEV2ZW50SWQgIT0gdGhpcy5zdGF0ZS5yZWFkTWFya2VyRXZlbnRJZDtcblxuICAgICAgICAvLyB3ZSBhbHNvIHJlbWVtYmVyIHRoZSBsYXN0IHJlYWQgcmVjZWlwdCB3ZSBzZW50IHRvIGF2b2lkIHNwYW1taW5nIHRoZVxuICAgICAgICAvLyBzYW1lIG9uZSBhdCB0aGUgc2VydmVyIHJlcGVhdGVkbHlcbiAgICAgICAgaWYgKHNob3VsZFNlbmRSUiB8fCBzaG91bGRTZW5kUk0pIHtcbiAgICAgICAgICAgIGlmIChzaG91bGRTZW5kUlIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RSUlNlbnRFdmVudElkID0gbGFzdFJlYWRFdmVudC5nZXRJZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYXN0UmVhZEV2ZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGFzdFJNU2VudEV2ZW50SWQgPSB0aGlzLnN0YXRlLnJlYWRNYXJrZXJFdmVudElkO1xuXG4gICAgICAgICAgICBjb25zdCByb29tSWQgPSB0aGlzLnByb3BzLnRpbWVsaW5lU2V0LnJvb20ucm9vbUlkO1xuICAgICAgICAgICAgY29uc3QgaGlkZGVuUlIgPSBTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFwiZmVhdHVyZV9oaWRkZW5fcmVhZF9yZWNlaXB0c1wiLCByb29tSWQpO1xuXG4gICAgICAgICAgICBkZWJ1Z2xvZygnVGltZWxpbmVQYW5lbDogU2VuZGluZyBSZWFkIE1hcmtlcnMgZm9yICcsXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy50aW1lbGluZVNldC5yb29tLnJvb21JZCxcbiAgICAgICAgICAgICAgICAncm0nLCB0aGlzLnN0YXRlLnJlYWRNYXJrZXJFdmVudElkLFxuICAgICAgICAgICAgICAgIGxhc3RSZWFkRXZlbnQgPyAncnIgJyArIGxhc3RSZWFkRXZlbnQuZ2V0SWQoKSA6ICcnLFxuICAgICAgICAgICAgICAgICcgaGlkZGVuOicgKyBoaWRkZW5SUixcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBNYXRyaXhDbGllbnRQZWcuZ2V0KCkuc2V0Um9vbVJlYWRNYXJrZXJzKFxuICAgICAgICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnJlYWRNYXJrZXJFdmVudElkLFxuICAgICAgICAgICAgICAgIGxhc3RSZWFkRXZlbnQsIC8vIENvdWxkIGJlIG51bGwsIGluIHdoaWNoIGNhc2Ugbm8gUlIgaXMgc2VudFxuICAgICAgICAgICAgICAgIHsgaGlkZGVuOiBoaWRkZW5SUiB9LFxuICAgICAgICAgICAgKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIC9yZWFkX21hcmtlcnMgQVBJIGlzIG5vdCBpbXBsZW1lbnRlZCBvbiB0aGlzIEhTLCBmYWxsYmFjayB0byBqdXN0IFJSXG4gICAgICAgICAgICAgICAgaWYgKGUuZXJyY29kZSA9PT0gJ01fVU5SRUNPR05JWkVEJyAmJiBsYXN0UmVhZEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRyaXhDbGllbnRQZWcuZ2V0KCkuc2VuZFJlYWRSZWNlaXB0KFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFJlYWRFdmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgICAgICApLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RSUlNlbnRFdmVudElkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGl0IGZhaWxlZCwgc28gYWxsb3cgcmV0cmllcyBuZXh0IHRpbWUgdGhlIHVzZXIgaXMgYWN0aXZlXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0UlJTZW50RXZlbnRJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RSTVNlbnRFdmVudElkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGRvIGEgcXVpY2stcmVzZXQgb2Ygb3VyIHVucmVhZE5vdGlmaWNhdGlvbkNvdW50IHRvIGF2b2lkIGhhdmluZ1xuICAgICAgICAgICAgLy8gdG8gd2FpdCBmcm9tIHRoZSByZW1vdGUgZWNobyBmcm9tIHRoZSBob21lc2VydmVyLlxuICAgICAgICAgICAgLy8gd2Ugb25seSBkbyB0aGlzIGlmIHdlJ3JlIHJpZ2h0IGF0IHRoZSBlbmQsIGJlY2F1c2Ugd2UncmUganVzdCBhc3N1bWluZ1xuICAgICAgICAgICAgLy8gdGhhdCBzZW5kaW5nIGFuIFJSIGZvciB0aGUgbGF0ZXN0IG1lc3NhZ2Ugd2lsbCBzZXQgb3VyIG5vdGlmIGNvdW50ZXJcbiAgICAgICAgICAgIC8vIHRvIHplcm86IGl0IG1heSBub3QgZG8gdGhpcyBpZiB3ZSBzZW5kIGFuIFJSIGZvciBzb21ld2hlcmUgYmVmb3JlIHRoZSBlbmQuXG4gICAgICAgICAgICBpZiAodGhpcy5pc0F0RW5kT2ZMaXZlVGltZWxpbmUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMudGltZWxpbmVTZXQucm9vbS5zZXRVbnJlYWROb3RpZmljYXRpb25Db3VudChOb3RpZmljYXRpb25Db3VudFR5cGUuVG90YWwsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMudGltZWxpbmVTZXQucm9vbS5zZXRVbnJlYWROb3RpZmljYXRpb25Db3VudChOb3RpZmljYXRpb25Db3VudFR5cGUuSGlnaGxpZ2h0LCAwKTtcbiAgICAgICAgICAgICAgICBkaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdvbl9yb29tX3JlYWQnLFxuICAgICAgICAgICAgICAgICAgICByb29tSWQ6IHRoaXMucHJvcHMudGltZWxpbmVTZXQucm9vbS5yb29tSWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gaWYgdGhlIHJlYWQgbWFya2VyIGlzIG9uIHRoZSBzY3JlZW4sIHdlIGNhbiBub3cgYXNzdW1lIHdlJ3ZlIGNhdWdodCB1cCB0byB0aGUgZW5kXG4gICAgLy8gb2YgdGhlIHNjcmVlbiwgc28gbW92ZSB0aGUgbWFya2VyIGRvd24gdG8gdGhlIGJvdHRvbSBvZiB0aGUgc2NyZWVuLlxuICAgIHByaXZhdGUgdXBkYXRlUmVhZE1hcmtlciA9ICgpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3BzLm1hbmFnZVJlYWRNYXJrZXJzKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLmdldFJlYWRNYXJrZXJQb3NpdGlvbigpID09PSAxKSB7XG4gICAgICAgICAgICAvLyB0aGUgcmVhZCBtYXJrZXIgaXMgYXQgYW4gZXZlbnQgYmVsb3cgdGhlIHZpZXdwb3J0LFxuICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byByZXdpbmQgaXQuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gbW92ZSB0aGUgUk0gdG8gKmFmdGVyKiB0aGUgbWVzc2FnZSBhdCB0aGUgYm90dG9tIG9mIHRoZSBzY3JlZW4uIFRoaXNcbiAgICAgICAgLy8gYXZvaWRzIGEgcHJvYmxlbSB3aGVyZWJ5IHdlIG5ldmVyIGFkdmFuY2UgdGhlIFJNIGlmIHRoZXJlIGlzIGEgaHVnZVxuICAgICAgICAvLyBtZXNzYWdlIHdoaWNoIGRvZXNuJ3QgZml0IG9uIHRoZSBzY3JlZW4uXG4gICAgICAgIGNvbnN0IGxhc3REaXNwbGF5ZWRJbmRleCA9IHRoaXMuZ2V0TGFzdERpc3BsYXllZEV2ZW50SW5kZXgoe1xuICAgICAgICAgICAgYWxsb3dQYXJ0aWFsOiB0cnVlLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobGFzdERpc3BsYXllZEluZGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFzdERpc3BsYXllZEV2ZW50ID0gdGhpcy5zdGF0ZS5ldmVudHNbbGFzdERpc3BsYXllZEluZGV4XTtcbiAgICAgICAgdGhpcy5zZXRSZWFkTWFya2VyKFxuICAgICAgICAgICAgbGFzdERpc3BsYXllZEV2ZW50LmdldElkKCksXG4gICAgICAgICAgICBsYXN0RGlzcGxheWVkRXZlbnQuZ2V0VHMoKSxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB0aGUgcmVhZC1tYXJrZXIgc2hvdWxkIGJlY29tZSBpbnZpc2libGUsIHNvIHRoYXQgaWYgdGhlIHVzZXIgc2Nyb2xsc1xuICAgICAgICAvLyBkb3duLCB0aGV5IGRvbid0IHNlZSBpdC5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUucmVhZE1hcmtlclZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHJlYWRNYXJrZXJWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VuZCB0aGUgdXBkYXRlZCByZWFkIG1hcmtlciAoYWxvbmcgd2l0aCByZWFkIHJlY2VpcHQpIHRvIHRoZSBzZXJ2ZXJcbiAgICAgICAgdGhpcy5zZW5kUmVhZFJlY2VpcHQoKTtcbiAgICB9O1xuXG4gICAgLy8gYWR2YW5jZSB0aGUgcmVhZCBtYXJrZXIgcGFzdCBhbnkgZXZlbnRzIHdlIHNlbnQgb3Vyc2VsdmVzLlxuICAgIHByaXZhdGUgYWR2YW5jZVJlYWRNYXJrZXJQYXN0TXlFdmVudHMoKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5wcm9wcy5tYW5hZ2VSZWFkTWFya2VycykgcmV0dXJuO1xuXG4gICAgICAgIC8vIHdlIGNhbGwgYHRpbWVsaW5lV2luZG93LmdldEV2ZW50cygpYCByYXRoZXIgdGhhbiB1c2luZ1xuICAgICAgICAvLyBgdGhpcy5zdGF0ZS5saXZlRXZlbnRzYCwgYmVjYXVzZSBSZWFjdCBiYXRjaGVzIHRoZSB1cGRhdGUgdG8gdGhlXG4gICAgICAgIC8vIGxhdHRlciwgc28gaXQgbWF5IG5vdCBoYXZlIGJlZW4gdXBkYXRlZCB5ZXQuXG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMudGltZWxpbmVXaW5kb3cuZ2V0RXZlbnRzKCk7XG5cbiAgICAgICAgLy8gZmlyc3QgZmluZCB3aGVyZSB0aGUgY3VycmVudCBSTSBpc1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGV2ZW50c1tpXS5nZXRJZCgpID09IHRoaXMuc3RhdGUucmVhZE1hcmtlckV2ZW50SWQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+PSBldmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3cgdGhpbmsgYWJvdXQgYWR2YW5jaW5nIGl0XG4gICAgICAgIGNvbnN0IG15VXNlcklkID0gTWF0cml4Q2xpZW50UGVnLmdldCgpLmNyZWRlbnRpYWxzLnVzZXJJZDtcbiAgICAgICAgZm9yIChpKys7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ID0gZXZlbnRzW2ldO1xuICAgICAgICAgICAgaWYgKGV2LmdldFNlbmRlcigpICE9PSBteVVzZXJJZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGkgaXMgbm93IHRoZSBmaXJzdCB1bnJlYWQgbWVzc2FnZSB3aGljaCB3ZSBkaWRuJ3Qgc2VuZCBvdXJzZWx2ZXMuXG4gICAgICAgIGktLTtcblxuICAgICAgICBjb25zdCBldiA9IGV2ZW50c1tpXTtcbiAgICAgICAgdGhpcy5zZXRSZWFkTWFya2VyKGV2LmdldElkKCksIGV2LmdldFRzKCkpO1xuICAgIH1cblxuICAgIC8qIGp1bXAgZG93biB0byB0aGUgYm90dG9tIG9mIHRoaXMgcm9vbSwgd2hlcmUgbmV3IGV2ZW50cyBhcmUgYXJyaXZpbmdcbiAgICAgKi9cbiAgICBwdWJsaWMganVtcFRvTGl2ZVRpbWVsaW5lID0gKCk6IHZvaWQgPT4ge1xuICAgICAgICAvLyBpZiB3ZSBjYW4ndCBmb3J3YXJkLXBhZ2luYXRlIHRoZSBleGlzdGluZyB0aW1lbGluZSwgdGhlbiB0aGVyZVxuICAgICAgICAvLyBpcyBubyBwb2ludCByZWxvYWRpbmcgaXQgLSBqdXN0IGp1bXAgc3RyYWlnaHQgdG8gdGhlIGJvdHRvbS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCByZWxvYWQgdGhlIHRpbWVsaW5lIHJhdGhlciB0aGFuIHRyeWluZyB0byBwYWdpbmF0ZVxuICAgICAgICAvLyB0aHJvdWdoIGFsbCBvZiBzcGFjZS10aW1lLlxuICAgICAgICBpZiAodGhpcy50aW1lbGluZVdpbmRvdy5jYW5QYWdpbmF0ZShFdmVudFRpbWVsaW5lLkZPUldBUkRTKSkge1xuICAgICAgICAgICAgdGhpcy5sb2FkVGltZWxpbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZVBhbmVsLmN1cnJlbnQ/LnNjcm9sbFRvQm90dG9tKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHVibGljIHNjcm9sbFRvRXZlbnRJZk5lZWRlZCA9IChldmVudElkOiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgICAgICAgdGhpcy5tZXNzYWdlUGFuZWwuY3VycmVudD8uc2Nyb2xsVG9FdmVudElmTmVlZGVkKGV2ZW50SWQpO1xuICAgIH07XG5cbiAgICAvKiBzY3JvbGwgdG8gc2hvdyB0aGUgcmVhZC11cC10byBtYXJrZXIuIFdlIHB1dCBpdCAxLzMgb2YgdGhlIHdheSBkb3duXG4gICAgICogdGhlIGNvbnRhaW5lci5cbiAgICAgKi9cbiAgICBwdWJsaWMganVtcFRvUmVhZE1hcmtlciA9ICgpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3BzLm1hbmFnZVJlYWRNYXJrZXJzKSByZXR1cm47XG4gICAgICAgIGlmICghdGhpcy5tZXNzYWdlUGFuZWwuY3VycmVudCkgcmV0dXJuO1xuICAgICAgICBpZiAoIXRoaXMuc3RhdGUucmVhZE1hcmtlckV2ZW50SWQpIHJldHVybjtcblxuICAgICAgICAvLyB3ZSBtYXkgbm90IGhhdmUgbG9hZGVkIHRoZSBldmVudCBjb3JyZXNwb25kaW5nIHRvIHRoZSByZWFkLW1hcmtlclxuICAgICAgICAvLyBpbnRvIHRoZSB0aW1lbGluZVdpbmRvdy4gSW4gdGhhdCBjYXNlLCBhdHRlbXB0cyB0byBzY3JvbGwgdG8gaXRcbiAgICAgICAgLy8gd2lsbCBmYWlsLlxuICAgICAgICAvL1xuICAgICAgICAvLyBhIHF1aWNrIHdheSB0byBmaWd1cmUgb3V0IGlmIHdlJ3ZlIGxvYWRlZCB0aGUgcmVsZXZhbnQgZXZlbnQgaXNcbiAgICAgICAgLy8gc2ltcGx5IHRvIGNoZWNrIGlmIHRoZSBtZXNzYWdlcGFuZWwga25vd3Mgd2hlcmUgdGhlIHJlYWQtbWFya2VyIGlzLlxuICAgICAgICBjb25zdCByZXQgPSB0aGlzLm1lc3NhZ2VQYW5lbC5jdXJyZW50LmdldFJlYWRNYXJrZXJQb3NpdGlvbigpO1xuICAgICAgICBpZiAocmV0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbWVzc2FnZXBhbmVsIGtub3dzIHdoZXJlIHRoZSBSTSBpcywgc28gd2UgbXVzdCBoYXZlIGxvYWRlZFxuICAgICAgICAgICAgLy8gdGhlIHJlbGV2YW50IGV2ZW50LlxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlUGFuZWwuY3VycmVudC5zY3JvbGxUb0V2ZW50KHRoaXMuc3RhdGUucmVhZE1hcmtlckV2ZW50SWQsXG4gICAgICAgICAgICAgICAgMCwgMS8zKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvb2tzIGxpa2Ugd2UgaGF2ZW4ndCBsb2FkZWQgdGhlIGV2ZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHJlYWQtbWFya2VyLlxuICAgICAgICAvLyBBcyB3aXRoIGp1bXBUb0xpdmVUaW1lbGluZSwgd2Ugd2FudCB0byByZWxvYWQgdGhlIHRpbWVsaW5lIGFyb3VuZCB0aGVcbiAgICAgICAgLy8gcmVhZC1tYXJrZXIuXG4gICAgICAgIHRoaXMubG9hZFRpbWVsaW5lKHRoaXMuc3RhdGUucmVhZE1hcmtlckV2ZW50SWQsIDAsIDEvMyk7XG4gICAgfTtcblxuICAgIC8qIHVwZGF0ZSB0aGUgcmVhZC11cC10byBtYXJrZXIgdG8gbWF0Y2ggdGhlIHJlYWQgcmVjZWlwdFxuICAgICAqL1xuICAgIHB1YmxpYyBmb3JnZXRSZWFkTWFya2VyID0gKCk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAoIXRoaXMucHJvcHMubWFuYWdlUmVhZE1hcmtlcnMpIHJldHVybjtcblxuICAgICAgICBjb25zdCBybUlkID0gdGhpcy5nZXRDdXJyZW50UmVhZFJlY2VpcHQoKTtcblxuICAgICAgICAvLyBzZWUgaWYgd2Uga25vdyB0aGUgdGltZXN0YW1wIGZvciB0aGUgcnIgZXZlbnRcbiAgICAgICAgY29uc3QgdGwgPSB0aGlzLnByb3BzLnRpbWVsaW5lU2V0LmdldFRpbWVsaW5lRm9yRXZlbnQocm1JZCk7XG4gICAgICAgIGxldCBybVRzO1xuICAgICAgICBpZiAodGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gdGwuZ2V0RXZlbnRzKCkuZmluZCgoZSkgPT4geyByZXR1cm4gZS5nZXRJZCgpID09IHJtSWQ7IH0pO1xuICAgICAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcm1UcyA9IGV2ZW50LmdldFRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFJlYWRNYXJrZXIocm1JZCwgcm1Ucyk7XG4gICAgfTtcblxuICAgIC8qIHJldHVybiB0cnVlIGlmIHRoZSBjb250ZW50IGlzIGZ1bGx5IHNjcm9sbGVkIGRvd24gYW5kIHdlIGFyZVxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGxpdmUgdGltZWxpbmUuXG4gICAgICovXG4gICAgcHVibGljIGlzQXRFbmRPZkxpdmVUaW1lbGluZSA9ICgpOiBib29sZWFuID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZVBhbmVsLmN1cnJlbnQ/LmlzQXRCb3R0b20oKVxuICAgICAgICAgICAgJiYgdGhpcy50aW1lbGluZVdpbmRvd1xuICAgICAgICAgICAgJiYgIXRoaXMudGltZWxpbmVXaW5kb3cuY2FuUGFnaW5hdGUoRXZlbnRUaW1lbGluZS5GT1JXQVJEUyk7XG4gICAgfTtcblxuICAgIC8qIGdldCB0aGUgY3VycmVudCBzY3JvbGwgc3RhdGUuIFNlZSBTY3JvbGxQYW5lbC5nZXRTY3JvbGxTdGF0ZSBmb3JcbiAgICAgKiBkZXRhaWxzLlxuICAgICAqXG4gICAgICogcmV0dXJucyBudWxsIGlmIHdlIGFyZSBub3QgbW91bnRlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0U2Nyb2xsU3RhdGUgPSAoKTogSVNjcm9sbFN0YXRlID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLm1lc3NhZ2VQYW5lbC5jdXJyZW50KSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VQYW5lbC5jdXJyZW50LmdldFNjcm9sbFN0YXRlKCk7XG4gICAgfTtcblxuICAgIC8vIHJldHVybnMgb25lIG9mOlxuICAgIC8vXG4gICAgLy8gIG51bGw6IHRoZXJlIGlzIG5vIHJlYWQgbWFya2VyXG4gICAgLy8gIC0xOiByZWFkIG1hcmtlciBpcyBhYm92ZSB0aGUgd2luZG93XG4gICAgLy8gICAwOiByZWFkIG1hcmtlciBpcyB2aXNpYmxlXG4gICAgLy8gICsxOiByZWFkIG1hcmtlciBpcyBiZWxvdyB0aGUgd2luZG93XG4gICAgcHVibGljIGdldFJlYWRNYXJrZXJQb3NpdGlvbiA9ICgpOiBudW1iZXIgPT4ge1xuICAgICAgICBpZiAoIXRoaXMucHJvcHMubWFuYWdlUmVhZE1hcmtlcnMpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoIXRoaXMubWVzc2FnZVBhbmVsLmN1cnJlbnQpIHJldHVybiBudWxsO1xuXG4gICAgICAgIGNvbnN0IHJldCA9IHRoaXMubWVzc2FnZVBhbmVsLmN1cnJlbnQuZ2V0UmVhZE1hcmtlclBvc2l0aW9uKCk7XG4gICAgICAgIGlmIChyZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgbWVzc2FnZVBhbmVsIGRvZXNuJ3Qga25vdyB3aGVyZSB0aGUgcmVhZCBtYXJrZXIgaXMuXG4gICAgICAgIC8vIGlmIHdlIGtub3cgdGhlIHRpbWVzdGFtcCBvZiB0aGUgcmVhZCBtYXJrZXIsIG1ha2UgYSBndWVzcyBiYXNlZCBvbiB0aGF0LlxuICAgICAgICBjb25zdCBybVRzID0gVGltZWxpbmVQYW5lbC5yb29tUmVhZE1hcmtlclRzTWFwW3RoaXMucHJvcHMudGltZWxpbmVTZXQucm9vbS5yb29tSWRdO1xuICAgICAgICBpZiAocm1UcyAmJiB0aGlzLnN0YXRlLmV2ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAocm1UcyA8IHRoaXMuc3RhdGUuZXZlbnRzWzBdLmdldFRzKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHB1YmxpYyBjYW5KdW1wVG9SZWFkTWFya2VyID0gKCk6IGJvb2xlYW4gPT4ge1xuICAgICAgICAvLyAxLiBEbyBub3Qgc2hvdyBqdW1wIGJhciBpZiBuZWl0aGVyIHRoZSBSTSBub3IgdGhlIFJSIGFyZSBzZXQuXG4gICAgICAgIC8vIDMuIFdlIHdhbnQgdG8gc2hvdyB0aGUgYmFyIGlmIHRoZSByZWFkLW1hcmtlciBpcyBvZmYgdGhlIHRvcCBvZiB0aGUgc2NyZWVuLlxuICAgICAgICAvLyA0LiBBbHNvLCBpZiBwb3MgPT09IG51bGwsIHRoZSBldmVudCBtaWdodCBub3QgYmUgcGFnaW5hdGVkIC0gc2hvdyB0aGUgdW5yZWFkIGJhclxuICAgICAgICBjb25zdCBwb3MgPSB0aGlzLmdldFJlYWRNYXJrZXJQb3NpdGlvbigpO1xuICAgICAgICBjb25zdCByZXQgPSB0aGlzLnN0YXRlLnJlYWRNYXJrZXJFdmVudElkICE9PSBudWxsICYmIC8vIDEuXG4gICAgICAgICAgICAocG9zIDwgMCB8fCBwb3MgPT09IG51bGwpOyAvLyAzLiwgNC5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBjYWxsZWQgYnkgdGhlIHBhcmVudCBjb21wb25lbnQgd2hlbiBQYWdlVXAvRG93bi9ldGMgaXMgcHJlc3NlZC5cbiAgICAgKlxuICAgICAqIFdlIHBhc3MgaXQgZG93biB0byB0aGUgc2Nyb2xsIHBhbmVsLlxuICAgICAqL1xuICAgIHB1YmxpYyBoYW5kbGVTY3JvbGxLZXkgPSBldiA9PiB7XG4gICAgICAgIGlmICghdGhpcy5tZXNzYWdlUGFuZWwuY3VycmVudCkgeyByZXR1cm47IH1cblxuICAgICAgICAvLyBqdW1wIHRvIHRoZSBsaXZlIHRpbWVsaW5lIG9uIGN0cmwtZW5kLCByYXRoZXIgdGhhbiB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAvLyB0aW1lbGluZSB3aW5kb3cuXG4gICAgICAgIGlmIChldi5jdHJsS2V5ICYmICFldi5zaGlmdEtleSAmJiAhZXYuYWx0S2V5ICYmICFldi5tZXRhS2V5ICYmIGV2LmtleSA9PT0gS2V5LkVORCkge1xuICAgICAgICAgICAgdGhpcy5qdW1wVG9MaXZlVGltZWxpbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZVBhbmVsLmN1cnJlbnQuaGFuZGxlU2Nyb2xsS2V5KGV2KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcml2YXRlIGluaXRUaW1lbGluZShwcm9wczogSVByb3BzKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGluaXRpYWxFdmVudCA9IHByb3BzLmV2ZW50SWQ7XG4gICAgICAgIGNvbnN0IHBpeGVsT2Zmc2V0ID0gcHJvcHMuZXZlbnRQaXhlbE9mZnNldDtcblxuICAgICAgICAvLyBpZiBhIHBpeGVsT2Zmc2V0IGlzIGdpdmVuLCBpdCBpcyByZWxhdGl2ZSB0byB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgICAvLyBjb250YWluZXIuIElmIG5vdCwgcHV0IHRoZSBldmVudCBpbiB0aGUgbWlkZGxlIG9mIHRoZSBjb250YWluZXIuXG4gICAgICAgIGxldCBvZmZzZXRCYXNlID0gMTtcbiAgICAgICAgaWYgKHBpeGVsT2Zmc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIG9mZnNldEJhc2UgPSAwLjU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkVGltZWxpbmUoaW5pdGlhbEV2ZW50LCBwaXhlbE9mZnNldCwgb2Zmc2V0QmFzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogKHJlKS1sb2FkIHRoZSBldmVudCB0aW1lbGluZSwgYW5kIGluaXRpYWxpc2UgdGhlIHNjcm9sbCBzdGF0ZSwgY2VudGVyZWRcbiAgICAgKiBhcm91bmQgdGhlIGdpdmVuIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmc/fSAgZXZlbnRJZCB0aGUgZXZlbnQgdG8gZm9jdXMgb24uIElmIHVuZGVmaW5lZCwgd2lsbFxuICAgICAqICAgIHNjcm9sbCB0byB0aGUgYm90dG9tIG9mIHRoZSByb29tLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXI/fSBwaXhlbE9mZnNldCAgIG9mZnNldCB0byBwb3NpdGlvbiB0aGUgZ2l2ZW4gZXZlbnQgYXRcbiAgICAgKiAgICAocGl4ZWxzIGZyb20gdGhlIG9mZnNldEJhc2UpLiBJZiBvbWl0dGVkLCBkZWZhdWx0cyB0byAwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXI/fSBvZmZzZXRCYXNlIHRoZSByZWZlcmVuY2UgcG9pbnQgZm9yIHRoZSBwaXhlbE9mZnNldC4gMFxuICAgICAqICAgICBtZWFucyB0aGUgdG9wIG9mIHRoZSBjb250YWluZXIsIDEgbWVhbnMgdGhlIGJvdHRvbSwgYW5kIGZyYWN0aW9uYWxcbiAgICAgKiAgICAgdmFsdWVzIG1lYW4gc29tZXdoZXJlIGluIHRoZSBtaWRkbGUuIElmIG9taXR0ZWQsIGl0IGRlZmF1bHRzIHRvIDAuXG4gICAgICovXG4gICAgcHJpdmF0ZSBsb2FkVGltZWxpbmUoZXZlbnRJZD86IHN0cmluZywgcGl4ZWxPZmZzZXQ/OiBudW1iZXIsIG9mZnNldEJhc2U/OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy50aW1lbGluZVdpbmRvdyA9IG5ldyBUaW1lbGluZVdpbmRvdyhcbiAgICAgICAgICAgIE1hdHJpeENsaWVudFBlZy5nZXQoKSwgdGhpcy5wcm9wcy50aW1lbGluZVNldCxcbiAgICAgICAgICAgIHsgd2luZG93TGltaXQ6IHRoaXMucHJvcHMudGltZWxpbmVDYXAgfSk7XG5cbiAgICAgICAgY29uc3Qgb25Mb2FkZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy51bm1vdW50ZWQpIHJldHVybjtcblxuICAgICAgICAgICAgLy8gY2xlYXIgdGhlIHRpbWVsaW5lIG1pbi1oZWlnaHQgd2hlblxuICAgICAgICAgICAgLy8gKHJlKWxvYWRpbmcgdGhlIHRpbWVsaW5lXG4gICAgICAgICAgICBpZiAodGhpcy5tZXNzYWdlUGFuZWwuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZVBhbmVsLmN1cnJlbnQub25UaW1lbGluZVJlc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlbG9hZEV2ZW50cygpO1xuXG4gICAgICAgICAgICAvLyBJZiB3ZSBzd2l0Y2hlZCBhd2F5IGZyb20gdGhlIHJvb20gd2hpbGUgdGhlcmUgd2VyZSBwZW5kaW5nXG4gICAgICAgICAgICAvLyBvdXRnb2luZyBldmVudHMsIHRoZSByZWFkLW1hcmtlciB3aWxsIGJlIGJlZm9yZSB0aG9zZSBldmVudHMuXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHNraXAgb3ZlciBhbnkgd2hpY2ggaGF2ZSBzdWJzZXF1ZW50bHkgYmVlbiBzZW50LlxuICAgICAgICAgICAgdGhpcy5hZHZhbmNlUmVhZE1hcmtlclBhc3RNeUV2ZW50cygpO1xuXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBjYW5CYWNrUGFnaW5hdGU6IHRoaXMudGltZWxpbmVXaW5kb3cuY2FuUGFnaW5hdGUoRXZlbnRUaW1lbGluZS5CQUNLV0FSRFMpLFxuICAgICAgICAgICAgICAgIGNhbkZvcndhcmRQYWdpbmF0ZTogdGhpcy50aW1lbGluZVdpbmRvdy5jYW5QYWdpbmF0ZShFdmVudFRpbWVsaW5lLkZPUldBUkRTKSxcbiAgICAgICAgICAgICAgICB0aW1lbGluZUxvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpc2UgdGhlIHNjcm9sbCBzdGF0ZSBvZiB0aGUgbWVzc2FnZSBwYW5lbFxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5tZXNzYWdlUGFuZWwuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHNob3VsZG4ndCBoYXBwZW4gLSB3ZSBrbm93IHdlJ3JlIG1vdW50ZWQgYmVjYXVzZVxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSdyZSBpbiBhIHNldFN0YXRlIGNhbGxiYWNrLCBhbmQgd2Uga25vd1xuICAgICAgICAgICAgICAgICAgICAvLyB0aW1lbGluZUxvYWRpbmcgaXMgbm93IGZhbHNlLCBzbyByZW5kZXIoKSBzaG91bGQgaGF2ZVxuICAgICAgICAgICAgICAgICAgICAvLyBtb3VudGVkIHRoZSBtZXNzYWdlIHBhbmVsLlxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFwiY2FuJ3QgaW5pdGlhbGlzZSBzY3JvbGwgc3RhdGUgYmVjYXVzZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWVzc2FnZVBhbmVsIGRpZG4ndCBsb2FkXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZVBhbmVsLmN1cnJlbnQuc2Nyb2xsVG9FdmVudChldmVudElkLCBwaXhlbE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldEJhc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZVBhbmVsLmN1cnJlbnQuc2Nyb2xsVG9Cb3R0b20oKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5zZW5kUmVhZFJlY2VpcHRPbkxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kUmVhZFJlY2VpcHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBvbkVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy51bm1vdW50ZWQpIHJldHVybjtcblxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHRpbWVsaW5lTG9hZGluZzogZmFsc2UgfSk7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgYEVycm9yIGxvYWRpbmcgdGltZWxpbmUgcGFuZWwgYXQgJHtldmVudElkfTogJHtlcnJvcn1gLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgbGV0IG9uRmluaXNoZWQ7XG5cbiAgICAgICAgICAgIC8vIGlmIHdlIHdlcmUgZ2l2ZW4gYW4gZXZlbnQgSUQsIHRoZW4gd2hlbiB0aGUgdXNlciBjbG9zZXMgdGhlXG4gICAgICAgICAgICAvLyBkaWFsb2csIGxldCdzIGp1bXAgdG8gdGhlIGVuZCBvZiB0aGUgdGltZWxpbmUuIElmIHdlIHdlcmVuJ3QsXG4gICAgICAgICAgICAvLyBzb21ldGhpbmcgaGFzIGdvbmUgYmFkbHkgd3JvbmcgYW5kIHJhdGhlciB0aGFuIGNhdXNpbmcgYSBsb29wIG9mXG4gICAgICAgICAgICAvLyB1bmRpc21pc3NhYmxlIGRpYWxvZ3MsIGxldCdzIGp1c3QgZ2l2ZSB1cC5cbiAgICAgICAgICAgIGlmIChldmVudElkKSB7XG4gICAgICAgICAgICAgICAgb25GaW5pc2hlZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ28gdmlhIHRoZSBkaXNwYXRjaGVyIHNvIHRoYXQgdGhlIFVSTCBpcyB1cGRhdGVkXG4gICAgICAgICAgICAgICAgICAgIGRpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IEFjdGlvbi5WaWV3Um9vbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb21faWQ6IHRoaXMucHJvcHMudGltZWxpbmVTZXQucm9vbS5yb29tSWQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbWVzc2FnZTtcbiAgICAgICAgICAgIGlmIChlcnJvci5lcnJjb2RlID09ICdNX0ZPUkJJRERFTicpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gX3QoXG4gICAgICAgICAgICAgICAgICAgIFwiVHJpZWQgdG8gbG9hZCBhIHNwZWNpZmljIHBvaW50IGluIHRoaXMgcm9vbSdzIHRpbWVsaW5lLCBidXQgeW91IFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJkbyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIHZpZXcgdGhlIG1lc3NhZ2UgaW4gcXVlc3Rpb24uXCIsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IF90KFxuICAgICAgICAgICAgICAgICAgICBcIlRyaWVkIHRvIGxvYWQgYSBzcGVjaWZpYyBwb2ludCBpbiB0aGlzIHJvb20ncyB0aW1lbGluZSwgYnV0IHdhcyBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwidW5hYmxlIHRvIGZpbmQgaXQuXCIsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE1vZGFsLmNyZWF0ZVRyYWNrZWREaWFsb2coJ0ZhaWxlZCB0byBsb2FkIHRpbWVsaW5lIHBvc2l0aW9uJywgJycsIEVycm9yRGlhbG9nLCB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IF90KFwiRmFpbGVkIHRvIGxvYWQgdGltZWxpbmUgcG9zaXRpb25cIiksXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgb25GaW5pc2hlZDogb25GaW5pc2hlZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGlmIHdlIGFscmVhZHkgaGF2ZSB0aGUgZXZlbnQgaW4gcXVlc3Rpb24sIFRpbWVsaW5lV2luZG93LmxvYWRcbiAgICAgICAgLy8gcmV0dXJucyBhIHJlc29sdmVkIHByb21pc2UuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEluIHRoaXMgc2l0dWF0aW9uLCB3ZSBkb24ndCByZWFsbHkgd2FudCB0byBkZWZlciB0aGUgdXBkYXRlIG9mIHRoZVxuICAgICAgICAvLyBzdGF0ZSB0byB0aGUgbmV4dCBldmVudCBsb29wLCBiZWNhdXNlIGl0IG1ha2VzIHJvb20tc3dpdGNoaW5nIGZlZWxcbiAgICAgICAgLy8gcXVpdGUgc2xvdy4gU28gd2UgZGV0ZWN0IHRoYXQgc2l0dWF0aW9uIGFuZCBzaG9ydGN1dCBzdHJhaWdodCB0b1xuICAgICAgICAvLyBjYWxsaW5nIF9yZWxvYWRFdmVudHMgYW5kIHVwZGF0aW5nIHRoZSBzdGF0ZS5cblxuICAgICAgICBjb25zdCB0aW1lbGluZSA9IHRoaXMucHJvcHMudGltZWxpbmVTZXQuZ2V0VGltZWxpbmVGb3JFdmVudChldmVudElkKTtcbiAgICAgICAgaWYgKHRpbWVsaW5lKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgaG90LXBhdGggb3B0aW1pemF0aW9uIGJ5IHNraXBwaW5nIGEgcHJvbWlzZSB0aWNrXG4gICAgICAgICAgICAvLyBieSByZXBlYXRpbmcgYSBuby1vcCBzeW5jIGJyYW5jaCBpbiBUaW1lbGluZVNldC5nZXRUaW1lbGluZUZvckV2ZW50ICYgTWF0cml4Q2xpZW50LmdldEV2ZW50VGltZWxpbmVcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmVXaW5kb3cubG9hZChldmVudElkLCBJTklUSUFMX1NJWkUpOyAvLyBpbiB0aGlzIGJyYW5jaCB0aGlzIG1ldGhvZCB3aWxsIGhhcHBlbiBpbiBzeW5jIHRpbWVcbiAgICAgICAgICAgIG9uTG9hZGVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwcm9tID0gdGhpcy50aW1lbGluZVdpbmRvdy5sb2FkKGV2ZW50SWQsIElOSVRJQUxfU0laRSk7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBldmVudHM6IFtdLFxuICAgICAgICAgICAgICAgIGxpdmVFdmVudHM6IFtdLFxuICAgICAgICAgICAgICAgIGNhbkJhY2tQYWdpbmF0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2FuRm9yd2FyZFBhZ2luYXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0aW1lbGluZUxvYWRpbmc6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb20udGhlbihvbkxvYWRlZCwgb25FcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgdGhlIGNvbXBsZXRpb24gb2YgYSB0aW1lbGluZSBsb2FkIG9yIGxvY2FsRWNob1VwZGF0ZSwgYnlcbiAgICAvLyByZWxvYWRpbmcgdGhlIGV2ZW50cyBmcm9tIHRoZSB0aW1lbGluZXdpbmRvdyBhbmQgcGVuZGluZyBldmVudCBsaXN0IGludG9cbiAgICAvLyB0aGUgc3RhdGUuXG4gICAgcHJpdmF0ZSByZWxvYWRFdmVudHMoKTogdm9pZCB7XG4gICAgICAgIC8vIHdlIG1pZ2h0IGhhdmUgc3dpdGNoZWQgcm9vbXMgc2luY2UgdGhlIGxvYWQgc3RhcnRlZCAtIGp1c3QgYmluXG4gICAgICAgIC8vIHRoZSByZXN1bHRzIGlmIHNvLlxuICAgICAgICBpZiAodGhpcy51bm1vdW50ZWQpIHJldHVybjtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHRoaXMuZ2V0RXZlbnRzKCkpO1xuICAgIH1cblxuICAgIC8vIEZvcmNlIHJlZnJlc2ggdGhlIHRpbWVsaW5lIGJlZm9yZSB0aHJlYWRzIHN1cHBvcnQgcGVuZGluZyBldmVudHNcbiAgICBwdWJsaWMgcmVmcmVzaFRpbWVsaW5lKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRUaW1lbGluZSgpO1xuICAgICAgICB0aGlzLnJlbG9hZEV2ZW50cygpO1xuICAgIH1cblxuICAgIC8vIGdldCB0aGUgbGlzdCBvZiBldmVudHMgZnJvbSB0aGUgdGltZWxpbmUgd2luZG93IGFuZCB0aGUgcGVuZGluZyBldmVudCBsaXN0XG4gICAgcHJpdmF0ZSBnZXRFdmVudHMoKTogUGljazxJU3RhdGUsIFwiZXZlbnRzXCIgfCBcImxpdmVFdmVudHNcIiB8IFwiZmlyc3RWaXNpYmxlRXZlbnRJbmRleFwiPiB7XG4gICAgICAgIGNvbnN0IGV2ZW50czogTWF0cml4RXZlbnRbXSA9IHRoaXMudGltZWxpbmVXaW5kb3cuZ2V0RXZlbnRzKCk7XG5cbiAgICAgICAgLy8gYGFycmF5RmFzdENsb25lYCBwZXJmb3JtcyBhIHNoYWxsb3cgY29weSBvZiB0aGUgYXJyYXlcbiAgICAgICAgLy8gd2Ugd2FudCB0aGUgbGFzdCBldmVudCB0byBiZSBkZWNyeXB0ZWQgZmlyc3QgYnV0IGRpc3BsYXllZCBsYXN0XG4gICAgICAgIC8vIGByZXZlcnNlYCBpcyBkZXN0cnVjdGl2ZSBhbmQgdW5mb3J0dW5hdGVseSBtdXRhdGVzIHRoZSBcImV2ZW50c1wiIGFycmF5XG4gICAgICAgIGFycmF5RmFzdENsb25lKGV2ZW50cylcbiAgICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAgIC5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGllbnQgPSBNYXRyaXhDbGllbnRQZWcuZ2V0KCk7XG4gICAgICAgICAgICAgICAgY2xpZW50LmRlY3J5cHRFdmVudElmTmVlZGVkKGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGZpcnN0VmlzaWJsZUV2ZW50SW5kZXggPSB0aGlzLmNoZWNrRm9yUHJlSm9pblVJU0koZXZlbnRzKTtcblxuICAgICAgICAvLyBIb2xkIG9udG8gdGhlIGxpdmUgZXZlbnRzIHNlcGFyYXRlbHkuIFRoZSByZWFkIHJlY2VpcHQgYW5kIHJlYWQgbWFya2VyXG4gICAgICAgIC8vIHNob3VsZCB1c2UgdGhpcyBsaXN0LCBzbyB0aGF0IHRoZXkgZG9uJ3QgYWR2YW5jZSBpbnRvIHBlbmRpbmcgZXZlbnRzLlxuICAgICAgICBjb25zdCBsaXZlRXZlbnRzID0gWy4uLmV2ZW50c107XG5cbiAgICAgICAgLy8gaWYgd2UncmUgYXQgdGhlIGVuZCBvZiB0aGUgbGl2ZSB0aW1lbGluZSwgYXBwZW5kIHRoZSBwZW5kaW5nIGV2ZW50c1xuICAgICAgICBpZiAoIXRoaXMudGltZWxpbmVXaW5kb3cuY2FuUGFnaW5hdGUoRXZlbnRUaW1lbGluZS5GT1JXQVJEUykpIHtcbiAgICAgICAgICAgIGV2ZW50cy5wdXNoKC4uLnRoaXMucHJvcHMudGltZWxpbmVTZXQuZ2V0UGVuZGluZ0V2ZW50cygpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBldmVudHMsXG4gICAgICAgICAgICBsaXZlRXZlbnRzLFxuICAgICAgICAgICAgZmlyc3RWaXNpYmxlRXZlbnRJbmRleCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBmb3IgdW5kZWNyeXB0YWJsZSBtZXNzYWdlcyB0aGF0IHdlcmUgc2VudCB3aGlsZSB0aGUgdXNlciB3YXMgbm90IGluXG4gICAgICogdGhlIHJvb20uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5PE1hdHJpeEV2ZW50Pn0gZXZlbnRzIFRoZSB0aW1lbGluZSBldmVudHMgdG8gY2hlY2tcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGluZGV4IHdpdGhpbiBgZXZlbnRzYCBvZiB0aGUgZXZlbnQgYWZ0ZXIgdGhlIG1vc3QgcmVjZW50XG4gICAgICogdW5kZWNyeXB0YWJsZSBldmVudCB0aGF0IHdhcyBzZW50IHdoaWxlIHRoZSB1c2VyIHdhcyBub3QgaW4gdGhlIHJvb20uICBJZiBub1xuICAgICAqIHN1Y2ggZXZlbnRzIHdlcmUgZm91bmQsIHRoZW4gaXQgcmV0dXJucyAwLlxuICAgICAqL1xuICAgIHByaXZhdGUgY2hlY2tGb3JQcmVKb2luVUlTSShldmVudHM6IE1hdHJpeEV2ZW50W10pOiBudW1iZXIge1xuICAgICAgICBjb25zdCByb29tID0gdGhpcy5wcm9wcy50aW1lbGluZVNldC5yb29tO1xuXG4gICAgICAgIGlmIChldmVudHMubGVuZ3RoID09PSAwIHx8ICFyb29tIHx8XG4gICAgICAgICAgICAhTWF0cml4Q2xpZW50UGVnLmdldCgpLmlzUm9vbUVuY3J5cHRlZChyb29tLnJvb21JZCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdXNlcklkID0gTWF0cml4Q2xpZW50UGVnLmdldCgpLmNyZWRlbnRpYWxzLnVzZXJJZDtcblxuICAgICAgICAvLyBnZXQgdGhlIHVzZXIncyBtZW1iZXJzaGlwIGF0IHRoZSBsYXN0IGV2ZW50IGJ5IGdldHRpbmcgdGhlIHRpbWVsaW5lXG4gICAgICAgIC8vIHRoYXQgdGhlIGV2ZW50IGJlbG9uZ3MgdG8sIGFuZCB0cmF2ZXJzaW5nIHRoZSB0aW1lbGluZSBsb29raW5nIGZvclxuICAgICAgICAvLyB0aGF0IGV2ZW50LCB3aGlsZSBrZWVwaW5nIHRyYWNrIG9mIHRoZSB1c2VyJ3MgbWVtYmVyc2hpcFxuICAgICAgICBsZXQgaTtcbiAgICAgICAgbGV0IHVzZXJNZW1iZXJzaGlwID0gXCJsZWF2ZVwiO1xuICAgICAgICBmb3IgKGkgPSBldmVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVsaW5lID0gcm9vbS5nZXRUaW1lbGluZUZvckV2ZW50KGV2ZW50c1tpXS5nZXRJZCgpKTtcbiAgICAgICAgICAgIGlmICghdGltZWxpbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBTb21laG93LCBpdCBzZWVtcyB0byBiZSBwb3NzaWJsZSBmb3IgbGl2ZSBldmVudHMgdG8gbm90IGhhdmVcbiAgICAgICAgICAgICAgICAvLyBhIHRpbWVsaW5lLCBldmVuIHRob3VnaCB0aGF0IHNob3VsZCBub3QgaGFwcGVuLiA6KFxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZWN0b3ItaW0vZWxlbWVudC13ZWIvaXNzdWVzLzEyMTIwXG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAgICAgICAgIGBFdmVudCAke2V2ZW50c1tpXS5nZXRJZCgpfSBpbiByb29tICR7cm9vbS5yb29tSWR9IGlzIGxpdmUsIGAgK1xuICAgICAgICAgICAgICAgICAgICBgYnV0IGl0IGRvZXMgbm90IGhhdmUgYSB0aW1lbGluZWAsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVzZXJNZW1iZXJzaGlwRXZlbnQgPVxuICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5nZXRTdGF0ZShFdmVudFRpbWVsaW5lLkZPUldBUkRTKS5nZXRNZW1iZXIodXNlcklkKTtcbiAgICAgICAgICAgIHVzZXJNZW1iZXJzaGlwID0gdXNlck1lbWJlcnNoaXBFdmVudCA/IHVzZXJNZW1iZXJzaGlwRXZlbnQubWVtYmVyc2hpcCA6IFwibGVhdmVcIjtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVsaW5lRXZlbnRzID0gdGltZWxpbmUuZ2V0RXZlbnRzKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gdGltZWxpbmVFdmVudHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IHRpbWVsaW5lRXZlbnRzW2pdO1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5nZXRJZCgpID09PSBldmVudHNbaV0uZ2V0SWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmdldFN0YXRlS2V5KCkgPT09IHVzZXJJZFxuICAgICAgICAgICAgICAgICAgICAmJiBldmVudC5nZXRUeXBlKCkgPT09IFwibS5yb29tLm1lbWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZDb250ZW50ID0gZXZlbnQuZ2V0UHJldkNvbnRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdXNlck1lbWJlcnNoaXAgPSBwcmV2Q29udGVudC5tZW1iZXJzaGlwIHx8IFwibGVhdmVcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vdyBnbyB0aHJvdWdoIHRoZSByZXN0IG9mIHRoZSBldmVudHMgYW5kIGZpbmQgdGhlIGZpcnN0IHVuZGVjcnlwdGFibGVcbiAgICAgICAgLy8gb25lIHRoYXQgd2FzIHNlbnQgd2hlbiB0aGUgdXNlciB3YXNuJ3QgaW4gdGhlIHJvb21cbiAgICAgICAgZm9yICg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGV2ZW50c1tpXTtcbiAgICAgICAgICAgIGlmIChldmVudC5nZXRTdGF0ZUtleSgpID09PSB1c2VySWRcbiAgICAgICAgICAgICAgICAmJiBldmVudC5nZXRUeXBlKCkgPT09IFwibS5yb29tLm1lbWJlclwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkNvbnRlbnQgPSBldmVudC5nZXRQcmV2Q29udGVudCgpO1xuICAgICAgICAgICAgICAgIHVzZXJNZW1iZXJzaGlwID0gcHJldkNvbnRlbnQubWVtYmVyc2hpcCB8fCBcImxlYXZlXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVzZXJNZW1iZXJzaGlwID09PSBcImxlYXZlXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgKGV2ZW50LmlzRGVjcnlwdGlvbkZhaWx1cmUoKSB8fCBldmVudC5pc0JlaW5nRGVjcnlwdGVkKCkpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVhY2hlZCBhbiB1bmRlY3J5cHRhYmxlIG1lc3NhZ2Ugd2hlbiB0aGUgdXNlciB3YXNuJ3QgaW5cbiAgICAgICAgICAgICAgICAvLyB0aGUgcm9vbSAtLSBkb24ndCB0cnkgdG8gbG9hZCBhbnkgbW9yZVxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IGZvciBub3csIHdlIGFzc3VtZSB0aGF0IGV2ZW50cyB0aGF0IGFyZSBiZWluZyBkZWNyeXB0ZWQgYXJlXG4gICAgICAgICAgICAgICAgLy8gbm90IGRlY3J5cHRhYmxlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHByaXZhdGUgaW5kZXhGb3JFdmVudElkKGV2SWQ6IHN0cmluZyk6IG51bWJlciB8IG51bGwge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhdGUuZXZlbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoZXZJZCA9PSB0aGlzLnN0YXRlLmV2ZW50c1tpXS5nZXRJZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRMYXN0RGlzcGxheWVkRXZlbnRJbmRleChvcHRzOiBJRXZlbnRJbmRleE9wdHMgPSB7fSk6IG51bWJlciB8IG51bGwge1xuICAgICAgICBjb25zdCBpZ25vcmVPd24gPSBvcHRzLmlnbm9yZU93biB8fCBmYWxzZTtcbiAgICAgICAgY29uc3QgYWxsb3dQYXJ0aWFsID0gb3B0cy5hbGxvd1BhcnRpYWwgfHwgZmFsc2U7XG5cbiAgICAgICAgY29uc3QgbWVzc2FnZVBhbmVsID0gdGhpcy5tZXNzYWdlUGFuZWwuY3VycmVudDtcbiAgICAgICAgaWYgKCFtZXNzYWdlUGFuZWwpIHJldHVybiBudWxsO1xuXG4gICAgICAgIGNvbnN0IG1lc3NhZ2VQYW5lbE5vZGUgPSBSZWFjdERPTS5maW5kRE9NTm9kZShtZXNzYWdlUGFuZWwpIGFzIEhUTUxFbGVtZW50O1xuICAgICAgICBpZiAoIW1lc3NhZ2VQYW5lbE5vZGUpIHJldHVybiBudWxsOyAvLyBzb21ldGltZXMgdGhpcyBoYXBwZW5zIGZvciBmcmVzaCByb29tcy9wb3N0LXN5bmNcbiAgICAgICAgY29uc3Qgd3JhcHBlclJlY3QgPSBtZXNzYWdlUGFuZWxOb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCBteVVzZXJJZCA9IE1hdHJpeENsaWVudFBlZy5nZXQoKS5jcmVkZW50aWFscy51c2VySWQ7XG5cbiAgICAgICAgY29uc3QgaXNOb2RlSW5WaWV3ID0gKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYm91bmRpbmdSZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBpZiAoKGFsbG93UGFydGlhbCAmJiBib3VuZGluZ1JlY3QudG9wIDwgd3JhcHBlclJlY3QuYm90dG9tKSB8fFxuICAgICAgICAgICAgICAgICAgICAoIWFsbG93UGFydGlhbCAmJiBib3VuZGluZ1JlY3QuYm90dG9tIDwgd3JhcHBlclJlY3QuYm90dG9tKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gV2Uga2VlcCB0cmFjayBvZiBob3cgbWFueSBvZiB0aGUgYWRqYWNlbnQgZXZlbnRzIGRpZG4ndCBoYXZlIGEgdGlsZVxuICAgICAgICAvLyBidXQgc2hvdWxkIGhhdmUgdGhlIHJlYWQgcmVjZWlwdCBtb3ZlZCBwYXN0IHRoZW0sIHNvXG4gICAgICAgIC8vIHdlIGNhbiBpbmNsdWRlIHRob3NlIG9uY2Ugd2UgZmluZCB0aGUgbGFzdCBkaXNwbGF5ZWQgKHZpc2libGUpIGV2ZW50LlxuICAgICAgICAvLyBUaGUgY291bnRlciBpcyBub3Qgc3RhcnRlZCBmb3IgZXZlbnRzIHdlIGRvbid0IHdhbnRcbiAgICAgICAgLy8gdG8gc2VuZCBhIHJlYWQgcmVjZWlwdCBmb3IgKG91ciBvd24gZXZlbnRzLCBsb2NhbCBlY2hvcykuXG4gICAgICAgIGxldCBhZGphY2VudEludmlzaWJsZUV2ZW50Q291bnQgPSAwO1xuICAgICAgICAvLyBVc2UgYGxpdmVFdmVudHNgIGhlcmUgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRoZSByZWFkIG1hcmtlciBvciByZWFkXG4gICAgICAgIC8vIHJlY2VpcHQgdG8gYWR2YW5jZSBpbnRvIHBlbmRpbmcgZXZlbnRzLlxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZS5saXZlRXZlbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBjb25zdCBldiA9IHRoaXMuc3RhdGUubGl2ZUV2ZW50c1tpXTtcblxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG1lc3NhZ2VQYW5lbC5nZXROb2RlRm9yRXZlbnRJZChldi5nZXRJZCgpKTtcbiAgICAgICAgICAgIGNvbnN0IGlzSW5WaWV3ID0gaXNOb2RlSW5WaWV3KG5vZGUpO1xuXG4gICAgICAgICAgICAvLyB3aGVuIHdlJ3ZlIHJlYWNoZWQgdGhlIGZpcnN0IHZpc2libGUgZXZlbnQsIGFuZCB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgIC8vIGV2ZW50cyB3ZXJlIGFsbCBpbnZpc2libGUgKHdpdGggdGhlIGZpcnN0IG9uZSBub3QgYmVpbmcgaWdub3JlZCksXG4gICAgICAgICAgICAvLyByZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpbnZpc2libGUgZXZlbnQuXG4gICAgICAgICAgICBpZiAoaXNJblZpZXcgJiYgYWRqYWNlbnRJbnZpc2libGVFdmVudENvdW50ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgKyBhZGphY2VudEludmlzaWJsZUV2ZW50Q291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZSAmJiAhaXNJblZpZXcpIHtcbiAgICAgICAgICAgICAgICAvLyBoYXMgbm9kZSBidXQgbm90IGluIHZpZXcsIHNvIHJlc2V0IGFkamFjZW50IGludmlzaWJsZSBldmVudHNcbiAgICAgICAgICAgICAgICBhZGphY2VudEludmlzaWJsZUV2ZW50Q291bnQgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBzaG91bGRJZ25vcmUgPSAhIWV2LnN0YXR1cyB8fCAvLyBsb2NhbCBlY2hvXG4gICAgICAgICAgICAgICAgKGlnbm9yZU93biAmJiBldi5nZXRTZW5kZXIoKSA9PT0gbXlVc2VySWQpOyAvLyBvd24gbWVzc2FnZVxuICAgICAgICAgICAgY29uc3QgaXNXaXRob3V0VGlsZSA9ICFoYXZlVGlsZUZvckV2ZW50KGV2LCB0aGlzLmNvbnRleHQ/LnNob3dIaWRkZW5FdmVudHNJblRpbWVsaW5lKSB8fFxuICAgICAgICAgICAgICAgIHNob3VsZEhpZGVFdmVudChldiwgdGhpcy5jb250ZXh0KTtcblxuICAgICAgICAgICAgaWYgKGlzV2l0aG91dFRpbGUgfHwgIW5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBzdGFydCBjb3VudGluZyBpZiB0aGUgZXZlbnQgc2hvdWxkIGJlIGlnbm9yZWQsXG4gICAgICAgICAgICAgICAgLy8gYnV0IGNvbnRpbnVlIGNvdW50aW5nIGlmIHdlIHdlcmUgYWxyZWFkeSBzbyB0aGUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgLy8gdG8gdGhlIHByZXZpb3VzIGludmlzYmxlIGV2ZW50IHRoYXQgZGlkbid0IG5lZWQgdG8gYmUgaWdub3JlZFxuICAgICAgICAgICAgICAgIC8vIGRvZXNuJ3QgZ2V0IG1lc3NlZCB1cFxuICAgICAgICAgICAgICAgIGlmICghc2hvdWxkSWdub3JlIHx8IChzaG91bGRJZ25vcmUgJiYgYWRqYWNlbnRJbnZpc2libGVFdmVudENvdW50ICE9PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICArK2FkamFjZW50SW52aXNpYmxlRXZlbnRDb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaG91bGRJZ25vcmUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzSW5WaWV3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlkIG9mIHRoZSBldmVudCBjb3JyZXNwb25kaW5nIHRvIG91ciB1c2VyJ3MgbGF0ZXN0IHJlYWQtcmVjZWlwdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlU3ludGhlc2l6ZWQgSWYgdHJ1ZSwgcmV0dXJuIG9ubHkgcmVjZWlwdHMgdGhhdFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZSBiZWVuIHNlbnQgYnkgdGhlIHNlcnZlciwgbm90XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBsaWNpdCBvbmVzIGdlbmVyYXRlZCBieSB0aGUgSlNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNESy5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBldmVudCBJRFxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0Q3VycmVudFJlYWRSZWNlaXB0KGlnbm9yZVN5bnRoZXNpemVkID0gZmFsc2UpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBNYXRyaXhDbGllbnRQZWcuZ2V0KCk7XG4gICAgICAgIC8vIHRoZSBjbGllbnQgY2FuIGJlIG51bGwgb24gbG9nb3V0XG4gICAgICAgIGlmIChjbGllbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBteVVzZXJJZCA9IGNsaWVudC5jcmVkZW50aWFscy51c2VySWQ7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLnRpbWVsaW5lU2V0LnJvb20uZ2V0RXZlbnRSZWFkVXBUbyhteVVzZXJJZCwgaWdub3JlU3ludGhlc2l6ZWQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0UmVhZE1hcmtlcihldmVudElkOiBzdHJpbmcsIGV2ZW50VHM6IG51bWJlciwgaW5oaWJpdFNldFN0YXRlID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgcm9vbUlkID0gdGhpcy5wcm9wcy50aW1lbGluZVNldC5yb29tLnJvb21JZDtcblxuICAgICAgICAvLyBkb24ndCB1cGRhdGUgdGhlIHN0YXRlIChhbmQgY2F1c2UgYSByZS1yZW5kZXIpIGlmIHRoZXJlIGlzXG4gICAgICAgIC8vIG5vIGNoYW5nZSB0byB0aGUgUk0uXG4gICAgICAgIGlmIChldmVudElkID09PSB0aGlzLnN0YXRlLnJlYWRNYXJrZXJFdmVudElkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbiBvcmRlciB0byBsYXRlciBmaWd1cmUgb3V0IGlmIHRoZSByZWFkIG1hcmtlciBpc1xuICAgICAgICAvLyBhYm92ZSBvciBiZWxvdyB0aGUgdmlzaWJsZSB0aW1lbGluZSwgd2Ugc3Rhc2ggdGhlIHRpbWVzdGFtcC5cbiAgICAgICAgVGltZWxpbmVQYW5lbC5yb29tUmVhZE1hcmtlclRzTWFwW3Jvb21JZF0gPSBldmVudFRzO1xuXG4gICAgICAgIGlmIChpbmhpYml0U2V0U3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvIHRoZSBsb2NhbCBlY2hvIG9mIHRoZSBSTVxuICAgICAgICAvLyBydW4gdGhlIHJlbmRlciBjeWNsZSBiZWZvcmUgY2FsbGluZyB0aGUgY2FsbGJhY2ssIHNvIHRoYXRcbiAgICAgICAgLy8gZ2V0UmVhZE1hcmtlclBvc2l0aW9uKCkgcmV0dXJucyB0aGUgcmlnaHQgdGhpbmcuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgcmVhZE1hcmtlckV2ZW50SWQ6IGV2ZW50SWQsXG4gICAgICAgIH0sIHRoaXMucHJvcHMub25SZWFkTWFya2VyVXBkYXRlZCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzaG91bGRQYWdpbmF0ZSgpOiBib29sZWFuIHtcbiAgICAgICAgLy8gZG9uJ3QgdHJ5IHRvIHBhZ2luYXRlIHdoaWxlIGV2ZW50cyBpbiB0aGUgdGltZWxpbmUgYXJlXG4gICAgICAgIC8vIHN0aWxsIGJlaW5nIGRlY3J5cHRlZC4gV2UgZG9uJ3QgcmVuZGVyIGV2ZW50cyB3aGlsZSB0aGV5J3JlXG4gICAgICAgIC8vIGJlaW5nIGRlY3J5cHRlZCwgc28gdGhleSBkb24ndCB0YWtlIHVwIHNwYWNlIGluIHRoZSB0aW1lbGluZS5cbiAgICAgICAgLy8gVGhpcyBtZWFucyB3ZSBjYW4gcHVsbCBxdWl0ZSBhIGxvdCBvZiBldmVudHMgaW50byB0aGUgdGltZWxpbmVcbiAgICAgICAgLy8gYW5kIGVuZCB1cCB0cnlpbmcgdG8gcmVuZGVyIGEgbG90IG9mIGV2ZW50cy5cbiAgICAgICAgcmV0dXJuICF0aGlzLnN0YXRlLmV2ZW50cy5zb21lKChlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZS5pc0JlaW5nRGVjcnlwdGVkKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0UmVsYXRpb25zRm9yRXZlbnQgPSAoXG4gICAgICAgIGV2ZW50SWQ6IHN0cmluZyxcbiAgICAgICAgcmVsYXRpb25UeXBlOiBSZWxhdGlvblR5cGUsXG4gICAgICAgIGV2ZW50VHlwZTogRXZlbnRUeXBlIHwgc3RyaW5nLFxuICAgICkgPT4gdGhpcy5wcm9wcy50aW1lbGluZVNldC5nZXRSZWxhdGlvbnNGb3JFdmVudChldmVudElkLCByZWxhdGlvblR5cGUsIGV2ZW50VHlwZSk7XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8vIGp1c3Qgc2hvdyBhIHNwaW5uZXIgd2hpbGUgdGhlIHRpbWVsaW5lIGxvYWRzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBwdXQgaXQgaW4gYSBkaXYgb2YgdGhlIHJpZ2h0IGNsYXNzIChteF9Sb29tVmlld19tZXNzYWdlUGFuZWwpIHNvXG4gICAgICAgIC8vIHRoYXQgdGhlIG9yZGVyIGluIHRoZSByb29tdmlldyBmbGV4Ym94IGlzIGNvcnJlY3QsIGFuZFxuICAgICAgICAvLyBteF9Sb29tVmlld19tZXNzYWdlTGlzdFdyYXBwZXIgdG8gcG9zaXRpb24gdGhlIGlubmVyIGRpdiBpbiB0aGVcbiAgICAgICAgLy8gcmlnaHQgcGxhY2UuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE5vdGUgdGhhdCB0aGUgY2xpY2stb24tc2VhcmNoLXJlc3VsdCBmdW5jdGlvbmFsaXR5IHJlbGllcyBvbiB0aGVcbiAgICAgICAgLy8gZmFjdCB0aGF0IHRoZSBtZXNzYWdlUGFuZWwgaXMgaGlkZGVuIHdoaWxlIHRoZSB0aW1lbGluZSByZWxvYWRzLFxuICAgICAgICAvLyBidXQgdGhhdCB0aGUgUm9vbUhlYWRlciAoY29tcGxldGUgd2l0aCBzZWFyY2ggdGVybSkgY29udGludWVzIHRvXG4gICAgICAgIC8vIGV4aXN0LlxuICAgICAgICBpZiAodGhpcy5zdGF0ZS50aW1lbGluZUxvYWRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJteF9Sb29tVmlld19tZXNzYWdlUGFuZWxTcGlubmVyXCI+XG4gICAgICAgICAgICAgICAgICAgIDxTcGlubmVyIC8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZXZlbnRzLmxlbmd0aCA9PSAwICYmICF0aGlzLnN0YXRlLmNhbkJhY2tQYWdpbmF0ZSAmJiB0aGlzLnByb3BzLmVtcHR5KSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXt0aGlzLnByb3BzLmNsYXNzTmFtZSArIFwiIG14X1Jvb21WaWV3X21lc3NhZ2VMaXN0V3JhcHBlclwifT5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJteF9Sb29tVmlld19lbXB0eVwiPnsgdGhpcy5wcm9wcy5lbXB0eSB9PC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2l2ZSB0aGUgbWVzc2FnZXBhbmVsIGEgc3RpY2t5Ym90dG9tIGlmIHdlJ3JlIGF0IHRoZSBlbmQgb2YgdGhlXG4gICAgICAgIC8vIGxpdmUgdGltZWxpbmUsIHNvIHRoYXQgdGhlIGFycml2YWwgb2YgbmV3IGV2ZW50cyB0cmlnZ2VycyBhXG4gICAgICAgIC8vIHNjcm9sbC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgc3RpY2t5Qm90dG9tIGlzICpmYWxzZSogaWYgd2UgY2FuIHBhZ2luYXRlXG4gICAgICAgIC8vIGZvcndhcmRzLCBvdGhlcndpc2UgaWYgc29tZWJvZHkgaGl0cyB0aGUgYm90dG9tIG9mIHRoZSBsb2FkZWRcbiAgICAgICAgLy8gZXZlbnRzIHdoZW4gdmlld2luZyBoaXN0b3JpY2FsIG1lc3NhZ2VzLCB3ZSBnZXQgc3R1Y2sgaW4gYSBsb29wXG4gICAgICAgIC8vIG9mIHBhZ2luYXRpbmcgb3VyIHdheSB0aHJvdWdoIHRoZSBlbnRpcmUgaGlzdG9yeSBvZiB0aGUgcm9vbS5cbiAgICAgICAgY29uc3Qgc3RpY2t5Qm90dG9tID0gIXRoaXMudGltZWxpbmVXaW5kb3cuY2FuUGFnaW5hdGUoRXZlbnRUaW1lbGluZS5GT1JXQVJEUyk7XG5cbiAgICAgICAgLy8gSWYgdGhlIHN0YXRlIGlzIFBSRVBBUkVEIG9yIENBVENIVVAsIHdlJ3JlIHN0aWxsIHdhaXRpbmcgZm9yIHRoZSBqcy1zZGsgdG8gc3luYyB3aXRoXG4gICAgICAgIC8vIHRoZSBIUyBhbmQgZmV0Y2ggdGhlIGxhdGVzdCBldmVudHMsIHNvIHdlIGFyZSBlZmZlY3RpdmVseSBmb3J3YXJkIHBhZ2luYXRpbmcuXG4gICAgICAgIGNvbnN0IGZvcndhcmRQYWdpbmF0aW5nID0gKFxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5mb3J3YXJkUGFnaW5hdGluZyB8fFxuICAgICAgICAgICAgWydQUkVQQVJFRCcsICdDQVRDSFVQJ10uaW5jbHVkZXModGhpcy5zdGF0ZS5jbGllbnRTeW5jU3RhdGUpXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuc3RhdGUuZmlyc3RWaXNpYmxlRXZlbnRJbmRleFxuICAgICAgICAgICAgPyB0aGlzLnN0YXRlLmV2ZW50cy5zbGljZSh0aGlzLnN0YXRlLmZpcnN0VmlzaWJsZUV2ZW50SW5kZXgpXG4gICAgICAgICAgICA6IHRoaXMuc3RhdGUuZXZlbnRzO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPE1lc3NhZ2VQYW5lbFxuICAgICAgICAgICAgICAgIHJlZj17dGhpcy5tZXNzYWdlUGFuZWx9XG4gICAgICAgICAgICAgICAgcm9vbT17dGhpcy5wcm9wcy50aW1lbGluZVNldC5yb29tfVxuICAgICAgICAgICAgICAgIHBlcm1hbGlua0NyZWF0b3I9e3RoaXMucHJvcHMucGVybWFsaW5rQ3JlYXRvcn1cbiAgICAgICAgICAgICAgICBoaWRkZW49e3RoaXMucHJvcHMuaGlkZGVufVxuICAgICAgICAgICAgICAgIGJhY2tQYWdpbmF0aW5nPXt0aGlzLnN0YXRlLmJhY2tQYWdpbmF0aW5nfVxuICAgICAgICAgICAgICAgIGZvcndhcmRQYWdpbmF0aW5nPXtmb3J3YXJkUGFnaW5hdGluZ31cbiAgICAgICAgICAgICAgICBldmVudHM9e2V2ZW50c31cbiAgICAgICAgICAgICAgICBoaWdobGlnaHRlZEV2ZW50SWQ9e3RoaXMucHJvcHMuaGlnaGxpZ2h0ZWRFdmVudElkfVxuICAgICAgICAgICAgICAgIHJlYWRNYXJrZXJFdmVudElkPXt0aGlzLnN0YXRlLnJlYWRNYXJrZXJFdmVudElkfVxuICAgICAgICAgICAgICAgIHJlYWRNYXJrZXJWaXNpYmxlPXt0aGlzLnN0YXRlLnJlYWRNYXJrZXJWaXNpYmxlfVxuICAgICAgICAgICAgICAgIHN1cHByZXNzRmlyc3REYXRlU2VwYXJhdG9yPXt0aGlzLnN0YXRlLmNhbkJhY2tQYWdpbmF0ZX1cbiAgICAgICAgICAgICAgICBzaG93VXJsUHJldmlldz17dGhpcy5wcm9wcy5zaG93VXJsUHJldmlld31cbiAgICAgICAgICAgICAgICBzaG93UmVhZFJlY2VpcHRzPXt0aGlzLnByb3BzLnNob3dSZWFkUmVjZWlwdHN9XG4gICAgICAgICAgICAgICAgb3VyVXNlcklkPXtNYXRyaXhDbGllbnRQZWcuZ2V0KCkuY3JlZGVudGlhbHMudXNlcklkfVxuICAgICAgICAgICAgICAgIHN0aWNreUJvdHRvbT17c3RpY2t5Qm90dG9tfVxuICAgICAgICAgICAgICAgIG9uU2Nyb2xsPXt0aGlzLm9uTWVzc2FnZUxpc3RTY3JvbGx9XG4gICAgICAgICAgICAgICAgb25Vc2VyU2Nyb2xsPXt0aGlzLnByb3BzLm9uVXNlclNjcm9sbH1cbiAgICAgICAgICAgICAgICBvbkZpbGxSZXF1ZXN0PXt0aGlzLm9uTWVzc2FnZUxpc3RGaWxsUmVxdWVzdH1cbiAgICAgICAgICAgICAgICBvblVuZmlsbFJlcXVlc3Q9e3RoaXMub25NZXNzYWdlTGlzdFVuZmlsbFJlcXVlc3R9XG4gICAgICAgICAgICAgICAgaXNUd2VsdmVIb3VyPXt0aGlzLmNvbnRleHQ/LnNob3dUd2VsdmVIb3VyVGltZXN0YW1wcyA/PyB0aGlzLnN0YXRlLmlzVHdlbHZlSG91cn1cbiAgICAgICAgICAgICAgICBhbHdheXNTaG93VGltZXN0YW1wcz17XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuYWx3YXlzU2hvd1RpbWVzdGFtcHMgPz9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0Py5hbHdheXNTaG93VGltZXN0YW1wcyA/P1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmFsd2F5c1Nob3dUaW1lc3RhbXBzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17dGhpcy5wcm9wcy5jbGFzc05hbWV9XG4gICAgICAgICAgICAgICAgdGlsZVNoYXBlPXt0aGlzLnByb3BzLnRpbGVTaGFwZX1cbiAgICAgICAgICAgICAgICByZXNpemVOb3RpZmllcj17dGhpcy5wcm9wcy5yZXNpemVOb3RpZmllcn1cbiAgICAgICAgICAgICAgICBnZXRSZWxhdGlvbnNGb3JFdmVudD17dGhpcy5nZXRSZWxhdGlvbnNGb3JFdmVudH1cbiAgICAgICAgICAgICAgICBlZGl0U3RhdGU9e3RoaXMucHJvcHMuZWRpdFN0YXRlfVxuICAgICAgICAgICAgICAgIHNob3dSZWFjdGlvbnM9e3RoaXMucHJvcHMuc2hvd1JlYWN0aW9uc31cbiAgICAgICAgICAgICAgICBsYXlvdXQ9e3RoaXMucHJvcHMubGF5b3V0fVxuICAgICAgICAgICAgICAgIGVuYWJsZUZsYWlyPXtTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFVJRmVhdHVyZS5GbGFpcil9XG4gICAgICAgICAgICAgICAgaGlkZVRocmVhZGVkTWVzc2FnZXM9e3RoaXMucHJvcHMuaGlkZVRocmVhZGVkTWVzc2FnZXN9XG4gICAgICAgICAgICAgICAgZGlzYWJsZUdyb3VwaW5nPXt0aGlzLnByb3BzLmRpc2FibGVHcm91cGluZ31cbiAgICAgICAgICAgIC8+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUaW1lbGluZVBhbmVsO1xuIl19