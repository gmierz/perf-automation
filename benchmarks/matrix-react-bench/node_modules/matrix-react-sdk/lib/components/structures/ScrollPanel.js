"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _Timer = _interopRequireDefault(require("../../utils/Timer"));

var _AutoHideScrollbar = _interopRequireDefault(require("./AutoHideScrollbar"));

var _replaceableComponent = require("../../utils/replaceableComponent");

var _KeyBindingsManager = require("../../KeyBindingsManager");

var _logger = require("matrix-js-sdk/src/logger");

var _dec, _class, _class2, _temp;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const DEBUG_SCROLL = false; // The amount of extra scroll distance to allow prior to unfilling.
// See getExcessHeight.

const UNPAGINATION_PADDING = 6000; // The number of milliseconds to debounce calls to onUnfillRequest, to prevent
// many scroll events causing many unfilling requests.

const UNFILL_REQUEST_DEBOUNCE_MS = 200; // _updateHeight makes the height a ceiled multiple of this so we
// don't have to update the height too often. It also allows the user
// to scroll past the pagination spinner a bit so they don't feel blocked so
// much while the content loads.

const PAGE_SIZE = 400;
let debuglog;

if (DEBUG_SCROLL) {
  // using bind means that we get to keep useful line numbers in the console
  debuglog = _logger.logger.log.bind(console, "ScrollPanel debuglog:");
} else {
  debuglog = function () {};
}

let ScrollPanel = (_dec = (0, _replaceableComponent.replaceableComponent)("structures.ScrollPanel"), _dec(_class = (_temp = _class2 = class ScrollPanel extends _react.default.Component {
  // Are we currently trying to backfill?
  // Is the current fill request caused by a props update?
  // Did another request to check the fill state arrive while we were trying to backfill?
  // Is that next fill request scheduled because of a props update?
  constructor(props, context) {
    super(props, context);
    (0, _defineProperty2.default)(this, "pendingFillRequests", {
      b: null,
      f: null
    });
    (0, _defineProperty2.default)(this, "itemlist", /*#__PURE__*/(0, _react.createRef)());
    (0, _defineProperty2.default)(this, "unmounted", false);
    (0, _defineProperty2.default)(this, "scrollTimeout", void 0);
    (0, _defineProperty2.default)(this, "isFilling", void 0);
    (0, _defineProperty2.default)(this, "isFillingDueToPropsUpdate", false);
    (0, _defineProperty2.default)(this, "fillRequestWhileRunning", void 0);
    (0, _defineProperty2.default)(this, "pendingFillDueToPropsUpdate", void 0);
    (0, _defineProperty2.default)(this, "scrollState", void 0);
    (0, _defineProperty2.default)(this, "preventShrinkingState", void 0);
    (0, _defineProperty2.default)(this, "unfillDebouncer", void 0);
    (0, _defineProperty2.default)(this, "bottomGrowth", void 0);
    (0, _defineProperty2.default)(this, "pages", void 0);
    (0, _defineProperty2.default)(this, "heightUpdateInProgress", void 0);
    (0, _defineProperty2.default)(this, "divScroll", void 0);
    (0, _defineProperty2.default)(this, "onScroll", ev => {
      // skip scroll events caused by resizing
      if (this.props.resizeNotifier && this.props.resizeNotifier.isResizing) return;
      debuglog("onScroll", this.getScrollNode().scrollTop);
      this.scrollTimeout.restart();
      this.saveScrollState();
      this.updatePreventShrinking();
      this.props.onScroll(ev);
      this.checkFillState();
    });
    (0, _defineProperty2.default)(this, "onResize", () => {
      debuglog("onResize");
      this.checkScroll(); // update preventShrinkingState if present

      if (this.preventShrinkingState) {
        this.preventShrinking();
      }
    });
    (0, _defineProperty2.default)(this, "checkScroll", (isFromPropsUpdate = false) => {
      if (this.unmounted) {
        return;
      }

      this.restoreSavedScrollState();
      this.checkFillState(0, isFromPropsUpdate);
    });
    (0, _defineProperty2.default)(this, "isAtBottom", () => {
      const sn = this.getScrollNode(); // fractional values (both too big and too small)
      // for scrollTop happen on certain browsers/platforms
      // when scrolled all the way down. E.g. Chrome 72 on debian.
      //
      // We therefore leave a bit of wiggle-room and assume we're at the
      // bottom if the unscrolled area is less than one pixel high.
      //
      // non-standard DPI settings also seem to have effect here and can
      // actually lead to scrollTop+clientHeight being *larger* than
      // scrollHeight. (observed in element-desktop on Ubuntu 20.04)
      //

      return sn.scrollHeight - (sn.scrollTop + sn.clientHeight) <= 1;
    });
    (0, _defineProperty2.default)(this, "checkFillState", async (depth = 0, isFromPropsUpdate = false) => {
      if (this.unmounted) {
        return;
      }

      const isFirstCall = depth === 0;
      const sn = this.getScrollNode(); // if there is less than a screenful of messages above or below the
      // viewport, try to get some more messages.
      //
      // scrollTop is the number of pixels between the top of the content and
      //     the top of the viewport.
      //
      // scrollHeight is the total height of the content.
      //
      // clientHeight is the height of the viewport (excluding borders,
      // margins, and scrollbars).
      //
      //
      //   .---------.          -                 -
      //   |         |          |  scrollTop      |
      // .-+---------+-.    -   -                 |
      // | |         | |    |                     |
      // | |         | |    |  clientHeight       | scrollHeight
      // | |         | |    |                     |
      // `-+---------+-'    -                     |
      //   |         |                            |
      //   |         |                            |
      //   `---------'                            -
      //
      // as filling is async and recursive,
      // don't allow more than 1 chain of calls concurrently
      // do make a note when a new request comes in while already running one,
      // so we can trigger a new chain of calls once done.
      // However, we make an exception for when we're already filling due to a
      // props (or children) update, because very often the children include
      // spinners to say whether we're paginating or not, so this would cause
      // infinite paginating.

      if (isFirstCall) {
        if (this.isFilling && !this.isFillingDueToPropsUpdate) {
          debuglog("isFilling: not entering while request is ongoing, marking for a subsequent request");
          this.fillRequestWhileRunning = true;
          this.pendingFillDueToPropsUpdate = isFromPropsUpdate;
          return;
        }

        debuglog("isFilling: setting");
        this.isFilling = true;
        this.isFillingDueToPropsUpdate = isFromPropsUpdate;
      }

      const itemlist = this.itemlist.current;
      const firstTile = itemlist && itemlist.firstElementChild;
      const contentTop = firstTile && firstTile.offsetTop;
      const fillPromises = []; // if scrollTop gets to 1 screen from the top of the first tile,
      // try backward filling

      if (!firstTile || sn.scrollTop - contentTop < sn.clientHeight) {
        // need to back-fill
        fillPromises.push(this.maybeFill(depth, true));
      } // if scrollTop gets to 2 screens from the end (so 1 screen below viewport),
      // try forward filling


      if (sn.scrollHeight - sn.scrollTop < sn.clientHeight * 2) {
        // need to forward-fill
        fillPromises.push(this.maybeFill(depth, false));
      }

      if (fillPromises.length) {
        try {
          await Promise.all(fillPromises);
        } catch (err) {
          _logger.logger.error(err);
        }
      }

      if (isFirstCall) {
        debuglog("isFilling: clearing");
        this.isFilling = false;
        this.isFillingDueToPropsUpdate = false;
      }

      if (this.fillRequestWhileRunning) {
        const refillDueToPropsUpdate = this.pendingFillDueToPropsUpdate;
        this.fillRequestWhileRunning = false;
        this.pendingFillDueToPropsUpdate = false;
        this.checkFillState(0, refillDueToPropsUpdate);
      }
    });
    (0, _defineProperty2.default)(this, "getScrollState", () => this.scrollState);
    (0, _defineProperty2.default)(this, "resetScrollState", () => {
      this.scrollState = {
        stuckAtBottom: this.props.startAtBottom
      };
      this.bottomGrowth = 0;
      this.pages = 0;
      this.scrollTimeout = new _Timer.default(100);
      this.heightUpdateInProgress = false;
    });
    (0, _defineProperty2.default)(this, "scrollToTop", () => {
      this.getScrollNode().scrollTop = 0;
      this.saveScrollState();
    });
    (0, _defineProperty2.default)(this, "scrollToBottom", () => {
      // the easiest way to make sure that the scroll state is correctly
      // saved is to do the scroll, then save the updated state. (Calculating
      // it ourselves is hard, and we can't rely on an onScroll callback
      // happening, since there may be no user-visible change here).
      const sn = this.getScrollNode();
      sn.scrollTop = sn.scrollHeight;
      this.saveScrollState();
    });
    (0, _defineProperty2.default)(this, "scrollRelative", mult => {
      const scrollNode = this.getScrollNode();
      const delta = mult * scrollNode.clientHeight * 0.9;
      scrollNode.scrollBy(0, delta);
      this.saveScrollState();
    });
    (0, _defineProperty2.default)(this, "handleScrollKey", ev => {
      let isScrolling = false;
      const roomAction = (0, _KeyBindingsManager.getKeyBindingsManager)().getRoomAction(ev);

      switch (roomAction) {
        case _KeyBindingsManager.RoomAction.ScrollUp:
          this.scrollRelative(-1);
          isScrolling = true;
          break;

        case _KeyBindingsManager.RoomAction.RoomScrollDown:
          this.scrollRelative(1);
          isScrolling = true;
          break;

        case _KeyBindingsManager.RoomAction.JumpToFirstMessage:
          this.scrollToTop();
          isScrolling = true;
          break;

        case _KeyBindingsManager.RoomAction.JumpToLatestMessage:
          this.scrollToBottom();
          isScrolling = true;
          break;
      }

      if (isScrolling && this.props.onUserScroll) {
        this.props.onUserScroll(ev);
      }
    });
    (0, _defineProperty2.default)(this, "scrollToToken", (scrollToken, pixelOffset, offsetBase) => {
      pixelOffset = pixelOffset || 0;
      offsetBase = offsetBase || 0; // set the trackedScrollToken so we can get the node through getTrackedNode

      this.scrollState = {
        stuckAtBottom: false,
        trackedScrollToken: scrollToken
      };
      const trackedNode = this.getTrackedNode();
      const scrollNode = this.getScrollNode();

      if (trackedNode) {
        // set the scrollTop to the position we want.
        // note though, that this might not succeed if the combination of offsetBase and pixelOffset
        // would position the trackedNode towards the top of the viewport.
        // This because when setting the scrollTop only 10 or so events might be loaded,
        // not giving enough content below the trackedNode to scroll downwards
        // enough so it ends up in the top of the viewport.
        debuglog("scrollToken: setting scrollTop", {
          offsetBase,
          pixelOffset,
          offsetTop: trackedNode.offsetTop
        });
        scrollNode.scrollTop = trackedNode.offsetTop - scrollNode.clientHeight * offsetBase + pixelOffset;
        this.saveScrollState();
      }
    });
    (0, _defineProperty2.default)(this, "collectScroll", divScroll => {
      this.divScroll = divScroll;
    });
    (0, _defineProperty2.default)(this, "preventShrinking", () => {
      const messageList = this.itemlist.current;
      const tiles = messageList && messageList.children;

      if (!messageList) {
        return;
      }

      let lastTileNode;

      for (let i = tiles.length - 1; i >= 0; i--) {
        const node = tiles[i];

        if (node.dataset.scrollTokens) {
          lastTileNode = node;
          break;
        }
      }

      if (!lastTileNode) {
        return;
      }

      this.clearPreventShrinking();
      const offsetFromBottom = messageList.clientHeight - (lastTileNode.offsetTop + lastTileNode.clientHeight);
      this.preventShrinkingState = {
        offsetFromBottom: offsetFromBottom,
        offsetNode: lastTileNode
      };
      debuglog("prevent shrinking, last tile ", offsetFromBottom, "px from bottom");
    });
    (0, _defineProperty2.default)(this, "clearPreventShrinking", () => {
      const messageList = this.itemlist.current;
      const balanceElement = messageList && messageList.parentElement;
      if (balanceElement) balanceElement.style.paddingBottom = null;
      this.preventShrinkingState = null;
      debuglog("prevent shrinking cleared");
    });
    (0, _defineProperty2.default)(this, "updatePreventShrinking", () => {
      if (this.preventShrinkingState) {
        const sn = this.getScrollNode();
        const scrollState = this.scrollState;
        const messageList = this.itemlist.current;
        const {
          offsetNode,
          offsetFromBottom
        } = this.preventShrinkingState; // element used to set paddingBottom to balance the typing notifs disappearing

        const balanceElement = messageList.parentElement; // if the offsetNode got unmounted, clear

        let shouldClear = !offsetNode.parentElement; // also if 200px from bottom

        if (!shouldClear && !scrollState.stuckAtBottom) {
          const spaceBelowViewport = sn.scrollHeight - (sn.scrollTop + sn.clientHeight);
          shouldClear = spaceBelowViewport >= 200;
        } // try updating if not clearing


        if (!shouldClear) {
          const currentOffset = messageList.clientHeight - (offsetNode.offsetTop + offsetNode.clientHeight);
          const offsetDiff = offsetFromBottom - currentOffset;

          if (offsetDiff > 0) {
            balanceElement.style.paddingBottom = `${offsetDiff}px`;
            debuglog("update prevent shrinking ", offsetDiff, "px from bottom");
          } else if (offsetDiff < 0) {
            shouldClear = true;
          }
        }

        if (shouldClear) {
          this.clearPreventShrinking();
        }
      }
    });

    if (this.props.resizeNotifier) {
      this.props.resizeNotifier.on("middlePanelResizedNoisy", this.onResize);
    }

    this.resetScrollState();
  }

  componentDidMount() {
    this.checkScroll();
  }

  componentDidUpdate() {
    // after adding event tiles, we may need to tweak the scroll (either to
    // keep at the bottom of the timeline, or to maintain the view after
    // adding events to the top).
    //
    // This will also re-check the fill state, in case the paginate was inadequate
    this.checkScroll(true);
    this.updatePreventShrinking();
  }

  componentWillUnmount() {
    // set a boolean to say we've been unmounted, which any pending
    // promises can use to throw away their results.
    //
    // (We could use isMounted(), but facebook have deprecated that.)
    this.unmounted = true;

    if (this.props.resizeNotifier) {
      this.props.resizeNotifier.removeListener("middlePanelResizedNoisy", this.onResize);
    }
  }

  // returns the vertical height in the given direction that can be removed from
  // the content box (which has a height of scrollHeight, see checkFillState) without
  // pagination occuring.
  //
  // padding* = UNPAGINATION_PADDING
  //
  // ### Region determined as excess.
  //
  //   .---------.                        -              -
  //   |#########|                        |              |
  //   |#########|   -                    |  scrollTop   |
  //   |         |   | padding*           |              |
  //   |         |   |                    |              |
  // .-+---------+-. -  -                 |              |
  // : |         | :    |                 |              |
  // : |         | :    |  clientHeight   |              |
  // : |         | :    |                 |              |
  // .-+---------+-.    -                 -              |
  // | |         | |    |                                |
  // | |         | |    |  clientHeight                  | scrollHeight
  // | |         | |    |                                |
  // `-+---------+-'    -                                |
  // : |         | :    |                                |
  // : |         | :    |  clientHeight                  |
  // : |         | :    |                                |
  // `-+---------+-' -  -                                |
  //   |         |   | padding*                          |
  //   |         |   |                                   |
  //   |#########|   -                                   |
  //   |#########|                                       |
  //   `---------'                                       -
  getExcessHeight(backwards) {
    const sn = this.getScrollNode();
    const contentHeight = this.getMessagesHeight();
    const listHeight = this.getListHeight();
    const clippedHeight = contentHeight - listHeight;
    const unclippedScrollTop = sn.scrollTop + clippedHeight;

    if (backwards) {
      return unclippedScrollTop - sn.clientHeight - UNPAGINATION_PADDING;
    } else {
      return contentHeight - (unclippedScrollTop + 2 * sn.clientHeight) - UNPAGINATION_PADDING;
    }
  } // check the scroll state and send out backfill requests if necessary.


  // check if unfilling is possible and send an unfill request if necessary
  checkUnfillState(backwards) {
    let excessHeight = this.getExcessHeight(backwards);

    if (excessHeight <= 0) {
      return;
    }

    const origExcessHeight = excessHeight;
    const tiles = this.itemlist.current.children; // The scroll token of the first/last tile to be unpaginated

    let markerScrollToken = null; // Subtract heights of tiles to simulate the tiles being unpaginated until the
    // excess height is less than the height of the next tile to subtract. This
    // prevents excessHeight becoming negative, which could lead to future
    // pagination.
    //
    // If backwards is true, we unpaginate (remove) tiles from the back (top).

    let tile;

    for (let i = 0; i < tiles.length; i++) {
      tile = tiles[backwards ? i : tiles.length - 1 - i]; // Subtract height of tile as if it were unpaginated

      excessHeight -= tile.clientHeight; //If removing the tile would lead to future pagination, break before setting scroll token

      if (tile.clientHeight > excessHeight) {
        break;
      } // The tile may not have a scroll token, so guard it


      if (tile.dataset.scrollTokens) {
        markerScrollToken = tile.dataset.scrollTokens.split(',')[0];
      }
    }

    if (markerScrollToken) {
      // Use a debouncer to prevent multiple unfill calls in quick succession
      // This is to make the unfilling process less aggressive
      if (this.unfillDebouncer) {
        clearTimeout(this.unfillDebouncer);
      }

      this.unfillDebouncer = setTimeout(() => {
        this.unfillDebouncer = null;
        debuglog("unfilling now", backwards, origExcessHeight);
        this.props.onUnfillRequest(backwards, markerScrollToken);
      }, UNFILL_REQUEST_DEBOUNCE_MS);
    }
  } // check if there is already a pending fill request. If not, set one off.


  maybeFill(depth, backwards) {
    const dir = backwards ? 'b' : 'f';

    if (this.pendingFillRequests[dir]) {
      debuglog("Already a " + dir + " fill in progress - not starting another");
      return;
    }

    debuglog("starting " + dir + " fill"); // onFillRequest can end up calling us recursively (via onScroll
    // events) so make sure we set this before firing off the call.

    this.pendingFillRequests[dir] = true; // wait 1ms before paginating, because otherwise
    // this will block the scroll event handler for +700ms
    // if messages are already cached in memory,
    // This would cause jumping to happen on Chrome/macOS.

    return new Promise(resolve => setTimeout(resolve, 1)).then(() => {
      return this.props.onFillRequest(backwards);
    }).finally(() => {
      this.pendingFillRequests[dir] = false;
    }).then(hasMoreResults => {
      if (this.unmounted) {
        return;
      } // Unpaginate once filling is complete


      this.checkUnfillState(!backwards);
      debuglog("" + dir + " fill complete; hasMoreResults:" + hasMoreResults);

      if (hasMoreResults) {
        // further pagination requests have been disabled until now, so
        // it's time to check the fill state again in case the pagination
        // was insufficient.
        return this.checkFillState(depth + 1);
      }
    });
  }
  /* get the current scroll state. This returns an object with the following
   * properties:
   *
   * boolean stuckAtBottom: true if we are tracking the bottom of the
   *   scroll. false if we are tracking a particular child.
   *
   * string trackedScrollToken: undefined if stuckAtBottom is true; if it is
   *   false, the first token in data-scroll-tokens of the child which we are
   *   tracking.
   *
   * number bottomOffset: undefined if stuckAtBottom is true; if it is false,
   *   the number of pixels the bottom of the tracked child is above the
   *   bottom of the scroll panel.
   */


  saveScrollState() {
    if (this.props.stickyBottom && this.isAtBottom()) {
      this.scrollState = {
        stuckAtBottom: true
      };
      debuglog("saved stuckAtBottom state");
      return;
    }

    const scrollNode = this.getScrollNode();
    const viewportBottom = scrollNode.scrollHeight - (scrollNode.scrollTop + scrollNode.clientHeight);
    const itemlist = this.itemlist.current;
    const messages = itemlist.children;
    let node = null; // TODO: do a binary search here, as items are sorted by offsetTop
    // loop backwards, from bottom-most message (as that is the most common case)

    for (let i = messages.length - 1; i >= 0; --i) {
      if (!messages[i].dataset.scrollTokens) {
        continue;
      }

      node = messages[i]; // break at the first message (coming from the bottom)
      // that has it's offsetTop above the bottom of the viewport.

      if (this.topFromBottom(node) > viewportBottom) {
        // Use this node as the scrollToken
        break;
      }
    }

    if (!node) {
      debuglog("unable to save scroll state: found no children in the viewport");
      return;
    }

    const scrollToken = node.dataset.scrollTokens.split(',')[0];
    debuglog("saving anchored scroll state to message", node && node.innerText, scrollToken);
    const bottomOffset = this.topFromBottom(node);
    this.scrollState = {
      stuckAtBottom: false,
      trackedNode: node,
      trackedScrollToken: scrollToken,
      bottomOffset: bottomOffset,
      pixelOffset: bottomOffset - viewportBottom //needed for restoring the scroll position when coming back to the room

    };
  }

  async restoreSavedScrollState() {
    const scrollState = this.scrollState;

    if (scrollState.stuckAtBottom) {
      const sn = this.getScrollNode();

      if (sn.scrollTop !== sn.scrollHeight) {
        sn.scrollTop = sn.scrollHeight;
      }
    } else if (scrollState.trackedScrollToken) {
      const itemlist = this.itemlist.current;
      const trackedNode = this.getTrackedNode();

      if (trackedNode) {
        const newBottomOffset = this.topFromBottom(trackedNode);
        const bottomDiff = newBottomOffset - scrollState.bottomOffset;
        this.bottomGrowth += bottomDiff;
        scrollState.bottomOffset = newBottomOffset;
        const newHeight = `${this.getListHeight()}px`;

        if (itemlist.style.height !== newHeight) {
          itemlist.style.height = newHeight;
        }

        debuglog("balancing height because messages below viewport grew by", bottomDiff);
      }
    }

    if (!this.heightUpdateInProgress) {
      this.heightUpdateInProgress = true;

      try {
        await this.updateHeight();
      } finally {
        this.heightUpdateInProgress = false;
      }
    } else {
      debuglog("not updating height because request already in progress");
    }
  } // need a better name that also indicates this will change scrollTop? Rebalance height? Reveal content?


  async updateHeight() {
    // wait until user has stopped scrolling
    if (this.scrollTimeout.isRunning()) {
      debuglog("updateHeight waiting for scrolling to end ... ");
      await this.scrollTimeout.finished();
    } else {
      debuglog("updateHeight getting straight to business, no scrolling going on.");
    } // We might have unmounted since the timer finished, so abort if so.


    if (this.unmounted) {
      return;
    }

    const sn = this.getScrollNode();
    const itemlist = this.itemlist.current;
    const contentHeight = this.getMessagesHeight();
    const minHeight = sn.clientHeight;
    const height = Math.max(minHeight, contentHeight);
    this.pages = Math.ceil(height / PAGE_SIZE);
    const displayScrollbar = contentHeight > minHeight;
    sn.dataset.scrollbar = displayScrollbar.toString();
    this.bottomGrowth = 0;
    const newHeight = `${this.getListHeight()}px`;
    const scrollState = this.scrollState;

    if (scrollState.stuckAtBottom) {
      if (itemlist.style.height !== newHeight) {
        itemlist.style.height = newHeight;
      }

      if (sn.scrollTop !== sn.scrollHeight) {
        sn.scrollTop = sn.scrollHeight;
      }

      debuglog("updateHeight to", newHeight);
    } else if (scrollState.trackedScrollToken) {
      const trackedNode = this.getTrackedNode(); // if the timeline has been reloaded
      // this can be called before scrollToBottom or whatever has been called
      // so don't do anything if the node has disappeared from
      // the currently filled piece of the timeline

      if (trackedNode) {
        const oldTop = trackedNode.offsetTop;

        if (itemlist.style.height !== newHeight) {
          itemlist.style.height = newHeight;
        }

        const newTop = trackedNode.offsetTop;
        const topDiff = newTop - oldTop; // important to scroll by a relative amount as
        // reading scrollTop and then setting it might
        // yield out of date values and cause a jump
        // when setting it

        sn.scrollBy(0, topDiff);
        debuglog("updateHeight to", {
          newHeight,
          topDiff
        });
      }
    }
  }

  getTrackedNode() {
    const scrollState = this.scrollState;
    const trackedNode = scrollState.trackedNode;

    if (!trackedNode || !trackedNode.parentElement) {
      let node;
      const messages = this.itemlist.current.children;
      const scrollToken = scrollState.trackedScrollToken;

      for (let i = messages.length - 1; i >= 0; --i) {
        const m = messages[i]; // 'data-scroll-tokens' is a DOMString of comma-separated scroll tokens
        // There might only be one scroll token

        if (m.dataset.scrollTokens && m.dataset.scrollTokens.split(',').indexOf(scrollToken) !== -1) {
          node = m;
          break;
        }
      }

      if (node) {
        debuglog("had to find tracked node again for " + scrollState.trackedScrollToken);
      }

      scrollState.trackedNode = node;
    }

    if (!scrollState.trackedNode) {
      debuglog("No node with ; '" + scrollState.trackedScrollToken + "'");
      return;
    }

    return scrollState.trackedNode;
  }

  getListHeight() {
    return this.bottomGrowth + this.pages * PAGE_SIZE;
  }

  getMessagesHeight() {
    const itemlist = this.itemlist.current;
    const lastNode = itemlist.lastElementChild;
    const lastNodeBottom = lastNode ? lastNode.offsetTop + lastNode.clientHeight : 0;
    const firstNodeTop = itemlist.firstElementChild ? itemlist.firstElementChild.offsetTop : 0; // 18 is itemlist padding

    return lastNodeBottom - firstNodeTop + 18 * 2;
  }

  topFromBottom(node) {
    // current capped height - distance from top = distance from bottom of container to top of tracked element
    return this.itemlist.current.clientHeight - node.offsetTop;
  }
  /* get the DOM node which has the scrollTop property we care about for our
   * message panel.
   */


  getScrollNode() {
    if (this.unmounted) {
      // this shouldn't happen, but when it does, turn the NPE into
      // something more meaningful.
      throw new Error("ScrollPanel.getScrollNode called when unmounted");
    }

    if (!this.divScroll) {
      // Likewise, we should have the ref by this point, but if not
      // turn the NPE into something meaningful.
      throw new Error("ScrollPanel.getScrollNode called before AutoHideScrollbar ref collected");
    }

    return this.divScroll;
  }

  render() {
    // TODO: the classnames on the div and ol could do with being updated to
    // reflect the fact that we don't necessarily contain a list of messages.
    // it's not obvious why we have a separate div and ol anyway.
    // give the <ol> an explicit role=list because Safari+VoiceOver seems to think an ordered-list with
    // list-style-type: none; is no longer a list
    return /*#__PURE__*/_react.default.createElement(_AutoHideScrollbar.default, {
      wrappedRef: this.collectScroll,
      onScroll: this.onScroll,
      onWheel: this.props.onUserScroll,
      className: `mx_ScrollPanel ${this.props.className}`,
      style: this.props.style
    }, this.props.fixedChildren, /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_RoomView_messageListWrapper"
    }, /*#__PURE__*/_react.default.createElement("ol", {
      ref: this.itemlist,
      className: "mx_RoomView_MessageList",
      "aria-live": "polite",
      role: "list"
    }, this.props.children)));
  }

}, (0, _defineProperty2.default)(_class2, "defaultProps", {
  stickyBottom: true,
  startAtBottom: true,
  onFillRequest: function (backwards) {
    return Promise.resolve(false);
  },
  onUnfillRequest: function (backwards, scrollToken) {},
  onScroll: function () {}
}), _temp)) || _class);
exports.default = ScrollPanel;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3N0cnVjdHVyZXMvU2Nyb2xsUGFuZWwudHN4Il0sIm5hbWVzIjpbIkRFQlVHX1NDUk9MTCIsIlVOUEFHSU5BVElPTl9QQURESU5HIiwiVU5GSUxMX1JFUVVFU1RfREVCT1VOQ0VfTVMiLCJQQUdFX1NJWkUiLCJkZWJ1Z2xvZyIsImxvZ2dlciIsImxvZyIsImJpbmQiLCJjb25zb2xlIiwiU2Nyb2xsUGFuZWwiLCJSZWFjdCIsIkNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJjb250ZXh0IiwiYiIsImYiLCJldiIsInJlc2l6ZU5vdGlmaWVyIiwiaXNSZXNpemluZyIsImdldFNjcm9sbE5vZGUiLCJzY3JvbGxUb3AiLCJzY3JvbGxUaW1lb3V0IiwicmVzdGFydCIsInNhdmVTY3JvbGxTdGF0ZSIsInVwZGF0ZVByZXZlbnRTaHJpbmtpbmciLCJvblNjcm9sbCIsImNoZWNrRmlsbFN0YXRlIiwiY2hlY2tTY3JvbGwiLCJwcmV2ZW50U2hyaW5raW5nU3RhdGUiLCJwcmV2ZW50U2hyaW5raW5nIiwiaXNGcm9tUHJvcHNVcGRhdGUiLCJ1bm1vdW50ZWQiLCJyZXN0b3JlU2F2ZWRTY3JvbGxTdGF0ZSIsInNuIiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiZGVwdGgiLCJpc0ZpcnN0Q2FsbCIsImlzRmlsbGluZyIsImlzRmlsbGluZ0R1ZVRvUHJvcHNVcGRhdGUiLCJmaWxsUmVxdWVzdFdoaWxlUnVubmluZyIsInBlbmRpbmdGaWxsRHVlVG9Qcm9wc1VwZGF0ZSIsIml0ZW1saXN0IiwiY3VycmVudCIsImZpcnN0VGlsZSIsImZpcnN0RWxlbWVudENoaWxkIiwiY29udGVudFRvcCIsIm9mZnNldFRvcCIsImZpbGxQcm9taXNlcyIsInB1c2giLCJtYXliZUZpbGwiLCJsZW5ndGgiLCJQcm9taXNlIiwiYWxsIiwiZXJyIiwiZXJyb3IiLCJyZWZpbGxEdWVUb1Byb3BzVXBkYXRlIiwic2Nyb2xsU3RhdGUiLCJzdHVja0F0Qm90dG9tIiwic3RhcnRBdEJvdHRvbSIsImJvdHRvbUdyb3d0aCIsInBhZ2VzIiwiVGltZXIiLCJoZWlnaHRVcGRhdGVJblByb2dyZXNzIiwibXVsdCIsInNjcm9sbE5vZGUiLCJkZWx0YSIsInNjcm9sbEJ5IiwiaXNTY3JvbGxpbmciLCJyb29tQWN0aW9uIiwiZ2V0Um9vbUFjdGlvbiIsIlJvb21BY3Rpb24iLCJTY3JvbGxVcCIsInNjcm9sbFJlbGF0aXZlIiwiUm9vbVNjcm9sbERvd24iLCJKdW1wVG9GaXJzdE1lc3NhZ2UiLCJzY3JvbGxUb1RvcCIsIkp1bXBUb0xhdGVzdE1lc3NhZ2UiLCJzY3JvbGxUb0JvdHRvbSIsIm9uVXNlclNjcm9sbCIsInNjcm9sbFRva2VuIiwicGl4ZWxPZmZzZXQiLCJvZmZzZXRCYXNlIiwidHJhY2tlZFNjcm9sbFRva2VuIiwidHJhY2tlZE5vZGUiLCJnZXRUcmFja2VkTm9kZSIsImRpdlNjcm9sbCIsIm1lc3NhZ2VMaXN0IiwidGlsZXMiLCJjaGlsZHJlbiIsImxhc3RUaWxlTm9kZSIsImkiLCJub2RlIiwiZGF0YXNldCIsInNjcm9sbFRva2VucyIsImNsZWFyUHJldmVudFNocmlua2luZyIsIm9mZnNldEZyb21Cb3R0b20iLCJvZmZzZXROb2RlIiwiYmFsYW5jZUVsZW1lbnQiLCJwYXJlbnRFbGVtZW50Iiwic3R5bGUiLCJwYWRkaW5nQm90dG9tIiwic2hvdWxkQ2xlYXIiLCJzcGFjZUJlbG93Vmlld3BvcnQiLCJjdXJyZW50T2Zmc2V0Iiwib2Zmc2V0RGlmZiIsIm9uIiwib25SZXNpemUiLCJyZXNldFNjcm9sbFN0YXRlIiwiY29tcG9uZW50RGlkTW91bnQiLCJjb21wb25lbnREaWRVcGRhdGUiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInJlbW92ZUxpc3RlbmVyIiwiZ2V0RXhjZXNzSGVpZ2h0IiwiYmFja3dhcmRzIiwiY29udGVudEhlaWdodCIsImdldE1lc3NhZ2VzSGVpZ2h0IiwibGlzdEhlaWdodCIsImdldExpc3RIZWlnaHQiLCJjbGlwcGVkSGVpZ2h0IiwidW5jbGlwcGVkU2Nyb2xsVG9wIiwiY2hlY2tVbmZpbGxTdGF0ZSIsImV4Y2Vzc0hlaWdodCIsIm9yaWdFeGNlc3NIZWlnaHQiLCJtYXJrZXJTY3JvbGxUb2tlbiIsInRpbGUiLCJzcGxpdCIsInVuZmlsbERlYm91bmNlciIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJvblVuZmlsbFJlcXVlc3QiLCJkaXIiLCJwZW5kaW5nRmlsbFJlcXVlc3RzIiwicmVzb2x2ZSIsInRoZW4iLCJvbkZpbGxSZXF1ZXN0IiwiZmluYWxseSIsImhhc01vcmVSZXN1bHRzIiwic3RpY2t5Qm90dG9tIiwiaXNBdEJvdHRvbSIsInZpZXdwb3J0Qm90dG9tIiwibWVzc2FnZXMiLCJ0b3BGcm9tQm90dG9tIiwiaW5uZXJUZXh0IiwiYm90dG9tT2Zmc2V0IiwibmV3Qm90dG9tT2Zmc2V0IiwiYm90dG9tRGlmZiIsIm5ld0hlaWdodCIsImhlaWdodCIsInVwZGF0ZUhlaWdodCIsImlzUnVubmluZyIsImZpbmlzaGVkIiwibWluSGVpZ2h0IiwiTWF0aCIsIm1heCIsImNlaWwiLCJkaXNwbGF5U2Nyb2xsYmFyIiwic2Nyb2xsYmFyIiwidG9TdHJpbmciLCJvbGRUb3AiLCJuZXdUb3AiLCJ0b3BEaWZmIiwibSIsImluZGV4T2YiLCJsYXN0Tm9kZSIsImxhc3RFbGVtZW50Q2hpbGQiLCJsYXN0Tm9kZUJvdHRvbSIsImZpcnN0Tm9kZVRvcCIsIkVycm9yIiwicmVuZGVyIiwiY29sbGVjdFNjcm9sbCIsImNsYXNzTmFtZSIsImZpeGVkQ2hpbGRyZW4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBZ0JBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUdBOzs7Ozs7OztBQUVBLE1BQU1BLFlBQVksR0FBRyxLQUFyQixDLENBRUE7QUFDQTs7QUFDQSxNQUFNQyxvQkFBb0IsR0FBRyxJQUE3QixDLENBQ0E7QUFDQTs7QUFDQSxNQUFNQywwQkFBMEIsR0FBRyxHQUFuQyxDLENBQ0E7QUFDQTtBQUNBO0FBQ0E7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SHhCO0FBSUksTUFBQSxTQUFTLEVBQUcsa0JBQWlCLEtBQUtuRSxLQUFMLENBQVcrSixTQUFVLEVBSnREO0FBS0ksTUFBQSxLQUFLLEVBQUUsS0FBSy9KLEtBQUwsQ0FBV3dGO0FBTHRCLE9BT00sS0FBS3hGLEtBQUwsQ0FBV2dLLGFBUGpCLGVBUUk7QUFBSyxNQUFBLFNBQVMsRUFBQztBQUFmLG9CQUNJO0FBQUksTUFBQSxHQUFHLEVBQUUsS0FBS2xJLFFBQWQ7QUFBd0IsTUFBQSxTQUFTLEVBQUMseUJBQWxDO0FBQTRELG1CQUFVLFFBQXRFO0FBQStFLE1BQUEsSUFBSSxFQUFDO0FBQXBGLE9BQ00sS0FBSzlCLEtBQUwsQ0FBVzZFLFFBRGpCLENBREosQ0FSSixDQURKO0FBZ0JIOztBQTN4QjRELEMseURBQ3ZDO0FBQ2xCaUQsRUFBQUEsWUFBWSxFQUFFLElBREk7QUFFbEIvRSxFQUFBQSxhQUFhLEVBQUUsSUFGRztBQUdsQjRFLEVBQUFBLGFBQWEsRUFBRSxVQUFTckIsU0FBVCxFQUE2QjtBQUFFLFdBQU85RCxPQUFPLENBQUNpRixPQUFSLENBQWdCLEtBQWhCLENBQVA7QUFBZ0MsR0FINUQ7QUFJbEJILEVBQUFBLGVBQWUsRUFBRSxVQUFTaEIsU0FBVCxFQUE2QmxDLFdBQTdCLEVBQWtELENBQUUsQ0FKbkQ7QUFLbEJ2RCxFQUFBQSxRQUFRLEVBQUUsWUFBVyxDQUFFO0FBTEwsQyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxNSAtIDIwMjEgVGhlIE1hdHJpeC5vcmcgRm91bmRhdGlvbiBDLkkuQy5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlUmVmLCBDU1NQcm9wZXJ0aWVzLCBSZWFjdE5vZGUsIFN5bnRoZXRpY0V2ZW50LCBLZXlib2FyZEV2ZW50IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgVGltZXIgZnJvbSAnLi4vLi4vdXRpbHMvVGltZXInO1xuaW1wb3J0IEF1dG9IaWRlU2Nyb2xsYmFyIGZyb20gXCIuL0F1dG9IaWRlU2Nyb2xsYmFyXCI7XG5pbXBvcnQgeyByZXBsYWNlYWJsZUNvbXBvbmVudCB9IGZyb20gXCIuLi8uLi91dGlscy9yZXBsYWNlYWJsZUNvbXBvbmVudFwiO1xuaW1wb3J0IHsgZ2V0S2V5QmluZGluZ3NNYW5hZ2VyLCBSb29tQWN0aW9uIH0gZnJvbSBcIi4uLy4uL0tleUJpbmRpbmdzTWFuYWdlclwiO1xuaW1wb3J0IFJlc2l6ZU5vdGlmaWVyIGZyb20gXCIuLi8uLi91dGlscy9SZXNpemVOb3RpZmllclwiO1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvbG9nZ2VyXCI7XG5cbmNvbnN0IERFQlVHX1NDUk9MTCA9IGZhbHNlO1xuXG4vLyBUaGUgYW1vdW50IG9mIGV4dHJhIHNjcm9sbCBkaXN0YW5jZSB0byBhbGxvdyBwcmlvciB0byB1bmZpbGxpbmcuXG4vLyBTZWUgZ2V0RXhjZXNzSGVpZ2h0LlxuY29uc3QgVU5QQUdJTkFUSU9OX1BBRERJTkcgPSA2MDAwO1xuLy8gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVib3VuY2UgY2FsbHMgdG8gb25VbmZpbGxSZXF1ZXN0LCB0byBwcmV2ZW50XG4vLyBtYW55IHNjcm9sbCBldmVudHMgY2F1c2luZyBtYW55IHVuZmlsbGluZyByZXF1ZXN0cy5cbmNvbnN0IFVORklMTF9SRVFVRVNUX0RFQk9VTkNFX01TID0gMjAwO1xuLy8gX3VwZGF0ZUhlaWdodCBtYWtlcyB0aGUgaGVpZ2h0IGEgY2VpbGVkIG11bHRpcGxlIG9mIHRoaXMgc28gd2Vcbi8vIGRvbid0IGhhdmUgdG8gdXBkYXRlIHRoZSBoZWlnaHQgdG9vIG9mdGVuLiBJdCBhbHNvIGFsbG93cyB0aGUgdXNlclxuLy8gdG8gc2Nyb2xsIHBhc3QgdGhlIHBhZ2luYXRpb24gc3Bpbm5lciBhIGJpdCBzbyB0aGV5IGRvbid0IGZlZWwgYmxvY2tlZCBzb1xuLy8gbXVjaCB3aGlsZSB0aGUgY29udGVudCBsb2Fkcy5cbmNvbnN0IFBBR0VfU0laRSA9IDQwMDtcblxubGV0IGRlYnVnbG9nO1xuaWYgKERFQlVHX1NDUk9MTCkge1xuICAgIC8vIHVzaW5nIGJpbmQgbWVhbnMgdGhhdCB3ZSBnZXQgdG8ga2VlcCB1c2VmdWwgbGluZSBudW1iZXJzIGluIHRoZSBjb25zb2xlXG4gICAgZGVidWdsb2cgPSBsb2dnZXIubG9nLmJpbmQoY29uc29sZSwgXCJTY3JvbGxQYW5lbCBkZWJ1Z2xvZzpcIik7XG59IGVsc2Uge1xuICAgIGRlYnVnbG9nID0gZnVuY3Rpb24oKSB7fTtcbn1cblxuaW50ZXJmYWNlIElQcm9wcyB7XG4gICAgLyogc3RpY2t5Qm90dG9tOiBpZiBzZXQgdG8gdHJ1ZSwgdGhlbiBvbmNlIHRoZSB1c2VyIGhpdHMgdGhlIGJvdHRvbSBvZlxuICAgICAqIHRoZSBsaXN0LCBhbnkgbmV3IGNoaWxkcmVuIGFkZGVkIHRvIHRoZSBsaXN0IHdpbGwgY2F1c2UgdGhlIGxpc3QgdG9cbiAgICAgKiBzY3JvbGwgZG93biB0byBzaG93IHRoZSBuZXcgZWxlbWVudCwgcmF0aGVyIHRoYW4gcHJlc2VydmluZyB0aGVcbiAgICAgKiBleGlzdGluZyB2aWV3LlxuICAgICAqL1xuICAgIHN0aWNreUJvdHRvbT86IGJvb2xlYW47XG5cbiAgICAvKiBzdGFydEF0Qm90dG9tOiBpZiBzZXQgdG8gdHJ1ZSwgdGhlIHZpZXcgaXMgYXNzdW1lZCB0byBzdGFydFxuICAgICAqIHNjcm9sbGVkIHRvIHRoZSBib3R0b20uXG4gICAgICogWFhYOiBJdCdzIGxpa2VseSB0aGlzIGlzIHVubmVjZXNzYXJ5IGFuZCBjYW4gYmUgZGVyaXZlZCBmcm9tXG4gICAgICogc3RpY2t5Qm90dG9tLCBidXQgSSdtIGFkZGluZyBhbiBleHRyYSBwYXJhbWV0ZXIgdG8gZW5zdXJlXG4gICAgICogYmVoYXZpb3VyIHN0YXlzIHRoZSBzYW1lIGZvciBvdGhlciB1c2VzIG9mIFNjcm9sbFBhbmVsLlxuICAgICAqIElmIHNvLCBsZXQncyByZW1vdmUgdGhpcyBwYXJhbWV0ZXIgZG93biB0aGUgbGluZS5cbiAgICAgKi9cbiAgICBzdGFydEF0Qm90dG9tPzogYm9vbGVhbjtcblxuICAgIC8qIGNsYXNzTmFtZTogY2xhc3NuYW1lcyB0byBhZGQgdG8gdGhlIHRvcC1sZXZlbCBkaXZcbiAgICAgKi9cbiAgICBjbGFzc05hbWU/OiBzdHJpbmc7XG5cbiAgICAvKiBzdHlsZTogc3R5bGVzIHRvIGFkZCB0byB0aGUgdG9wLWxldmVsIGRpdlxuICAgICAqL1xuICAgIHN0eWxlPzogQ1NTUHJvcGVydGllcztcblxuICAgIC8qIHJlc2l6ZU5vdGlmaWVyOiBSZXNpemVOb3RpZmllciB0byBrbm93IHdoZW4gbWlkZGxlIGNvbHVtbiBoYXMgY2hhbmdlZCBzaXplXG4gICAgICovXG4gICAgcmVzaXplTm90aWZpZXI/OiBSZXNpemVOb3RpZmllcjtcblxuICAgIC8qIGZpeGVkQ2hpbGRyZW46IGFsbG93cyBmb3IgY2hpbGRyZW4gdG8gYmUgcGFzc2VkIHdoaWNoIGFyZSByZW5kZXJlZCBvdXRzaWRlXG4gICAgICogb2YgdGhlIHdyYXBwZXJcbiAgICAgKi9cbiAgICBmaXhlZENoaWxkcmVuPzogUmVhY3ROb2RlO1xuXG4gICAgLyogb25GaWxsUmVxdWVzdChiYWNrd2FyZHMpOiBhIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBvbiBzY3JvbGwgd2hlblxuICAgICAqIHRoZSB1c2VyIG5lYXJzIHRoZSBzdGFydCAoYmFja3dhcmRzID0gdHJ1ZSkgb3IgZW5kIChiYWNrd2FyZHMgPVxuICAgICAqIGZhbHNlKSBvZiB0aGUgbGlzdC5cbiAgICAgKlxuICAgICAqIFRoaXMgc2hvdWxkIHJldHVybiBhIHByb21pc2U7IG5vIG1vcmUgY2FsbHMgd2lsbCBiZSBtYWRlIHVudGlsIHRoZVxuICAgICAqIHByb21pc2UgY29tcGxldGVzLlxuICAgICAqXG4gICAgICogVGhlIHByb21pc2Ugc2hvdWxkIHJlc29sdmUgdG8gdHJ1ZSBpZiB0aGVyZSBpcyBtb3JlIGRhdGEgdG8gYmVcbiAgICAgKiByZXRyaWV2ZWQgaW4gdGhpcyBkaXJlY3Rpb24gKGluIHdoaWNoIGNhc2Ugb25GaWxsUmVxdWVzdCBtYXkgYmVcbiAgICAgKiBjYWxsZWQgYWdhaW4gaW1tZWRpYXRlbHkpLCBvciBmYWxzZSBpZiB0aGVyZSBpcyBubyBtb3JlIGRhdGEgaW4gdGhpc1xuICAgICAqIGRpcmVjdG9uIChhdCB0aGlzIHRpbWUpIC0gd2hpY2ggd2lsbCBzdG9wIHRoZSBwYWdpbmF0aW9uIGN5Y2xlIHVudGlsXG4gICAgICogdGhlIHVzZXIgc2Nyb2xscyBhZ2Fpbi5cbiAgICAgKi9cbiAgICBvbkZpbGxSZXF1ZXN0PyhiYWNrd2FyZHM6IGJvb2xlYW4pOiBQcm9taXNlPGJvb2xlYW4+O1xuXG4gICAgLyogb25VbmZpbGxSZXF1ZXN0KGJhY2t3YXJkcyk6IGEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIG9uIHNjcm9sbCB3aGVuXG4gICAgICogdGhlcmUgYXJlIGNoaWxkcmVuIGVsZW1lbnRzIHRoYXQgYXJlIGZhciBvdXQgb2YgdmlldyBhbmQgY291bGQgYmUgcmVtb3ZlZFxuICAgICAqIHdpdGhvdXQgY2F1c2luZyBwYWdpbmF0aW9uIHRvIG9jY3VyLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgYWNjZXB0IGEgYm9vbGVhbiwgd2hpY2ggaXMgdHJ1ZSB0byBpbmRpY2F0ZSB0aGUgYmFjay90b3BcbiAgICAgKiBvZiB0aGUgcGFuZWwgYW5kIGZhbHNlIG90aGVyd2lzZSwgYW5kIGEgc2Nyb2xsIHRva2VuLCB3aGljaCByZWZlcnMgdG8gdGhlXG4gICAgICogZmlyc3QgZWxlbWVudCB0byByZW1vdmUgaWYgcmVtb3ZpbmcgZnJvbSB0aGUgZnJvbnQvYm90dG9tLCBhbmQgbGFzdCBlbGVtZW50XG4gICAgICogdG8gcmVtb3ZlIGlmIHJlbW92aW5nIGZyb20gdGhlIGJhY2svdG9wLlxuICAgICAqL1xuICAgIG9uVW5maWxsUmVxdWVzdD8oYmFja3dhcmRzOiBib29sZWFuLCBzY3JvbGxUb2tlbjogc3RyaW5nKTogdm9pZDtcblxuICAgIC8qIG9uU2Nyb2xsOiBhIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuZXZlciBhbnkgc2Nyb2xsIGhhcHBlbnMuXG4gICAgICovXG4gICAgb25TY3JvbGw/KGV2ZW50OiBFdmVudCk6IHZvaWQ7XG5cbiAgICAvKiBvblVzZXJTY3JvbGw6IGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGludGVyYWN0cyB3aXRoIHRoZSByb29tIHRpbWVsaW5lXG4gICAgICovXG4gICAgb25Vc2VyU2Nyb2xsPyhldmVudDogU3ludGhldGljRXZlbnQpOiB2b2lkO1xufVxuXG4vKiBUaGlzIGNvbXBvbmVudCBpbXBsZW1lbnRzIGFuIGludGVsbGlnZW50IHNjcm9sbGluZyBsaXN0LlxuICpcbiAqIEl0IHdyYXBzIGEgbGlzdCBvZiA8bGk+IGNoaWxkcmVuOyB3aGVuIGl0ZW1zIGFyZSBhZGRlZCB0byB0aGUgc3RhcnQgb3IgZW5kXG4gKiBvZiB0aGUgbGlzdCwgdGhlIHNjcm9sbCBwb3NpdGlvbiBpcyB1cGRhdGVkIHNvIHRoYXQgdGhlIHVzZXIgc3RpbGwgc2VlcyB0aGVcbiAqIHNhbWUgcG9zaXRpb24gaW4gdGhlIGxpc3QuXG4gKlxuICogSXQgYWxzbyBwcm92aWRlcyBhIGhvb2sgd2hpY2ggYWxsb3dzIHBhcmVudHMgdG8gcHJvdmlkZSBtb3JlIGxpc3QgZWxlbWVudHNcbiAqIHdoZW4gd2UgZ2V0IGNsb3NlIHRvIHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIGxpc3QuXG4gKlxuICogRWFjaCBjaGlsZCBlbGVtZW50IHNob3VsZCBoYXZlIGEgJ2RhdGEtc2Nyb2xsLXRva2VucycuIFRoaXMgc3RyaW5nIG9mXG4gKiBjb21tYS1zZXBhcmF0ZWQgdG9rZW5zIG1heSBjb250YWluIGEgc2luZ2xlIHRva2VuIG9yIG1hbnksIHdoZXJlIG1hbnkgaW5kaWNhdGVzXG4gKiB0aGF0IHRoZSBlbGVtZW50IGNvbnRhaW5zIGVsZW1lbnRzIHRoYXQgaGF2ZSBzY3JvbGwgdG9rZW5zIHRoZW1zZWx2ZXMuIFRoZSBmaXJzdFxuICogdG9rZW4gaW4gJ2RhdGEtc2Nyb2xsLXRva2VucycgaXMgdXNlZCB0byBzZXJpYWxpc2UgdGhlIHNjcm9sbCBzdGF0ZSwgYW5kIHJldHVybmVkXG4gKiBhcyB0aGUgJ3RyYWNrZWRTY3JvbGxUb2tlbicgYXR0cmlidXRlIGJ5IGdldFNjcm9sbFN0YXRlKCkuXG4gKlxuICogSU1QT1JUQU5UOiBJTkRJVklEVUFMIFRPS0VOUyBXSVRISU4gJ2RhdGEtc2Nyb2xsLXRva2VucycgTVVTVCBOT1QgQ09OVEFJTiBDT01NQVMuXG4gKlxuICogU29tZSBub3RlcyBhYm91dCB0aGUgaW1wbGVtZW50YXRpb246XG4gKlxuICogVGhlIHNhdmVkICdzY3JvbGxTdGF0ZScgY2FuIGV4aXN0IGluIG9uZSBvZiB0d28gc3RhdGVzOlxuICpcbiAqICAgLSBzdHVja0F0Qm90dG9tOiAodGhlIGRlZmF1bHQsIGFuZCByZXN0b3JlZCBieSByZXNldFNjcm9sbFN0YXRlKTogdGhlXG4gKiAgICAgdmlld3BvcnQgaXMgc2Nyb2xsZWQgZG93biBhcyBmYXIgYXMgaXQgY2FuIGJlLiBXaGVuIHRoZSBjaGlsZHJlbiBhcmVcbiAqICAgICB1cGRhdGVkLCB0aGUgc2Nyb2xsIHBvc2l0aW9uIHdpbGwgYmUgdXBkYXRlZCB0byBlbnN1cmUgaXQgaXMgc3RpbGwgYXRcbiAqICAgICB0aGUgYm90dG9tLlxuICpcbiAqICAgLSBmaXhlZCwgaW4gd2hpY2ggdGhlIHZpZXdwb3J0IGlzIGNvbmNlcHR1YWxseSB0aWVkIGF0IGEgc3BlY2lmaWMgc2Nyb2xsXG4gKiAgICAgb2Zmc2V0LiAgV2UgZG9uJ3Qgc2F2ZSB0aGUgYWJzb2x1dGUgc2Nyb2xsIG9mZnNldCwgYmVjYXVzZSB0aGF0IHdvdWxkIGJlXG4gKiAgICAgYWZmZWN0ZWQgYnkgd2luZG93IHdpZHRoLCB6b29tIGxldmVsLCBhbW91bnQgb2Ygc2Nyb2xsYmFjaywgZXRjLiBJbnN0ZWFkXG4gKiAgICAgd2Ugc2F2ZSBhbiBpZGVudGlmaWVyIGZvciB0aGUgbGFzdCBmdWxseS12aXNpYmxlIG1lc3NhZ2UsIGFuZCB0aGUgbnVtYmVyXG4gKiAgICAgb2YgcGl4ZWxzIHRoZSB3aW5kb3cgd2FzIHNjcm9sbGVkIGJlbG93IGl0IC0gd2hpY2ggaXMgaG9wZWZ1bGx5IG5lYXJcbiAqICAgICBlbm91Z2guXG4gKlxuICogVGhlICdzdGlja3lCb3R0b20nIHByb3BlcnR5IGNvbnRyb2xzIHRoZSBiZWhhdmlvdXIgd2hlbiB3ZSByZWFjaCB0aGUgYm90dG9tXG4gKiBvZiB0aGUgd2luZG93IChlaXRoZXIgdGhyb3VnaCBhIHVzZXItaW5pdGlhdGVkIHNjcm9sbCwgb3IgYnkgY2FsbGluZ1xuICogc2Nyb2xsVG9Cb3R0b20pLiBJZiBzdGlja3lCb3R0b20gaXMgZW5hYmxlZCwgdGhlIHNjcm9sbFN0YXRlIHdpbGwgZW50ZXJcbiAqICdzdHVja0F0Qm90dG9tJyBzdGF0ZSAtIGVuc3VyaW5nIHRoYXQgbmV3IGFkZGl0aW9ucyBjYXVzZSB0aGUgd2luZG93IHRvXG4gKiBzY3JvbGwgZG93biBmdXJ0aGVyLiBJZiBzdGlja3lCb3R0b20gaXMgZGlzYWJsZWQsIHdlIGp1c3Qgc2F2ZSB0aGUgc2Nyb2xsXG4gKiBvZmZzZXQgYXMgbm9ybWFsLlxuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgSVNjcm9sbFN0YXRlIHtcbiAgICBzdHVja0F0Qm90dG9tOiBib29sZWFuO1xuICAgIHRyYWNrZWROb2RlPzogSFRNTEVsZW1lbnQ7XG4gICAgdHJhY2tlZFNjcm9sbFRva2VuPzogc3RyaW5nO1xuICAgIGJvdHRvbU9mZnNldD86IG51bWJlcjtcbiAgICBwaXhlbE9mZnNldD86IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIElQcmV2ZW50U2hyaW5raW5nU3RhdGUge1xuICAgIG9mZnNldEZyb21Cb3R0b206IG51bWJlcjtcbiAgICBvZmZzZXROb2RlOiBIVE1MRWxlbWVudDtcbn1cblxuQHJlcGxhY2VhYmxlQ29tcG9uZW50KFwic3RydWN0dXJlcy5TY3JvbGxQYW5lbFwiKVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2Nyb2xsUGFuZWwgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8SVByb3BzPiB7XG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgc3RpY2t5Qm90dG9tOiB0cnVlLFxuICAgICAgICBzdGFydEF0Qm90dG9tOiB0cnVlLFxuICAgICAgICBvbkZpbGxSZXF1ZXN0OiBmdW5jdGlvbihiYWNrd2FyZHM6IGJvb2xlYW4pIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7IH0sXG4gICAgICAgIG9uVW5maWxsUmVxdWVzdDogZnVuY3Rpb24oYmFja3dhcmRzOiBib29sZWFuLCBzY3JvbGxUb2tlbjogc3RyaW5nKSB7fSxcbiAgICAgICAgb25TY3JvbGw6IGZ1bmN0aW9uKCkge30sXG4gICAgfTtcblxuICAgIHByaXZhdGUgcmVhZG9ubHkgcGVuZGluZ0ZpbGxSZXF1ZXN0czogUmVjb3JkPFwiYlwiIHwgXCJmXCIsIGJvb2xlYW4+ID0ge1xuICAgICAgICBiOiBudWxsLFxuICAgICAgICBmOiBudWxsLFxuICAgIH07XG4gICAgcHJpdmF0ZSByZWFkb25seSBpdGVtbGlzdCA9IGNyZWF0ZVJlZjxIVE1MT0xpc3RFbGVtZW50PigpO1xuICAgIHByaXZhdGUgdW5tb3VudGVkID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBzY3JvbGxUaW1lb3V0OiBUaW1lcjtcbiAgICAvLyBBcmUgd2UgY3VycmVudGx5IHRyeWluZyB0byBiYWNrZmlsbD9cbiAgICBwcml2YXRlIGlzRmlsbGluZzogYm9vbGVhbjtcbiAgICAvLyBJcyB0aGUgY3VycmVudCBmaWxsIHJlcXVlc3QgY2F1c2VkIGJ5IGEgcHJvcHMgdXBkYXRlP1xuICAgIHByaXZhdGUgaXNGaWxsaW5nRHVlVG9Qcm9wc1VwZGF0ZSA9IGZhbHNlO1xuICAgIC8vIERpZCBhbm90aGVyIHJlcXVlc3QgdG8gY2hlY2sgdGhlIGZpbGwgc3RhdGUgYXJyaXZlIHdoaWxlIHdlIHdlcmUgdHJ5aW5nIHRvIGJhY2tmaWxsP1xuICAgIHByaXZhdGUgZmlsbFJlcXVlc3RXaGlsZVJ1bm5pbmc6IGJvb2xlYW47XG4gICAgLy8gSXMgdGhhdCBuZXh0IGZpbGwgcmVxdWVzdCBzY2hlZHVsZWQgYmVjYXVzZSBvZiBhIHByb3BzIHVwZGF0ZT9cbiAgICBwcml2YXRlIHBlbmRpbmdGaWxsRHVlVG9Qcm9wc1VwZGF0ZTogYm9vbGVhbjtcbiAgICBwcml2YXRlIHNjcm9sbFN0YXRlOiBJU2Nyb2xsU3RhdGU7XG4gICAgcHJpdmF0ZSBwcmV2ZW50U2hyaW5raW5nU3RhdGU6IElQcmV2ZW50U2hyaW5raW5nU3RhdGU7XG4gICAgcHJpdmF0ZSB1bmZpbGxEZWJvdW5jZXI6IG51bWJlcjtcbiAgICBwcml2YXRlIGJvdHRvbUdyb3d0aDogbnVtYmVyO1xuICAgIHByaXZhdGUgcGFnZXM6IG51bWJlcjtcbiAgICBwcml2YXRlIGhlaWdodFVwZGF0ZUluUHJvZ3Jlc3M6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBkaXZTY3JvbGw6IEhUTUxEaXZFbGVtZW50O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIocHJvcHMsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLnJlc2l6ZU5vdGlmaWVyKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLnJlc2l6ZU5vdGlmaWVyLm9uKFwibWlkZGxlUGFuZWxSZXNpemVkTm9pc3lcIiwgdGhpcy5vblJlc2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlc2V0U2Nyb2xsU3RhdGUoKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5jaGVja1Njcm9sbCgpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgLy8gYWZ0ZXIgYWRkaW5nIGV2ZW50IHRpbGVzLCB3ZSBtYXkgbmVlZCB0byB0d2VhayB0aGUgc2Nyb2xsIChlaXRoZXIgdG9cbiAgICAgICAgLy8ga2VlcCBhdCB0aGUgYm90dG9tIG9mIHRoZSB0aW1lbGluZSwgb3IgdG8gbWFpbnRhaW4gdGhlIHZpZXcgYWZ0ZXJcbiAgICAgICAgLy8gYWRkaW5nIGV2ZW50cyB0byB0aGUgdG9wKS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhpcyB3aWxsIGFsc28gcmUtY2hlY2sgdGhlIGZpbGwgc3RhdGUsIGluIGNhc2UgdGhlIHBhZ2luYXRlIHdhcyBpbmFkZXF1YXRlXG4gICAgICAgIHRoaXMuY2hlY2tTY3JvbGwodHJ1ZSk7XG4gICAgICAgIHRoaXMudXBkYXRlUHJldmVudFNocmlua2luZygpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICAvLyBzZXQgYSBib29sZWFuIHRvIHNheSB3ZSd2ZSBiZWVuIHVubW91bnRlZCwgd2hpY2ggYW55IHBlbmRpbmdcbiAgICAgICAgLy8gcHJvbWlzZXMgY2FuIHVzZSB0byB0aHJvdyBhd2F5IHRoZWlyIHJlc3VsdHMuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIChXZSBjb3VsZCB1c2UgaXNNb3VudGVkKCksIGJ1dCBmYWNlYm9vayBoYXZlIGRlcHJlY2F0ZWQgdGhhdC4pXG4gICAgICAgIHRoaXMudW5tb3VudGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5yZXNpemVOb3RpZmllcikge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5yZXNpemVOb3RpZmllci5yZW1vdmVMaXN0ZW5lcihcIm1pZGRsZVBhbmVsUmVzaXplZE5vaXN5XCIsIHRoaXMub25SZXNpemUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvblNjcm9sbCA9IGV2ID0+IHtcbiAgICAgICAgLy8gc2tpcCBzY3JvbGwgZXZlbnRzIGNhdXNlZCBieSByZXNpemluZ1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5yZXNpemVOb3RpZmllciAmJiB0aGlzLnByb3BzLnJlc2l6ZU5vdGlmaWVyLmlzUmVzaXppbmcpIHJldHVybjtcbiAgICAgICAgZGVidWdsb2coXCJvblNjcm9sbFwiLCB0aGlzLmdldFNjcm9sbE5vZGUoKS5zY3JvbGxUb3ApO1xuICAgICAgICB0aGlzLnNjcm9sbFRpbWVvdXQucmVzdGFydCgpO1xuICAgICAgICB0aGlzLnNhdmVTY3JvbGxTdGF0ZSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVByZXZlbnRTaHJpbmtpbmcoKTtcbiAgICAgICAgdGhpcy5wcm9wcy5vblNjcm9sbChldik7XG4gICAgICAgIHRoaXMuY2hlY2tGaWxsU3RhdGUoKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvblJlc2l6ZSA9ICgpID0+IHtcbiAgICAgICAgZGVidWdsb2coXCJvblJlc2l6ZVwiKTtcbiAgICAgICAgdGhpcy5jaGVja1Njcm9sbCgpO1xuICAgICAgICAvLyB1cGRhdGUgcHJldmVudFNocmlua2luZ1N0YXRlIGlmIHByZXNlbnRcbiAgICAgICAgaWYgKHRoaXMucHJldmVudFNocmlua2luZ1N0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZlbnRTaHJpbmtpbmcoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBhZnRlciBhbiB1cGRhdGUgdG8gdGhlIGNvbnRlbnRzIG9mIHRoZSBwYW5lbCwgY2hlY2sgdGhhdCB0aGUgc2Nyb2xsIGlzXG4gICAgLy8gd2hlcmUgaXQgb3VnaHQgdG8gYmUsIGFuZCBzZXQgb2ZmIHBhZ2luYXRpb24gcmVxdWVzdHMgaWYgbmVjZXNzYXJ5LlxuICAgIHB1YmxpYyBjaGVja1Njcm9sbCA9IChpc0Zyb21Qcm9wc1VwZGF0ZSA9IGZhbHNlKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnVubW91bnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzdG9yZVNhdmVkU2Nyb2xsU3RhdGUoKTtcbiAgICAgICAgdGhpcy5jaGVja0ZpbGxTdGF0ZSgwLCBpc0Zyb21Qcm9wc1VwZGF0ZSk7XG4gICAgfTtcblxuICAgIC8vIHJldHVybiB0cnVlIGlmIHRoZSBjb250ZW50IGlzIGZ1bGx5IHNjcm9sbGVkIGRvd24gcmlnaHQgbm93OyBlbHNlIGZhbHNlLlxuICAgIC8vXG4gICAgLy8gbm90ZSB0aGF0IHRoaXMgaXMgaW5kZXBlbmRlbnQgb2YgdGhlICdzdHVja0F0Qm90dG9tJyBzdGF0ZSAtIGl0IGlzIHNpbXBseVxuICAgIC8vIGFib3V0IHdoZXRoZXIgdGhlIGNvbnRlbnQgaXMgc2Nyb2xsZWQgZG93biByaWdodCBub3csIGlycmVzcGVjdGl2ZSBvZlxuICAgIC8vIHdoZXRoZXIgaXQgd2lsbCBzdGF5IHRoYXQgd2F5IHdoZW4gdGhlIGNoaWxkcmVuIHVwZGF0ZS5cbiAgICBwdWJsaWMgaXNBdEJvdHRvbSA9ICgpID0+IHtcbiAgICAgICAgY29uc3Qgc24gPSB0aGlzLmdldFNjcm9sbE5vZGUoKTtcbiAgICAgICAgLy8gZnJhY3Rpb25hbCB2YWx1ZXMgKGJvdGggdG9vIGJpZyBhbmQgdG9vIHNtYWxsKVxuICAgICAgICAvLyBmb3Igc2Nyb2xsVG9wIGhhcHBlbiBvbiBjZXJ0YWluIGJyb3dzZXJzL3BsYXRmb3Jtc1xuICAgICAgICAvLyB3aGVuIHNjcm9sbGVkIGFsbCB0aGUgd2F5IGRvd24uIEUuZy4gQ2hyb21lIDcyIG9uIGRlYmlhbi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2UgdGhlcmVmb3JlIGxlYXZlIGEgYml0IG9mIHdpZ2dsZS1yb29tIGFuZCBhc3N1bWUgd2UncmUgYXQgdGhlXG4gICAgICAgIC8vIGJvdHRvbSBpZiB0aGUgdW5zY3JvbGxlZCBhcmVhIGlzIGxlc3MgdGhhbiBvbmUgcGl4ZWwgaGlnaC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gbm9uLXN0YW5kYXJkIERQSSBzZXR0aW5ncyBhbHNvIHNlZW0gdG8gaGF2ZSBlZmZlY3QgaGVyZSBhbmQgY2FuXG4gICAgICAgIC8vIGFjdHVhbGx5IGxlYWQgdG8gc2Nyb2xsVG9wK2NsaWVudEhlaWdodCBiZWluZyAqbGFyZ2VyKiB0aGFuXG4gICAgICAgIC8vIHNjcm9sbEhlaWdodC4gKG9ic2VydmVkIGluIGVsZW1lbnQtZGVza3RvcCBvbiBVYnVudHUgMjAuMDQpXG4gICAgICAgIC8vXG4gICAgICAgIHJldHVybiBzbi5zY3JvbGxIZWlnaHQgLSAoc24uc2Nyb2xsVG9wICsgc24uY2xpZW50SGVpZ2h0KSA8PSAxO1xuICAgIH07XG5cbiAgICAvLyByZXR1cm5zIHRoZSB2ZXJ0aWNhbCBoZWlnaHQgaW4gdGhlIGdpdmVuIGRpcmVjdGlvbiB0aGF0IGNhbiBiZSByZW1vdmVkIGZyb21cbiAgICAvLyB0aGUgY29udGVudCBib3ggKHdoaWNoIGhhcyBhIGhlaWdodCBvZiBzY3JvbGxIZWlnaHQsIHNlZSBjaGVja0ZpbGxTdGF0ZSkgd2l0aG91dFxuICAgIC8vIHBhZ2luYXRpb24gb2NjdXJpbmcuXG4gICAgLy9cbiAgICAvLyBwYWRkaW5nKiA9IFVOUEFHSU5BVElPTl9QQURESU5HXG4gICAgLy9cbiAgICAvLyAjIyMgUmVnaW9uIGRldGVybWluZWQgYXMgZXhjZXNzLlxuICAgIC8vXG4gICAgLy8gICAuLS0tLS0tLS0tLiAgICAgICAgICAgICAgICAgICAgICAgIC0gICAgICAgICAgICAgIC1cbiAgICAvLyAgIHwjIyMjIyMjIyN8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfFxuICAgIC8vICAgfCMjIyMjIyMjI3wgICAtICAgICAgICAgICAgICAgICAgICB8ICBzY3JvbGxUb3AgICB8XG4gICAgLy8gICB8ICAgICAgICAgfCAgIHwgcGFkZGluZyogICAgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAgICAvLyAgIHwgICAgICAgICB8ICAgfCAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfFxuICAgIC8vIC4tKy0tLS0tLS0tLSstLiAtICAtICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8XG4gICAgLy8gOiB8ICAgICAgICAgfCA6ICAgIHwgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAgICAvLyA6IHwgICAgICAgICB8IDogICAgfCAgY2xpZW50SGVpZ2h0ICAgfCAgICAgICAgICAgICAgfFxuICAgIC8vIDogfCAgICAgICAgIHwgOiAgICB8ICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8XG4gICAgLy8gLi0rLS0tLS0tLS0tKy0uICAgIC0gICAgICAgICAgICAgICAgIC0gICAgICAgICAgICAgIHxcbiAgICAvLyB8IHwgICAgICAgICB8IHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgIC8vIHwgfCAgICAgICAgIHwgfCAgICB8ICBjbGllbnRIZWlnaHQgICAgICAgICAgICAgICAgICB8IHNjcm9sbEhlaWdodFxuICAgIC8vIHwgfCAgICAgICAgIHwgfCAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gYC0rLS0tLS0tLS0tKy0nICAgIC0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyA6IHwgICAgICAgICB8IDogICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgIC8vIDogfCAgICAgICAgIHwgOiAgICB8ICBjbGllbnRIZWlnaHQgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gOiB8ICAgICAgICAgfCA6ICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyBgLSstLS0tLS0tLS0rLScgLSAgLSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgIC8vICAgfCAgICAgICAgIHwgICB8IHBhZGRpbmcqICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gICB8ICAgICAgICAgfCAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyAgIHwjIyMjIyMjIyN8ICAgLSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgIC8vICAgfCMjIyMjIyMjI3wgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gICBgLS0tLS0tLS0tJyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC1cbiAgICBwcml2YXRlIGdldEV4Y2Vzc0hlaWdodChiYWNrd2FyZHM6IGJvb2xlYW4pOiBudW1iZXIge1xuICAgICAgICBjb25zdCBzbiA9IHRoaXMuZ2V0U2Nyb2xsTm9kZSgpO1xuICAgICAgICBjb25zdCBjb250ZW50SGVpZ2h0ID0gdGhpcy5nZXRNZXNzYWdlc0hlaWdodCgpO1xuICAgICAgICBjb25zdCBsaXN0SGVpZ2h0ID0gdGhpcy5nZXRMaXN0SGVpZ2h0KCk7XG4gICAgICAgIGNvbnN0IGNsaXBwZWRIZWlnaHQgPSBjb250ZW50SGVpZ2h0IC0gbGlzdEhlaWdodDtcbiAgICAgICAgY29uc3QgdW5jbGlwcGVkU2Nyb2xsVG9wID0gc24uc2Nyb2xsVG9wICsgY2xpcHBlZEhlaWdodDtcblxuICAgICAgICBpZiAoYmFja3dhcmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5jbGlwcGVkU2Nyb2xsVG9wIC0gc24uY2xpZW50SGVpZ2h0IC0gVU5QQUdJTkFUSU9OX1BBRERJTkc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudEhlaWdodCAtICh1bmNsaXBwZWRTY3JvbGxUb3AgKyAyKnNuLmNsaWVudEhlaWdodCkgLSBVTlBBR0lOQVRJT05fUEFERElORztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIHRoZSBzY3JvbGwgc3RhdGUgYW5kIHNlbmQgb3V0IGJhY2tmaWxsIHJlcXVlc3RzIGlmIG5lY2Vzc2FyeS5cbiAgICBwdWJsaWMgY2hlY2tGaWxsU3RhdGUgPSBhc3luYyAoZGVwdGggPSAwLCBpc0Zyb21Qcm9wc1VwZGF0ZSA9IGZhbHNlKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgICAgIGlmICh0aGlzLnVubW91bnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNGaXJzdENhbGwgPSBkZXB0aCA9PT0gMDtcbiAgICAgICAgY29uc3Qgc24gPSB0aGlzLmdldFNjcm9sbE5vZGUoKTtcblxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBsZXNzIHRoYW4gYSBzY3JlZW5mdWwgb2YgbWVzc2FnZXMgYWJvdmUgb3IgYmVsb3cgdGhlXG4gICAgICAgIC8vIHZpZXdwb3J0LCB0cnkgdG8gZ2V0IHNvbWUgbW9yZSBtZXNzYWdlcy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gc2Nyb2xsVG9wIGlzIHRoZSBudW1iZXIgb2YgcGl4ZWxzIGJldHdlZW4gdGhlIHRvcCBvZiB0aGUgY29udGVudCBhbmRcbiAgICAgICAgLy8gICAgIHRoZSB0b3Agb2YgdGhlIHZpZXdwb3J0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBzY3JvbGxIZWlnaHQgaXMgdGhlIHRvdGFsIGhlaWdodCBvZiB0aGUgY29udGVudC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gY2xpZW50SGVpZ2h0IGlzIHRoZSBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0IChleGNsdWRpbmcgYm9yZGVycyxcbiAgICAgICAgLy8gbWFyZ2lucywgYW5kIHNjcm9sbGJhcnMpLlxuICAgICAgICAvL1xuICAgICAgICAvL1xuICAgICAgICAvLyAgIC4tLS0tLS0tLS0uICAgICAgICAgIC0gICAgICAgICAgICAgICAgIC1cbiAgICAgICAgLy8gICB8ICAgICAgICAgfCAgICAgICAgICB8ICBzY3JvbGxUb3AgICAgICB8XG4gICAgICAgIC8vIC4tKy0tLS0tLS0tLSstLiAgICAtICAgLSAgICAgICAgICAgICAgICAgfFxuICAgICAgICAvLyB8IHwgICAgICAgICB8IHwgICAgfCAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgfCB8ICAgIHwgIGNsaWVudEhlaWdodCAgICAgICB8IHNjcm9sbEhlaWdodFxuICAgICAgICAvLyB8IHwgICAgICAgICB8IHwgICAgfCAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgLy8gYC0rLS0tLS0tLS0tKy0nICAgIC0gICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgIC8vICAgfCAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAvLyAgIHwgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgLy8gICBgLS0tLS0tLS0tJyAgICAgICAgICAgICAgICAgICAgICAgICAgICAtXG4gICAgICAgIC8vXG5cbiAgICAgICAgLy8gYXMgZmlsbGluZyBpcyBhc3luYyBhbmQgcmVjdXJzaXZlLFxuICAgICAgICAvLyBkb24ndCBhbGxvdyBtb3JlIHRoYW4gMSBjaGFpbiBvZiBjYWxscyBjb25jdXJyZW50bHlcbiAgICAgICAgLy8gZG8gbWFrZSBhIG5vdGUgd2hlbiBhIG5ldyByZXF1ZXN0IGNvbWVzIGluIHdoaWxlIGFscmVhZHkgcnVubmluZyBvbmUsXG4gICAgICAgIC8vIHNvIHdlIGNhbiB0cmlnZ2VyIGEgbmV3IGNoYWluIG9mIGNhbGxzIG9uY2UgZG9uZS5cbiAgICAgICAgLy8gSG93ZXZlciwgd2UgbWFrZSBhbiBleGNlcHRpb24gZm9yIHdoZW4gd2UncmUgYWxyZWFkeSBmaWxsaW5nIGR1ZSB0byBhXG4gICAgICAgIC8vIHByb3BzIChvciBjaGlsZHJlbikgdXBkYXRlLCBiZWNhdXNlIHZlcnkgb2Z0ZW4gdGhlIGNoaWxkcmVuIGluY2x1ZGVcbiAgICAgICAgLy8gc3Bpbm5lcnMgdG8gc2F5IHdoZXRoZXIgd2UncmUgcGFnaW5hdGluZyBvciBub3QsIHNvIHRoaXMgd291bGQgY2F1c2VcbiAgICAgICAgLy8gaW5maW5pdGUgcGFnaW5hdGluZy5cbiAgICAgICAgaWYgKGlzRmlyc3RDYWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0ZpbGxpbmcgJiYgIXRoaXMuaXNGaWxsaW5nRHVlVG9Qcm9wc1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgIGRlYnVnbG9nKFwiaXNGaWxsaW5nOiBub3QgZW50ZXJpbmcgd2hpbGUgcmVxdWVzdCBpcyBvbmdvaW5nLCBtYXJraW5nIGZvciBhIHN1YnNlcXVlbnQgcmVxdWVzdFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGxSZXF1ZXN0V2hpbGVSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdGaWxsRHVlVG9Qcm9wc1VwZGF0ZSA9IGlzRnJvbVByb3BzVXBkYXRlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlYnVnbG9nKFwiaXNGaWxsaW5nOiBzZXR0aW5nXCIpO1xuICAgICAgICAgICAgdGhpcy5pc0ZpbGxpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5pc0ZpbGxpbmdEdWVUb1Byb3BzVXBkYXRlID0gaXNGcm9tUHJvcHNVcGRhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpdGVtbGlzdCA9IHRoaXMuaXRlbWxpc3QuY3VycmVudDtcbiAgICAgICAgY29uc3QgZmlyc3RUaWxlID0gaXRlbWxpc3QgJiYgaXRlbWxpc3QuZmlyc3RFbGVtZW50Q2hpbGQgYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUb3AgPSBmaXJzdFRpbGUgJiYgZmlyc3RUaWxlLm9mZnNldFRvcDtcbiAgICAgICAgY29uc3QgZmlsbFByb21pc2VzID0gW107XG5cbiAgICAgICAgLy8gaWYgc2Nyb2xsVG9wIGdldHMgdG8gMSBzY3JlZW4gZnJvbSB0aGUgdG9wIG9mIHRoZSBmaXJzdCB0aWxlLFxuICAgICAgICAvLyB0cnkgYmFja3dhcmQgZmlsbGluZ1xuICAgICAgICBpZiAoIWZpcnN0VGlsZSB8fCAoc24uc2Nyb2xsVG9wIC0gY29udGVudFRvcCkgPCBzbi5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gYmFjay1maWxsXG4gICAgICAgICAgICBmaWxsUHJvbWlzZXMucHVzaCh0aGlzLm1heWJlRmlsbChkZXB0aCwgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHNjcm9sbFRvcCBnZXRzIHRvIDIgc2NyZWVucyBmcm9tIHRoZSBlbmQgKHNvIDEgc2NyZWVuIGJlbG93IHZpZXdwb3J0KSxcbiAgICAgICAgLy8gdHJ5IGZvcndhcmQgZmlsbGluZ1xuICAgICAgICBpZiAoKHNuLnNjcm9sbEhlaWdodCAtIHNuLnNjcm9sbFRvcCkgPCBzbi5jbGllbnRIZWlnaHQgKiAyKSB7XG4gICAgICAgICAgICAvLyBuZWVkIHRvIGZvcndhcmQtZmlsbFxuICAgICAgICAgICAgZmlsbFByb21pc2VzLnB1c2godGhpcy5tYXliZUZpbGwoZGVwdGgsIGZhbHNlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsbFByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChmaWxsUHJvbWlzZXMpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRmlyc3RDYWxsKSB7XG4gICAgICAgICAgICBkZWJ1Z2xvZyhcImlzRmlsbGluZzogY2xlYXJpbmdcIik7XG4gICAgICAgICAgICB0aGlzLmlzRmlsbGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5pc0ZpbGxpbmdEdWVUb1Byb3BzVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5maWxsUmVxdWVzdFdoaWxlUnVubmluZykge1xuICAgICAgICAgICAgY29uc3QgcmVmaWxsRHVlVG9Qcm9wc1VwZGF0ZSA9IHRoaXMucGVuZGluZ0ZpbGxEdWVUb1Byb3BzVXBkYXRlO1xuICAgICAgICAgICAgdGhpcy5maWxsUmVxdWVzdFdoaWxlUnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nRmlsbER1ZVRvUHJvcHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tGaWxsU3RhdGUoMCwgcmVmaWxsRHVlVG9Qcm9wc1VwZGF0ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gY2hlY2sgaWYgdW5maWxsaW5nIGlzIHBvc3NpYmxlIGFuZCBzZW5kIGFuIHVuZmlsbCByZXF1ZXN0IGlmIG5lY2Vzc2FyeVxuICAgIHByaXZhdGUgY2hlY2tVbmZpbGxTdGF0ZShiYWNrd2FyZHM6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgbGV0IGV4Y2Vzc0hlaWdodCA9IHRoaXMuZ2V0RXhjZXNzSGVpZ2h0KGJhY2t3YXJkcyk7XG4gICAgICAgIGlmIChleGNlc3NIZWlnaHQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb3JpZ0V4Y2Vzc0hlaWdodCA9IGV4Y2Vzc0hlaWdodDtcblxuICAgICAgICBjb25zdCB0aWxlcyA9IHRoaXMuaXRlbWxpc3QuY3VycmVudC5jaGlsZHJlbjtcblxuICAgICAgICAvLyBUaGUgc2Nyb2xsIHRva2VuIG9mIHRoZSBmaXJzdC9sYXN0IHRpbGUgdG8gYmUgdW5wYWdpbmF0ZWRcbiAgICAgICAgbGV0IG1hcmtlclNjcm9sbFRva2VuID0gbnVsbDtcblxuICAgICAgICAvLyBTdWJ0cmFjdCBoZWlnaHRzIG9mIHRpbGVzIHRvIHNpbXVsYXRlIHRoZSB0aWxlcyBiZWluZyB1bnBhZ2luYXRlZCB1bnRpbCB0aGVcbiAgICAgICAgLy8gZXhjZXNzIGhlaWdodCBpcyBsZXNzIHRoYW4gdGhlIGhlaWdodCBvZiB0aGUgbmV4dCB0aWxlIHRvIHN1YnRyYWN0LiBUaGlzXG4gICAgICAgIC8vIHByZXZlbnRzIGV4Y2Vzc0hlaWdodCBiZWNvbWluZyBuZWdhdGl2ZSwgd2hpY2ggY291bGQgbGVhZCB0byBmdXR1cmVcbiAgICAgICAgLy8gcGFnaW5hdGlvbi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgYmFja3dhcmRzIGlzIHRydWUsIHdlIHVucGFnaW5hdGUgKHJlbW92ZSkgdGlsZXMgZnJvbSB0aGUgYmFjayAodG9wKS5cbiAgICAgICAgbGV0IHRpbGU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRpbGUgPSB0aWxlc1tiYWNrd2FyZHMgPyBpIDogdGlsZXMubGVuZ3RoIC0gMSAtIGldO1xuICAgICAgICAgICAgLy8gU3VidHJhY3QgaGVpZ2h0IG9mIHRpbGUgYXMgaWYgaXQgd2VyZSB1bnBhZ2luYXRlZFxuICAgICAgICAgICAgZXhjZXNzSGVpZ2h0IC09IHRpbGUuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgLy9JZiByZW1vdmluZyB0aGUgdGlsZSB3b3VsZCBsZWFkIHRvIGZ1dHVyZSBwYWdpbmF0aW9uLCBicmVhayBiZWZvcmUgc2V0dGluZyBzY3JvbGwgdG9rZW5cbiAgICAgICAgICAgIGlmICh0aWxlLmNsaWVudEhlaWdodCA+IGV4Y2Vzc0hlaWdodCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIHRpbGUgbWF5IG5vdCBoYXZlIGEgc2Nyb2xsIHRva2VuLCBzbyBndWFyZCBpdFxuICAgICAgICAgICAgaWYgKHRpbGUuZGF0YXNldC5zY3JvbGxUb2tlbnMpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXJTY3JvbGxUb2tlbiA9IHRpbGUuZGF0YXNldC5zY3JvbGxUb2tlbnMuc3BsaXQoJywnKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXJrZXJTY3JvbGxUb2tlbikge1xuICAgICAgICAgICAgLy8gVXNlIGEgZGVib3VuY2VyIHRvIHByZXZlbnQgbXVsdGlwbGUgdW5maWxsIGNhbGxzIGluIHF1aWNrIHN1Y2Nlc3Npb25cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdG8gbWFrZSB0aGUgdW5maWxsaW5nIHByb2Nlc3MgbGVzcyBhZ2dyZXNzaXZlXG4gICAgICAgICAgICBpZiAodGhpcy51bmZpbGxEZWJvdW5jZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy51bmZpbGxEZWJvdW5jZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51bmZpbGxEZWJvdW5jZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuZmlsbERlYm91bmNlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgZGVidWdsb2coXCJ1bmZpbGxpbmcgbm93XCIsIGJhY2t3YXJkcywgb3JpZ0V4Y2Vzc0hlaWdodCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblVuZmlsbFJlcXVlc3QoYmFja3dhcmRzLCBtYXJrZXJTY3JvbGxUb2tlbik7XG4gICAgICAgICAgICB9LCBVTkZJTExfUkVRVUVTVF9ERUJPVU5DRV9NUyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgcGVuZGluZyBmaWxsIHJlcXVlc3QuIElmIG5vdCwgc2V0IG9uZSBvZmYuXG4gICAgcHJpdmF0ZSBtYXliZUZpbGwoZGVwdGg6IG51bWJlciwgYmFja3dhcmRzOiBib29sZWFuKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGRpciA9IGJhY2t3YXJkcyA/ICdiJyA6ICdmJztcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0ZpbGxSZXF1ZXN0c1tkaXJdKSB7XG4gICAgICAgICAgICBkZWJ1Z2xvZyhcIkFscmVhZHkgYSBcIitkaXIrXCIgZmlsbCBpbiBwcm9ncmVzcyAtIG5vdCBzdGFydGluZyBhbm90aGVyXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVidWdsb2coXCJzdGFydGluZyBcIitkaXIrXCIgZmlsbFwiKTtcblxuICAgICAgICAvLyBvbkZpbGxSZXF1ZXN0IGNhbiBlbmQgdXAgY2FsbGluZyB1cyByZWN1cnNpdmVseSAodmlhIG9uU2Nyb2xsXG4gICAgICAgIC8vIGV2ZW50cykgc28gbWFrZSBzdXJlIHdlIHNldCB0aGlzIGJlZm9yZSBmaXJpbmcgb2ZmIHRoZSBjYWxsLlxuICAgICAgICB0aGlzLnBlbmRpbmdGaWxsUmVxdWVzdHNbZGlyXSA9IHRydWU7XG5cbiAgICAgICAgLy8gd2FpdCAxbXMgYmVmb3JlIHBhZ2luYXRpbmcsIGJlY2F1c2Ugb3RoZXJ3aXNlXG4gICAgICAgIC8vIHRoaXMgd2lsbCBibG9jayB0aGUgc2Nyb2xsIGV2ZW50IGhhbmRsZXIgZm9yICs3MDBtc1xuICAgICAgICAvLyBpZiBtZXNzYWdlcyBhcmUgYWxyZWFkeSBjYWNoZWQgaW4gbWVtb3J5LFxuICAgICAgICAvLyBUaGlzIHdvdWxkIGNhdXNlIGp1bXBpbmcgdG8gaGFwcGVuIG9uIENocm9tZS9tYWNPUy5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxKSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5vbkZpbGxSZXF1ZXN0KGJhY2t3YXJkcyk7XG4gICAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nRmlsbFJlcXVlc3RzW2Rpcl0gPSBmYWxzZTtcbiAgICAgICAgfSkudGhlbigoaGFzTW9yZVJlc3VsdHMpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnVubW91bnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVucGFnaW5hdGUgb25jZSBmaWxsaW5nIGlzIGNvbXBsZXRlXG4gICAgICAgICAgICB0aGlzLmNoZWNrVW5maWxsU3RhdGUoIWJhY2t3YXJkcyk7XG5cbiAgICAgICAgICAgIGRlYnVnbG9nKFwiXCIrZGlyK1wiIGZpbGwgY29tcGxldGU7IGhhc01vcmVSZXN1bHRzOlwiK2hhc01vcmVSZXN1bHRzKTtcbiAgICAgICAgICAgIGlmIChoYXNNb3JlUmVzdWx0cykge1xuICAgICAgICAgICAgICAgIC8vIGZ1cnRoZXIgcGFnaW5hdGlvbiByZXF1ZXN0cyBoYXZlIGJlZW4gZGlzYWJsZWQgdW50aWwgbm93LCBzb1xuICAgICAgICAgICAgICAgIC8vIGl0J3MgdGltZSB0byBjaGVjayB0aGUgZmlsbCBzdGF0ZSBhZ2FpbiBpbiBjYXNlIHRoZSBwYWdpbmF0aW9uXG4gICAgICAgICAgICAgICAgLy8gd2FzIGluc3VmZmljaWVudC5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGVja0ZpbGxTdGF0ZShkZXB0aCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiBnZXQgdGhlIGN1cnJlbnQgc2Nyb2xsIHN0YXRlLiBUaGlzIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuICAgICAqIHByb3BlcnRpZXM6XG4gICAgICpcbiAgICAgKiBib29sZWFuIHN0dWNrQXRCb3R0b206IHRydWUgaWYgd2UgYXJlIHRyYWNraW5nIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICogICBzY3JvbGwuIGZhbHNlIGlmIHdlIGFyZSB0cmFja2luZyBhIHBhcnRpY3VsYXIgY2hpbGQuXG4gICAgICpcbiAgICAgKiBzdHJpbmcgdHJhY2tlZFNjcm9sbFRva2VuOiB1bmRlZmluZWQgaWYgc3R1Y2tBdEJvdHRvbSBpcyB0cnVlOyBpZiBpdCBpc1xuICAgICAqICAgZmFsc2UsIHRoZSBmaXJzdCB0b2tlbiBpbiBkYXRhLXNjcm9sbC10b2tlbnMgb2YgdGhlIGNoaWxkIHdoaWNoIHdlIGFyZVxuICAgICAqICAgdHJhY2tpbmcuXG4gICAgICpcbiAgICAgKiBudW1iZXIgYm90dG9tT2Zmc2V0OiB1bmRlZmluZWQgaWYgc3R1Y2tBdEJvdHRvbSBpcyB0cnVlOyBpZiBpdCBpcyBmYWxzZSxcbiAgICAgKiAgIHRoZSBudW1iZXIgb2YgcGl4ZWxzIHRoZSBib3R0b20gb2YgdGhlIHRyYWNrZWQgY2hpbGQgaXMgYWJvdmUgdGhlXG4gICAgICogICBib3R0b20gb2YgdGhlIHNjcm9sbCBwYW5lbC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0U2Nyb2xsU3RhdGUgPSAoKTogSVNjcm9sbFN0YXRlID0+IHRoaXMuc2Nyb2xsU3RhdGU7XG5cbiAgICAvKiByZXNldCB0aGUgc2F2ZWQgc2Nyb2xsIHN0YXRlLlxuICAgICAqXG4gICAgICogVGhpcyBpcyB1c2VmdWwgaWYgdGhlIGxpc3QgaXMgYmVpbmcgcmVwbGFjZWQsIGFuZCB5b3UgZG9uJ3Qgd2FudCB0b1xuICAgICAqIHByZXNlcnZlIHNjcm9sbCBldmVuIGlmIG5ldyBjaGlsZHJlbiBoYXBwZW4gdG8gaGF2ZSB0aGUgc2FtZSBzY3JvbGxcbiAgICAgKiB0b2tlbnMgYXMgb2xkIG9uZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIHdpbGwgY2F1c2UgdGhlIHZpZXdwb3J0IHRvIGJlIHNjcm9sbGVkIGRvd24gdG8gdGhlIGJvdHRvbSBvbiB0aGVcbiAgICAgKiBuZXh0IHVwZGF0ZSBvZiB0aGUgY2hpbGQgbGlzdC4gVGhpcyBpcyBkaWZmZXJlbnQgdG8gc2Nyb2xsVG9Cb3R0b20oKSxcbiAgICAgKiB3aGljaCB3b3VsZCBzYXZlIHRoZSBjdXJyZW50IGJvdHRvbS1tb3N0IGNoaWxkIGFzIHRoZSBhY3RpdmUgb25lIChzbyBpc1xuICAgICAqIG5vIHVzZSBpZiBubyBjaGlsZHJlbiBleGlzdCB5ZXQsIG9yIGlmIHlvdSBhcmUgYWJvdXQgdG8gcmVwbGFjZSB0aGVcbiAgICAgKiBjaGlsZCBsaXN0LilcbiAgICAgKi9cbiAgICBwdWJsaWMgcmVzZXRTY3JvbGxTdGF0ZSA9ICgpOiB2b2lkID0+IHtcbiAgICAgICAgdGhpcy5zY3JvbGxTdGF0ZSA9IHtcbiAgICAgICAgICAgIHN0dWNrQXRCb3R0b206IHRoaXMucHJvcHMuc3RhcnRBdEJvdHRvbSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ib3R0b21Hcm93dGggPSAwO1xuICAgICAgICB0aGlzLnBhZ2VzID0gMDtcbiAgICAgICAgdGhpcy5zY3JvbGxUaW1lb3V0ID0gbmV3IFRpbWVyKDEwMCk7XG4gICAgICAgIHRoaXMuaGVpZ2h0VXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBqdW1wIHRvIHRoZSB0b3Agb2YgdGhlIGNvbnRlbnQuXG4gICAgICovXG4gICAgcHVibGljIHNjcm9sbFRvVG9wID0gKCk6IHZvaWQgPT4ge1xuICAgICAgICB0aGlzLmdldFNjcm9sbE5vZGUoKS5zY3JvbGxUb3AgPSAwO1xuICAgICAgICB0aGlzLnNhdmVTY3JvbGxTdGF0ZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBqdW1wIHRvIHRoZSBib3R0b20gb2YgdGhlIGNvbnRlbnQuXG4gICAgICovXG4gICAgcHVibGljIHNjcm9sbFRvQm90dG9tID0gKCk6IHZvaWQgPT4ge1xuICAgICAgICAvLyB0aGUgZWFzaWVzdCB3YXkgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHNjcm9sbCBzdGF0ZSBpcyBjb3JyZWN0bHlcbiAgICAgICAgLy8gc2F2ZWQgaXMgdG8gZG8gdGhlIHNjcm9sbCwgdGhlbiBzYXZlIHRoZSB1cGRhdGVkIHN0YXRlLiAoQ2FsY3VsYXRpbmdcbiAgICAgICAgLy8gaXQgb3Vyc2VsdmVzIGlzIGhhcmQsIGFuZCB3ZSBjYW4ndCByZWx5IG9uIGFuIG9uU2Nyb2xsIGNhbGxiYWNrXG4gICAgICAgIC8vIGhhcHBlbmluZywgc2luY2UgdGhlcmUgbWF5IGJlIG5vIHVzZXItdmlzaWJsZSBjaGFuZ2UgaGVyZSkuXG4gICAgICAgIGNvbnN0IHNuID0gdGhpcy5nZXRTY3JvbGxOb2RlKCk7XG4gICAgICAgIHNuLnNjcm9sbFRvcCA9IHNuLnNjcm9sbEhlaWdodDtcbiAgICAgICAgdGhpcy5zYXZlU2Nyb2xsU3RhdGUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGFnZSB1cC9kb3duLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG11bHQ6IC0xIHRvIHBhZ2UgdXAsICsxIHRvIHBhZ2UgZG93blxuICAgICAqL1xuICAgIHB1YmxpYyBzY3JvbGxSZWxhdGl2ZSA9IChtdWx0OiBudW1iZXIpOiB2b2lkID0+IHtcbiAgICAgICAgY29uc3Qgc2Nyb2xsTm9kZSA9IHRoaXMuZ2V0U2Nyb2xsTm9kZSgpO1xuICAgICAgICBjb25zdCBkZWx0YSA9IG11bHQgKiBzY3JvbGxOb2RlLmNsaWVudEhlaWdodCAqIDAuOTtcbiAgICAgICAgc2Nyb2xsTm9kZS5zY3JvbGxCeSgwLCBkZWx0YSk7XG4gICAgICAgIHRoaXMuc2F2ZVNjcm9sbFN0YXRlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNjcm9sbCB1cC9kb3duIGluIHJlc3BvbnNlIHRvIGEgc2Nyb2xsIGtleVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBldiB0aGUga2V5Ym9hcmQgZXZlbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgaGFuZGxlU2Nyb2xsS2V5ID0gKGV2OiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAgIGxldCBpc1Njcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICBjb25zdCByb29tQWN0aW9uID0gZ2V0S2V5QmluZGluZ3NNYW5hZ2VyKCkuZ2V0Um9vbUFjdGlvbihldik7XG4gICAgICAgIHN3aXRjaCAocm9vbUFjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBSb29tQWN0aW9uLlNjcm9sbFVwOlxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsUmVsYXRpdmUoLTEpO1xuICAgICAgICAgICAgICAgIGlzU2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUm9vbUFjdGlvbi5Sb29tU2Nyb2xsRG93bjpcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFJlbGF0aXZlKDEpO1xuICAgICAgICAgICAgICAgIGlzU2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUm9vbUFjdGlvbi5KdW1wVG9GaXJzdE1lc3NhZ2U6XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb1RvcCgpO1xuICAgICAgICAgICAgICAgIGlzU2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUm9vbUFjdGlvbi5KdW1wVG9MYXRlc3RNZXNzYWdlOlxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9Cb3R0b20oKTtcbiAgICAgICAgICAgICAgICBpc1Njcm9sbGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU2Nyb2xsaW5nICYmIHRoaXMucHJvcHMub25Vc2VyU2Nyb2xsKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uVXNlclNjcm9sbChldik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyogU2Nyb2xsIHRoZSBwYW5lbCB0byBicmluZyB0aGUgRE9NIG5vZGUgd2l0aCB0aGUgc2Nyb2xsIHRva2VuXG4gICAgICogYHNjcm9sbFRva2VuYCBpbnRvIHZpZXcuXG4gICAgICpcbiAgICAgKiBvZmZzZXRCYXNlIGdpdmVzIHRoZSByZWZlcmVuY2UgcG9pbnQgZm9yIHRoZSBwaXhlbE9mZnNldC4gMCBtZWFucyB0aGVcbiAgICAgKiB0b3Agb2YgdGhlIGNvbnRhaW5lciwgMSBtZWFucyB0aGUgYm90dG9tLCBhbmQgZnJhY3Rpb25hbCB2YWx1ZXMgbWVhblxuICAgICAqIHNvbWV3aGVyZSBpbiB0aGUgbWlkZGxlLiBJZiBvbWl0dGVkLCBpdCBkZWZhdWx0cyB0byAwLlxuICAgICAqXG4gICAgICogcGl4ZWxPZmZzZXQgZ2l2ZXMgdGhlIG51bWJlciBvZiBwaXhlbHMgKmFib3ZlKiB0aGUgb2Zmc2V0QmFzZSB0aGF0IHRoZVxuICAgICAqIG5vZGUgKHNwZWNpZmljYWxseSwgdGhlIGJvdHRvbSBvZiBpdCkgd2lsbCBiZSBwb3NpdGlvbmVkLiBJZiBvbWl0dGVkLCBpdFxuICAgICAqIGRlZmF1bHRzIHRvIDAuXG4gICAgICovXG4gICAgcHVibGljIHNjcm9sbFRvVG9rZW4gPSAoc2Nyb2xsVG9rZW46IHN0cmluZywgcGl4ZWxPZmZzZXQ6IG51bWJlciwgb2Zmc2V0QmFzZTogbnVtYmVyKTogdm9pZCA9PiB7XG4gICAgICAgIHBpeGVsT2Zmc2V0ID0gcGl4ZWxPZmZzZXQgfHwgMDtcbiAgICAgICAgb2Zmc2V0QmFzZSA9IG9mZnNldEJhc2UgfHwgMDtcblxuICAgICAgICAvLyBzZXQgdGhlIHRyYWNrZWRTY3JvbGxUb2tlbiBzbyB3ZSBjYW4gZ2V0IHRoZSBub2RlIHRocm91Z2ggZ2V0VHJhY2tlZE5vZGVcbiAgICAgICAgdGhpcy5zY3JvbGxTdGF0ZSA9IHtcbiAgICAgICAgICAgIHN0dWNrQXRCb3R0b206IGZhbHNlLFxuICAgICAgICAgICAgdHJhY2tlZFNjcm9sbFRva2VuOiBzY3JvbGxUb2tlbixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdHJhY2tlZE5vZGUgPSB0aGlzLmdldFRyYWNrZWROb2RlKCk7XG4gICAgICAgIGNvbnN0IHNjcm9sbE5vZGUgPSB0aGlzLmdldFNjcm9sbE5vZGUoKTtcbiAgICAgICAgaWYgKHRyYWNrZWROb2RlKSB7XG4gICAgICAgICAgICAvLyBzZXQgdGhlIHNjcm9sbFRvcCB0byB0aGUgcG9zaXRpb24gd2Ugd2FudC5cbiAgICAgICAgICAgIC8vIG5vdGUgdGhvdWdoLCB0aGF0IHRoaXMgbWlnaHQgbm90IHN1Y2NlZWQgaWYgdGhlIGNvbWJpbmF0aW9uIG9mIG9mZnNldEJhc2UgYW5kIHBpeGVsT2Zmc2V0XG4gICAgICAgICAgICAvLyB3b3VsZCBwb3NpdGlvbiB0aGUgdHJhY2tlZE5vZGUgdG93YXJkcyB0aGUgdG9wIG9mIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgICAgIC8vIFRoaXMgYmVjYXVzZSB3aGVuIHNldHRpbmcgdGhlIHNjcm9sbFRvcCBvbmx5IDEwIG9yIHNvIGV2ZW50cyBtaWdodCBiZSBsb2FkZWQsXG4gICAgICAgICAgICAvLyBub3QgZ2l2aW5nIGVub3VnaCBjb250ZW50IGJlbG93IHRoZSB0cmFja2VkTm9kZSB0byBzY3JvbGwgZG93bndhcmRzXG4gICAgICAgICAgICAvLyBlbm91Z2ggc28gaXQgZW5kcyB1cCBpbiB0aGUgdG9wIG9mIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgICAgIGRlYnVnbG9nKFwic2Nyb2xsVG9rZW46IHNldHRpbmcgc2Nyb2xsVG9wXCIsIHsgb2Zmc2V0QmFzZSwgcGl4ZWxPZmZzZXQsIG9mZnNldFRvcDogdHJhY2tlZE5vZGUub2Zmc2V0VG9wIH0pO1xuICAgICAgICAgICAgc2Nyb2xsTm9kZS5zY3JvbGxUb3AgPSAodHJhY2tlZE5vZGUub2Zmc2V0VG9wIC0gKHNjcm9sbE5vZGUuY2xpZW50SGVpZ2h0ICogb2Zmc2V0QmFzZSkpICsgcGl4ZWxPZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLnNhdmVTY3JvbGxTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByaXZhdGUgc2F2ZVNjcm9sbFN0YXRlKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5zdGlja3lCb3R0b20gJiYgdGhpcy5pc0F0Qm90dG9tKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsU3RhdGUgPSB7IHN0dWNrQXRCb3R0b206IHRydWUgfTtcbiAgICAgICAgICAgIGRlYnVnbG9nKFwic2F2ZWQgc3R1Y2tBdEJvdHRvbSBzdGF0ZVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNjcm9sbE5vZGUgPSB0aGlzLmdldFNjcm9sbE5vZGUoKTtcbiAgICAgICAgY29uc3Qgdmlld3BvcnRCb3R0b20gPSBzY3JvbGxOb2RlLnNjcm9sbEhlaWdodCAtIChzY3JvbGxOb2RlLnNjcm9sbFRvcCArIHNjcm9sbE5vZGUuY2xpZW50SGVpZ2h0KTtcblxuICAgICAgICBjb25zdCBpdGVtbGlzdCA9IHRoaXMuaXRlbWxpc3QuY3VycmVudDtcbiAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBpdGVtbGlzdC5jaGlsZHJlbjtcbiAgICAgICAgbGV0IG5vZGUgPSBudWxsO1xuXG4gICAgICAgIC8vIFRPRE86IGRvIGEgYmluYXJ5IHNlYXJjaCBoZXJlLCBhcyBpdGVtcyBhcmUgc29ydGVkIGJ5IG9mZnNldFRvcFxuICAgICAgICAvLyBsb29wIGJhY2t3YXJkcywgZnJvbSBib3R0b20tbW9zdCBtZXNzYWdlIChhcyB0aGF0IGlzIHRoZSBtb3N0IGNvbW1vbiBjYXNlKVxuICAgICAgICBmb3IgKGxldCBpID0gbWVzc2FnZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2VzW2ldIGFzIEhUTUxFbGVtZW50KS5kYXRhc2V0LnNjcm9sbFRva2Vucykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG1lc3NhZ2VzW2ldO1xuICAgICAgICAgICAgLy8gYnJlYWsgYXQgdGhlIGZpcnN0IG1lc3NhZ2UgKGNvbWluZyBmcm9tIHRoZSBib3R0b20pXG4gICAgICAgICAgICAvLyB0aGF0IGhhcyBpdCdzIG9mZnNldFRvcCBhYm92ZSB0aGUgYm90dG9tIG9mIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgICAgIGlmICh0aGlzLnRvcEZyb21Cb3R0b20obm9kZSkgPiB2aWV3cG9ydEJvdHRvbSkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGlzIG5vZGUgYXMgdGhlIHNjcm9sbFRva2VuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIGRlYnVnbG9nKFwidW5hYmxlIHRvIHNhdmUgc2Nyb2xsIHN0YXRlOiBmb3VuZCBubyBjaGlsZHJlbiBpbiB0aGUgdmlld3BvcnRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2Nyb2xsVG9rZW4gPSBub2RlLmRhdGFzZXQuc2Nyb2xsVG9rZW5zLnNwbGl0KCcsJylbMF07XG4gICAgICAgIGRlYnVnbG9nKFwic2F2aW5nIGFuY2hvcmVkIHNjcm9sbCBzdGF0ZSB0byBtZXNzYWdlXCIsIG5vZGUgJiYgbm9kZS5pbm5lclRleHQsIHNjcm9sbFRva2VuKTtcbiAgICAgICAgY29uc3QgYm90dG9tT2Zmc2V0ID0gdGhpcy50b3BGcm9tQm90dG9tKG5vZGUpO1xuICAgICAgICB0aGlzLnNjcm9sbFN0YXRlID0ge1xuICAgICAgICAgICAgc3R1Y2tBdEJvdHRvbTogZmFsc2UsXG4gICAgICAgICAgICB0cmFja2VkTm9kZTogbm9kZSxcbiAgICAgICAgICAgIHRyYWNrZWRTY3JvbGxUb2tlbjogc2Nyb2xsVG9rZW4sXG4gICAgICAgICAgICBib3R0b21PZmZzZXQ6IGJvdHRvbU9mZnNldCxcbiAgICAgICAgICAgIHBpeGVsT2Zmc2V0OiBib3R0b21PZmZzZXQgLSB2aWV3cG9ydEJvdHRvbSwgLy9uZWVkZWQgZm9yIHJlc3RvcmluZyB0aGUgc2Nyb2xsIHBvc2l0aW9uIHdoZW4gY29taW5nIGJhY2sgdG8gdGhlIHJvb21cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIHJlc3RvcmVTYXZlZFNjcm9sbFN0YXRlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBzY3JvbGxTdGF0ZSA9IHRoaXMuc2Nyb2xsU3RhdGU7XG5cbiAgICAgICAgaWYgKHNjcm9sbFN0YXRlLnN0dWNrQXRCb3R0b20pIHtcbiAgICAgICAgICAgIGNvbnN0IHNuID0gdGhpcy5nZXRTY3JvbGxOb2RlKCk7XG4gICAgICAgICAgICBpZiAoc24uc2Nyb2xsVG9wICE9PSBzbi5zY3JvbGxIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBzbi5zY3JvbGxUb3AgPSBzbi5zY3JvbGxIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2Nyb2xsU3RhdGUudHJhY2tlZFNjcm9sbFRva2VuKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtbGlzdCA9IHRoaXMuaXRlbWxpc3QuY3VycmVudDtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrZWROb2RlID0gdGhpcy5nZXRUcmFja2VkTm9kZSgpO1xuICAgICAgICAgICAgaWYgKHRyYWNrZWROb2RlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Qm90dG9tT2Zmc2V0ID0gdGhpcy50b3BGcm9tQm90dG9tKHRyYWNrZWROb2RlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBib3R0b21EaWZmID0gbmV3Qm90dG9tT2Zmc2V0IC0gc2Nyb2xsU3RhdGUuYm90dG9tT2Zmc2V0O1xuICAgICAgICAgICAgICAgIHRoaXMuYm90dG9tR3Jvd3RoICs9IGJvdHRvbURpZmY7XG4gICAgICAgICAgICAgICAgc2Nyb2xsU3RhdGUuYm90dG9tT2Zmc2V0ID0gbmV3Qm90dG9tT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0hlaWdodCA9IGAke3RoaXMuZ2V0TGlzdEhlaWdodCgpfXB4YDtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbWxpc3Quc3R5bGUuaGVpZ2h0ICE9PSBuZXdIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbWxpc3Quc3R5bGUuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWJ1Z2xvZyhcImJhbGFuY2luZyBoZWlnaHQgYmVjYXVzZSBtZXNzYWdlcyBiZWxvdyB2aWV3cG9ydCBncmV3IGJ5XCIsIGJvdHRvbURpZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5oZWlnaHRVcGRhdGVJblByb2dyZXNzKSB7XG4gICAgICAgICAgICB0aGlzLmhlaWdodFVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZUhlaWdodCgpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodFVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnbG9nKFwibm90IHVwZGF0aW5nIGhlaWdodCBiZWNhdXNlIHJlcXVlc3QgYWxyZWFkeSBpbiBwcm9ncmVzc1wiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5lZWQgYSBiZXR0ZXIgbmFtZSB0aGF0IGFsc28gaW5kaWNhdGVzIHRoaXMgd2lsbCBjaGFuZ2Ugc2Nyb2xsVG9wPyBSZWJhbGFuY2UgaGVpZ2h0PyBSZXZlYWwgY29udGVudD9cbiAgICBwcml2YXRlIGFzeW5jIHVwZGF0ZUhlaWdodCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgLy8gd2FpdCB1bnRpbCB1c2VyIGhhcyBzdG9wcGVkIHNjcm9sbGluZ1xuICAgICAgICBpZiAodGhpcy5zY3JvbGxUaW1lb3V0LmlzUnVubmluZygpKSB7XG4gICAgICAgICAgICBkZWJ1Z2xvZyhcInVwZGF0ZUhlaWdodCB3YWl0aW5nIGZvciBzY3JvbGxpbmcgdG8gZW5kIC4uLiBcIik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNjcm9sbFRpbWVvdXQuZmluaXNoZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnbG9nKFwidXBkYXRlSGVpZ2h0IGdldHRpbmcgc3RyYWlnaHQgdG8gYnVzaW5lc3MsIG5vIHNjcm9sbGluZyBnb2luZyBvbi5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBtaWdodCBoYXZlIHVubW91bnRlZCBzaW5jZSB0aGUgdGltZXIgZmluaXNoZWQsIHNvIGFib3J0IGlmIHNvLlxuICAgICAgICBpZiAodGhpcy51bm1vdW50ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNuID0gdGhpcy5nZXRTY3JvbGxOb2RlKCk7XG4gICAgICAgIGNvbnN0IGl0ZW1saXN0ID0gdGhpcy5pdGVtbGlzdC5jdXJyZW50O1xuICAgICAgICBjb25zdCBjb250ZW50SGVpZ2h0ID0gdGhpcy5nZXRNZXNzYWdlc0hlaWdodCgpO1xuICAgICAgICBjb25zdCBtaW5IZWlnaHQgPSBzbi5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWF4KG1pbkhlaWdodCwgY29udGVudEhlaWdodCk7XG4gICAgICAgIHRoaXMucGFnZXMgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gUEFHRV9TSVpFKTtcbiAgICAgICAgY29uc3QgZGlzcGxheVNjcm9sbGJhciA9IGNvbnRlbnRIZWlnaHQgPiBtaW5IZWlnaHQ7XG4gICAgICAgIHNuLmRhdGFzZXQuc2Nyb2xsYmFyID0gZGlzcGxheVNjcm9sbGJhci50b1N0cmluZygpO1xuICAgICAgICB0aGlzLmJvdHRvbUdyb3d0aCA9IDA7XG4gICAgICAgIGNvbnN0IG5ld0hlaWdodCA9IGAke3RoaXMuZ2V0TGlzdEhlaWdodCgpfXB4YDtcblxuICAgICAgICBjb25zdCBzY3JvbGxTdGF0ZSA9IHRoaXMuc2Nyb2xsU3RhdGU7XG4gICAgICAgIGlmIChzY3JvbGxTdGF0ZS5zdHVja0F0Qm90dG9tKSB7XG4gICAgICAgICAgICBpZiAoaXRlbWxpc3Quc3R5bGUuaGVpZ2h0ICE9PSBuZXdIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBpdGVtbGlzdC5zdHlsZS5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc24uc2Nyb2xsVG9wICE9PSBzbi5zY3JvbGxIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBzbi5zY3JvbGxUb3AgPSBzbi5zY3JvbGxIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWJ1Z2xvZyhcInVwZGF0ZUhlaWdodCB0b1wiLCBuZXdIZWlnaHQpO1xuICAgICAgICB9IGVsc2UgaWYgKHNjcm9sbFN0YXRlLnRyYWNrZWRTY3JvbGxUb2tlbikge1xuICAgICAgICAgICAgY29uc3QgdHJhY2tlZE5vZGUgPSB0aGlzLmdldFRyYWNrZWROb2RlKCk7XG4gICAgICAgICAgICAvLyBpZiB0aGUgdGltZWxpbmUgaGFzIGJlZW4gcmVsb2FkZWRcbiAgICAgICAgICAgIC8vIHRoaXMgY2FuIGJlIGNhbGxlZCBiZWZvcmUgc2Nyb2xsVG9Cb3R0b20gb3Igd2hhdGV2ZXIgaGFzIGJlZW4gY2FsbGVkXG4gICAgICAgICAgICAvLyBzbyBkb24ndCBkbyBhbnl0aGluZyBpZiB0aGUgbm9kZSBoYXMgZGlzYXBwZWFyZWQgZnJvbVxuICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnRseSBmaWxsZWQgcGllY2Ugb2YgdGhlIHRpbWVsaW5lXG4gICAgICAgICAgICBpZiAodHJhY2tlZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRUb3AgPSB0cmFja2VkTm9kZS5vZmZzZXRUb3A7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1saXN0LnN0eWxlLmhlaWdodCAhPT0gbmV3SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1saXN0LnN0eWxlLmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VG9wID0gdHJhY2tlZE5vZGUub2Zmc2V0VG9wO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvcERpZmYgPSBuZXdUb3AgLSBvbGRUb3A7XG4gICAgICAgICAgICAgICAgLy8gaW1wb3J0YW50IHRvIHNjcm9sbCBieSBhIHJlbGF0aXZlIGFtb3VudCBhc1xuICAgICAgICAgICAgICAgIC8vIHJlYWRpbmcgc2Nyb2xsVG9wIGFuZCB0aGVuIHNldHRpbmcgaXQgbWlnaHRcbiAgICAgICAgICAgICAgICAvLyB5aWVsZCBvdXQgb2YgZGF0ZSB2YWx1ZXMgYW5kIGNhdXNlIGEganVtcFxuICAgICAgICAgICAgICAgIC8vIHdoZW4gc2V0dGluZyBpdFxuICAgICAgICAgICAgICAgIHNuLnNjcm9sbEJ5KDAsIHRvcERpZmYpO1xuICAgICAgICAgICAgICAgIGRlYnVnbG9nKFwidXBkYXRlSGVpZ2h0IHRvXCIsIHsgbmV3SGVpZ2h0LCB0b3BEaWZmIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUcmFja2VkTm9kZSgpOiBIVE1MRWxlbWVudCB7XG4gICAgICAgIGNvbnN0IHNjcm9sbFN0YXRlID0gdGhpcy5zY3JvbGxTdGF0ZTtcbiAgICAgICAgY29uc3QgdHJhY2tlZE5vZGUgPSBzY3JvbGxTdGF0ZS50cmFja2VkTm9kZTtcblxuICAgICAgICBpZiAoIXRyYWNrZWROb2RlIHx8ICF0cmFja2VkTm9kZS5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICBsZXQgbm9kZTtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gdGhpcy5pdGVtbGlzdC5jdXJyZW50LmNoaWxkcmVuO1xuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsVG9rZW4gPSBzY3JvbGxTdGF0ZS50cmFja2VkU2Nyb2xsVG9rZW47XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBtZXNzYWdlcy5sZW5ndGgtMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gbWVzc2FnZXNbaV0gYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgLy8gJ2RhdGEtc2Nyb2xsLXRva2VucycgaXMgYSBET01TdHJpbmcgb2YgY29tbWEtc2VwYXJhdGVkIHNjcm9sbCB0b2tlbnNcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBtaWdodCBvbmx5IGJlIG9uZSBzY3JvbGwgdG9rZW5cbiAgICAgICAgICAgICAgICBpZiAobS5kYXRhc2V0LnNjcm9sbFRva2VucyAmJlxuICAgICAgICAgICAgICAgICAgICBtLmRhdGFzZXQuc2Nyb2xsVG9rZW5zLnNwbGl0KCcsJykuaW5kZXhPZihzY3JvbGxUb2tlbikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBtO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGRlYnVnbG9nKFwiaGFkIHRvIGZpbmQgdHJhY2tlZCBub2RlIGFnYWluIGZvciBcIiArIHNjcm9sbFN0YXRlLnRyYWNrZWRTY3JvbGxUb2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY3JvbGxTdGF0ZS50cmFja2VkTm9kZSA9IG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNjcm9sbFN0YXRlLnRyYWNrZWROb2RlKSB7XG4gICAgICAgICAgICBkZWJ1Z2xvZyhcIk5vIG5vZGUgd2l0aCA7ICdcIitzY3JvbGxTdGF0ZS50cmFja2VkU2Nyb2xsVG9rZW4rXCInXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjcm9sbFN0YXRlLnRyYWNrZWROb2RlO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0TGlzdEhlaWdodCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3R0b21Hcm93dGggKyAodGhpcy5wYWdlcyAqIFBBR0VfU0laRSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRNZXNzYWdlc0hlaWdodCgpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBpdGVtbGlzdCA9IHRoaXMuaXRlbWxpc3QuY3VycmVudDtcbiAgICAgICAgY29uc3QgbGFzdE5vZGUgPSBpdGVtbGlzdC5sYXN0RWxlbWVudENoaWxkIGFzIEhUTUxFbGVtZW50O1xuICAgICAgICBjb25zdCBsYXN0Tm9kZUJvdHRvbSA9IGxhc3ROb2RlID8gbGFzdE5vZGUub2Zmc2V0VG9wICsgbGFzdE5vZGUuY2xpZW50SGVpZ2h0IDogMDtcbiAgICAgICAgY29uc3QgZmlyc3ROb2RlVG9wID0gaXRlbWxpc3QuZmlyc3RFbGVtZW50Q2hpbGQgPyAoaXRlbWxpc3QuZmlyc3RFbGVtZW50Q2hpbGQgYXMgSFRNTEVsZW1lbnQpLm9mZnNldFRvcCA6IDA7XG4gICAgICAgIC8vIDE4IGlzIGl0ZW1saXN0IHBhZGRpbmdcbiAgICAgICAgcmV0dXJuIGxhc3ROb2RlQm90dG9tIC0gZmlyc3ROb2RlVG9wICsgKDE4ICogMik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB0b3BGcm9tQm90dG9tKG5vZGU6IEhUTUxFbGVtZW50KTogbnVtYmVyIHtcbiAgICAgICAgLy8gY3VycmVudCBjYXBwZWQgaGVpZ2h0IC0gZGlzdGFuY2UgZnJvbSB0b3AgPSBkaXN0YW5jZSBmcm9tIGJvdHRvbSBvZiBjb250YWluZXIgdG8gdG9wIG9mIHRyYWNrZWQgZWxlbWVudFxuICAgICAgICByZXR1cm4gdGhpcy5pdGVtbGlzdC5jdXJyZW50LmNsaWVudEhlaWdodCAtIG5vZGUub2Zmc2V0VG9wO1xuICAgIH1cblxuICAgIC8qIGdldCB0aGUgRE9NIG5vZGUgd2hpY2ggaGFzIHRoZSBzY3JvbGxUb3AgcHJvcGVydHkgd2UgY2FyZSBhYm91dCBmb3Igb3VyXG4gICAgICogbWVzc2FnZSBwYW5lbC5cbiAgICAgKi9cbiAgICBwcml2YXRlIGdldFNjcm9sbE5vZGUoKTogSFRNTERpdkVsZW1lbnQge1xuICAgICAgICBpZiAodGhpcy51bm1vdW50ZWQpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkbid0IGhhcHBlbiwgYnV0IHdoZW4gaXQgZG9lcywgdHVybiB0aGUgTlBFIGludG9cbiAgICAgICAgICAgIC8vIHNvbWV0aGluZyBtb3JlIG1lYW5pbmdmdWwuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTY3JvbGxQYW5lbC5nZXRTY3JvbGxOb2RlIGNhbGxlZCB3aGVuIHVubW91bnRlZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5kaXZTY3JvbGwpIHtcbiAgICAgICAgICAgIC8vIExpa2V3aXNlLCB3ZSBzaG91bGQgaGF2ZSB0aGUgcmVmIGJ5IHRoaXMgcG9pbnQsIGJ1dCBpZiBub3RcbiAgICAgICAgICAgIC8vIHR1cm4gdGhlIE5QRSBpbnRvIHNvbWV0aGluZyBtZWFuaW5nZnVsLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2Nyb2xsUGFuZWwuZ2V0U2Nyb2xsTm9kZSBjYWxsZWQgYmVmb3JlIEF1dG9IaWRlU2Nyb2xsYmFyIHJlZiBjb2xsZWN0ZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5kaXZTY3JvbGw7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjb2xsZWN0U2Nyb2xsID0gKGRpdlNjcm9sbDogSFRNTERpdkVsZW1lbnQpID0+IHtcbiAgICAgICAgdGhpcy5kaXZTY3JvbGwgPSBkaXZTY3JvbGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgIE1hcmsgdGhlIGJvdHRvbSBvZmZzZXQgb2YgdGhlIGxhc3QgdGlsZSBzbyB3ZSBjYW4gYmFsYW5jZSBpdCBvdXQgd2hlblxuICAgIGFueXRoaW5nIGJlbG93IGl0IGNoYW5nZXMsIGJ5IGNhbGxpbmcgdXBkYXRlUHJldmVudFNocmlua2luZywgdG8ga2VlcFxuICAgIHRoZSBzYW1lIG1pbmltdW0gYm90dG9tIG9mZnNldCwgZWZmZWN0aXZlbHkgcHJldmVudGluZyB0aGUgdGltZWxpbmUgdG8gc2hyaW5rLlxuICAgICovXG4gICAgcHVibGljIHByZXZlbnRTaHJpbmtpbmcgPSAoKTogdm9pZCA9PiB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VMaXN0ID0gdGhpcy5pdGVtbGlzdC5jdXJyZW50O1xuICAgICAgICBjb25zdCB0aWxlcyA9IG1lc3NhZ2VMaXN0ICYmIG1lc3NhZ2VMaXN0LmNoaWxkcmVuO1xuICAgICAgICBpZiAoIW1lc3NhZ2VMaXN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxhc3RUaWxlTm9kZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRpbGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gdGlsZXNbaV0gYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAobm9kZS5kYXRhc2V0LnNjcm9sbFRva2Vucykge1xuICAgICAgICAgICAgICAgIGxhc3RUaWxlTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsYXN0VGlsZU5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyUHJldmVudFNocmlua2luZygpO1xuICAgICAgICBjb25zdCBvZmZzZXRGcm9tQm90dG9tID0gbWVzc2FnZUxpc3QuY2xpZW50SGVpZ2h0IC0gKGxhc3RUaWxlTm9kZS5vZmZzZXRUb3AgKyBsYXN0VGlsZU5vZGUuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgdGhpcy5wcmV2ZW50U2hyaW5raW5nU3RhdGUgPSB7XG4gICAgICAgICAgICBvZmZzZXRGcm9tQm90dG9tOiBvZmZzZXRGcm9tQm90dG9tLFxuICAgICAgICAgICAgb2Zmc2V0Tm9kZTogbGFzdFRpbGVOb2RlLFxuICAgICAgICB9O1xuICAgICAgICBkZWJ1Z2xvZyhcInByZXZlbnQgc2hyaW5raW5nLCBsYXN0IHRpbGUgXCIsIG9mZnNldEZyb21Cb3R0b20sIFwicHggZnJvbSBib3R0b21cIik7XG4gICAgfTtcblxuICAgIC8qKiBDbGVhciBzaHJpbmtpbmcgcHJldmVudGlvbi4gVXNlZCBpbnRlcm5hbGx5LCBhbmQgd2hlbiB0aGUgdGltZWxpbmUgaXMgcmVsb2FkZWQuICovXG4gICAgcHVibGljIGNsZWFyUHJldmVudFNocmlua2luZyA9ICgpOiB2b2lkID0+IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZUxpc3QgPSB0aGlzLml0ZW1saXN0LmN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IGJhbGFuY2VFbGVtZW50ID0gbWVzc2FnZUxpc3QgJiYgbWVzc2FnZUxpc3QucGFyZW50RWxlbWVudDtcbiAgICAgICAgaWYgKGJhbGFuY2VFbGVtZW50KSBiYWxhbmNlRWxlbWVudC5zdHlsZS5wYWRkaW5nQm90dG9tID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcmV2ZW50U2hyaW5raW5nU3RhdGUgPSBudWxsO1xuICAgICAgICBkZWJ1Z2xvZyhcInByZXZlbnQgc2hyaW5raW5nIGNsZWFyZWRcIik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgIHVwZGF0ZSB0aGUgY29udGFpbmVyIHBhZGRpbmcgdG8gYmFsYW5jZVxuICAgIHRoZSBib3R0b20gb2Zmc2V0IG9mIHRoZSBsYXN0IHRpbGUgc2luY2VcbiAgICBwcmV2ZW50U2hyaW5raW5nIHdhcyBjYWxsZWQuXG4gICAgQ2xlYXJzIHRoZSBwcmV2ZW50LXNocmlua2luZyBzdGF0ZSBvbmVzIHRoZSBvZmZzZXRcbiAgICBmcm9tIHRoZSBib3R0b20gb2YgdGhlIG1hcmtlZCB0aWxlIGdyb3dzIGxhcmdlciB0aGFuXG4gICAgd2hhdCBpdCB3YXMgd2hlbiBtYXJraW5nLlxuICAgICovXG4gICAgcHVibGljIHVwZGF0ZVByZXZlbnRTaHJpbmtpbmcgPSAoKTogdm9pZCA9PiB7XG4gICAgICAgIGlmICh0aGlzLnByZXZlbnRTaHJpbmtpbmdTdGF0ZSkge1xuICAgICAgICAgICAgY29uc3Qgc24gPSB0aGlzLmdldFNjcm9sbE5vZGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbFN0YXRlID0gdGhpcy5zY3JvbGxTdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VMaXN0ID0gdGhpcy5pdGVtbGlzdC5jdXJyZW50O1xuICAgICAgICAgICAgY29uc3QgeyBvZmZzZXROb2RlLCBvZmZzZXRGcm9tQm90dG9tIH0gPSB0aGlzLnByZXZlbnRTaHJpbmtpbmdTdGF0ZTtcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgdXNlZCB0byBzZXQgcGFkZGluZ0JvdHRvbSB0byBiYWxhbmNlIHRoZSB0eXBpbmcgbm90aWZzIGRpc2FwcGVhcmluZ1xuICAgICAgICAgICAgY29uc3QgYmFsYW5jZUVsZW1lbnQgPSBtZXNzYWdlTGlzdC5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgLy8gaWYgdGhlIG9mZnNldE5vZGUgZ290IHVubW91bnRlZCwgY2xlYXJcbiAgICAgICAgICAgIGxldCBzaG91bGRDbGVhciA9ICFvZmZzZXROb2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAvLyBhbHNvIGlmIDIwMHB4IGZyb20gYm90dG9tXG4gICAgICAgICAgICBpZiAoIXNob3VsZENsZWFyICYmICFzY3JvbGxTdGF0ZS5zdHVja0F0Qm90dG9tKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3BhY2VCZWxvd1ZpZXdwb3J0ID0gc24uc2Nyb2xsSGVpZ2h0IC0gKHNuLnNjcm9sbFRvcCArIHNuLmNsaWVudEhlaWdodCk7XG4gICAgICAgICAgICAgICAgc2hvdWxkQ2xlYXIgPSBzcGFjZUJlbG93Vmlld3BvcnQgPj0gMjAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdHJ5IHVwZGF0aW5nIGlmIG5vdCBjbGVhcmluZ1xuICAgICAgICAgICAgaWYgKCFzaG91bGRDbGVhcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRPZmZzZXQgPSBtZXNzYWdlTGlzdC5jbGllbnRIZWlnaHQgLSAob2Zmc2V0Tm9kZS5vZmZzZXRUb3AgKyBvZmZzZXROb2RlLmNsaWVudEhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0RGlmZiA9IG9mZnNldEZyb21Cb3R0b20gLSBjdXJyZW50T2Zmc2V0O1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXREaWZmID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBiYWxhbmNlRWxlbWVudC5zdHlsZS5wYWRkaW5nQm90dG9tID0gYCR7b2Zmc2V0RGlmZn1weGA7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnbG9nKFwidXBkYXRlIHByZXZlbnQgc2hyaW5raW5nIFwiLCBvZmZzZXREaWZmLCBcInB4IGZyb20gYm90dG9tXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob2Zmc2V0RGlmZiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkQ2xlYXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRDbGVhcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJQcmV2ZW50U2hyaW5raW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvLyBUT0RPOiB0aGUgY2xhc3NuYW1lcyBvbiB0aGUgZGl2IGFuZCBvbCBjb3VsZCBkbyB3aXRoIGJlaW5nIHVwZGF0ZWQgdG9cbiAgICAgICAgLy8gcmVmbGVjdCB0aGUgZmFjdCB0aGF0IHdlIGRvbid0IG5lY2Vzc2FyaWx5IGNvbnRhaW4gYSBsaXN0IG9mIG1lc3NhZ2VzLlxuICAgICAgICAvLyBpdCdzIG5vdCBvYnZpb3VzIHdoeSB3ZSBoYXZlIGEgc2VwYXJhdGUgZGl2IGFuZCBvbCBhbnl3YXkuXG5cbiAgICAgICAgLy8gZ2l2ZSB0aGUgPG9sPiBhbiBleHBsaWNpdCByb2xlPWxpc3QgYmVjYXVzZSBTYWZhcmkrVm9pY2VPdmVyIHNlZW1zIHRvIHRoaW5rIGFuIG9yZGVyZWQtbGlzdCB3aXRoXG4gICAgICAgIC8vIGxpc3Qtc3R5bGUtdHlwZTogbm9uZTsgaXMgbm8gbG9uZ2VyIGEgbGlzdFxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPEF1dG9IaWRlU2Nyb2xsYmFyXG4gICAgICAgICAgICAgICAgd3JhcHBlZFJlZj17dGhpcy5jb2xsZWN0U2Nyb2xsfVxuICAgICAgICAgICAgICAgIG9uU2Nyb2xsPXt0aGlzLm9uU2Nyb2xsfVxuICAgICAgICAgICAgICAgIG9uV2hlZWw9e3RoaXMucHJvcHMub25Vc2VyU2Nyb2xsfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YG14X1Njcm9sbFBhbmVsICR7dGhpcy5wcm9wcy5jbGFzc05hbWV9YH1cbiAgICAgICAgICAgICAgICBzdHlsZT17dGhpcy5wcm9wcy5zdHlsZX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7IHRoaXMucHJvcHMuZml4ZWRDaGlsZHJlbiB9XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJteF9Sb29tVmlld19tZXNzYWdlTGlzdFdyYXBwZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgPG9sIHJlZj17dGhpcy5pdGVtbGlzdH0gY2xhc3NOYW1lPVwibXhfUm9vbVZpZXdfTWVzc2FnZUxpc3RcIiBhcmlhLWxpdmU9XCJwb2xpdGVcIiByb2xlPVwibGlzdFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgeyB0aGlzLnByb3BzLmNoaWxkcmVuIH1cbiAgICAgICAgICAgICAgICAgICAgPC9vbD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvQXV0b0hpZGVTY3JvbGxiYXI+XG4gICAgICAgICk7XG4gICAgfVxufVxuIl19