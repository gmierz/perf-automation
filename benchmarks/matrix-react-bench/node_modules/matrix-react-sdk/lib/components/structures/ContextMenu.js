"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChevronFace = void 0;
Object.defineProperty(exports, "ContextMenuButton", {
  enumerable: true,
  get: function () {
    return _ContextMenuButton.ContextMenuButton;
  }
});
Object.defineProperty(exports, "ContextMenuTooltipButton", {
  enumerable: true,
  get: function () {
    return _ContextMenuTooltipButton.ContextMenuTooltipButton;
  }
});
Object.defineProperty(exports, "MenuGroup", {
  enumerable: true,
  get: function () {
    return _MenuGroup.MenuGroup;
  }
});
Object.defineProperty(exports, "MenuItem", {
  enumerable: true,
  get: function () {
    return _MenuItem.MenuItem;
  }
});
Object.defineProperty(exports, "MenuItemCheckbox", {
  enumerable: true,
  get: function () {
    return _MenuItemCheckbox.MenuItemCheckbox;
  }
});
Object.defineProperty(exports, "MenuItemRadio", {
  enumerable: true,
  get: function () {
    return _MenuItemRadio.MenuItemRadio;
  }
});
Object.defineProperty(exports, "StyledMenuItemCheckbox", {
  enumerable: true,
  get: function () {
    return _StyledMenuItemCheckbox.StyledMenuItemCheckbox;
  }
});
Object.defineProperty(exports, "StyledMenuItemRadio", {
  enumerable: true,
  get: function () {
    return _StyledMenuItemRadio.StyledMenuItemRadio;
  }
});
exports.alwaysAboveRightOf = exports.alwaysAboveLeftOf = exports.aboveLeftOf = void 0;
exports.createMenu = createMenu;
exports.useContextMenu = exports.toRightOf = exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _react = _interopRequireWildcard(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _classnames = _interopRequireDefault(require("classnames"));

var _reactFocusLock = _interopRequireDefault(require("react-focus-lock"));

var _Keyboard = require("../../Keyboard");

var _replaceableComponent = require("../../utils/replaceableComponent");

var _UIStore = _interopRequireDefault(require("../../stores/UIStore"));

var _ContextMenuButton = require("../../accessibility/context_menu/ContextMenuButton");

var _ContextMenuTooltipButton = require("../../accessibility/context_menu/ContextMenuTooltipButton");

var _MenuGroup = require("../../accessibility/context_menu/MenuGroup");

var _MenuItem = require("../../accessibility/context_menu/MenuItem");

var _MenuItemCheckbox = require("../../accessibility/context_menu/MenuItemCheckbox");

var _MenuItemRadio = require("../../accessibility/context_menu/MenuItemRadio");

var _StyledMenuItemCheckbox = require("../../accessibility/context_menu/StyledMenuItemCheckbox");

var _StyledMenuItemRadio = require("../../accessibility/context_menu/StyledMenuItemRadio");

var _dec, _class, _class2, _temp;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Shamelessly ripped off Modal.js.  There's probably a better way
// of doing reusable widgets like dialog boxes & menus where we go and
// pass in a custom control as the actual body.
const ContextualMenuContainerId = "mx_ContextualMenu_Container";

function getOrCreateContainer() {
  let container = document.getElementById(ContextualMenuContainerId);

  if (!container) {
    container = document.createElement("div");
    container.id = ContextualMenuContainerId;
    document.body.appendChild(container);
  }

  return container;
}

let ChevronFace;
exports.ChevronFace = ChevronFace;

(function (ChevronFace) {
  ChevronFace["Top"] = "top";
  ChevronFace["Bottom"] = "bottom";
  ChevronFace["Left"] = "left";
  ChevronFace["Right"] = "right";
  ChevronFace["None"] = "none";
})(ChevronFace || (exports.ChevronFace = ChevronFace = {}));

let ContextMenu = ( // Generic ContextMenu Portal wrapper
// all options inside the menu should be of role=menuitem/menuitemcheckbox/menuitemradiobutton and have tabIndex={-1}
// this will allow the ContextMenu to manage its own focus using arrow keys as per the ARIA guidelines.
_dec = (0, _replaceableComponent.replaceableComponent)("structures.ContextMenu"), _dec(_class = (_temp = _class2 = class ContextMenu extends _react.default.PureComponent {
  constructor(props, context) {
    super(props, context);
    (0, _defineProperty2.default)(this, "initialFocus", void 0);
    (0, _defineProperty2.default)(this, "collectContextMenuRect", element => {
      // We don't need to clean up when unmounting, so ignore
      if (!element) return;
      const first = element.querySelector('[role^="menuitem"]') || element.querySelector('[tab-index]');

      if (first) {
        first.focus();
      }

      this.setState({
        contextMenuElem: element
      });
    });
    (0, _defineProperty2.default)(this, "onContextMenu", e => {
      if (this.props.onFinished) {
        this.props.onFinished();
        e.preventDefault();
        e.stopPropagation();
        const x = e.clientX;
        const y = e.clientY; // XXX: This isn't pretty but the only way to allow opening a different context menu on right click whilst
        // a context menu and its click-guard are up without completely rewriting how the context menus work.

        setImmediate(() => {
          const clickEvent = document.createEvent('MouseEvents');
          clickEvent.initMouseEvent('contextmenu', true, true, window, 0, 0, 0, x, y, false, false, false, false, 0, null);
          document.elementFromPoint(x, y).dispatchEvent(clickEvent);
        });
      }
    });
    (0, _defineProperty2.default)(this, "onContextMenuPreventBubbling", e => {
      // stop propagation so that any context menu handlers don't leak out of this context menu
      // but do not inhibit the default browser menu
      e.stopPropagation();
    });
    (0, _defineProperty2.default)(this, "onFinished", ev => {
      ev.stopPropagation();
      ev.preventDefault();
      if (this.props.onFinished) this.props.onFinished();
    });
    (0, _defineProperty2.default)(this, "onMoveFocus", (element, up) => {
      let descending = false; // are we currently descending or ascending through the DOM tree?

      do {
        var _element$getAttribute;

        const child = up ? element.lastElementChild : element.firstElementChild;
        const sibling = up ? element.previousElementSibling : element.nextElementSibling;

        if (descending) {
          if (child) {
            element = child;
          } else if (sibling) {
            element = sibling;
          } else {
            descending = false;
            element = element.parentElement;
          }
        } else {
          if (sibling) {
            element = sibling;
            descending = true;
          } else {
            element = element.parentElement;
          }
        }

        if (element) {
          if (element.classList.contains("mx_ContextualMenu")) {
            // we hit the top
            element = up ? element.lastElementChild : element.firstElementChild;
            descending = true;
          }
        }
      } while (element && !((_element$getAttribute = element.getAttribute("role")) !== null && _element$getAttribute !== void 0 && _element$getAttribute.startsWith("menuitem")));

      if (element) {
        element.focus();
      }
    });
    (0, _defineProperty2.default)(this, "onMoveFocusHomeEnd", (element, up) => {
      let results = element.querySelectorAll('[role^="menuitem"]');

      if (!results) {
        results = element.querySelectorAll('[tab-index]');
      }

      if (results && results.length) {
        if (up) {
          results[0].focus();
        } else {
          results[results.length - 1].focus();
        }
      }
    });
    (0, _defineProperty2.default)(this, "onClick", ev => {
      // Don't allow clicks to escape the context menu wrapper
      ev.stopPropagation();
    });
    (0, _defineProperty2.default)(this, "onKeyDown", ev => {
      // don't let keyboard handling escape the context menu
      ev.stopPropagation();

      if (!this.props.managed) {
        if (ev.key === _Keyboard.Key.ESCAPE) {
          this.props.onFinished();
          ev.preventDefault();
        }

        return;
      }

      let handled = true;

      switch (ev.key) {
        // XXX: this is imitating roving behaviour, it should really use the RovingTabIndex utils
        // to inherit proper handling of unmount edge cases
        case _Keyboard.Key.TAB:
        case _Keyboard.Key.ESCAPE:
        case _Keyboard.Key.ARROW_LEFT: // close on left and right arrows too for when it is a context menu on a <Toolbar />

        case _Keyboard.Key.ARROW_RIGHT:
          this.props.onFinished();
          break;

        case _Keyboard.Key.ARROW_UP:
          this.onMoveFocus(ev.target, true);
          break;

        case _Keyboard.Key.ARROW_DOWN:
          this.onMoveFocus(ev.target, false);
          break;

        case _Keyboard.Key.HOME:
          this.onMoveFocusHomeEnd(this.state.contextMenuElem, true);
          break;

        case _Keyboard.Key.END:
          this.onMoveFocusHomeEnd(this.state.contextMenuElem, false);
          break;

        default:
          handled = false;
      }

      if (handled) {
        // consume all other keys in context menu
        ev.preventDefault();
      }
    });
    this.state = {
      contextMenuElem: null
    }; // persist what had focus when we got initialized so we can return it after

    this.initialFocus = document.activeElement;
  }

  componentWillUnmount() {
    // return focus to the thing which had it before us
    this.initialFocus.focus();
  }

  renderMenu(hasBackground = this.props.hasBackground) {
    const position = {};
    const props = this.props;

    if (props.top) {
      position.top = props.top;
    } else {
      position.bottom = props.bottom;
    }

    let chevronFace;

    if (props.left) {
      position.left = props.left;
      chevronFace = ChevronFace.Left;
    } else {
      position.right = props.right;
      chevronFace = ChevronFace.Right;
    }

    const contextMenuRect = this.state.contextMenuElem ? this.state.contextMenuElem.getBoundingClientRect() : null;
    const chevronOffset = {};

    if (props.chevronFace) {
      chevronFace = props.chevronFace;
    }

    const hasChevron = chevronFace && chevronFace !== ChevronFace.None;

    if (chevronFace === ChevronFace.Top || chevronFace === ChevronFace.Bottom) {
      chevronOffset.left = props.chevronOffset;
    } else if (position.top !== undefined) {
      const target = position.top; // By default, no adjustment is made

      let adjusted = target; // If we know the dimensions of the context menu, adjust its position
      // such that it does not leave the (padded) window.

      if (contextMenuRect) {
        const padding = 10;
        adjusted = Math.min(position.top, document.body.clientHeight - contextMenuRect.height - padding);
      }

      position.top = adjusted;
      chevronOffset.top = Math.max(props.chevronOffset, props.chevronOffset + target - adjusted);
    }

    let chevron;

    if (hasChevron) {
      chevron = /*#__PURE__*/_react.default.createElement("div", {
        style: chevronOffset,
        className: "mx_ContextualMenu_chevron_" + chevronFace
      });
    }

    const menuClasses = (0, _classnames.default)({
      'mx_ContextualMenu': true,

      /**
       * In some cases we may get the number of 0, which still means that we're supposed to properly
       * add the specific position class, but as it was falsy things didn't work as intended.
       * In addition, defensively check for counter cases where we may get more than one value,
       * even if we shouldn't.
       */
      'mx_ContextualMenu_left': !hasChevron && position.left !== undefined && !position.right,
      'mx_ContextualMenu_right': !hasChevron && position.right !== undefined && !position.left,
      'mx_ContextualMenu_top': !hasChevron && position.top !== undefined && !position.bottom,
      'mx_ContextualMenu_bottom': !hasChevron && position.bottom !== undefined && !position.top,
      'mx_ContextualMenu_withChevron_left': chevronFace === ChevronFace.Left,
      'mx_ContextualMenu_withChevron_right': chevronFace === ChevronFace.Right,
      'mx_ContextualMenu_withChevron_top': chevronFace === ChevronFace.Top,
      'mx_ContextualMenu_withChevron_bottom': chevronFace === ChevronFace.Bottom,
      'mx_ContextualMenu_rightAligned': this.props.rightAligned === true,
      'mx_ContextualMenu_bottomAligned': this.props.bottomAligned === true
    });
    const menuStyle = {};

    if (props.menuWidth) {
      menuStyle.width = props.menuWidth;
    }

    if (props.menuHeight) {
      menuStyle.height = props.menuHeight;
    }

    if (!isNaN(Number(props.menuPaddingTop))) {
      menuStyle["paddingTop"] = props.menuPaddingTop;
    }

    if (!isNaN(Number(props.menuPaddingLeft))) {
      menuStyle["paddingLeft"] = props.menuPaddingLeft;
    }

    if (!isNaN(Number(props.menuPaddingBottom))) {
      menuStyle["paddingBottom"] = props.menuPaddingBottom;
    }

    if (!isNaN(Number(props.menuPaddingRight))) {
      menuStyle["paddingRight"] = props.menuPaddingRight;
    }

    const wrapperStyle = {};

    if (!isNaN(Number(props.zIndex))) {
      menuStyle["zIndex"] = props.zIndex + 1;
      wrapperStyle["zIndex"] = props.zIndex;
    }

    let background;

    if (hasBackground) {
      background = /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_ContextualMenu_background",
        style: wrapperStyle,
        onClick: this.onFinished,
        onContextMenu: this.onContextMenu
      });
    }

    let body = /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, chevron, props.children);

    if (props.focusLock) {
      body = /*#__PURE__*/_react.default.createElement(_reactFocusLock.default, null, body);
    }

    return /*#__PURE__*/_react.default.createElement("div", {
      className: (0, _classnames.default)("mx_ContextualMenu_wrapper", this.props.wrapperClassName),
      style: _objectSpread(_objectSpread({}, position), wrapperStyle),
      onKeyDown: this.onKeyDown,
      onClick: this.onClick,
      onContextMenu: this.onContextMenuPreventBubbling
    }, background, /*#__PURE__*/_react.default.createElement("div", {
      className: menuClasses,
      style: menuStyle,
      ref: this.collectContextMenuRect,
      role: this.props.managed ? "menu" : undefined
    }, body));
  }

  render() {
    if (this.props.mountAsChild) {
      // Render as a child of the current parent
      return this.renderMenu();
    } else {
      // Render as a child of a container at the root of the DOM
      return /*#__PURE__*/_reactDom.default.createPortal(this.renderMenu(), getOrCreateContainer());
    }
  }

}, (0, _defineProperty2.default)(_class2, "defaultProps", {
  hasBackground: true,
  managed: true
}), _temp)) || _class);
exports.default = ContextMenu;

// Placement method for <ContextMenu /> to position context menu to right of elementRect with chevronOffset
const toRightOf = (elementRect, chevronOffset = 12) => {
  const left = elementRect.right + window.pageXOffset + 3;
  let top = elementRect.top + elementRect.height / 2 + window.pageYOffset;
  top -= chevronOffset + 8; // where 8 is half the height of the chevron

  return {
    left,
    top,
    chevronOffset
  };
};

exports.toRightOf = toRightOf;

// Placement method for <ContextMenu /> to position context menu right-aligned and flowing to the left of elementRect,
// and either above or below: wherever there is more space (maybe this should be aboveOrBelowLeftOf?)
const aboveLeftOf = (elementRect, chevronFace = ChevronFace.None, vPadding = 0) => {
  const menuOptions = {
    chevronFace
  };
  const buttonRight = elementRect.right + window.pageXOffset;
  const buttonBottom = elementRect.bottom + window.pageYOffset;
  const buttonTop = elementRect.top + window.pageYOffset; // Align the right edge of the menu to the right edge of the button

  menuOptions.right = _UIStore.default.instance.windowWidth - buttonRight; // Align the menu vertically on whichever side of the button has more space available.

  if (buttonBottom < _UIStore.default.instance.windowHeight / 2) {
    menuOptions.top = buttonBottom + vPadding;
  } else {
    menuOptions.bottom = _UIStore.default.instance.windowHeight - buttonTop + vPadding;
  }

  return menuOptions;
}; // Placement method for <ContextMenu /> to position context menu right-aligned and flowing to the left of elementRect
// and always above elementRect


exports.aboveLeftOf = aboveLeftOf;

const alwaysAboveLeftOf = (elementRect, chevronFace = ChevronFace.None, vPadding = 0) => {
  const menuOptions = {
    chevronFace
  };
  const buttonRight = elementRect.right + window.pageXOffset;
  const buttonBottom = elementRect.bottom + window.pageYOffset;
  const buttonTop = elementRect.top + window.pageYOffset; // Align the right edge of the menu to the right edge of the button

  menuOptions.right = _UIStore.default.instance.windowWidth - buttonRight; // Align the menu vertically on whichever side of the button has more space available.

  if (buttonBottom < _UIStore.default.instance.windowHeight / 2) {
    menuOptions.top = buttonBottom + vPadding;
  } else {
    menuOptions.bottom = _UIStore.default.instance.windowHeight - buttonTop + vPadding;
  }

  return menuOptions;
}; // Placement method for <ContextMenu /> to position context menu right-aligned and flowing to the right of elementRect
// and always above elementRect


exports.alwaysAboveLeftOf = alwaysAboveLeftOf;

const alwaysAboveRightOf = (elementRect, chevronFace = ChevronFace.None, vPadding = 0) => {
  const menuOptions = {
    chevronFace
  };
  const buttonLeft = elementRect.left + window.pageXOffset;
  const buttonTop = elementRect.top + window.pageYOffset; // Align the left edge of the menu to the left edge of the button

  menuOptions.left = buttonLeft; // Align the menu vertically above the menu

  menuOptions.bottom = _UIStore.default.instance.windowHeight - buttonTop + vPadding;
  return menuOptions;
};

exports.alwaysAboveRightOf = alwaysAboveRightOf;

const useContextMenu = () => {
  const button = (0, _react.useRef)(null);
  const [isOpen, setIsOpen] = (0, _react.useState)(false);

  const open = ev => {
    ev === null || ev === void 0 ? void 0 : ev.preventDefault();
    ev === null || ev === void 0 ? void 0 : ev.stopPropagation();
    setIsOpen(true);
  };

  const close = ev => {
    ev === null || ev === void 0 ? void 0 : ev.preventDefault();
    ev === null || ev === void 0 ? void 0 : ev.stopPropagation();
    setIsOpen(false);
  };

  return [isOpen, button, open, close, setIsOpen];
}; // XXX: Deprecated, used only for dynamic Tooltips. Avoid using at all costs.


exports.useContextMenu = useContextMenu;

function createMenu(ElementClass, props) {
  const onFinished = function (...args) {
    var _props$onFinished;

    _reactDom.default.unmountComponentAtNode(getOrCreateContainer());

    props === null || props === void 0 ? void 0 : (_props$onFinished = props.onFinished) === null || _props$onFinished === void 0 ? void 0 : _props$onFinished.apply(null, args);
  };

  const menu = /*#__PURE__*/_react.default.createElement(ContextMenu, (0, _extends2.default)({}, props, {
    mountAsChild: true,
    hasBackground: false,
    onFinished: onFinished // eslint-disable-line react/jsx-no-bind
    ,
    windowResize: onFinished // eslint-disable-line react/jsx-no-bind

  }), /*#__PURE__*/_react.default.createElement(ElementClass, (0, _extends2.default)({}, props, {
    onFinished: onFinished
  })));

  _reactDom.default.render(menu, getOrCreateContainer());

  return {
    close: onFinished
  };
} // re-export the semantic helper components for simplicity
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3N0cnVjdHVyZXMvQ29udGV4dE1lbnUudHN4Il0sIm5hbWVzIjpbIkNvbnRleHR1YWxNZW51Q29udGFpbmVySWQiLCJnZXRPckNyZWF0ZUNvbnRhaW5lciIsImNvbnRhaW5lciIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJjcmVhdGVFbGVtZW50IiwiaWQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJDaGV2cm9uRmFjZSIsIkNvbnRleHRNZW51IiwiUmVhY3QiLCJQdXJlQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJwcm9wcyIsImNvbnRleHQiLCJlbGVtZW50IiwiZmlyc3QiLCJxdWVyeVNlbGVjdG9yIiwiZm9jdXMiLCJzZXRTdGF0ZSIsImNvbnRleHRNZW51RWxlbSIsImUiLCJvbkZpbmlzaGVkIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJ4IiwiY2xpZW50WCIsInkiLCJjbGllbnRZIiwic2V0SW1tZWRpYXRlIiwiY2xpY2tFdmVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdE1vdXNlRXZlbnQiLCJ3aW5kb3ciLCJlbGVtZW50RnJvbVBvaW50IiwiZGlzcGF0Y2hFdmVudCIsImV2IiwidXAiLCJkZXNjZW5kaW5nIiwiY2hpbGQiLCJsYXN0RWxlbWVudENoaWxkIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJzaWJsaW5nIiwicHJldmlvdXNFbGVtZW50U2libGluZyIsIm5leHRFbGVtZW50U2libGluZyIsInBhcmVudEVsZW1lbnQiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsImdldEF0dHJpYnV0ZSIsInN0YXJ0c1dpdGgiLCJyZXN1bHRzIiwicXVlcnlTZWxlY3RvckFsbCIsImxlbmd0aCIsIm1hbmFnZWQiLCJrZXkiLCJLZXkiLCJFU0NBUEUiLCJoYW5kbGVkIiwiVEFCIiwiQVJST1dfTEVGVCIsIkFSUk9XX1JJR0hUIiwiQVJST1dfVVAiLCJvbk1vdmVGb2N1cyIsInRhcmdldCIsIkFSUk9XX0RPV04iLCJIT01FIiwib25Nb3ZlRm9jdXNIb21lRW5kIiwic3RhdGUiLCJFTkQiLCJpbml0aWFsRm9jdXMiLCJhY3RpdmVFbGVtZW50IiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJyZW5kZXJNZW51IiwiaGFzQmFja2dyb3VuZCIsInBvc2l0aW9uIiwidG9wIiwiYm90dG9tIiwiY2hldnJvbkZhY2UiLCJsZWZ0IiwiTGVmdCIsInJpZ2h0IiwiUmlnaHQiLCJjb250ZXh0TWVudVJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjaGV2cm9uT2Zmc2V0IiwiaGFzQ2hldnJvbiIsIk5vbmUiLCJUb3AiLCJCb3R0b20iLCJ1bmRlZmluZWQiLCJhZGp1c3RlZCIsInBhZGRpbmciLCJNYXRoIiwibWluIiwiY2xpZW50SGVpZ2h0IiwiaGVpZ2h0IiwibWF4IiwiY2hldnJvbiIsIm1lbnVDbGFzc2VzIiwicmlnaHRBbGlnbmVkIiwiYm90dG9tQWxpZ25lZCIsIm1lbnVTdHlsZSIsIm1lbnVXaWR0aCIsIndpZHRoIiwibWVudUhlaWdodCIsImlzTmFOIiwiTnVtYmVyIiwibWVudVBhZGRpbmdUb3AiLCJtZW51UGFkZGluZ0xlZnQiLCJtZW51UGFkZGluZ0JvdHRvbSIsIm1lbnVQYWRkaW5nUmlnaHQiLCJ3cmFwcGVyU3R5bGUiLCJ6SW5kZXgiLCJiYWNrZ3JvdW5kIiwib25Db250ZXh0TWVudSIsImNoaWxkcmVuIiwiZm9jdXNMb2NrIiwid3JhcHBlckNsYXNzTmFtZSIsIm9uS2V5RG93biIsIm9uQ2xpY2siLCJvbkNvbnRleHRNZW51UHJldmVudEJ1YmJsaW5nIiwiY29sbGVjdENvbnRleHRNZW51UmVjdCIsInJlbmRlciIsIm1vdW50QXNDaGlsZCIsIlJlYWN0RE9NIiwiY3JlYXRlUG9ydGFsIiwidG9SaWdodE9mIiwiZWxlbWVudFJlY3QiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwiYWJvdmVMZWZ0T2YiLCJ2UGFkZGluZyIsIm1lbnVPcHRpb25zIiwiYnV0dG9uUmlnaHQiLCJidXR0b25Cb3R0b20iLCJidXR0b25Ub3AiLCJVSVN0b3JlIiwiaW5zdGFuY2UiLCJ3aW5kb3dXaWR0aCIsIndpbmRvd0hlaWdodCIsImFsd2F5c0Fib3ZlTGVmdE9mIiwiYWx3YXlzQWJvdmVSaWdodE9mIiwiYnV0dG9uTGVmdCIsInVzZUNvbnRleHRNZW51IiwiYnV0dG9uIiwiaXNPcGVuIiwic2V0SXNPcGVuIiwib3BlbiIsImNsb3NlIiwiY3JlYXRlTWVudSIsIkVsZW1lbnRDbGFzcyIsImFyZ3MiLCJ1bm1vdW50Q29tcG9uZW50QXROb2RlIiwiYXBwbHkiLCJtZW51Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUVBOztBQUNBOztBQWloQkE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7OztBQXRoQkE7QUFDQTtBQUNBO0FBRUEsTUFBTUEseUJBQXlCLEdBQUcsNkJBQWxDOztBQUVBLFNBQVNDLG9CQUFULEdBQWdEO0FBQzVDLE1BQUlDLFNBQVMsR0FBR0MsUUFBUSxDQUFDQyxjQUFULENBQXdCSix5QkFBeEIsQ0FBaEI7O0FBRUEsTUFBSSxDQUFDRSxTQUFMLEVBQWdCO0FBQ1pBLElBQUFBLFNBQVMsR0FBR0MsUUFBUSxDQUFDRSxhQUFULENBQXVCLEtBQXZCLENBQVo7QUFDQUgsSUFBQUEsU0FBUyxDQUFDSSxFQUFWLEdBQWVOLHlCQUFmO0FBQ0FHLElBQUFBLFFBQVEsQ0FBQ0ksSUFBVCxDQUFjQyxXQUFkLENBQTBCTixTQUExQjtBQUNIOztBQUVELFNBQU9BLFNBQVA7QUFDSDs7SUFXV08sVzs7O1dBQUFBLFc7QUFBQUEsRUFBQUEsVztBQUFBQSxFQUFBQSxXO0FBQUFBLEVBQUFBLFc7QUFBQUEsRUFBQUEsVztBQUFBQSxFQUFBQSxXO0dBQUFBLFcsMkJBQUFBLFc7O0lBa0RTQyxXLEtBSnJCO0FB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LEVBQUVTO0FBQXJDLEtBUFMsQ0FBYjs7QUFVQXNHLG9CQUFTRixNQUFULENBQWdCZ0MsSUFBaEIsRUFBc0IxSixvQkFBb0IsRUFBMUM7O0FBRUEsU0FBTztBQUFFb0osSUFBQUEsS0FBSyxFQUFFOUg7QUFBVCxHQUFQO0FBQ0gsQyxDQUVEIiwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE1LCAyMDE2IE9wZW5NYXJrZXQgTHRkXG5Db3B5cmlnaHQgMjAxOCBOZXcgVmVjdG9yIEx0ZFxuQ29weXJpZ2h0IDIwMTkgVGhlIE1hdHJpeC5vcmcgRm91bmRhdGlvbiBDLkkuQy5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgUmVhY3QsIHsgQ1NTUHJvcGVydGllcywgUmVmT2JqZWN0LCBTeW50aGV0aWNFdmVudCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gXCJjbGFzc25hbWVzXCI7XG5pbXBvcnQgRm9jdXNMb2NrIGZyb20gXCJyZWFjdC1mb2N1cy1sb2NrXCI7XG5cbmltcG9ydCB7IEtleSB9IGZyb20gXCIuLi8uLi9LZXlib2FyZFwiO1xuaW1wb3J0IHsgV3JpdGVhYmxlIH0gZnJvbSBcIi4uLy4uL0B0eXBlcy9jb21tb25cIjtcbmltcG9ydCB7IHJlcGxhY2VhYmxlQ29tcG9uZW50IH0gZnJvbSBcIi4uLy4uL3V0aWxzL3JlcGxhY2VhYmxlQ29tcG9uZW50XCI7XG5pbXBvcnQgVUlTdG9yZSBmcm9tIFwiLi4vLi4vc3RvcmVzL1VJU3RvcmVcIjtcblxuLy8gU2hhbWVsZXNzbHkgcmlwcGVkIG9mZiBNb2RhbC5qcy4gIFRoZXJlJ3MgcHJvYmFibHkgYSBiZXR0ZXIgd2F5XG4vLyBvZiBkb2luZyByZXVzYWJsZSB3aWRnZXRzIGxpa2UgZGlhbG9nIGJveGVzICYgbWVudXMgd2hlcmUgd2UgZ28gYW5kXG4vLyBwYXNzIGluIGEgY3VzdG9tIGNvbnRyb2wgYXMgdGhlIGFjdHVhbCBib2R5LlxuXG5jb25zdCBDb250ZXh0dWFsTWVudUNvbnRhaW5lcklkID0gXCJteF9Db250ZXh0dWFsTWVudV9Db250YWluZXJcIjtcblxuZnVuY3Rpb24gZ2V0T3JDcmVhdGVDb250YWluZXIoKTogSFRNTERpdkVsZW1lbnQge1xuICAgIGxldCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChDb250ZXh0dWFsTWVudUNvbnRhaW5lcklkKSBhcyBIVE1MRGl2RWxlbWVudDtcblxuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGNvbnRhaW5lci5pZCA9IENvbnRleHR1YWxNZW51Q29udGFpbmVySWQ7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElQb3NpdGlvbiB7XG4gICAgdG9wPzogbnVtYmVyO1xuICAgIGJvdHRvbT86IG51bWJlcjtcbiAgICBsZWZ0PzogbnVtYmVyO1xuICAgIHJpZ2h0PzogbnVtYmVyO1xuICAgIHJpZ2h0QWxpZ25lZD86IGJvb2xlYW47XG4gICAgYm90dG9tQWxpZ25lZD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBlbnVtIENoZXZyb25GYWNlIHtcbiAgICBUb3AgPSBcInRvcFwiLFxuICAgIEJvdHRvbSA9IFwiYm90dG9tXCIsXG4gICAgTGVmdCA9IFwibGVmdFwiLFxuICAgIFJpZ2h0ID0gXCJyaWdodFwiLFxuICAgIE5vbmUgPSBcIm5vbmVcIixcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJUHJvcHMgZXh0ZW5kcyBJUG9zaXRpb24ge1xuICAgIG1lbnVXaWR0aD86IG51bWJlcjtcbiAgICBtZW51SGVpZ2h0PzogbnVtYmVyO1xuXG4gICAgY2hldnJvbk9mZnNldD86IG51bWJlcjtcbiAgICBjaGV2cm9uRmFjZT86IENoZXZyb25GYWNlO1xuXG4gICAgbWVudVBhZGRpbmdUb3A/OiBudW1iZXI7XG4gICAgbWVudVBhZGRpbmdCb3R0b20/OiBudW1iZXI7XG4gICAgbWVudVBhZGRpbmdMZWZ0PzogbnVtYmVyO1xuICAgIG1lbnVQYWRkaW5nUmlnaHQ/OiBudW1iZXI7XG5cbiAgICB6SW5kZXg/OiBudW1iZXI7XG5cbiAgICAvLyBJZiB0cnVlLCBpbnNlcnQgYW4gaW52aXNpYmxlIHNjcmVlbi1zaXplZCBlbGVtZW50IGJlaGluZCB0aGUgbWVudSB0aGF0IHdoZW4gY2xpY2tlZCB3aWxsIGNsb3NlIGl0LlxuICAgIGhhc0JhY2tncm91bmQ/OiBib29sZWFuO1xuICAgIC8vIHdoZXRoZXIgdGhpcyBjb250ZXh0IG1lbnUgc2hvdWxkIGJlIGZvY3VzIG1hbmFnZWQuIElmIGZhbHNlIGl0IG11c3QgaGFuZGxlIGl0c2VsZlxuICAgIG1hbmFnZWQ/OiBib29sZWFuO1xuICAgIHdyYXBwZXJDbGFzc05hbWU/OiBzdHJpbmc7XG5cbiAgICAvLyBJZiB0cnVlLCB0aGlzIGNvbnRleHQgbWVudSB3aWxsIGJlIG1vdW50ZWQgYXMgYSBjaGlsZCB0byB0aGUgcGFyZW50IGNvbnRhaW5lci4gT3RoZXJ3aXNlXG4gICAgLy8gaXQgd2lsbCBiZSBtb3VudGVkIHRvIGEgY29udGFpbmVyIGF0IHRoZSByb290IG9mIHRoZSBET00uXG4gICAgbW91bnRBc0NoaWxkPzogYm9vbGVhbjtcblxuICAgIC8vIElmIHNwZWNpZmllZCwgY29udGVudHMgd2lsbCBiZSB3cmFwcGVkIGluIGEgRm9jdXNMb2NrLCB0aGlzIGlzIG9ubHkgbmVlZGVkIGlmIHRoZSBjb250ZXh0IG1lbnUgaXMgYmVpbmcgcmVuZGVyZWRcbiAgICAvLyB3aXRoaW4gYW4gZXhpc3RpbmcgRm9jdXNMb2NrIGUuZyBpbnNpZGUgYSBtb2RhbC5cbiAgICBmb2N1c0xvY2s/OiBib29sZWFuO1xuXG4gICAgLy8gRnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIG1lbnUgY2xvc2VcbiAgICBvbkZpbmlzaGVkKCk7XG4gICAgLy8gb24gcmVzaXplIGNhbGxiYWNrXG4gICAgd2luZG93UmVzaXplPygpO1xufVxuXG5pbnRlcmZhY2UgSVN0YXRlIHtcbiAgICBjb250ZXh0TWVudUVsZW06IEhUTUxEaXZFbGVtZW50O1xufVxuXG4vLyBHZW5lcmljIENvbnRleHRNZW51IFBvcnRhbCB3cmFwcGVyXG4vLyBhbGwgb3B0aW9ucyBpbnNpZGUgdGhlIG1lbnUgc2hvdWxkIGJlIG9mIHJvbGU9bWVudWl0ZW0vbWVudWl0ZW1jaGVja2JveC9tZW51aXRlbXJhZGlvYnV0dG9uIGFuZCBoYXZlIHRhYkluZGV4PXstMX1cbi8vIHRoaXMgd2lsbCBhbGxvdyB0aGUgQ29udGV4dE1lbnUgdG8gbWFuYWdlIGl0cyBvd24gZm9jdXMgdXNpbmcgYXJyb3cga2V5cyBhcyBwZXIgdGhlIEFSSUEgZ3VpZGVsaW5lcy5cbkByZXBsYWNlYWJsZUNvbXBvbmVudChcInN0cnVjdHVyZXMuQ29udGV4dE1lbnVcIilcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRleHRNZW51IGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxJUHJvcHMsIElTdGF0ZT4ge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgaW5pdGlhbEZvY3VzOiBIVE1MRWxlbWVudDtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGhhc0JhY2tncm91bmQ6IHRydWUsXG4gICAgICAgIG1hbmFnZWQ6IHRydWUsXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgY29udGV4dE1lbnVFbGVtOiBudWxsLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHBlcnNpc3Qgd2hhdCBoYWQgZm9jdXMgd2hlbiB3ZSBnb3QgaW5pdGlhbGl6ZWQgc28gd2UgY2FuIHJldHVybiBpdCBhZnRlclxuICAgICAgICB0aGlzLmluaXRpYWxGb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYXMgSFRNTEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIC8vIHJldHVybiBmb2N1cyB0byB0aGUgdGhpbmcgd2hpY2ggaGFkIGl0IGJlZm9yZSB1c1xuICAgICAgICB0aGlzLmluaXRpYWxGb2N1cy5mb2N1cygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgY29sbGVjdENvbnRleHRNZW51UmVjdCA9IChlbGVtZW50OiBIVE1MRGl2RWxlbWVudCkgPT4ge1xuICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGNsZWFuIHVwIHdoZW4gdW5tb3VudGluZywgc28gaWdub3JlXG4gICAgICAgIGlmICghZWxlbWVudCkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IGZpcnN0ID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yPEhUTUxFbGVtZW50PignW3JvbGVePVwibWVudWl0ZW1cIl0nKVxuICAgICAgICAgICAgfHwgZWxlbWVudC5xdWVyeVNlbGVjdG9yPEhUTUxFbGVtZW50PignW3RhYi1pbmRleF0nKTtcblxuICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgIGZpcnN0LmZvY3VzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGNvbnRleHRNZW51RWxlbTogZWxlbWVudCxcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25Db250ZXh0TWVudSA9IChlKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25GaW5pc2hlZCgpO1xuXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgY29uc3QgeCA9IGUuY2xpZW50WDtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBlLmNsaWVudFk7XG5cbiAgICAgICAgICAgIC8vIFhYWDogVGhpcyBpc24ndCBwcmV0dHkgYnV0IHRoZSBvbmx5IHdheSB0byBhbGxvdyBvcGVuaW5nIGEgZGlmZmVyZW50IGNvbnRleHQgbWVudSBvbiByaWdodCBjbGljayB3aGlsc3RcbiAgICAgICAgICAgIC8vIGEgY29udGV4dCBtZW51IGFuZCBpdHMgY2xpY2stZ3VhcmQgYXJlIHVwIHdpdGhvdXQgY29tcGxldGVseSByZXdyaXRpbmcgaG93IHRoZSBjb250ZXh0IG1lbnVzIHdvcmsuXG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsaWNrRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcbiAgICAgICAgICAgICAgICBjbGlja0V2ZW50LmluaXRNb3VzZUV2ZW50KFxuICAgICAgICAgICAgICAgICAgICAnY29udGV4dG1lbnUnLCB0cnVlLCB0cnVlLCB3aW5kb3csIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsIDAsIHgsIHksIGZhbHNlLCBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UsIGZhbHNlLCAwLCBudWxsLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh4LCB5KS5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbkNvbnRleHRNZW51UHJldmVudEJ1YmJsaW5nID0gKGUpID0+IHtcbiAgICAgICAgLy8gc3RvcCBwcm9wYWdhdGlvbiBzbyB0aGF0IGFueSBjb250ZXh0IG1lbnUgaGFuZGxlcnMgZG9uJ3QgbGVhayBvdXQgb2YgdGhpcyBjb250ZXh0IG1lbnVcbiAgICAgICAgLy8gYnV0IGRvIG5vdCBpbmhpYml0IHRoZSBkZWZhdWx0IGJyb3dzZXIgbWVudVxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH07XG5cbiAgICAvLyBQcmV2ZW50IGNsaWNrcyBvbiB0aGUgYmFja2dyb3VuZCBmcm9tIGdvaW5nIHRocm91Z2ggdG8gdGhlIGNvbXBvbmVudCB3aGljaCBvcGVuZWQgdGhlIG1lbnUuXG4gICAgcHJpdmF0ZSBvbkZpbmlzaGVkID0gKGV2OiBSZWFjdC5Nb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkZpbmlzaGVkKSB0aGlzLnByb3BzLm9uRmluaXNoZWQoKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbk1vdmVGb2N1cyA9IChlbGVtZW50OiBFbGVtZW50LCB1cDogYm9vbGVhbikgPT4ge1xuICAgICAgICBsZXQgZGVzY2VuZGluZyA9IGZhbHNlOyAvLyBhcmUgd2UgY3VycmVudGx5IGRlc2NlbmRpbmcgb3IgYXNjZW5kaW5nIHRocm91Z2ggdGhlIERPTSB0cmVlP1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gdXAgPyBlbGVtZW50Lmxhc3RFbGVtZW50Q2hpbGQgOiBlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICAgICAgY29uc3Qgc2libGluZyA9IHVwID8gZWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nIDogZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmc7XG5cbiAgICAgICAgICAgIGlmIChkZXNjZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IHNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzY2VuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IHNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcIm14X0NvbnRleHR1YWxNZW51XCIpKSB7IC8vIHdlIGhpdCB0aGUgdG9wXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSB1cCA/IGVsZW1lbnQubGFzdEVsZW1lbnRDaGlsZCA6IGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZWxlbWVudCAmJiAhZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJyb2xlXCIpPy5zdGFydHNXaXRoKFwibWVudWl0ZW1cIikpO1xuXG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAoZWxlbWVudCBhcyBIVE1MRWxlbWVudCkuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcml2YXRlIG9uTW92ZUZvY3VzSG9tZUVuZCA9IChlbGVtZW50OiBFbGVtZW50LCB1cDogYm9vbGVhbikgPT4ge1xuICAgICAgICBsZXQgcmVzdWx0cyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW3JvbGVePVwibWVudWl0ZW1cIl0nKTtcbiAgICAgICAgaWYgKCFyZXN1bHRzKSB7XG4gICAgICAgICAgICByZXN1bHRzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbdGFiLWluZGV4XScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHRzICYmIHJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodXApIHtcbiAgICAgICAgICAgICAgICAocmVzdWx0c1swXSBhcyBIVE1MRWxlbWVudCkuZm9jdXMoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgKHJlc3VsdHNbcmVzdWx0cy5sZW5ndGggLSAxXSBhcyBIVE1MRWxlbWVudCkuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcml2YXRlIG9uQ2xpY2sgPSAoZXY6IFJlYWN0Lk1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgLy8gRG9uJ3QgYWxsb3cgY2xpY2tzIHRvIGVzY2FwZSB0aGUgY29udGV4dCBtZW51IHdyYXBwZXJcbiAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25LZXlEb3duID0gKGV2OiBSZWFjdC5LZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAgIC8vIGRvbid0IGxldCBrZXlib2FyZCBoYW5kbGluZyBlc2NhcGUgdGhlIGNvbnRleHQgbWVudVxuICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICBpZiAoIXRoaXMucHJvcHMubWFuYWdlZCkge1xuICAgICAgICAgICAgaWYgKGV2LmtleSA9PT0gS2V5LkVTQ0FQRSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25GaW5pc2hlZCgpO1xuICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaGFuZGxlZCA9IHRydWU7XG5cbiAgICAgICAgc3dpdGNoIChldi5rZXkpIHtcbiAgICAgICAgICAgIC8vIFhYWDogdGhpcyBpcyBpbWl0YXRpbmcgcm92aW5nIGJlaGF2aW91ciwgaXQgc2hvdWxkIHJlYWxseSB1c2UgdGhlIFJvdmluZ1RhYkluZGV4IHV0aWxzXG4gICAgICAgICAgICAvLyB0byBpbmhlcml0IHByb3BlciBoYW5kbGluZyBvZiB1bm1vdW50IGVkZ2UgY2FzZXNcbiAgICAgICAgICAgIGNhc2UgS2V5LlRBQjpcbiAgICAgICAgICAgIGNhc2UgS2V5LkVTQ0FQRTpcbiAgICAgICAgICAgIGNhc2UgS2V5LkFSUk9XX0xFRlQ6IC8vIGNsb3NlIG9uIGxlZnQgYW5kIHJpZ2h0IGFycm93cyB0b28gZm9yIHdoZW4gaXQgaXMgYSBjb250ZXh0IG1lbnUgb24gYSA8VG9vbGJhciAvPlxuICAgICAgICAgICAgY2FzZSBLZXkuQVJST1dfUklHSFQ6XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkZpbmlzaGVkKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtleS5BUlJPV19VUDpcbiAgICAgICAgICAgICAgICB0aGlzLm9uTW92ZUZvY3VzKGV2LnRhcmdldCBhcyBFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgS2V5LkFSUk9XX0RPV046XG4gICAgICAgICAgICAgICAgdGhpcy5vbk1vdmVGb2N1cyhldi50YXJnZXQgYXMgRWxlbWVudCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLZXkuSE9NRTpcbiAgICAgICAgICAgICAgICB0aGlzLm9uTW92ZUZvY3VzSG9tZUVuZCh0aGlzLnN0YXRlLmNvbnRleHRNZW51RWxlbSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtleS5FTkQ6XG4gICAgICAgICAgICAgICAgdGhpcy5vbk1vdmVGb2N1c0hvbWVFbmQodGhpcy5zdGF0ZS5jb250ZXh0TWVudUVsZW0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaGFuZGxlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhbmRsZWQpIHtcbiAgICAgICAgICAgIC8vIGNvbnN1bWUgYWxsIG90aGVyIGtleXMgaW4gY29udGV4dCBtZW51XG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCByZW5kZXJNZW51KGhhc0JhY2tncm91bmQgPSB0aGlzLnByb3BzLmhhc0JhY2tncm91bmQpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb246IFBhcnRpYWw8V3JpdGVhYmxlPERPTVJlY3Q+PiA9IHt9O1xuICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgaWYgKHByb3BzLnRvcCkge1xuICAgICAgICAgICAgcG9zaXRpb24udG9wID0gcHJvcHMudG9wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zaXRpb24uYm90dG9tID0gcHJvcHMuYm90dG9tO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNoZXZyb25GYWNlOiBDaGV2cm9uRmFjZTtcbiAgICAgICAgaWYgKHByb3BzLmxlZnQpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLmxlZnQgPSBwcm9wcy5sZWZ0O1xuICAgICAgICAgICAgY2hldnJvbkZhY2UgPSBDaGV2cm9uRmFjZS5MZWZ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zaXRpb24ucmlnaHQgPSBwcm9wcy5yaWdodDtcbiAgICAgICAgICAgIGNoZXZyb25GYWNlID0gQ2hldnJvbkZhY2UuUmlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb250ZXh0TWVudVJlY3QgPSB0aGlzLnN0YXRlLmNvbnRleHRNZW51RWxlbSA/IHRoaXMuc3RhdGUuY29udGV4dE1lbnVFbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogbnVsbDtcblxuICAgICAgICBjb25zdCBjaGV2cm9uT2Zmc2V0OiBDU1NQcm9wZXJ0aWVzID0ge307XG4gICAgICAgIGlmIChwcm9wcy5jaGV2cm9uRmFjZSkge1xuICAgICAgICAgICAgY2hldnJvbkZhY2UgPSBwcm9wcy5jaGV2cm9uRmFjZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNDaGV2cm9uID0gY2hldnJvbkZhY2UgJiYgY2hldnJvbkZhY2UgIT09IENoZXZyb25GYWNlLk5vbmU7XG5cbiAgICAgICAgaWYgKGNoZXZyb25GYWNlID09PSBDaGV2cm9uRmFjZS5Ub3AgfHwgY2hldnJvbkZhY2UgPT09IENoZXZyb25GYWNlLkJvdHRvbSkge1xuICAgICAgICAgICAgY2hldnJvbk9mZnNldC5sZWZ0ID0gcHJvcHMuY2hldnJvbk9mZnNldDtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbi50b3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gcG9zaXRpb24udG9wO1xuXG4gICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCBubyBhZGp1c3RtZW50IGlzIG1hZGVcbiAgICAgICAgICAgIGxldCBhZGp1c3RlZCA9IHRhcmdldDtcblxuICAgICAgICAgICAgLy8gSWYgd2Uga25vdyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgY29udGV4dCBtZW51LCBhZGp1c3QgaXRzIHBvc2l0aW9uXG4gICAgICAgICAgICAvLyBzdWNoIHRoYXQgaXQgZG9lcyBub3QgbGVhdmUgdGhlIChwYWRkZWQpIHdpbmRvdy5cbiAgICAgICAgICAgIGlmIChjb250ZXh0TWVudVJlY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWRkaW5nID0gMTA7XG4gICAgICAgICAgICAgICAgYWRqdXN0ZWQgPSBNYXRoLm1pbihwb3NpdGlvbi50b3AsIGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0IC0gY29udGV4dE1lbnVSZWN0LmhlaWdodCAtIHBhZGRpbmcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwb3NpdGlvbi50b3AgPSBhZGp1c3RlZDtcbiAgICAgICAgICAgIGNoZXZyb25PZmZzZXQudG9wID0gTWF0aC5tYXgocHJvcHMuY2hldnJvbk9mZnNldCwgcHJvcHMuY2hldnJvbk9mZnNldCArIHRhcmdldCAtIGFkanVzdGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjaGV2cm9uO1xuICAgICAgICBpZiAoaGFzQ2hldnJvbikge1xuICAgICAgICAgICAgY2hldnJvbiA9IDxkaXYgc3R5bGU9e2NoZXZyb25PZmZzZXR9IGNsYXNzTmFtZT17XCJteF9Db250ZXh0dWFsTWVudV9jaGV2cm9uX1wiICsgY2hldnJvbkZhY2V9IC8+O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWVudUNsYXNzZXMgPSBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgICdteF9Db250ZXh0dWFsTWVudSc6IHRydWUsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluIHNvbWUgY2FzZXMgd2UgbWF5IGdldCB0aGUgbnVtYmVyIG9mIDAsIHdoaWNoIHN0aWxsIG1lYW5zIHRoYXQgd2UncmUgc3VwcG9zZWQgdG8gcHJvcGVybHlcbiAgICAgICAgICAgICAqIGFkZCB0aGUgc3BlY2lmaWMgcG9zaXRpb24gY2xhc3MsIGJ1dCBhcyBpdCB3YXMgZmFsc3kgdGhpbmdzIGRpZG4ndCB3b3JrIGFzIGludGVuZGVkLlxuICAgICAgICAgICAgICogSW4gYWRkaXRpb24sIGRlZmVuc2l2ZWx5IGNoZWNrIGZvciBjb3VudGVyIGNhc2VzIHdoZXJlIHdlIG1heSBnZXQgbW9yZSB0aGFuIG9uZSB2YWx1ZSxcbiAgICAgICAgICAgICAqIGV2ZW4gaWYgd2Ugc2hvdWxkbid0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnbXhfQ29udGV4dHVhbE1lbnVfbGVmdCc6ICFoYXNDaGV2cm9uICYmIHBvc2l0aW9uLmxlZnQgIT09IHVuZGVmaW5lZCAmJiAhcG9zaXRpb24ucmlnaHQsXG4gICAgICAgICAgICAnbXhfQ29udGV4dHVhbE1lbnVfcmlnaHQnOiAhaGFzQ2hldnJvbiAmJiBwb3NpdGlvbi5yaWdodCAhPT0gdW5kZWZpbmVkICYmICFwb3NpdGlvbi5sZWZ0LFxuICAgICAgICAgICAgJ214X0NvbnRleHR1YWxNZW51X3RvcCc6ICFoYXNDaGV2cm9uICYmIHBvc2l0aW9uLnRvcCAhPT0gdW5kZWZpbmVkICYmICFwb3NpdGlvbi5ib3R0b20sXG4gICAgICAgICAgICAnbXhfQ29udGV4dHVhbE1lbnVfYm90dG9tJzogIWhhc0NoZXZyb24gJiYgcG9zaXRpb24uYm90dG9tICE9PSB1bmRlZmluZWQgJiYgIXBvc2l0aW9uLnRvcCxcbiAgICAgICAgICAgICdteF9Db250ZXh0dWFsTWVudV93aXRoQ2hldnJvbl9sZWZ0JzogY2hldnJvbkZhY2UgPT09IENoZXZyb25GYWNlLkxlZnQsXG4gICAgICAgICAgICAnbXhfQ29udGV4dHVhbE1lbnVfd2l0aENoZXZyb25fcmlnaHQnOiBjaGV2cm9uRmFjZSA9PT0gQ2hldnJvbkZhY2UuUmlnaHQsXG4gICAgICAgICAgICAnbXhfQ29udGV4dHVhbE1lbnVfd2l0aENoZXZyb25fdG9wJzogY2hldnJvbkZhY2UgPT09IENoZXZyb25GYWNlLlRvcCxcbiAgICAgICAgICAgICdteF9Db250ZXh0dWFsTWVudV93aXRoQ2hldnJvbl9ib3R0b20nOiBjaGV2cm9uRmFjZSA9PT0gQ2hldnJvbkZhY2UuQm90dG9tLFxuICAgICAgICAgICAgJ214X0NvbnRleHR1YWxNZW51X3JpZ2h0QWxpZ25lZCc6IHRoaXMucHJvcHMucmlnaHRBbGlnbmVkID09PSB0cnVlLFxuICAgICAgICAgICAgJ214X0NvbnRleHR1YWxNZW51X2JvdHRvbUFsaWduZWQnOiB0aGlzLnByb3BzLmJvdHRvbUFsaWduZWQgPT09IHRydWUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IG1lbnVTdHlsZTogQ1NTUHJvcGVydGllcyA9IHt9O1xuICAgICAgICBpZiAocHJvcHMubWVudVdpZHRoKSB7XG4gICAgICAgICAgICBtZW51U3R5bGUud2lkdGggPSBwcm9wcy5tZW51V2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcHMubWVudUhlaWdodCkge1xuICAgICAgICAgICAgbWVudVN0eWxlLmhlaWdodCA9IHByb3BzLm1lbnVIZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTmFOKE51bWJlcihwcm9wcy5tZW51UGFkZGluZ1RvcCkpKSB7XG4gICAgICAgICAgICBtZW51U3R5bGVbXCJwYWRkaW5nVG9wXCJdID0gcHJvcHMubWVudVBhZGRpbmdUb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc05hTihOdW1iZXIocHJvcHMubWVudVBhZGRpbmdMZWZ0KSkpIHtcbiAgICAgICAgICAgIG1lbnVTdHlsZVtcInBhZGRpbmdMZWZ0XCJdID0gcHJvcHMubWVudVBhZGRpbmdMZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNOYU4oTnVtYmVyKHByb3BzLm1lbnVQYWRkaW5nQm90dG9tKSkpIHtcbiAgICAgICAgICAgIG1lbnVTdHlsZVtcInBhZGRpbmdCb3R0b21cIl0gPSBwcm9wcy5tZW51UGFkZGluZ0JvdHRvbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzTmFOKE51bWJlcihwcm9wcy5tZW51UGFkZGluZ1JpZ2h0KSkpIHtcbiAgICAgICAgICAgIG1lbnVTdHlsZVtcInBhZGRpbmdSaWdodFwiXSA9IHByb3BzLm1lbnVQYWRkaW5nUmlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB3cmFwcGVyU3R5bGUgPSB7fTtcbiAgICAgICAgaWYgKCFpc05hTihOdW1iZXIocHJvcHMuekluZGV4KSkpIHtcbiAgICAgICAgICAgIG1lbnVTdHlsZVtcInpJbmRleFwiXSA9IHByb3BzLnpJbmRleCArIDE7XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGVbXCJ6SW5kZXhcIl0gPSBwcm9wcy56SW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYmFja2dyb3VuZDtcbiAgICAgICAgaWYgKGhhc0JhY2tncm91bmQpIHtcbiAgICAgICAgICAgIGJhY2tncm91bmQgPSAoXG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJteF9Db250ZXh0dWFsTWVudV9iYWNrZ3JvdW5kXCJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3dyYXBwZXJTdHlsZX1cbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5vbkZpbmlzaGVkfVxuICAgICAgICAgICAgICAgICAgICBvbkNvbnRleHRNZW51PXt0aGlzLm9uQ29udGV4dE1lbnV9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYm9keSA9IDw+XG4gICAgICAgICAgICB7IGNoZXZyb24gfVxuICAgICAgICAgICAgeyBwcm9wcy5jaGlsZHJlbiB9XG4gICAgICAgIDwvPjtcblxuICAgICAgICBpZiAocHJvcHMuZm9jdXNMb2NrKSB7XG4gICAgICAgICAgICBib2R5ID0gPEZvY3VzTG9jaz5cbiAgICAgICAgICAgICAgICB7IGJvZHkgfVxuICAgICAgICAgICAgPC9Gb2N1c0xvY2s+O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXCJteF9Db250ZXh0dWFsTWVudV93cmFwcGVyXCIsIHRoaXMucHJvcHMud3JhcHBlckNsYXNzTmFtZSl9XG4gICAgICAgICAgICAgICAgc3R5bGU9e3sgLi4ucG9zaXRpb24sIC4uLndyYXBwZXJTdHlsZSB9fVxuICAgICAgICAgICAgICAgIG9uS2V5RG93bj17dGhpcy5vbktleURvd259XG4gICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5vbkNsaWNrfVxuICAgICAgICAgICAgICAgIG9uQ29udGV4dE1lbnU9e3RoaXMub25Db250ZXh0TWVudVByZXZlbnRCdWJibGluZ31cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7IGJhY2tncm91bmQgfVxuICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXttZW51Q2xhc3Nlc31cbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e21lbnVTdHlsZX1cbiAgICAgICAgICAgICAgICAgICAgcmVmPXt0aGlzLmNvbGxlY3RDb250ZXh0TWVudVJlY3R9XG4gICAgICAgICAgICAgICAgICAgIHJvbGU9e3RoaXMucHJvcHMubWFuYWdlZCA/IFwibWVudVwiIDogdW5kZWZpbmVkfVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgeyBib2R5IH1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJlbmRlcigpOiBSZWFjdC5SZWFjdENoaWxkIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMubW91bnRBc0NoaWxkKSB7XG4gICAgICAgICAgICAvLyBSZW5kZXIgYXMgYSBjaGlsZCBvZiB0aGUgY3VycmVudCBwYXJlbnRcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlck1lbnUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlbmRlciBhcyBhIGNoaWxkIG9mIGEgY29udGFpbmVyIGF0IHRoZSByb290IG9mIHRoZSBET01cbiAgICAgICAgICAgIHJldHVybiBSZWFjdERPTS5jcmVhdGVQb3J0YWwodGhpcy5yZW5kZXJNZW51KCksIGdldE9yQ3JlYXRlQ29udGFpbmVyKCkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgdHlwZSBUb1JpZ2h0T2YgPSB7XG4gICAgbGVmdDogbnVtYmVyO1xuICAgIHRvcDogbnVtYmVyO1xuICAgIGNoZXZyb25PZmZzZXQ6IG51bWJlcjtcbn07XG5cbi8vIFBsYWNlbWVudCBtZXRob2QgZm9yIDxDb250ZXh0TWVudSAvPiB0byBwb3NpdGlvbiBjb250ZXh0IG1lbnUgdG8gcmlnaHQgb2YgZWxlbWVudFJlY3Qgd2l0aCBjaGV2cm9uT2Zmc2V0XG5leHBvcnQgY29uc3QgdG9SaWdodE9mID0gKGVsZW1lbnRSZWN0OiBQaWNrPERPTVJlY3QsIFwicmlnaHRcIiB8IFwidG9wXCIgfCBcImhlaWdodFwiPiwgY2hldnJvbk9mZnNldCA9IDEyKTogVG9SaWdodE9mID0+IHtcbiAgICBjb25zdCBsZWZ0ID0gZWxlbWVudFJlY3QucmlnaHQgKyB3aW5kb3cucGFnZVhPZmZzZXQgKyAzO1xuICAgIGxldCB0b3AgPSBlbGVtZW50UmVjdC50b3AgKyAoZWxlbWVudFJlY3QuaGVpZ2h0IC8gMikgKyB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgdG9wIC09IGNoZXZyb25PZmZzZXQgKyA4OyAvLyB3aGVyZSA4IGlzIGhhbGYgdGhlIGhlaWdodCBvZiB0aGUgY2hldnJvblxuICAgIHJldHVybiB7IGxlZnQsIHRvcCwgY2hldnJvbk9mZnNldCB9O1xufTtcblxuZXhwb3J0IHR5cGUgQWJvdmVMZWZ0T2YgPSBJUG9zaXRpb24gJiB7XG4gICAgY2hldnJvbkZhY2U6IENoZXZyb25GYWNlO1xufTtcblxuLy8gUGxhY2VtZW50IG1ldGhvZCBmb3IgPENvbnRleHRNZW51IC8+IHRvIHBvc2l0aW9uIGNvbnRleHQgbWVudSByaWdodC1hbGlnbmVkIGFuZCBmbG93aW5nIHRvIHRoZSBsZWZ0IG9mIGVsZW1lbnRSZWN0LFxuLy8gYW5kIGVpdGhlciBhYm92ZSBvciBiZWxvdzogd2hlcmV2ZXIgdGhlcmUgaXMgbW9yZSBzcGFjZSAobWF5YmUgdGhpcyBzaG91bGQgYmUgYWJvdmVPckJlbG93TGVmdE9mPylcbmV4cG9ydCBjb25zdCBhYm92ZUxlZnRPZiA9IChcbiAgICBlbGVtZW50UmVjdDogRE9NUmVjdCxcbiAgICBjaGV2cm9uRmFjZSA9IENoZXZyb25GYWNlLk5vbmUsXG4gICAgdlBhZGRpbmcgPSAwLFxuKTogQWJvdmVMZWZ0T2YgPT4ge1xuICAgIGNvbnN0IG1lbnVPcHRpb25zOiBJUG9zaXRpb24gJiB7IGNoZXZyb25GYWNlOiBDaGV2cm9uRmFjZSB9ID0geyBjaGV2cm9uRmFjZSB9O1xuXG4gICAgY29uc3QgYnV0dG9uUmlnaHQgPSBlbGVtZW50UmVjdC5yaWdodCArIHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICBjb25zdCBidXR0b25Cb3R0b20gPSBlbGVtZW50UmVjdC5ib3R0b20gKyB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgY29uc3QgYnV0dG9uVG9wID0gZWxlbWVudFJlY3QudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgIC8vIEFsaWduIHRoZSByaWdodCBlZGdlIG9mIHRoZSBtZW51IHRvIHRoZSByaWdodCBlZGdlIG9mIHRoZSBidXR0b25cbiAgICBtZW51T3B0aW9ucy5yaWdodCA9IFVJU3RvcmUuaW5zdGFuY2Uud2luZG93V2lkdGggLSBidXR0b25SaWdodDtcbiAgICAvLyBBbGlnbiB0aGUgbWVudSB2ZXJ0aWNhbGx5IG9uIHdoaWNoZXZlciBzaWRlIG9mIHRoZSBidXR0b24gaGFzIG1vcmUgc3BhY2UgYXZhaWxhYmxlLlxuICAgIGlmIChidXR0b25Cb3R0b20gPCBVSVN0b3JlLmluc3RhbmNlLndpbmRvd0hlaWdodCAvIDIpIHtcbiAgICAgICAgbWVudU9wdGlvbnMudG9wID0gYnV0dG9uQm90dG9tICsgdlBhZGRpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbWVudU9wdGlvbnMuYm90dG9tID0gKFVJU3RvcmUuaW5zdGFuY2Uud2luZG93SGVpZ2h0IC0gYnV0dG9uVG9wKSArIHZQYWRkaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBtZW51T3B0aW9ucztcbn07XG5cbi8vIFBsYWNlbWVudCBtZXRob2QgZm9yIDxDb250ZXh0TWVudSAvPiB0byBwb3NpdGlvbiBjb250ZXh0IG1lbnUgcmlnaHQtYWxpZ25lZCBhbmQgZmxvd2luZyB0byB0aGUgbGVmdCBvZiBlbGVtZW50UmVjdFxuLy8gYW5kIGFsd2F5cyBhYm92ZSBlbGVtZW50UmVjdFxuZXhwb3J0IGNvbnN0IGFsd2F5c0Fib3ZlTGVmdE9mID0gKGVsZW1lbnRSZWN0OiBET01SZWN0LCBjaGV2cm9uRmFjZSA9IENoZXZyb25GYWNlLk5vbmUsIHZQYWRkaW5nID0gMCkgPT4ge1xuICAgIGNvbnN0IG1lbnVPcHRpb25zOiBJUG9zaXRpb24gJiB7IGNoZXZyb25GYWNlOiBDaGV2cm9uRmFjZSB9ID0geyBjaGV2cm9uRmFjZSB9O1xuXG4gICAgY29uc3QgYnV0dG9uUmlnaHQgPSBlbGVtZW50UmVjdC5yaWdodCArIHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICBjb25zdCBidXR0b25Cb3R0b20gPSBlbGVtZW50UmVjdC5ib3R0b20gKyB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgY29uc3QgYnV0dG9uVG9wID0gZWxlbWVudFJlY3QudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgIC8vIEFsaWduIHRoZSByaWdodCBlZGdlIG9mIHRoZSBtZW51IHRvIHRoZSByaWdodCBlZGdlIG9mIHRoZSBidXR0b25cbiAgICBtZW51T3B0aW9ucy5yaWdodCA9IFVJU3RvcmUuaW5zdGFuY2Uud2luZG93V2lkdGggLSBidXR0b25SaWdodDtcbiAgICAvLyBBbGlnbiB0aGUgbWVudSB2ZXJ0aWNhbGx5IG9uIHdoaWNoZXZlciBzaWRlIG9mIHRoZSBidXR0b24gaGFzIG1vcmUgc3BhY2UgYXZhaWxhYmxlLlxuICAgIGlmIChidXR0b25Cb3R0b20gPCBVSVN0b3JlLmluc3RhbmNlLndpbmRvd0hlaWdodCAvIDIpIHtcbiAgICAgICAgbWVudU9wdGlvbnMudG9wID0gYnV0dG9uQm90dG9tICsgdlBhZGRpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbWVudU9wdGlvbnMuYm90dG9tID0gKFVJU3RvcmUuaW5zdGFuY2Uud2luZG93SGVpZ2h0IC0gYnV0dG9uVG9wKSArIHZQYWRkaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBtZW51T3B0aW9ucztcbn07XG5cbi8vIFBsYWNlbWVudCBtZXRob2QgZm9yIDxDb250ZXh0TWVudSAvPiB0byBwb3NpdGlvbiBjb250ZXh0IG1lbnUgcmlnaHQtYWxpZ25lZCBhbmQgZmxvd2luZyB0byB0aGUgcmlnaHQgb2YgZWxlbWVudFJlY3Rcbi8vIGFuZCBhbHdheXMgYWJvdmUgZWxlbWVudFJlY3RcbmV4cG9ydCBjb25zdCBhbHdheXNBYm92ZVJpZ2h0T2YgPSAoZWxlbWVudFJlY3Q6IERPTVJlY3QsIGNoZXZyb25GYWNlID0gQ2hldnJvbkZhY2UuTm9uZSwgdlBhZGRpbmcgPSAwKSA9PiB7XG4gICAgY29uc3QgbWVudU9wdGlvbnM6IElQb3NpdGlvbiAmIHsgY2hldnJvbkZhY2U6IENoZXZyb25GYWNlIH0gPSB7IGNoZXZyb25GYWNlIH07XG5cbiAgICBjb25zdCBidXR0b25MZWZ0ID0gZWxlbWVudFJlY3QubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICBjb25zdCBidXR0b25Ub3AgPSBlbGVtZW50UmVjdC50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgLy8gQWxpZ24gdGhlIGxlZnQgZWRnZSBvZiB0aGUgbWVudSB0byB0aGUgbGVmdCBlZGdlIG9mIHRoZSBidXR0b25cbiAgICBtZW51T3B0aW9ucy5sZWZ0ID0gYnV0dG9uTGVmdDtcbiAgICAvLyBBbGlnbiB0aGUgbWVudSB2ZXJ0aWNhbGx5IGFib3ZlIHRoZSBtZW51XG4gICAgbWVudU9wdGlvbnMuYm90dG9tID0gKFVJU3RvcmUuaW5zdGFuY2Uud2luZG93SGVpZ2h0IC0gYnV0dG9uVG9wKSArIHZQYWRkaW5nO1xuXG4gICAgcmV0dXJuIG1lbnVPcHRpb25zO1xufTtcblxudHlwZSBDb250ZXh0TWVudVR1cGxlPFQ+ID0gW2Jvb2xlYW4sIFJlZk9iamVjdDxUPiwgKCkgPT4gdm9pZCwgKCkgPT4gdm9pZCwgKHZhbDogYm9vbGVhbikgPT4gdm9pZF07XG5leHBvcnQgY29uc3QgdXNlQ29udGV4dE1lbnUgPSA8VCBleHRlbmRzIGFueSA9IEhUTUxFbGVtZW50PigpOiBDb250ZXh0TWVudVR1cGxlPFQ+ID0+IHtcbiAgICBjb25zdCBidXR0b24gPSB1c2VSZWY8VD4obnVsbCk7XG4gICAgY29uc3QgW2lzT3Blbiwgc2V0SXNPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBvcGVuID0gKGV2PzogU3ludGhldGljRXZlbnQpID0+IHtcbiAgICAgICAgZXY/LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2Py5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgc2V0SXNPcGVuKHRydWUpO1xuICAgIH07XG4gICAgY29uc3QgY2xvc2UgPSAoZXY/OiBTeW50aGV0aWNFdmVudCkgPT4ge1xuICAgICAgICBldj8ucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXY/LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBzZXRJc09wZW4oZmFsc2UpO1xuICAgIH07XG5cbiAgICByZXR1cm4gW2lzT3BlbiwgYnV0dG9uLCBvcGVuLCBjbG9zZSwgc2V0SXNPcGVuXTtcbn07XG5cbi8vIFhYWDogRGVwcmVjYXRlZCwgdXNlZCBvbmx5IGZvciBkeW5hbWljIFRvb2x0aXBzLiBBdm9pZCB1c2luZyBhdCBhbGwgY29zdHMuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWVudShFbGVtZW50Q2xhc3MsIHByb3BzKSB7XG4gICAgY29uc3Qgb25GaW5pc2hlZCA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZShnZXRPckNyZWF0ZUNvbnRhaW5lcigpKTtcbiAgICAgICAgcHJvcHM/Lm9uRmluaXNoZWQ/LmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBjb25zdCBtZW51ID0gPENvbnRleHRNZW51XG4gICAgICAgIHsuLi5wcm9wc31cbiAgICAgICAgbW91bnRBc0NoaWxkPXt0cnVlfVxuICAgICAgICBoYXNCYWNrZ3JvdW5kPXtmYWxzZX1cbiAgICAgICAgb25GaW5pc2hlZD17b25GaW5pc2hlZH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSByZWFjdC9qc3gtbm8tYmluZFxuICAgICAgICB3aW5kb3dSZXNpemU9e29uRmluaXNoZWR9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVhY3QvanN4LW5vLWJpbmRcbiAgICA+XG4gICAgICAgIDxFbGVtZW50Q2xhc3Mgey4uLnByb3BzfSBvbkZpbmlzaGVkPXtvbkZpbmlzaGVkfSAvPlxuICAgIDwvQ29udGV4dE1lbnU+O1xuXG4gICAgUmVhY3RET00ucmVuZGVyKG1lbnUsIGdldE9yQ3JlYXRlQ29udGFpbmVyKCkpO1xuXG4gICAgcmV0dXJuIHsgY2xvc2U6IG9uRmluaXNoZWQgfTtcbn1cblxuLy8gcmUtZXhwb3J0IHRoZSBzZW1hbnRpYyBoZWxwZXIgY29tcG9uZW50cyBmb3Igc2ltcGxpY2l0eVxuZXhwb3J0IHsgQ29udGV4dE1lbnVCdXR0b24gfSBmcm9tIFwiLi4vLi4vYWNjZXNzaWJpbGl0eS9jb250ZXh0X21lbnUvQ29udGV4dE1lbnVCdXR0b25cIjtcbmV4cG9ydCB7IENvbnRleHRNZW51VG9vbHRpcEJ1dHRvbiB9IGZyb20gXCIuLi8uLi9hY2Nlc3NpYmlsaXR5L2NvbnRleHRfbWVudS9Db250ZXh0TWVudVRvb2x0aXBCdXR0b25cIjtcbmV4cG9ydCB7IE1lbnVHcm91cCB9IGZyb20gXCIuLi8uLi9hY2Nlc3NpYmlsaXR5L2NvbnRleHRfbWVudS9NZW51R3JvdXBcIjtcbmV4cG9ydCB7IE1lbnVJdGVtIH0gZnJvbSBcIi4uLy4uL2FjY2Vzc2liaWxpdHkvY29udGV4dF9tZW51L01lbnVJdGVtXCI7XG5leHBvcnQgeyBNZW51SXRlbUNoZWNrYm94IH0gZnJvbSBcIi4uLy4uL2FjY2Vzc2liaWxpdHkvY29udGV4dF9tZW51L01lbnVJdGVtQ2hlY2tib3hcIjtcbmV4cG9ydCB7IE1lbnVJdGVtUmFkaW8gfSBmcm9tIFwiLi4vLi4vYWNjZXNzaWJpbGl0eS9jb250ZXh0X21lbnUvTWVudUl0ZW1SYWRpb1wiO1xuZXhwb3J0IHsgU3R5bGVkTWVudUl0ZW1DaGVja2JveCB9IGZyb20gXCIuLi8uLi9hY2Nlc3NpYmlsaXR5L2NvbnRleHRfbWVudS9TdHlsZWRNZW51SXRlbUNoZWNrYm94XCI7XG5leHBvcnQgeyBTdHlsZWRNZW51SXRlbVJhZGlvIH0gZnJvbSBcIi4uLy4uL2FjY2Vzc2liaWxpdHkvY29udGV4dF9tZW51L1N0eWxlZE1lbnVJdGVtUmFkaW9cIjtcbiJdfQ==