"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _SyntaxHighlight = _interopRequireDefault(require("../views/elements/SyntaxHighlight"));

var _languageHandler = require("../../languageHandler");

var _MatrixClientContext = _interopRequireDefault(require("../../contexts/MatrixClientContext"));

var _DevtoolsDialog = require("../views/dialogs/DevtoolsDialog");

var _EventUtils = require("../../utils/EventUtils");

var _MatrixClientPeg = require("../../MatrixClientPeg");

var _replaceableComponent = require("../../utils/replaceableComponent");

var _BaseDialog = _interopRequireDefault(require("../views/dialogs/BaseDialog"));

var _dec, _class;

let ViewSource = (_dec = (0, _replaceableComponent.replaceableComponent)("structures.ViewSource"), _dec(_class = class ViewSource extends _react.default.Component {
  constructor(props) {
    super(props);
    this.state = {
      isEditing: false
    };
  }

  onBack() {
    // TODO: refresh the "Event ID:" modal header
    this.setState({
      isEditing: false
    });
  }

  onEdit() {
    this.setState({
      isEditing: true
    });
  } // returns the dialog body for viewing the event source


  viewSourceContent() {
    const mxEvent = this.props.mxEvent.replacingEvent() || this.props.mxEvent; // show the replacing event, not the original, if it is an edit

    const isEncrypted = mxEvent.isEncrypted(); // @ts-ignore

    const decryptedEventSource = mxEvent.clearEvent; // FIXME: clearEvent is private

    const originalEventSource = mxEvent.event;

    if (isEncrypted) {
      return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement("details", {
        open: true,
        className: "mx_ViewSource_details"
      }, /*#__PURE__*/_react.default.createElement("summary", null, /*#__PURE__*/_react.default.createElement("span", {
        className: "mx_ViewSource_heading"
      }, (0, _languageHandler._t)("Decrypted event source"))), /*#__PURE__*/_react.default.createElement(_SyntaxHighlight.default, {
        className: "json"
      }, JSON.stringify(decryptedEventSource, null, 2))), /*#__PURE__*/_react.default.createElement("details", {
        className: "mx_ViewSource_details"
      }, /*#__PURE__*/_react.default.createElement("summary", null, /*#__PURE__*/_react.default.createElement("span", {
        className: "mx_ViewSource_heading"
      }, (0, _languageHandler._t)("Original event source"))), /*#__PURE__*/_react.default.createElement(_SyntaxHighlight.default, {
        className: "json"
      }, JSON.stringify(originalEventSource, null, 2))));
    } else {
      return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_ViewSource_heading"
      }, (0, _languageHandler._t)("Original event source")), /*#__PURE__*/_react.default.createElement(_SyntaxHighlight.default, {
        className: "json"
      }, JSON.stringify(originalEventSource, null, 2)));
    }
  } // returns the id of the initial message, not the id of the previous edit


  getBaseEventId() {
    const mxEvent = this.props.mxEvent.replacingEvent() || this.props.mxEvent; // show the replacing event, not the original, if it is an edit

    const isEncrypted = mxEvent.isEncrypted();
    const baseMxEvent = this.props.mxEvent;

    if (isEncrypted) {
      var _mxEvent$event$conten;

      // `relates_to` field is inside the encrypted event
      return ((_mxEvent$event$conten = mxEvent.event.content["m.relates_to"]) === null || _mxEvent$event$conten === void 0 ? void 0 : _mxEvent$event$conten.event_id) ?? baseMxEvent.getId();
    } else {
      var _mxEvent$getContent$m;

      return ((_mxEvent$getContent$m = mxEvent.getContent()["m.relates_to"]) === null || _mxEvent$getContent$m === void 0 ? void 0 : _mxEvent$getContent$m.event_id) ?? baseMxEvent.getId();
    }
  } // returns the SendCustomEvent component prefilled with the correct details


  editSourceContent() {
    const mxEvent = this.props.mxEvent.replacingEvent() || this.props.mxEvent; // show the replacing event, not the original, if it is an edit

    const isStateEvent = mxEvent.isState();
    const roomId = mxEvent.getRoomId();
    const originalContent = mxEvent.getContent();

    if (isStateEvent) {
      return /*#__PURE__*/_react.default.createElement(_MatrixClientContext.default.Consumer, null, cli => /*#__PURE__*/_react.default.createElement(_DevtoolsDialog.SendCustomEvent, {
        room: cli.getRoom(roomId),
        forceStateEvent: true,
        onBack: () => this.onBack(),
        inputs: {
          eventType: mxEvent.getType(),
          evContent: JSON.stringify(originalContent, null, "\t"),
          stateKey: mxEvent.getStateKey()
        }
      }));
    } else {
      var _originalContent$mNe;

      // prefill an edit-message event
      // keep only the `body` and `msgtype` fields of originalContent
      const bodyToStartFrom = ((_originalContent$mNe = originalContent["m.new_content"]) === null || _originalContent$mNe === void 0 ? void 0 : _originalContent$mNe.body) ?? originalContent.body; // prefill the last edit body, to start editing from there

      const newContent = {
        "body": ` * ${bodyToStartFrom}`,
        "msgtype": originalContent.msgtype,
        "m.new_content": {
          body: bodyToStartFrom,
          msgtype: originalContent.msgtype
        },
        "m.relates_to": {
          rel_type: "m.replace",
          event_id: this.getBaseEventId()
        }
      };
      return /*#__PURE__*/_react.default.createElement(_MatrixClientContext.default.Consumer, null, cli => /*#__PURE__*/_react.default.createElement(_DevtoolsDialog.SendCustomEvent, {
        room: cli.getRoom(roomId),
        forceStateEvent: false,
        forceGeneralEvent: true,
        onBack: () => this.onBack(),
        inputs: {
          eventType: mxEvent.getType(),
          evContent: JSON.stringify(newContent, null, "\t")
        }
      }));
    }
  }

  canSendStateEvent(mxEvent) {
    const cli = _MatrixClientPeg.MatrixClientPeg.get();

    const room = cli.getRoom(mxEvent.getRoomId());
    return room.currentState.mayClientSendStateEvent(mxEvent.getType(), cli);
  }

  render() {
    const mxEvent = this.props.mxEvent.replacingEvent() || this.props.mxEvent; // show the replacing event, not the original, if it is an edit

    const isEditing = this.state.isEditing;
    const roomId = mxEvent.getRoomId();
    const eventId = mxEvent.getId();
    const canEdit = mxEvent.isState() ? this.canSendStateEvent(mxEvent) : (0, _EventUtils.canEditContent)(this.props.mxEvent);
    return /*#__PURE__*/_react.default.createElement(_BaseDialog.default, {
      className: "mx_ViewSource",
      onFinished: this.props.onFinished,
      title: (0, _languageHandler._t)("View Source")
    }, /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("div", null, "Room ID: ", roomId), /*#__PURE__*/_react.default.createElement("div", null, "Event ID: ", eventId), /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_ViewSource_separator"
    }), isEditing ? this.editSourceContent() : this.viewSourceContent()), !isEditing && canEdit && /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_Dialog_buttons"
    }, /*#__PURE__*/_react.default.createElement("button", {
      onClick: () => this.onEdit()
    }, (0, _languageHandler._t)("Edit"))));
  }

}) || _class);
exports.default = ViewSource;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3N0cnVjdHVyZXMvVmlld1NvdXJjZS50c3giXSwibmFtZXMiOlsiVmlld1NvdXJjZSIsIlJlYWN0IiwiQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJwcm9wcyIsInN0YXRlIiwiaXNFZGl0aW5nIiwib25CYWNrIiwic2V0U3RhdGUiLCJvbkVkaXQiLCJ2aWV3U291cmNlQ29udGVudCIsIm14RXZlbnQiLCJyZXBsYWNpbmdFdmVudCIsImlzRW5jcnlwdGVkIiwiZGVjcnlwdGVkRXZlbnRTb3VyY2UiLCJjbGVhckV2ZW50Iiwib3JpZ2luYWxFdmVudFNvdXJjZSIsImV2ZW50IiwiSlNPTiIsInN0cmluZ2lmeSIsImdldEJhc2VFdmVudElkIiwiYmFzZU14RXZlbnQiLCJjb250ZW50IiwiZXZlbnRfaWQiLCJnZXRJZCIsImdldENvbnRlbnQiLCJlZGl0U291cmNlQ29udGVudCIsImlzU3RhdGVFdmVudCIsImlzU3RhdGUiLCJyb29tSWQiLCJnZXRSb29tSWQiLCJvcmlnaW5hbENvbnRlbnQiLCJjbGkiLCJnZXRSb29tIiwiZXZlbnRUeXBlIiwiZ2V0VHlwZSIsImV2Q29udGVudCIsInN0YXRlS2V5IiwiZ2V0U3RhdGVLZXkiLCJib2R5VG9TdGFydEZyb20iLCJib2R5IiwibmV3Q29udGVudCIsIm1zZ3R5cGUiLCJyZWxfdHlwZSIsImNhblNlbmRTdGF0ZUV2ZW50IiwiTWF0cml4Q2xpZW50UGVnIiwiZ2V0Iiwicm9vbSIsImN1cnJlbnRTdGF0ZSIsIm1heUNsaWVudFNlbmRTdGF0ZUV2ZW50IiwicmVuZGVyIiwiZXZlbnRJZCIsImNhbkVkaXQiLCJvbkZpbmlzaGVkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFrQkE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBR0E7Ozs7SUFXcUJBLFUsV0FEcEIsZ0RBQXFCLHVCQUFyQixDLGdCQUFELE1BQ3FCQSxVQURyQixTQUN3Q0MsZUFB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QUFMLENBQVdPLE9BQWxFLENBRHlCLENBQ2tEOztBQUUzRSxVQUFNTCxTQUFTLEdBQUcsS0FBS0QsS0FBTCxDQUFXQyxTQUE3QjtBQUNBLFVBQU11QixNQUFNLEdBQUdsQixPQUFPLENBQUNtQixTQUFSLEVBQWY7QUFDQSxVQUFNcUIsT0FBTyxHQUFHeEMsT0FBTyxDQUFDYSxLQUFSLEVBQWhCO0FBQ0EsVUFBTTRCLE9BQU8sR0FBR3pDLE9BQU8sQ0FBQ2lCLE9BQVIsS0FBb0IsS0FBS2dCLGlCQUFMLENBQXVCakMsT0FBdkIsQ0FBcEIsR0FBc0QsZ0NBQWUsS0FBS1AsS0FBTCxDQUFXTyxPQUExQixDQUF0RTtBQUNBLHdCQUNJLDZCQUFDLG1CQUFEO0FBQVksTUFBQSxTQUFTLEVBQUMsZUFBdEI7QUFBc0MsTUFBQSxVQUFVLEVBQUUsS0FBS1AsS0FBTCxDQUFXaUQsVUFBN0Q7QUFBeUUsTUFBQSxLQUFLLEVBQUUseUJBQUcsYUFBSDtBQUFoRixvQkFDSSx1REFDSSx1REFBZ0J4QixNQUFoQixDQURKLGVBRUksd0RBQWlCc0IsT0FBakIsQ0FGSixlQUdJO0FBQUssTUFBQSxTQUFTLEVBQUM7QUFBZixNQUhKLEVBSU03QyxTQUFTLEdBQUcsS0FBS29CLGlCQUFMLEVBQUgsR0FBOEIsS0FBS2hCLGlCQUFMLEVBSjdDLENBREosRUFPTSxDQUFDSixTQUFELElBQWM4QyxPQUFkLGlCQUNFO0FBQUssTUFBQSxTQUFTLEVBQUM7QUFBZixvQkFDSTtBQUFRLE1BQUEsT0FBTyxFQUFFLE1BQU0sS0FBSzNDLE1BQUw7QUFBdkIsT0FBd0MseUJBQUcsTUFBSCxDQUF4QyxDQURKLENBUlIsQ0FESjtBQWVIOztBQTNKbUUsQyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxNSwgMjAxNiBPcGVuTWFya2V0IEx0ZFxuQ29weXJpZ2h0IDIwMTkgTWljaGFlbCBUZWxhdHluc2tpIDw3dDNjaGd1eUBnbWFpbC5jb20+XG5Db3B5cmlnaHQgMjAxOSBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBTeW50YXhIaWdobGlnaHQgZnJvbSBcIi4uL3ZpZXdzL2VsZW1lbnRzL1N5bnRheEhpZ2hsaWdodFwiO1xuaW1wb3J0IHsgX3QgfSBmcm9tIFwiLi4vLi4vbGFuZ3VhZ2VIYW5kbGVyXCI7XG5pbXBvcnQgTWF0cml4Q2xpZW50Q29udGV4dCBmcm9tIFwiLi4vLi4vY29udGV4dHMvTWF0cml4Q2xpZW50Q29udGV4dFwiO1xuaW1wb3J0IHsgU2VuZEN1c3RvbUV2ZW50IH0gZnJvbSBcIi4uL3ZpZXdzL2RpYWxvZ3MvRGV2dG9vbHNEaWFsb2dcIjtcbmltcG9ydCB7IGNhbkVkaXRDb250ZW50IH0gZnJvbSBcIi4uLy4uL3V0aWxzL0V2ZW50VXRpbHNcIjtcbmltcG9ydCB7IE1hdHJpeENsaWVudFBlZyB9IGZyb20gJy4uLy4uL01hdHJpeENsaWVudFBlZyc7XG5pbXBvcnQgeyByZXBsYWNlYWJsZUNvbXBvbmVudCB9IGZyb20gXCIuLi8uLi91dGlscy9yZXBsYWNlYWJsZUNvbXBvbmVudFwiO1xuaW1wb3J0IHsgTWF0cml4RXZlbnQgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvbW9kZWxzL2V2ZW50XCI7XG5pbXBvcnQgeyBJRGlhbG9nUHJvcHMgfSBmcm9tIFwiLi4vdmlld3MvZGlhbG9ncy9JRGlhbG9nUHJvcHNcIjtcbmltcG9ydCBCYXNlRGlhbG9nIGZyb20gXCIuLi92aWV3cy9kaWFsb2dzL0Jhc2VEaWFsb2dcIjtcblxuaW50ZXJmYWNlIElQcm9wcyBleHRlbmRzIElEaWFsb2dQcm9wcyB7XG4gICAgbXhFdmVudDogTWF0cml4RXZlbnQ7IC8vIHRoZSBNYXRyaXhFdmVudCBhc3NvY2lhdGVkIHdpdGggdGhlIGNvbnRleHQgbWVudVxufVxuXG5pbnRlcmZhY2UgSVN0YXRlIHtcbiAgICBpc0VkaXRpbmc6IGJvb2xlYW47XG59XG5cbkByZXBsYWNlYWJsZUNvbXBvbmVudChcInN0cnVjdHVyZXMuVmlld1NvdXJjZVwiKVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlld1NvdXJjZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxJUHJvcHMsIElTdGF0ZT4ge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzOiBJUHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBpc0VkaXRpbmc6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgb25CYWNrKCk6IHZvaWQge1xuICAgICAgICAvLyBUT0RPOiByZWZyZXNoIHRoZSBcIkV2ZW50IElEOlwiIG1vZGFsIGhlYWRlclxuICAgICAgICB0aGlzLnNldFN0YXRlKHsgaXNFZGl0aW5nOiBmYWxzZSB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uRWRpdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGlzRWRpdGluZzogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIHRoZSBkaWFsb2cgYm9keSBmb3Igdmlld2luZyB0aGUgZXZlbnQgc291cmNlXG4gICAgcHJpdmF0ZSB2aWV3U291cmNlQ29udGVudCgpOiBKU1guRWxlbWVudCB7XG4gICAgICAgIGNvbnN0IG14RXZlbnQgPSB0aGlzLnByb3BzLm14RXZlbnQucmVwbGFjaW5nRXZlbnQoKSB8fCB0aGlzLnByb3BzLm14RXZlbnQ7IC8vIHNob3cgdGhlIHJlcGxhY2luZyBldmVudCwgbm90IHRoZSBvcmlnaW5hbCwgaWYgaXQgaXMgYW4gZWRpdFxuICAgICAgICBjb25zdCBpc0VuY3J5cHRlZCA9IG14RXZlbnQuaXNFbmNyeXB0ZWQoKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCBkZWNyeXB0ZWRFdmVudFNvdXJjZSA9IG14RXZlbnQuY2xlYXJFdmVudDsgLy8gRklYTUU6IGNsZWFyRXZlbnQgaXMgcHJpdmF0ZVxuICAgICAgICBjb25zdCBvcmlnaW5hbEV2ZW50U291cmNlID0gbXhFdmVudC5ldmVudDtcblxuICAgICAgICBpZiAoaXNFbmNyeXB0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPGRldGFpbHMgb3BlbiBjbGFzc05hbWU9XCJteF9WaWV3U291cmNlX2RldGFpbHNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzdW1tYXJ5PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cIm14X1ZpZXdTb3VyY2VfaGVhZGluZ1wiPnsgX3QoXCJEZWNyeXB0ZWQgZXZlbnQgc291cmNlXCIpIH08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3N1bW1hcnk+XG4gICAgICAgICAgICAgICAgICAgICAgICA8U3ludGF4SGlnaGxpZ2h0IGNsYXNzTmFtZT1cImpzb25cIj57IEpTT04uc3RyaW5naWZ5KGRlY3J5cHRlZEV2ZW50U291cmNlLCBudWxsLCAyKSB9PC9TeW50YXhIaWdobGlnaHQ+XG4gICAgICAgICAgICAgICAgICAgIDwvZGV0YWlscz5cbiAgICAgICAgICAgICAgICAgICAgPGRldGFpbHMgY2xhc3NOYW1lPVwibXhfVmlld1NvdXJjZV9kZXRhaWxzXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3VtbWFyeT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJteF9WaWV3U291cmNlX2hlYWRpbmdcIj57IF90KFwiT3JpZ2luYWwgZXZlbnQgc291cmNlXCIpIH08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3N1bW1hcnk+XG4gICAgICAgICAgICAgICAgICAgICAgICA8U3ludGF4SGlnaGxpZ2h0IGNsYXNzTmFtZT1cImpzb25cIj57IEpTT04uc3RyaW5naWZ5KG9yaWdpbmFsRXZlbnRTb3VyY2UsIG51bGwsIDIpIH08L1N5bnRheEhpZ2hsaWdodD5cbiAgICAgICAgICAgICAgICAgICAgPC9kZXRhaWxzPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJteF9WaWV3U291cmNlX2hlYWRpbmdcIj57IF90KFwiT3JpZ2luYWwgZXZlbnQgc291cmNlXCIpIH08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPFN5bnRheEhpZ2hsaWdodCBjbGFzc05hbWU9XCJqc29uXCI+eyBKU09OLnN0cmluZ2lmeShvcmlnaW5hbEV2ZW50U291cmNlLCBudWxsLCAyKSB9PC9TeW50YXhIaWdobGlnaHQ+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmV0dXJucyB0aGUgaWQgb2YgdGhlIGluaXRpYWwgbWVzc2FnZSwgbm90IHRoZSBpZCBvZiB0aGUgcHJldmlvdXMgZWRpdFxuICAgIHByaXZhdGUgZ2V0QmFzZUV2ZW50SWQoKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgbXhFdmVudCA9IHRoaXMucHJvcHMubXhFdmVudC5yZXBsYWNpbmdFdmVudCgpIHx8IHRoaXMucHJvcHMubXhFdmVudDsgLy8gc2hvdyB0aGUgcmVwbGFjaW5nIGV2ZW50LCBub3QgdGhlIG9yaWdpbmFsLCBpZiBpdCBpcyBhbiBlZGl0XG4gICAgICAgIGNvbnN0IGlzRW5jcnlwdGVkID0gbXhFdmVudC5pc0VuY3J5cHRlZCgpO1xuICAgICAgICBjb25zdCBiYXNlTXhFdmVudCA9IHRoaXMucHJvcHMubXhFdmVudDtcblxuICAgICAgICBpZiAoaXNFbmNyeXB0ZWQpIHtcbiAgICAgICAgICAgIC8vIGByZWxhdGVzX3RvYCBmaWVsZCBpcyBpbnNpZGUgdGhlIGVuY3J5cHRlZCBldmVudFxuICAgICAgICAgICAgcmV0dXJuIG14RXZlbnQuZXZlbnQuY29udGVudFtcIm0ucmVsYXRlc190b1wiXT8uZXZlbnRfaWQgPz8gYmFzZU14RXZlbnQuZ2V0SWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBteEV2ZW50LmdldENvbnRlbnQoKVtcIm0ucmVsYXRlc190b1wiXT8uZXZlbnRfaWQgPz8gYmFzZU14RXZlbnQuZ2V0SWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJldHVybnMgdGhlIFNlbmRDdXN0b21FdmVudCBjb21wb25lbnQgcHJlZmlsbGVkIHdpdGggdGhlIGNvcnJlY3QgZGV0YWlsc1xuICAgIHByaXZhdGUgZWRpdFNvdXJjZUNvbnRlbnQoKTogSlNYLkVsZW1lbnQge1xuICAgICAgICBjb25zdCBteEV2ZW50ID0gdGhpcy5wcm9wcy5teEV2ZW50LnJlcGxhY2luZ0V2ZW50KCkgfHwgdGhpcy5wcm9wcy5teEV2ZW50OyAvLyBzaG93IHRoZSByZXBsYWNpbmcgZXZlbnQsIG5vdCB0aGUgb3JpZ2luYWwsIGlmIGl0IGlzIGFuIGVkaXRcblxuICAgICAgICBjb25zdCBpc1N0YXRlRXZlbnQgPSBteEV2ZW50LmlzU3RhdGUoKTtcbiAgICAgICAgY29uc3Qgcm9vbUlkID0gbXhFdmVudC5nZXRSb29tSWQoKTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxDb250ZW50ID0gbXhFdmVudC5nZXRDb250ZW50KCk7XG5cbiAgICAgICAgaWYgKGlzU3RhdGVFdmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8TWF0cml4Q2xpZW50Q29udGV4dC5Db25zdW1lcj5cbiAgICAgICAgICAgICAgICAgICAgeyAoY2xpKSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8U2VuZEN1c3RvbUV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vbT17Y2xpLmdldFJvb20ocm9vbUlkKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZVN0YXRlRXZlbnQ9e3RydWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25CYWNrPXsoKSA9PiB0aGlzLm9uQmFjaygpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0cz17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFR5cGU6IG14RXZlbnQuZ2V0VHlwZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldkNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KG9yaWdpbmFsQ29udGVudCwgbnVsbCwgXCJcXHRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlS2V5OiBteEV2ZW50LmdldFN0YXRlS2V5KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICkgfVxuICAgICAgICAgICAgICAgIDwvTWF0cml4Q2xpZW50Q29udGV4dC5Db25zdW1lcj5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBwcmVmaWxsIGFuIGVkaXQtbWVzc2FnZSBldmVudFxuICAgICAgICAgICAgLy8ga2VlcCBvbmx5IHRoZSBgYm9keWAgYW5kIGBtc2d0eXBlYCBmaWVsZHMgb2Ygb3JpZ2luYWxDb250ZW50XG4gICAgICAgICAgICBjb25zdCBib2R5VG9TdGFydEZyb20gPSBvcmlnaW5hbENvbnRlbnRbXCJtLm5ld19jb250ZW50XCJdPy5ib2R5ID8/IG9yaWdpbmFsQ29udGVudC5ib2R5OyAvLyBwcmVmaWxsIHRoZSBsYXN0IGVkaXQgYm9keSwgdG8gc3RhcnQgZWRpdGluZyBmcm9tIHRoZXJlXG4gICAgICAgICAgICBjb25zdCBuZXdDb250ZW50ID0ge1xuICAgICAgICAgICAgICAgIFwiYm9keVwiOiBgICogJHtib2R5VG9TdGFydEZyb219YCxcbiAgICAgICAgICAgICAgICBcIm1zZ3R5cGVcIjogb3JpZ2luYWxDb250ZW50Lm1zZ3R5cGUsXG4gICAgICAgICAgICAgICAgXCJtLm5ld19jb250ZW50XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgYm9keTogYm9keVRvU3RhcnRGcm9tLFxuICAgICAgICAgICAgICAgICAgICBtc2d0eXBlOiBvcmlnaW5hbENvbnRlbnQubXNndHlwZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwibS5yZWxhdGVzX3RvXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgcmVsX3R5cGU6IFwibS5yZXBsYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50X2lkOiB0aGlzLmdldEJhc2VFdmVudElkKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxNYXRyaXhDbGllbnRDb250ZXh0LkNvbnN1bWVyPlxuICAgICAgICAgICAgICAgICAgICB7IChjbGkpID0+IChcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTZW5kQ3VzdG9tRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb29tPXtjbGkuZ2V0Um9vbShyb29tSWQpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlU3RhdGVFdmVudD17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VHZW5lcmFsRXZlbnQ9e3RydWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25CYWNrPXsoKSA9PiB0aGlzLm9uQmFjaygpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0cz17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFR5cGU6IG14RXZlbnQuZ2V0VHlwZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldkNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KG5ld0NvbnRlbnQsIG51bGwsIFwiXFx0XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICApIH1cbiAgICAgICAgICAgICAgICA8L01hdHJpeENsaWVudENvbnRleHQuQ29uc3VtZXI+XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjYW5TZW5kU3RhdGVFdmVudChteEV2ZW50OiBNYXRyaXhFdmVudCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBjbGkgPSBNYXRyaXhDbGllbnRQZWcuZ2V0KCk7XG4gICAgICAgIGNvbnN0IHJvb20gPSBjbGkuZ2V0Um9vbShteEV2ZW50LmdldFJvb21JZCgpKTtcbiAgICAgICAgcmV0dXJuIHJvb20uY3VycmVudFN0YXRlLm1heUNsaWVudFNlbmRTdGF0ZUV2ZW50KG14RXZlbnQuZ2V0VHlwZSgpLCBjbGkpO1xuICAgIH1cblxuICAgIHB1YmxpYyByZW5kZXIoKTogSlNYLkVsZW1lbnQge1xuICAgICAgICBjb25zdCBteEV2ZW50ID0gdGhpcy5wcm9wcy5teEV2ZW50LnJlcGxhY2luZ0V2ZW50KCkgfHwgdGhpcy5wcm9wcy5teEV2ZW50OyAvLyBzaG93IHRoZSByZXBsYWNpbmcgZXZlbnQsIG5vdCB0aGUgb3JpZ2luYWwsIGlmIGl0IGlzIGFuIGVkaXRcblxuICAgICAgICBjb25zdCBpc0VkaXRpbmcgPSB0aGlzLnN0YXRlLmlzRWRpdGluZztcbiAgICAgICAgY29uc3Qgcm9vbUlkID0gbXhFdmVudC5nZXRSb29tSWQoKTtcbiAgICAgICAgY29uc3QgZXZlbnRJZCA9IG14RXZlbnQuZ2V0SWQoKTtcbiAgICAgICAgY29uc3QgY2FuRWRpdCA9IG14RXZlbnQuaXNTdGF0ZSgpID8gdGhpcy5jYW5TZW5kU3RhdGVFdmVudChteEV2ZW50KSA6IGNhbkVkaXRDb250ZW50KHRoaXMucHJvcHMubXhFdmVudCk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8QmFzZURpYWxvZyBjbGFzc05hbWU9XCJteF9WaWV3U291cmNlXCIgb25GaW5pc2hlZD17dGhpcy5wcm9wcy5vbkZpbmlzaGVkfSB0aXRsZT17X3QoXCJWaWV3IFNvdXJjZVwiKX0+XG4gICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdj5Sb29tIElEOiB7IHJvb21JZCB9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXY+RXZlbnQgSUQ6IHsgZXZlbnRJZCB9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXhfVmlld1NvdXJjZV9zZXBhcmF0b3JcIiAvPlxuICAgICAgICAgICAgICAgICAgICB7IGlzRWRpdGluZyA/IHRoaXMuZWRpdFNvdXJjZUNvbnRlbnQoKSA6IHRoaXMudmlld1NvdXJjZUNvbnRlbnQoKSB9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgeyAhaXNFZGl0aW5nICYmIGNhbkVkaXQgJiYgKFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm14X0RpYWxvZ19idXR0b25zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHRoaXMub25FZGl0KCl9PnsgX3QoXCJFZGl0XCIpIH08L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKSB9XG4gICAgICAgICAgICA8L0Jhc2VEaWFsb2c+XG4gICAgICAgICk7XG4gICAgfVxufVxuIl19