"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _filesize = _interopRequireDefault(require("filesize"));

var _react = _interopRequireDefault(require("react"));

var _languageHandler = require("../../../languageHandler");

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _BaseDialog = _interopRequireDefault(require("./BaseDialog"));

var _DialogButtons = _interopRequireDefault(require("../elements/DialogButtons"));

var _dec, _class;

let UploadFailureDialog = (
/*
 * Tells the user about files we know cannot be uploaded before we even try uploading
 * them. This is named fairly generically but the only thing we check right now is
 * the size of the file.
 */
_dec = (0, _replaceableComponent.replaceableComponent)("views.dialogs.UploadFailureDialog"), _dec(_class = class UploadFailureDialog extends _react.default.Component {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "onCancelClick", () => {
      this.props.onFinished(false);
    });
    (0, _defineProperty2.default)(this, "onUploadClick", () => {
      this.props.onFinished(true);
    });
  }

  render() {
    let message;
    let preview;
    let buttons;

    if (this.props.totalFiles === 1 && this.props.badFiles.length === 1) {
      message = (0, _languageHandler._t)("This file is <b>too large</b> to upload. " + "The file size limit is %(limit)s but this file is %(sizeOfThisFile)s.", {
        limit: (0, _filesize.default)(this.props.contentMessages.getUploadLimit()),
        sizeOfThisFile: (0, _filesize.default)(this.props.badFiles[0].size)
      }, {
        b: sub => /*#__PURE__*/_react.default.createElement("b", null, sub)
      });
      buttons = /*#__PURE__*/_react.default.createElement(_DialogButtons.default, {
        primaryButton: (0, _languageHandler._t)('OK'),
        hasCancel: false,
        onPrimaryButtonClick: this.onCancelClick,
        focus: true
      });
    } else if (this.props.totalFiles === this.props.badFiles.length) {
      message = (0, _languageHandler._t)("These files are <b>too large</b> to upload. " + "The file size limit is %(limit)s.", {
        limit: (0, _filesize.default)(this.props.contentMessages.getUploadLimit())
      }, {
        b: sub => /*#__PURE__*/_react.default.createElement("b", null, sub)
      });
      buttons = /*#__PURE__*/_react.default.createElement(_DialogButtons.default, {
        primaryButton: (0, _languageHandler._t)('OK'),
        hasCancel: false,
        onPrimaryButtonClick: this.onCancelClick,
        focus: true
      });
    } else {
      message = (0, _languageHandler._t)("Some files are <b>too large</b> to be uploaded. " + "The file size limit is %(limit)s.", {
        limit: (0, _filesize.default)(this.props.contentMessages.getUploadLimit())
      }, {
        b: sub => /*#__PURE__*/_react.default.createElement("b", null, sub)
      });
      const howManyOthers = this.props.totalFiles - this.props.badFiles.length;
      buttons = /*#__PURE__*/_react.default.createElement(_DialogButtons.default, {
        primaryButton: (0, _languageHandler._t)('Upload %(count)s other files', {
          count: howManyOthers
        }),
        onPrimaryButtonClick: this.onUploadClick,
        hasCancel: true,
        cancelButton: (0, _languageHandler._t)("Cancel All"),
        onCancel: this.onCancelClick,
        focus: true
      });
    }

    return /*#__PURE__*/_react.default.createElement(_BaseDialog.default, {
      className: "mx_UploadFailureDialog",
      onFinished: this.onCancelClick,
      title: (0, _languageHandler._t)("Upload Error"),
      contentId: "mx_Dialog_content"
    }, /*#__PURE__*/_react.default.createElement("div", {
      id: "mx_Dialog_content"
    }, message, preview), buttons);
  }

}) || _class);
exports.default = UploadFailureDialog;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2RpYWxvZ3MvVXBsb2FkRmFpbHVyZURpYWxvZy50c3giXSwibmFtZXMiOlsiVXBsb2FkRmFpbHVyZURpYWxvZyIsIlJlYWN0IiwiQ29tcG9uZW50IiwicHJvcHMiLCJvbkZpbmlzaGVkIiwicmVuZGVyIiwibWVzc2FnZSIsInByZXZpZXciLCJidXR0b25zIiwidG90YWxGaWxlcyIsImJhZEZpbGVzIiwibGVuZ3RoIiwibGltaXQiLCJjb250ZW50TWVzc2FnZXMiLCJnZXRVcGxvYWRMaW1pdCIsInNpemVPZlRoaXNGaWxlIiwic2l6ZSIsImIiLCJzdWIiLCJvbkNhbmNlbENsaWNrIiwiaG93TWFueU90aGVycyIsImNvdW50Iiwib25VcGxvYWRDbGljayJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFnQkE7O0FBRUE7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7Ozs7SUFlcUJBLG1CO0FBTnJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7T0FDQyxnREFBcUIsbUNBQXJCLEMsZ0JBQUQsTUFDcUJBLG1CQURyQixTQUNpREMsZUFBTUMsU0FEdkQsQ0FDeUU7QUFBQTtBQUFBO0FBQUEseURBQzdDLE1BQVk7QUFDaEMsV0FBS0MsS0FBTCxDQUFXQyxVQUFYLENBQXNCLEtBQXRCO0FBQ0gsS0FIb0U7QUFBQSx5REFLN0MsTUFBWTtBQUNoQyxXQUFLRCxLQUFMLENBQVdDLFVBQVgsQ0FBc0IsSUFBdEI7QUFDSCxLQVBvRTtBQUFBOztBQVM5REMsRUFBQUEsTUFBTSxHQUFnQjtBQUN6QixRQUFJQyxPQUFKO0FBQ0EsUUFBSUMsT0FBSjtBQUNBLFFBQUlDLE9BQUo7O0FBQ0EsUUFBSSxLQUFLTCxLQUFMLENBQVdNLFVBQVgsS0FBMEIsQ0FBMUIsSUFBK0IsS0FBS04sS0FBTCxDQUFXTyxRQUFYLENBQW9CQyxNQUFwQixLQUErQixDQUFsRSxFQUFxRTtBQUNqRUwsTUFBQUEsT0FBTyxHQUFHLHlCQUNOLDhDQUNBLHVFQUZNLEVBR047QUFDSU0sUUFBQUEsS0FBSyxFQUFFLHVCQUFTLEtBQUtULEtBQUwsQ0FBV1UsZUFBWCxDQUEyQkMsY0FBM0IsRUFBVCxDQURYO0FBRUlDLFFBQUFBLGNBQWMsRUFBRSx1QkFBUyxLQUFLWixLQUFMLENBQVdPLFFBQVgsQ0FBb0IsQ0FBcEIsRUFBdUJNLElBQWhDO0FBRnBCLE9BSE0sRUFNSDtBQUNDQyxRQUFBQSxDQUFDLEVBQUVDLEdBQUcsaUJBQUksd0NBQUtBLEdBQUw7QUFEWCxPQU5HLENBQVY7QUFVQVYsTUFBQUEsT0FBTyxnQkFBRyw2QkFBQyxzQkFBRDtBQUFlLFFBQUEsYUFBYSxFQUFFLHlCQUFHLElBQUgsQ0FBOUI7QUFDTixRQUFBLFNBQVMsRUFBRSxLQURMO0FBRU4sUUFBQSxvQkFBb0IsRUFBRSxLQUFLVyxhQUZyQjtBQUdOLFFBQUEsS0FBSyxFQUFFO0FBSEQsUUFBVjtBQUtILEtBaEJELE1BZ0JPLElBQUksS0FBS2hCLEtBQUwsQ0FBV00sVUFBWCxLQUEwQixLQUFLTixLQUFMLENBQVdPLFFBQVgsQ0FBb0JDLE1BQWxELEVBQTBEO0FBQzdETCxNQUFBQSxPQUFPLEdBQUcseUJBQ04saURBQ0EsbUNBRk0sRUFHTjtBQUNJTSxRQUFBQSxLQUFLLEVBQUUsdUJBQVMsS0FBS1QsS0FBTCxDQUFXVSxlQUFYLENBQTJCQyxjQUEzQixFQUFUO0FBRFgsT0FITSxFQUtIO0FBQ0NHLFFBQUFBLENBQUMsRUFBRUMsR0FBRyxpQkFBSSx3Q0FBS0EsR0FBTDtBQURYLE9BTEcsQ0FBVjtBQVNBVixNQUFBQSxPQUFPLGdCQUFHLDZCQUFDLHNCQUFEO0FBQWUsUUFBQSxhQUFhLEVBQUUseUJBQUcsSUFBSCxDQUE5QjtBQUNOLFFBQUEsU0FBUyxFQUFFLEtBREw7QUFFTixRQUFBLG9CQUFvQixFQUFFLEtBQUtXLGFBRnJCO0FBR04sUUFBQSxLQUFLLEVBQUU7QUFIRCxRQUFWO0FBS0gsS0FmTSxNQWVBO0FBQ0hiLE1BQUFBLE9BQU8sR0FBRyx5QkFDTixxREFDQSxtQ0FGTSxFQUdOO0FBQ0lNLFFBQUFBLEtBQUssRUFBRSx1QkFBUyxLQUFLVCxLQUFMLENBQVdVLGVBQVgsQ0FBMkJDLGNBQTNCLEVBQVQ7QUFEWCxPQUhNLEVBS0g7QUFDQ0csUUFBQUEsQ0FBQyxFQUFFQyxHQUFHLGlCQUFJLHdDQUFLQSxHQUFMO0FBRFgsT0FMRyxDQUFWO0FBU0EsWUFBTUUsYUFBYSxHQUFHLEtBQUtqQixLQUFMLENBQVdNLFVBQVgsR0FBd0IsS0FBS04sS0FBTCxDQUFXTyxRQUFYLENBQW9CQyxNQUFsRTtBQUNBSCxNQUFBQSxPQUFPLGdCQUFHLDZCQUFDLHNCQUFEO0FBQ04sUUFBQSxhQUFhLEVBQUUseUJBQUcsOEJBQUgsRUFBbUM7QUFBRWEsVUFBQUEsS0FBSyxFQUFFRDtBQUFULFNBQW5DLENBRFQ7QUFFTixRQUFBLG9CQUFvQixFQUFFLEtBQUtFLGFBRnJCO0FBR04sUUFBQSxTQUFTLEVBQUUsSUFITDtBQUlOLFFBQUEsWUFBWSxFQUFFLHlCQUFHLFlBQUgsQ0FKUjtBQUtOLFFBQUEsUUFBUSxFQUFFLEtBQUtILGFBTFQ7QUFNTixRQUFBLEtBQUssRUFBRTtBQU5ELFFBQVY7QUFRSDs7QUFFRCx3QkFDSSw2QkFBQyxtQkFBRDtBQUFZLE1BQUEsU0FBUyxFQUFDLHdCQUF0QjtBQUNJLE1BQUEsVUFBVSxFQUFFLEtBQUtBLGFBRHJCO0FBRUksTUFBQSxLQUFLLEVBQUUseUJBQUcsY0FBSCxDQUZYO0FBR0ksTUFBQSxTQUFTLEVBQUM7QUFIZCxvQkFLSTtBQUFLLE1BQUEsRUFBRSxFQUFDO0FBQVIsT0FDTWIsT0FETixFQUVNQyxPQUZOLENBTEosRUFVTUMsT0FWTixDQURKO0FBY0g7O0FBL0VvRSxDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE5IE5ldyBWZWN0b3IgTHRkXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IGZpbGVzaXplIGZyb20gJ2ZpbGVzaXplJztcblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IF90IH0gZnJvbSAnLi4vLi4vLi4vbGFuZ3VhZ2VIYW5kbGVyJztcbmltcG9ydCBDb250ZW50TWVzc2FnZXMgZnJvbSAnLi4vLi4vLi4vQ29udGVudE1lc3NhZ2VzJztcbmltcG9ydCB7IHJlcGxhY2VhYmxlQ29tcG9uZW50IH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL3JlcGxhY2VhYmxlQ29tcG9uZW50XCI7XG5pbXBvcnQgQmFzZURpYWxvZyBmcm9tIFwiLi9CYXNlRGlhbG9nXCI7XG5pbXBvcnQgRGlhbG9nQnV0dG9ucyBmcm9tIFwiLi4vZWxlbWVudHMvRGlhbG9nQnV0dG9uc1wiO1xuaW1wb3J0IHsgSURpYWxvZ1Byb3BzIH0gZnJvbSBcIi4vSURpYWxvZ1Byb3BzXCI7XG5cbmludGVyZmFjZSBJUHJvcHMgZXh0ZW5kcyBJRGlhbG9nUHJvcHMge1xuICAgIGJhZEZpbGVzOiBGaWxlW107XG4gICAgdG90YWxGaWxlczogbnVtYmVyO1xuICAgIGNvbnRlbnRNZXNzYWdlczogQ29udGVudE1lc3NhZ2VzO1xufVxuXG4vKlxuICogVGVsbHMgdGhlIHVzZXIgYWJvdXQgZmlsZXMgd2Uga25vdyBjYW5ub3QgYmUgdXBsb2FkZWQgYmVmb3JlIHdlIGV2ZW4gdHJ5IHVwbG9hZGluZ1xuICogdGhlbS4gVGhpcyBpcyBuYW1lZCBmYWlybHkgZ2VuZXJpY2FsbHkgYnV0IHRoZSBvbmx5IHRoaW5nIHdlIGNoZWNrIHJpZ2h0IG5vdyBpc1xuICogdGhlIHNpemUgb2YgdGhlIGZpbGUuXG4gKi9cbkByZXBsYWNlYWJsZUNvbXBvbmVudChcInZpZXdzLmRpYWxvZ3MuVXBsb2FkRmFpbHVyZURpYWxvZ1wiKVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVXBsb2FkRmFpbHVyZURpYWxvZyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxJUHJvcHM+IHtcbiAgICBwcml2YXRlIG9uQ2FuY2VsQ2xpY2sgPSAoKTogdm9pZCA9PiB7XG4gICAgICAgIHRoaXMucHJvcHMub25GaW5pc2hlZChmYWxzZSk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25VcGxvYWRDbGljayA9ICgpOiB2b2lkID0+IHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkZpbmlzaGVkKHRydWUpO1xuICAgIH07XG5cbiAgICBwdWJsaWMgcmVuZGVyKCk6IEpTWC5FbGVtZW50IHtcbiAgICAgICAgbGV0IG1lc3NhZ2U7XG4gICAgICAgIGxldCBwcmV2aWV3O1xuICAgICAgICBsZXQgYnV0dG9ucztcbiAgICAgICAgaWYgKHRoaXMucHJvcHMudG90YWxGaWxlcyA9PT0gMSAmJiB0aGlzLnByb3BzLmJhZEZpbGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IF90KFxuICAgICAgICAgICAgICAgIFwiVGhpcyBmaWxlIGlzIDxiPnRvbyBsYXJnZTwvYj4gdG8gdXBsb2FkLiBcIiArXG4gICAgICAgICAgICAgICAgXCJUaGUgZmlsZSBzaXplIGxpbWl0IGlzICUobGltaXQpcyBidXQgdGhpcyBmaWxlIGlzICUoc2l6ZU9mVGhpc0ZpbGUpcy5cIixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxpbWl0OiBmaWxlc2l6ZSh0aGlzLnByb3BzLmNvbnRlbnRNZXNzYWdlcy5nZXRVcGxvYWRMaW1pdCgpKSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZU9mVGhpc0ZpbGU6IGZpbGVzaXplKHRoaXMucHJvcHMuYmFkRmlsZXNbMF0uc2l6ZSksXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBiOiBzdWIgPT4gPGI+eyBzdWIgfTwvYj4sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBidXR0b25zID0gPERpYWxvZ0J1dHRvbnMgcHJpbWFyeUJ1dHRvbj17X3QoJ09LJyl9XG4gICAgICAgICAgICAgICAgaGFzQ2FuY2VsPXtmYWxzZX1cbiAgICAgICAgICAgICAgICBvblByaW1hcnlCdXR0b25DbGljaz17dGhpcy5vbkNhbmNlbENsaWNrfVxuICAgICAgICAgICAgICAgIGZvY3VzPXt0cnVlfVxuICAgICAgICAgICAgLz47XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy50b3RhbEZpbGVzID09PSB0aGlzLnByb3BzLmJhZEZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IF90KFxuICAgICAgICAgICAgICAgIFwiVGhlc2UgZmlsZXMgYXJlIDxiPnRvbyBsYXJnZTwvYj4gdG8gdXBsb2FkLiBcIiArXG4gICAgICAgICAgICAgICAgXCJUaGUgZmlsZSBzaXplIGxpbWl0IGlzICUobGltaXQpcy5cIixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxpbWl0OiBmaWxlc2l6ZSh0aGlzLnByb3BzLmNvbnRlbnRNZXNzYWdlcy5nZXRVcGxvYWRMaW1pdCgpKSxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIGI6IHN1YiA9PiA8Yj57IHN1YiB9PC9iPixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJ1dHRvbnMgPSA8RGlhbG9nQnV0dG9ucyBwcmltYXJ5QnV0dG9uPXtfdCgnT0snKX1cbiAgICAgICAgICAgICAgICBoYXNDYW5jZWw9e2ZhbHNlfVxuICAgICAgICAgICAgICAgIG9uUHJpbWFyeUJ1dHRvbkNsaWNrPXt0aGlzLm9uQ2FuY2VsQ2xpY2t9XG4gICAgICAgICAgICAgICAgZm9jdXM9e3RydWV9XG4gICAgICAgICAgICAvPjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBfdChcbiAgICAgICAgICAgICAgICBcIlNvbWUgZmlsZXMgYXJlIDxiPnRvbyBsYXJnZTwvYj4gdG8gYmUgdXBsb2FkZWQuIFwiICtcbiAgICAgICAgICAgICAgICBcIlRoZSBmaWxlIHNpemUgbGltaXQgaXMgJShsaW1pdClzLlwiLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGltaXQ6IGZpbGVzaXplKHRoaXMucHJvcHMuY29udGVudE1lc3NhZ2VzLmdldFVwbG9hZExpbWl0KCkpLFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgYjogc3ViID0+IDxiPnsgc3ViIH08L2I+LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgaG93TWFueU90aGVycyA9IHRoaXMucHJvcHMudG90YWxGaWxlcyAtIHRoaXMucHJvcHMuYmFkRmlsZXMubGVuZ3RoO1xuICAgICAgICAgICAgYnV0dG9ucyA9IDxEaWFsb2dCdXR0b25zXG4gICAgICAgICAgICAgICAgcHJpbWFyeUJ1dHRvbj17X3QoJ1VwbG9hZCAlKGNvdW50KXMgb3RoZXIgZmlsZXMnLCB7IGNvdW50OiBob3dNYW55T3RoZXJzIH0pfVxuICAgICAgICAgICAgICAgIG9uUHJpbWFyeUJ1dHRvbkNsaWNrPXt0aGlzLm9uVXBsb2FkQ2xpY2t9XG4gICAgICAgICAgICAgICAgaGFzQ2FuY2VsPXt0cnVlfVxuICAgICAgICAgICAgICAgIGNhbmNlbEJ1dHRvbj17X3QoXCJDYW5jZWwgQWxsXCIpfVxuICAgICAgICAgICAgICAgIG9uQ2FuY2VsPXt0aGlzLm9uQ2FuY2VsQ2xpY2t9XG4gICAgICAgICAgICAgICAgZm9jdXM9e3RydWV9XG4gICAgICAgICAgICAvPjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8QmFzZURpYWxvZyBjbGFzc05hbWU9J214X1VwbG9hZEZhaWx1cmVEaWFsb2cnXG4gICAgICAgICAgICAgICAgb25GaW5pc2hlZD17dGhpcy5vbkNhbmNlbENsaWNrfVxuICAgICAgICAgICAgICAgIHRpdGxlPXtfdChcIlVwbG9hZCBFcnJvclwiKX1cbiAgICAgICAgICAgICAgICBjb250ZW50SWQ9J214X0RpYWxvZ19jb250ZW50J1xuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxkaXYgaWQ9J214X0RpYWxvZ19jb250ZW50Jz5cbiAgICAgICAgICAgICAgICAgICAgeyBtZXNzYWdlIH1cbiAgICAgICAgICAgICAgICAgICAgeyBwcmV2aWV3IH1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgIHsgYnV0dG9ucyB9XG4gICAgICAgICAgICA8L0Jhc2VEaWFsb2c+XG4gICAgICAgICk7XG4gICAgfVxufVxuIl19