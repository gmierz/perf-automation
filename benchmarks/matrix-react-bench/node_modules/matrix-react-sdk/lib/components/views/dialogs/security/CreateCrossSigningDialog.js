"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _MatrixClientPeg = require("../../../../MatrixClientPeg");

var _languageHandler = require("../../../../languageHandler");

var _Modal = _interopRequireDefault(require("../../../../Modal"));

var _InteractiveAuthEntryComponents = require("../../auth/InteractiveAuthEntryComponents");

var _DialogButtons = _interopRequireDefault(require("../../elements/DialogButtons"));

var _BaseDialog = _interopRequireDefault(require("../BaseDialog"));

var _Spinner = _interopRequireDefault(require("../../elements/Spinner"));

var _InteractiveAuthDialog = _interopRequireDefault(require("../InteractiveAuthDialog"));

var _replaceableComponent = require("../../../../utils/replaceableComponent");

var _logger = require("matrix-js-sdk/src/logger");

var _dec, _class;

let CreateCrossSigningDialog = (
/*
 * Walks the user through the process of creating a cross-signing keys. In most
 * cases, only a spinner is shown, but for more complex auth like SSO, the user
 * may need to complete some steps to proceed.
 */
_dec = (0, _replaceableComponent.replaceableComponent)("views.dialogs.security.CreateCrossSigningDialog"), _dec(_class = class CreateCrossSigningDialog extends _react.default.PureComponent {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "doBootstrapUIAuth", async makeRequest => {
      if (this.state.canUploadKeysWithPasswordOnly && this.state.accountPassword) {
        await makeRequest({
          type: 'm.login.password',
          identifier: {
            type: 'm.id.user',
            user: _MatrixClientPeg.MatrixClientPeg.get().getUserId()
          },
          // TODO: Remove `user` once servers support proper UIA
          // See https://github.com/matrix-org/synapse/issues/5665
          user: _MatrixClientPeg.MatrixClientPeg.get().getUserId(),
          password: this.state.accountPassword
        });
      } else if (this.props.tokenLogin) {
        // We are hoping the grace period is active
        await makeRequest({});
      } else {
        const dialogAesthetics = {
          [_InteractiveAuthEntryComponents.SSOAuthEntry.PHASE_PREAUTH]: {
            title: (0, _languageHandler._t)("Use Single Sign On to continue"),
            body: (0, _languageHandler._t)("To continue, use Single Sign On to prove your identity."),
            continueText: (0, _languageHandler._t)("Single Sign On"),
            continueKind: "primary"
          },
          [_InteractiveAuthEntryComponents.SSOAuthEntry.PHASE_POSTAUTH]: {
            title: (0, _languageHandler._t)("Confirm encryption setup"),
            body: (0, _languageHandler._t)("Click the button below to confirm setting up encryption."),
            continueText: (0, _languageHandler._t)("Confirm"),
            continueKind: "primary"
          }
        };

        const {
          finished
        } = _Modal.default.createTrackedDialog('Cross-signing keys dialog', '', _InteractiveAuthDialog.default, {
          title: (0, _languageHandler._t)("Setting up keys"),
          matrixClient: _MatrixClientPeg.MatrixClientPeg.get(),
          makeRequest,
          aestheticsForStagePhases: {
            [_InteractiveAuthEntryComponents.SSOAuthEntry.LOGIN_TYPE]: dialogAesthetics,
            [_InteractiveAuthEntryComponents.SSOAuthEntry.UNSTABLE_LOGIN_TYPE]: dialogAesthetics
          }
        });

        const [confirmed] = await finished;

        if (!confirmed) {
          throw new Error("Cross-signing key upload auth canceled");
        }
      }
    });
    (0, _defineProperty2.default)(this, "bootstrapCrossSigning", async () => {
      this.setState({
        error: null
      });

      const cli = _MatrixClientPeg.MatrixClientPeg.get();

      try {
        await cli.bootstrapCrossSigning({
          authUploadDeviceSigningKeys: this.doBootstrapUIAuth
        });
        this.props.onFinished(true);
      } catch (e) {
        if (this.props.tokenLogin) {
          // ignore any failures, we are relying on grace period here
          this.props.onFinished(false);
          return;
        }

        this.setState({
          error: e
        });

        _logger.logger.error("Error bootstrapping cross-signing", e);
      }
    });
    (0, _defineProperty2.default)(this, "onCancel", () => {
      this.props.onFinished(false);
    });
    this.state = {
      error: null,
      // Does the server offer a UI auth flow with just m.login.password
      // for /keys/device_signing/upload?
      // If we have an account password in memory, let's simplify and
      // assume it means password auth is also supported for device
      // signing key upload as well. This avoids hitting the server to
      // test auth flows, which may be slow under high load.
      canUploadKeysWithPasswordOnly: props.accountPassword ? true : null,
      accountPassword: props.accountPassword || ""
    };

    if (!this.state.accountPassword) {
      this.queryKeyUploadAuth();
    }
  }

  componentDidMount() {
    this.bootstrapCrossSigning();
  }

  async queryKeyUploadAuth() {
    try {
      await _MatrixClientPeg.MatrixClientPeg.get().uploadDeviceSigningKeys(null, {}); // We should never get here: the server should always require
      // UI auth to upload device signing keys. If we do, we upload
      // no keys which would be a no-op.

      _logger.logger.log("uploadDeviceSigningKeys unexpectedly succeeded without UI auth!");
    } catch (error) {
      if (!error.data || !error.data.flows) {
        _logger.logger.log("uploadDeviceSigningKeys advertised no flows!");

        return;
      }

      const canUploadKeysWithPasswordOnly = error.data.flows.some(f => {
        return f.stages.length === 1 && f.stages[0] === 'm.login.password';
      });
      this.setState({
        canUploadKeysWithPasswordOnly
      });
    }
  }

  render() {
    let content;

    if (this.state.error) {
      content = /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("p", null, (0, _languageHandler._t)("Unable to set up keys")), /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_Dialog_buttons"
      }, /*#__PURE__*/_react.default.createElement(_DialogButtons.default, {
        primaryButton: (0, _languageHandler._t)('Retry'),
        onPrimaryButtonClick: this.bootstrapCrossSigning,
        onCancel: this.onCancel
      })));
    } else {
      content = /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement(_Spinner.default, null));
    }

    return /*#__PURE__*/_react.default.createElement(_BaseDialog.default, {
      className: "mx_CreateCrossSigningDialog",
      onFinished: this.props.onFinished,
      title: (0, _languageHandler._t)("Setting up keys"),
      hasCancel: false,
      fixedWidth: false
    }, /*#__PURE__*/_react.default.createElement("div", null, content));
  }

}) || _class);
exports.default = CreateCrossSigningDialog;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2RpYWxvZ3Mvc2VjdXJpdHkvQ3JlYXRlQ3Jvc3NTaWduaW5nRGlhbG9nLnRzeCJdLCJuYW1lcyI6WyJDcmVhdGVDcm9zc1NpZ25pbmdEaWFsb2ciLCJSZWFjdCIsIlB1cmVDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsInByb3BzIiwibWFrZVJlcXVlc3QiLCJzdGF0ZSIsImNhblVwbG9hZEtleXNXaXRoUGFzc3dvcmRPbmx5IiwiYWNjb3VudFBhc3N3b3JkIiwidHlwZSIsImlkZW50aWZpZXIiLCJ1c2VyIiwiTWF0cml4Q2xpZW50UGVnIiwiZ2V0IiwiZ2V0VXNlcklkIiwicGFzc3dvcmQiLCJ0b2tlbkxvZ2luIiwiZGlhbG9nQWVzdGhldGljcyIsIlNTT0F1dGhFbnRyeSIsIlBIQVNFX1BSRUFVVEgiLCJ0aXRsZSIsImJvZHkiLCJjb250aW51ZVRleHQiLCJjb250aW51ZUtpbmQiLCJQSEFTRV9QT1NUQVVUSCIsImZpbmlzaGVkIiwiTW9kYWwiLCJjcmVhdGVUcmFja2VkRGlhbG9nIiwiSW50ZXJhY3RpdmVBdXRoRGlhbG9nIiwibWF0cml4Q2xpZW50IiwiYWVzdGhldGljc0ZvclN0YWdlUGhhc2VzIiwiTE9HSU5fVFlQRSIsIlVOU1RBQkxFX0xPR0lOX1RZUEUiLCJjb25maXJtZWQiLCJFcnJvciIsInNldFN0YXRlIiwiZXJyb3IiLCJjbGkiLCJib290c3RyYXBDcm9zc1NpZ25pbmciLCJhdXRoVXBsb2FkRGV2aWNlU2lnbmluZ0tleXMiLCJkb0Jvb3RzdHJhcFVJQXV0aCIsIm9uRmluaXNoZWQiLCJlIiwibG9nZ2VyIiwicXVlcnlLZXlVcGxvYWRBdXRoIiwiY29tcG9uZW50RGlkTW91bnQiLCJ1cGxvYWREZXZpY2VTaWduaW5nS2V5cyIsImxvZyIsImRhdGEiLCJmbG93cyIsInNvbWUiLCJmIiwic3RhZ2VzIiwibGVuZ3RoIiwicmVuZGVyIiwiY29udGVudCIsIm9uQ2FuY2VsIl0sIm1h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QUEzSnFGLEMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMTgsIDIwMTkgTmV3IFZlY3RvciBMdGRcbkNvcHlyaWdodCAyMDE5LCAyMDIwIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IENyb3NzU2lnbmluZ0tleXMgfSBmcm9tICdtYXRyaXgtanMtc2RrL3NyYy9jbGllbnQnO1xuXG5pbXBvcnQgeyBNYXRyaXhDbGllbnRQZWcgfSBmcm9tICcuLi8uLi8uLi8uLi9NYXRyaXhDbGllbnRQZWcnO1xuaW1wb3J0IHsgX3QgfSBmcm9tICcuLi8uLi8uLi8uLi9sYW5ndWFnZUhhbmRsZXInO1xuaW1wb3J0IE1vZGFsIGZyb20gJy4uLy4uLy4uLy4uL01vZGFsJztcbmltcG9ydCB7IFNTT0F1dGhFbnRyeSB9IGZyb20gJy4uLy4uL2F1dGgvSW50ZXJhY3RpdmVBdXRoRW50cnlDb21wb25lbnRzJztcbmltcG9ydCBEaWFsb2dCdXR0b25zIGZyb20gJy4uLy4uL2VsZW1lbnRzL0RpYWxvZ0J1dHRvbnMnO1xuaW1wb3J0IEJhc2VEaWFsb2cgZnJvbSAnLi4vQmFzZURpYWxvZyc7XG5pbXBvcnQgU3Bpbm5lciBmcm9tICcuLi8uLi9lbGVtZW50cy9TcGlubmVyJztcbmltcG9ydCBJbnRlcmFjdGl2ZUF1dGhEaWFsb2cgZnJvbSAnLi4vSW50ZXJhY3RpdmVBdXRoRGlhbG9nJztcbmltcG9ydCB7IHJlcGxhY2VhYmxlQ29tcG9uZW50IH0gZnJvbSBcIi4uLy4uLy4uLy4uL3V0aWxzL3JlcGxhY2VhYmxlQ29tcG9uZW50XCI7XG5cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9sb2dnZXJcIjtcblxuaW50ZXJmYWNlIElQcm9wcyB7XG4gICAgYWNjb3VudFBhc3N3b3JkPzogc3RyaW5nO1xuICAgIHRva2VuTG9naW4/OiBib29sZWFuO1xuICAgIG9uRmluaXNoZWQ/OiAoc3VjY2VzczogYm9vbGVhbikgPT4gdm9pZDtcbn1cblxuaW50ZXJmYWNlIElTdGF0ZSB7XG4gICAgZXJyb3I6IEVycm9yIHwgbnVsbDtcbiAgICBjYW5VcGxvYWRLZXlzV2l0aFBhc3N3b3JkT25seT86IGJvb2xlYW47XG4gICAgYWNjb3VudFBhc3N3b3JkOiBzdHJpbmc7XG59XG5cbi8qXG4gKiBXYWxrcyB0aGUgdXNlciB0aHJvdWdoIHRoZSBwcm9jZXNzIG9mIGNyZWF0aW5nIGEgY3Jvc3Mtc2lnbmluZyBrZXlzLiBJbiBtb3N0XG4gKiBjYXNlcywgb25seSBhIHNwaW5uZXIgaXMgc2hvd24sIGJ1dCBmb3IgbW9yZSBjb21wbGV4IGF1dGggbGlrZSBTU08sIHRoZSB1c2VyXG4gKiBtYXkgbmVlZCB0byBjb21wbGV0ZSBzb21lIHN0ZXBzIHRvIHByb2NlZWQuXG4gKi9cbkByZXBsYWNlYWJsZUNvbXBvbmVudChcInZpZXdzLmRpYWxvZ3Muc2VjdXJpdHkuQ3JlYXRlQ3Jvc3NTaWduaW5nRGlhbG9nXCIpXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDcmVhdGVDcm9zc1NpZ25pbmdEaWFsb2cgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PElQcm9wcywgSVN0YXRlPiB7XG4gICAgY29uc3RydWN0b3IocHJvcHM6IElQcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgLy8gRG9lcyB0aGUgc2VydmVyIG9mZmVyIGEgVUkgYXV0aCBmbG93IHdpdGgganVzdCBtLmxvZ2luLnBhc3N3b3JkXG4gICAgICAgICAgICAvLyBmb3IgL2tleXMvZGV2aWNlX3NpZ25pbmcvdXBsb2FkP1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBhY2NvdW50IHBhc3N3b3JkIGluIG1lbW9yeSwgbGV0J3Mgc2ltcGxpZnkgYW5kXG4gICAgICAgICAgICAvLyBhc3N1bWUgaXQgbWVhbnMgcGFzc3dvcmQgYXV0aCBpcyBhbHNvIHN1cHBvcnRlZCBmb3IgZGV2aWNlXG4gICAgICAgICAgICAvLyBzaWduaW5nIGtleSB1cGxvYWQgYXMgd2VsbC4gVGhpcyBhdm9pZHMgaGl0dGluZyB0aGUgc2VydmVyIHRvXG4gICAgICAgICAgICAvLyB0ZXN0IGF1dGggZmxvd3MsIHdoaWNoIG1heSBiZSBzbG93IHVuZGVyIGhpZ2ggbG9hZC5cbiAgICAgICAgICAgIGNhblVwbG9hZEtleXNXaXRoUGFzc3dvcmRPbmx5OiBwcm9wcy5hY2NvdW50UGFzc3dvcmQgPyB0cnVlIDogbnVsbCxcbiAgICAgICAgICAgIGFjY291bnRQYXNzd29yZDogcHJvcHMuYWNjb3VudFBhc3N3b3JkIHx8IFwiXCIsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmFjY291bnRQYXNzd29yZCkge1xuICAgICAgICAgICAgdGhpcy5xdWVyeUtleVVwbG9hZEF1dGgoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBjb21wb25lbnREaWRNb3VudCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5ib290c3RyYXBDcm9zc1NpZ25pbmcoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIHF1ZXJ5S2V5VXBsb2FkQXV0aCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IE1hdHJpeENsaWVudFBlZy5nZXQoKS51cGxvYWREZXZpY2VTaWduaW5nS2V5cyhudWxsLCB7fSBhcyBDcm9zc1NpZ25pbmdLZXlzKTtcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBuZXZlciBnZXQgaGVyZTogdGhlIHNlcnZlciBzaG91bGQgYWx3YXlzIHJlcXVpcmVcbiAgICAgICAgICAgIC8vIFVJIGF1dGggdG8gdXBsb2FkIGRldmljZSBzaWduaW5nIGtleXMuIElmIHdlIGRvLCB3ZSB1cGxvYWRcbiAgICAgICAgICAgIC8vIG5vIGtleXMgd2hpY2ggd291bGQgYmUgYSBuby1vcC5cbiAgICAgICAgICAgIGxvZ2dlci5sb2coXCJ1cGxvYWREZXZpY2VTaWduaW5nS2V5cyB1bmV4cGVjdGVkbHkgc3VjY2VlZGVkIHdpdGhvdXQgVUkgYXV0aCFcIik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yLmRhdGEgfHwgIWVycm9yLmRhdGEuZmxvd3MpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFwidXBsb2FkRGV2aWNlU2lnbmluZ0tleXMgYWR2ZXJ0aXNlZCBubyBmbG93cyFcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2FuVXBsb2FkS2V5c1dpdGhQYXNzd29yZE9ubHkgPSBlcnJvci5kYXRhLmZsb3dzLnNvbWUoZiA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYuc3RhZ2VzLmxlbmd0aCA9PT0gMSAmJiBmLnN0YWdlc1swXSA9PT0gJ20ubG9naW4ucGFzc3dvcmQnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBjYW5VcGxvYWRLZXlzV2l0aFBhc3N3b3JkT25seSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkb0Jvb3RzdHJhcFVJQXV0aCA9IGFzeW5jIChtYWtlUmVxdWVzdDogKGF1dGhEYXRhOiBhbnkpID0+IHZvaWQpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuY2FuVXBsb2FkS2V5c1dpdGhQYXNzd29yZE9ubHkgJiYgdGhpcy5zdGF0ZS5hY2NvdW50UGFzc3dvcmQpIHtcbiAgICAgICAgICAgIGF3YWl0IG1ha2VSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbS5sb2dpbi5wYXNzd29yZCcsXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllcjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbS5pZC51c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgdXNlcjogTWF0cml4Q2xpZW50UGVnLmdldCgpLmdldFVzZXJJZCgpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogUmVtb3ZlIGB1c2VyYCBvbmNlIHNlcnZlcnMgc3VwcG9ydCBwcm9wZXIgVUlBXG4gICAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRyaXgtb3JnL3N5bmFwc2UvaXNzdWVzLzU2NjVcbiAgICAgICAgICAgICAgICB1c2VyOiBNYXRyaXhDbGllbnRQZWcuZ2V0KCkuZ2V0VXNlcklkKCksXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IHRoaXMuc3RhdGUuYWNjb3VudFBhc3N3b3JkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy50b2tlbkxvZ2luKSB7XG4gICAgICAgICAgICAvLyBXZSBhcmUgaG9waW5nIHRoZSBncmFjZSBwZXJpb2QgaXMgYWN0aXZlXG4gICAgICAgICAgICBhd2FpdCBtYWtlUmVxdWVzdCh7fSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBkaWFsb2dBZXN0aGV0aWNzID0ge1xuICAgICAgICAgICAgICAgIFtTU09BdXRoRW50cnkuUEhBU0VfUFJFQVVUSF06IHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IF90KFwiVXNlIFNpbmdsZSBTaWduIE9uIHRvIGNvbnRpbnVlXCIpLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBfdChcIlRvIGNvbnRpbnVlLCB1c2UgU2luZ2xlIFNpZ24gT24gdG8gcHJvdmUgeW91ciBpZGVudGl0eS5cIiksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlVGV4dDogX3QoXCJTaW5nbGUgU2lnbiBPblwiKSxcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVLaW5kOiBcInByaW1hcnlcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFtTU09BdXRoRW50cnkuUEhBU0VfUE9TVEFVVEhdOiB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBfdChcIkNvbmZpcm0gZW5jcnlwdGlvbiBzZXR1cFwiKSxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogX3QoXCJDbGljayB0aGUgYnV0dG9uIGJlbG93IHRvIGNvbmZpcm0gc2V0dGluZyB1cCBlbmNyeXB0aW9uLlwiKSxcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVUZXh0OiBfdChcIkNvbmZpcm1cIiksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlS2luZDogXCJwcmltYXJ5XCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IHsgZmluaXNoZWQgfSA9IE1vZGFsLmNyZWF0ZVRyYWNrZWREaWFsb2coXG4gICAgICAgICAgICAgICAgJ0Nyb3NzLXNpZ25pbmcga2V5cyBkaWFsb2cnLCAnJywgSW50ZXJhY3RpdmVBdXRoRGlhbG9nLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IF90KFwiU2V0dGluZyB1cCBrZXlzXCIpLFxuICAgICAgICAgICAgICAgICAgICBtYXRyaXhDbGllbnQ6IE1hdHJpeENsaWVudFBlZy5nZXQoKSxcbiAgICAgICAgICAgICAgICAgICAgbWFrZVJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIGFlc3RoZXRpY3NGb3JTdGFnZVBoYXNlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgW1NTT0F1dGhFbnRyeS5MT0dJTl9UWVBFXTogZGlhbG9nQWVzdGhldGljcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtTU09BdXRoRW50cnkuVU5TVEFCTEVfTE9HSU5fVFlQRV06IGRpYWxvZ0Flc3RoZXRpY3MsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBbY29uZmlybWVkXSA9IGF3YWl0IGZpbmlzaGVkO1xuICAgICAgICAgICAgaWYgKCFjb25maXJtZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDcm9zcy1zaWduaW5nIGtleSB1cGxvYWQgYXV0aCBjYW5jZWxlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcml2YXRlIGJvb3RzdHJhcENyb3NzU2lnbmluZyA9IGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgY2xpID0gTWF0cml4Q2xpZW50UGVnLmdldCgpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBjbGkuYm9vdHN0cmFwQ3Jvc3NTaWduaW5nKHtcbiAgICAgICAgICAgICAgICBhdXRoVXBsb2FkRGV2aWNlU2lnbmluZ0tleXM6IHRoaXMuZG9Cb290c3RyYXBVSUF1dGgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25GaW5pc2hlZCh0cnVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMudG9rZW5Mb2dpbikge1xuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBhbnkgZmFpbHVyZXMsIHdlIGFyZSByZWx5aW5nIG9uIGdyYWNlIHBlcmlvZCBoZXJlXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkZpbmlzaGVkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBlcnJvcjogZSB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkVycm9yIGJvb3RzdHJhcHBpbmcgY3Jvc3Mtc2lnbmluZ1wiLCBlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcml2YXRlIG9uQ2FuY2VsID0gKCk6IHZvaWQgPT4ge1xuICAgICAgICB0aGlzLnByb3BzLm9uRmluaXNoZWQoZmFsc2UpO1xuICAgIH07XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCBjb250ZW50O1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5lcnJvcikge1xuICAgICAgICAgICAgY29udGVudCA9IDxkaXY+XG4gICAgICAgICAgICAgICAgPHA+eyBfdChcIlVuYWJsZSB0byBzZXQgdXAga2V5c1wiKSB9PC9wPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXhfRGlhbG9nX2J1dHRvbnNcIj5cbiAgICAgICAgICAgICAgICAgICAgPERpYWxvZ0J1dHRvbnMgcHJpbWFyeUJ1dHRvbj17X3QoJ1JldHJ5Jyl9XG4gICAgICAgICAgICAgICAgICAgICAgICBvblByaW1hcnlCdXR0b25DbGljaz17dGhpcy5ib290c3RyYXBDcm9zc1NpZ25pbmd9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNhbmNlbD17dGhpcy5vbkNhbmNlbH1cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSA8ZGl2PlxuICAgICAgICAgICAgICAgIDxTcGlubmVyIC8+XG4gICAgICAgICAgICA8L2Rpdj47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPEJhc2VEaWFsb2cgY2xhc3NOYW1lPVwibXhfQ3JlYXRlQ3Jvc3NTaWduaW5nRGlhbG9nXCJcbiAgICAgICAgICAgICAgICBvbkZpbmlzaGVkPXt0aGlzLnByb3BzLm9uRmluaXNoZWR9XG4gICAgICAgICAgICAgICAgdGl0bGU9e190KFwiU2V0dGluZyB1cCBrZXlzXCIpfVxuICAgICAgICAgICAgICAgIGhhc0NhbmNlbD17ZmFsc2V9XG4gICAgICAgICAgICAgICAgZml4ZWRXaWR0aD17ZmFsc2V9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgeyBjb250ZW50IH1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvQmFzZURpYWxvZz5cbiAgICAgICAgKTtcbiAgICB9XG59XG4iXX0=