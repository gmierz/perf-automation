"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _languageHandler = require("../../../languageHandler");

var _SdkConfig = _interopRequireDefault(require("../../../SdkConfig"));

var _BaseDialog = _interopRequireDefault(require("./BaseDialog"));

var _DialogButtons = _interopRequireDefault(require("../elements/DialogButtons"));

var _Spinner = _interopRequireDefault(require("../elements/Spinner"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
const KeySignatureUploadFailedDialog = ({
  failures,
  source,
  continuation,
  onFinished
}) => {
  const RETRIES = 2;
  const [retry, setRetry] = (0, _react.useState)(RETRIES);
  const [cancelled, setCancelled] = (0, _react.useState)(false);
  const [retrying, setRetrying] = (0, _react.useState)(false);
  const [success, setSuccess] = (0, _react.useState)(false);
  const onCancel = (0, _react.useRef)(onFinished);
  const causes = new Map([["_afterCrossSigningLocalKeyChange", (0, _languageHandler._t)("a new master key signature")], ["checkOwnCrossSigningTrust", (0, _languageHandler._t)("a new cross-signing key signature")], ["setDeviceVerification", (0, _languageHandler._t)("a device cross-signing signature")]]);
  const defaultCause = (0, _languageHandler._t)("a key signature");
  const onRetry = (0, _react.useCallback)(async () => {
    try {
      setRetrying(true);
      const cancel = new Promise((resolve, reject) => {
        onCancel.current = reject;
      }).finally(() => {
        setCancelled(true);
      });
      await Promise.race([continuation(), cancel]);
      setSuccess(true);
    } catch (e) {
      setRetry(r => r - 1);
    } finally {
      onCancel.current = onFinished;
      setRetrying(false);
    }
  }, [continuation, onFinished]);
  let body;

  if (!success && !cancelled && continuation && retry > 0) {
    const reason = causes.get(source) || defaultCause;

    const brand = _SdkConfig.default.get().brand;

    body = /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("p", null, (0, _languageHandler._t)("%(brand)s encountered an error during upload of:", {
      brand
    })), /*#__PURE__*/_react.default.createElement("p", null, reason), retrying && /*#__PURE__*/_react.default.createElement(_Spinner.default, null), /*#__PURE__*/_react.default.createElement("pre", null, JSON.stringify(failures, null, 2)), /*#__PURE__*/_react.default.createElement(_DialogButtons.default, {
      primaryButton: "Retry",
      hasCancel: true,
      onPrimaryButtonClick: onRetry,
      onCancel: onCancel.current,
      primaryDisabled: retrying
    }));
  } else {
    body = /*#__PURE__*/_react.default.createElement("div", null, success ? /*#__PURE__*/_react.default.createElement("span", null, (0, _languageHandler._t)("Upload completed")) : cancelled ? /*#__PURE__*/_react.default.createElement("span", null, (0, _languageHandler._t)("Cancelled signature upload")) : /*#__PURE__*/_react.default.createElement("span", null, (0, _languageHandler._t)("Unable to upload")), /*#__PURE__*/_react.default.createElement(_DialogButtons.default, {
      primaryButton: (0, _languageHandler._t)("OK"),
      hasCancel: false,
      onPrimaryButtonClick: onFinished
    }));
  }

  return /*#__PURE__*/_react.default.createElement(_BaseDialog.default, {
    title: success ? (0, _languageHandler._t)("Signature upload success") : (0, _languageHandler._t)("Signature upload failed"),
    fixedWidth: false,
    onFinished: () => {}
  }, body);
};

var _default = KeySignatureUploadFailedDialog;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2RpYWxvZ3MvS2V5U2lnbmF0dXJlVXBsb2FkRmFpbGVkRGlhbG9nLnRzeCJdLCJuYW1lcyI6WyJLZXlTaWduYXR1cmVVcGxvYWRGYWlsZWREaWFsb2ciLCJmYWlsdXJlcyIsInNvdXJjZSIsImNvbnRpbnVhdGlvbiIsIm9uRmluaXNoZWQiLCJSRVRSSUVTIiwicmV0cnkiLCJzZXRSZXRyeSIsImNhbmNlbGxlZCIsInNldENhbmNlbGxlZCIsInJldHJ5aW5nIiwic2V0UmV0cnlpbmciLCJzdWNjZXNzIiwic2V0U3VjY2VzcyIsIm9uQ2FuY2VsIiwiY2F1c2VzIiwiTWFwIiwiZGVmYXVsdENhdXNlIiwib25SZXRyeSIsImNhbmNlbCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiY3VycmVudCIsImZpbmFsbHkiLCJyYWNlIiwiZSIsInIiLCJib2R5IiwicmVhc29uIiwiZ2V0IiwiYnJhbmQiLCJTZGtDb25maWciLCJKU09OIiwic3RyaW5naWZ5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFnQkE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7OztBQXJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFtQkEsTUFBTUEsOEJBQWdELEdBQUcsQ0FBQztBQUN0REMsRUFBQUEsUUFEc0Q7QUFFdERDLEVBQUFBLE1BRnNEO0FBR3REQyxFQUFBQSxZQUhzRDtBQUl0REMsRUFBQUE7QUFKc0QsQ0FBRCxLQUtuRDtBQUNGLFFBQU1DLE9BQU8sR0FBRyxDQUFoQjtBQUNBLFFBQU0sQ0FBQ0MsS0FBRCxFQUFRQyxRQUFSLElBQW9CLHFCQUFTRixPQUFULENBQTFCO0FBQ0EsUUFBTSxDQUFDRyxTQUFELEVBQVlDLFlBQVosSUFBNEIscUJBQVMsS0FBVCxDQUFsQztBQUNBLFFBQU0sQ0FBQ0MsUUFBRCxFQUFX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LE1BQUEsb0JBQW9CLEVBQUVKO0FBSDFCLE1BTkksQ0FBUjtBQVlIOztBQUVELHNCQUNJLDZCQUFDLG1CQUFEO0FBQ0ksSUFBQSxLQUFLLEVBQUVRLE9BQU8sR0FDVix5QkFBRywwQkFBSCxDQURVLEdBRVYseUJBQUcseUJBQUgsQ0FIUjtBQUlJLElBQUEsVUFBVSxFQUFFLEtBSmhCO0FBS0ksSUFBQSxVQUFVLEVBQUUsTUFBTSxDQUFFO0FBTHhCLEtBT01nQixJQVBOLENBREo7QUFXSCxDQXJGRDs7ZUF1RmU1Qiw4QiIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAyMCBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IF90IH0gZnJvbSAnLi4vLi4vLi4vbGFuZ3VhZ2VIYW5kbGVyJztcbmltcG9ydCBTZGtDb25maWcgZnJvbSAnLi4vLi4vLi4vU2RrQ29uZmlnJztcbmltcG9ydCBCYXNlRGlhbG9nIGZyb20gXCIuL0Jhc2VEaWFsb2dcIjtcbmltcG9ydCBEaWFsb2dCdXR0b25zIGZyb20gXCIuLi9lbGVtZW50cy9EaWFsb2dCdXR0b25zXCI7XG5pbXBvcnQgU3Bpbm5lciBmcm9tIFwiLi4vZWxlbWVudHMvU3Bpbm5lclwiO1xuaW1wb3J0IHsgSURpYWxvZ1Byb3BzIH0gZnJvbSBcIi4vSURpYWxvZ1Byb3BzXCI7XG5cbmludGVyZmFjZSBJUHJvcHMgZXh0ZW5kcyBJRGlhbG9nUHJvcHMge1xuICAgIGZhaWx1cmVzOiBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCB7XG4gICAgICAgIGVycmNvZGU6IHN0cmluZztcbiAgICAgICAgZXJyb3I6IHN0cmluZztcbiAgICB9Pj47XG4gICAgc291cmNlOiBzdHJpbmc7XG4gICAgY29udGludWF0aW9uOiAoKSA9PiB2b2lkO1xufVxuXG5jb25zdCBLZXlTaWduYXR1cmVVcGxvYWRGYWlsZWREaWFsb2c6IFJlYWN0LkZDPElQcm9wcz4gPSAoe1xuICAgIGZhaWx1cmVzLFxuICAgIHNvdXJjZSxcbiAgICBjb250aW51YXRpb24sXG4gICAgb25GaW5pc2hlZCxcbn0pID0+IHtcbiAgICBjb25zdCBSRVRSSUVTID0gMjtcbiAgICBjb25zdCBbcmV0cnksIHNldFJldHJ5XSA9IHVzZVN0YXRlKFJFVFJJRVMpO1xuICAgIGNvbnN0IFtjYW5jZWxsZWQsIHNldENhbmNlbGxlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3JldHJ5aW5nLCBzZXRSZXRyeWluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3N1Y2Nlc3MsIHNldFN1Y2Nlc3NdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IG9uQ2FuY2VsID0gdXNlUmVmKG9uRmluaXNoZWQpO1xuXG4gICAgY29uc3QgY2F1c2VzID0gbmV3IE1hcChbXG4gICAgICAgIFtcIl9hZnRlckNyb3NzU2lnbmluZ0xvY2FsS2V5Q2hhbmdlXCIsIF90KFwiYSBuZXcgbWFzdGVyIGtleSBzaWduYXR1cmVcIildLFxuICAgICAgICBbXCJjaGVja093bkNyb3NzU2lnbmluZ1RydXN0XCIsIF90KFwiYSBuZXcgY3Jvc3Mtc2lnbmluZyBrZXkgc2lnbmF0dXJlXCIpXSxcbiAgICAgICAgW1wic2V0RGV2aWNlVmVyaWZpY2F0aW9uXCIsIF90KFwiYSBkZXZpY2UgY3Jvc3Mtc2lnbmluZyBzaWduYXR1cmVcIildLFxuICAgIF0pO1xuICAgIGNvbnN0IGRlZmF1bHRDYXVzZSA9IF90KFwiYSBrZXkgc2lnbmF0dXJlXCIpO1xuXG4gICAgY29uc3Qgb25SZXRyeSA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNldFJldHJ5aW5nKHRydWUpO1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIG9uQ2FuY2VsLmN1cnJlbnQgPSByZWplY3Q7XG4gICAgICAgICAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRDYW5jZWxsZWQodHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgICAgY29udGludWF0aW9uKCksXG4gICAgICAgICAgICAgICAgY2FuY2VsLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBzZXRTdWNjZXNzKHRydWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBzZXRSZXRyeShyID0+IHItMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBvbkNhbmNlbC5jdXJyZW50ID0gb25GaW5pc2hlZDtcbiAgICAgICAgICAgIHNldFJldHJ5aW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0sIFtjb250aW51YXRpb24sIG9uRmluaXNoZWRdKTtcblxuICAgIGxldCBib2R5O1xuICAgIGlmICghc3VjY2VzcyAmJiAhY2FuY2VsbGVkICYmIGNvbnRpbnVhdGlvbiAmJiByZXRyeSA+IDApIHtcbiAgICAgICAgY29uc3QgcmVhc29uID0gY2F1c2VzLmdldChzb3VyY2UpIHx8IGRlZmF1bHRDYXVzZTtcbiAgICAgICAgY29uc3QgYnJhbmQgPSBTZGtDb25maWcuZ2V0KCkuYnJhbmQ7XG5cbiAgICAgICAgYm9keSA9ICg8ZGl2PlxuICAgICAgICAgICAgPHA+eyBfdChcIiUoYnJhbmQpcyBlbmNvdW50ZXJlZCBhbiBlcnJvciBkdXJpbmcgdXBsb2FkIG9mOlwiLCB7IGJyYW5kIH0pIH08L3A+XG4gICAgICAgICAgICA8cD57IHJlYXNvbiB9PC9wPlxuICAgICAgICAgICAgeyByZXRyeWluZyAmJiA8U3Bpbm5lciAvPiB9XG4gICAgICAgICAgICA8cHJlPnsgSlNPTi5zdHJpbmdpZnkoZmFpbHVyZXMsIG51bGwsIDIpIH08L3ByZT5cbiAgICAgICAgICAgIDxEaWFsb2dCdXR0b25zXG4gICAgICAgICAgICAgICAgcHJpbWFyeUJ1dHRvbj0nUmV0cnknXG4gICAgICAgICAgICAgICAgaGFzQ2FuY2VsPXt0cnVlfVxuICAgICAgICAgICAgICAgIG9uUHJpbWFyeUJ1dHRvbkNsaWNrPXtvblJldHJ5fVxuICAgICAgICAgICAgICAgIG9uQ2FuY2VsPXtvbkNhbmNlbC5jdXJyZW50fVxuICAgICAgICAgICAgICAgIHByaW1hcnlEaXNhYmxlZD17cmV0cnlpbmd9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj4pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJvZHkgPSAoPGRpdj5cbiAgICAgICAgICAgIHsgc3VjY2VzcyA/XG4gICAgICAgICAgICAgICAgPHNwYW4+eyBfdChcIlVwbG9hZCBjb21wbGV0ZWRcIikgfTwvc3Bhbj4gOlxuICAgICAgICAgICAgICAgIGNhbmNlbGxlZCA/XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPnsgX3QoXCJDYW5jZWxsZWQgc2lnbmF0dXJlIHVwbG9hZFwiKSB9PC9zcGFuPiA6XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPnsgX3QoXCJVbmFibGUgdG8gdXBsb2FkXCIpIH08L3NwYW4+IH1cbiAgICAgICAgICAgIDxEaWFsb2dCdXR0b25zXG4gICAgICAgICAgICAgICAgcHJpbWFyeUJ1dHRvbj17X3QoXCJPS1wiKX1cbiAgICAgICAgICAgICAgICBoYXNDYW5jZWw9e2ZhbHNlfVxuICAgICAgICAgICAgICAgIG9uUHJpbWFyeUJ1dHRvbkNsaWNrPXtvbkZpbmlzaGVkfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9kaXY+KTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmFzZURpYWxvZ1xuICAgICAgICAgICAgdGl0bGU9e3N1Y2Nlc3MgP1xuICAgICAgICAgICAgICAgIF90KFwiU2lnbmF0dXJlIHVwbG9hZCBzdWNjZXNzXCIpIDpcbiAgICAgICAgICAgICAgICBfdChcIlNpZ25hdHVyZSB1cGxvYWQgZmFpbGVkXCIpfVxuICAgICAgICAgICAgZml4ZWRXaWR0aD17ZmFsc2V9XG4gICAgICAgICAgICBvbkZpbmlzaGVkPXsoKSA9PiB7fX1cbiAgICAgICAgPlxuICAgICAgICAgICAgeyBib2R5IH1cbiAgICAgICAgPC9CYXNlRGlhbG9nPlxuICAgICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBLZXlTaWduYXR1cmVVcGxvYWRGYWlsZWREaWFsb2c7XG4iXX0=