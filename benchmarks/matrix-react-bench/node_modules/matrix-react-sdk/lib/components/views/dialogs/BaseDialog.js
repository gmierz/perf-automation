"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _reactFocusLock = _interopRequireDefault(require("react-focus-lock"));

var _classnames = _interopRequireDefault(require("classnames"));

var _Keyboard = require("../../../Keyboard");

var _AccessibleButton = _interopRequireDefault(require("../elements/AccessibleButton"));

var _MatrixClientPeg = require("../../../MatrixClientPeg");

var _languageHandler = require("../../../languageHandler");

var _MatrixClientContext = _interopRequireDefault(require("../../../contexts/MatrixClientContext"));

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _dec, _class, _class2, _temp;

let BaseDialog = (
/*
 * Basic container for modal dialogs.
 *
 * Includes a div for the title, and a keypress handler which cancels the
 * dialog on escape.
 */
_dec = (0, _replaceableComponent.replaceableComponent)("views.dialogs.BaseDialog"), _dec(_class = (_temp = _class2 = class BaseDialog extends _react.default.Component {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "matrixClient", void 0);
    (0, _defineProperty2.default)(this, "onKeyDown", e => {
      if (this.props.onKeyDown) {
        this.props.onKeyDown(e);
      }

      if (this.props.hasCancel && e.key === _Keyboard.Key.ESCAPE) {
        e.stopPropagation();
        e.preventDefault();
        this.props.onFinished(false);
      }
    });
    (0, _defineProperty2.default)(this, "onCancelClick", e => {
      this.props.onFinished(false);
    });
    this.matrixClient = _MatrixClientPeg.MatrixClientPeg.get();
  }

  render() {
    let cancelButton;

    if (this.props.hasCancel) {
      cancelButton = /*#__PURE__*/_react.default.createElement(_AccessibleButton.default, {
        onClick: this.onCancelClick,
        className: "mx_Dialog_cancelButton",
        "aria-label": (0, _languageHandler._t)("Close dialog")
      });
    }

    let headerImage;

    if (this.props.headerImage) {
      headerImage = /*#__PURE__*/_react.default.createElement("img", {
        className: "mx_Dialog_titleImage",
        src: this.props.headerImage,
        alt: ""
      });
    }

    return /*#__PURE__*/_react.default.createElement(_MatrixClientContext.default.Provider, {
      value: this.matrixClient
    }, /*#__PURE__*/_react.default.createElement(_reactFocusLock.default, {
      returnFocus: true,
      lockProps: {
        onKeyDown: this.onKeyDown,
        role: "dialog",
        ["aria-labelledby"]: "mx_BaseDialog_title",
        // This should point to a node describing the dialog.
        // If we were about to completely follow this recommendation we'd need to
        // make all the components relying on BaseDialog to be aware of it.
        // So instead we will use the whole content as the description.
        // Description comes first and if the content contains more text,
        // AT users can skip its presentation.
        ["aria-describedby"]: this.props.contentId
      },
      className: (0, _classnames.default)({
        [this.props.className]: true,
        'mx_Dialog_fixedWidth': this.props.fixedWidth
      })
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: (0, _classnames.default)('mx_Dialog_header', {
        'mx_Dialog_headerWithButton': !!this.props.headerButton,
        'mx_Dialog_headerWithCancel': !!cancelButton
      })
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: (0, _classnames.default)('mx_Dialog_title', this.props.titleClass),
      id: "mx_BaseDialog_title"
    }, headerImage, this.props.title), this.props.headerButton, cancelButton), this.props.children));
  }

}, (0, _defineProperty2.default)(_class2, "defaultProps", {
  hasCancel: true,
  fixedWidth: true
}), _temp)) || _class);
exports.default = BaseDialog;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2RpYWxvZ3MvQmFzZURpYWxvZy50c3giXSwibmFtZXMiOlsiQmFzZURpYWxvZyIsIlJlYWN0IiwiQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJwcm9wcyIsImUiLCJvbktleURvd24iLCJoYXNDYW5jZWwiLCJrZXkiLCJLZXkiLCJFU0NBUEUiLCJzdG9wUHJvcGFnYXRpb24iLCJwcmV2ZW50RGVmYXVsdCIsIm9uRmluaXNoZWQiLCJtYXRyaXhDbGllbnQiLCJNYXRyaXhDbGllbnRQZWciLCJnZXQiLCJyZW5kZXIiLCJjYW5jZWxCdXR0b24iLCJvbkNhbmNlbENsaWNrIiwiaGVhZGVySW1hZ2UiLCJyb2xlIiwiY29udGVudElkIiwiY2xhc3NOYW1lIiwiZml4ZWRXaWR0aCIsImhlYWRlckJ1dHRvbiIsInRpdGxlQ2xhc3MiLCJ0aXRsZSIsImNoaWxkcmVuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWtCQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztJQWlEcUJBLFU7QUFQckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO09BQ0MsZ0RBQXFCLDBCQUFyQixDLG1DQUFELE1BQ3FCQSxVQURyQixTQUN3Q0MsZUFBTUMsU0FEOUMsQ0FDZ0U7QUFRNURDLEVBQUFBLFdBQVcsQ0FBQ0MsS0FBRCxFQUFRO0FBQ2YsVUFBTUEsS0FBTjtBQURlO0FBQUEscURBTUVDLENBQUQsSUFBa0Q7QUFDbEUsVUFBSSxLQUFLRCxLQUFMLENBQVdFLFNBQWYsRUFBMEI7QUFDdEIsYUFBS0YsS0FBTCxDQUFXRSxTQUFYLENBQXFCRCxDQUFyQjtBQUNIOztBQUNELFVBQUksS0FBS0QsS0FBTCxDQUFXRyxTQUFYLElBQXdCRixDQUFDLENBQUNHLEdBQUYsS0FBVUMsY0FBSUMsTUFBMUMsRUFBa0Q7QUFDOUNMLFFBQUFBLENBQUMsQ0FBQ00sZUFBRjtBQUNBTixRQUFBQSxDQUFDLENBQUNPLGNBQUY7QUFDQSxhQUFLUixLQUFMLENBQVdTLFVBQVgsQ0FBc0IsS0FBdEI7QUFDSDtBQUNKLEtBZmtCO0FBQUEseURBaUJNUixDQUFELElBQTBCO0FBQzlDLFdBQUtELEtBQUwsQ0FBV1MsVUFBWCxDQUFzQixLQUF0QjtBQUNILEtBbkJrQjtBQUdmLFNBQUtDLFlBQUwsR0FBb0JDLGlDQUFnQkMsR0FBaEIsRUFBcEI7QUFDSDs7QUFpQk1DLEVBQUFBLE1BQU0sR0FBZ0I7QUFDekIsUUFBSUMsWUFBSjs7QUFDQSxRQUFJLEtBQUtkLEtBQUwsQ0FBV0csU0FBZixFQUEwQjtBQUN0QlcsTUFBQUEsWUFBWSxnQkFDUiw2QkFBQyx5QkFBRDtBQUFrQixRQUFBLE9BQU8sRUFBRSxLQUFLQyxhQUFoQztBQUErQyxRQUFBLFNBQVMsRUFBQyx3QkFBekQ7QUFBa0Ysc0JBQVkseUJBQUcsY0FBSDtBQUE5RixRQURKO0FBR0g7O0FBRUQsUUFBSUMsV0FBSjs7QUFDQSxRQUFJLEtBQUtoQixLQUFMLENBQVdnQixXQUFmLEVBQTRCO0FBQ3hCQSxNQUFBQSxXQUFXLGdCQUFHO0FBQUssUUFBQSxTQUFTLEVBQUMsc0JBQWY7QUFBc0MsUUFBQSxHQUFHLEVBQUUsS0FBS2hCLEtBQUwsQ0FBV2dCLFdBQXREO0FBQW1FLFFBQUEsR0FBRyxFQUFDO0FBQXZFLFFBQWQ7QUFDSDs7QUFFRCx3QkFDSSw2QkFBQyw0QkFBRCxDQUFxQixRQUFyQjtBQUE4QixNQUFBLEtBQUssRUFBRSxLQUFLTjtBQUExQyxvQkFDSSw2QkFBQyx1QkFBRDtBQUNJLE1BQUEsV0FBVyxFQUFFLElBRGpCO0FBRUksTUFBQSxTQUFTLEVBQUU7QUFDUFIsUUFBQUEsU0FBUyxFQUFFLEtBQUtBLFNBRFQ7QUFFUGUsUUFBQUEsSUFBSSxFQUFFLFFBRkM7QUFHUCxTQUFDLGlCQUFELEdBQXFCLHFCQUhkO0FBSVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBQyxrQkFBRCxHQUFzQixLQUFLakIsS0FBTCxDQUFXa0I7QUFWMUIsT0FGZjtBQWNJLE1BQUEsU0FBUyxFQUFFLHlCQUFXO0FBQ2xCLFNBQUMsS0FBS2xCLEtBQUwsQ0FBV21CLFNBQVosR0FBd0IsSUFETjtBQUVsQixnQ0FBd0IsS0FBS25CLEtBQUwsQ0FBV29CO0FBRmpCLE9BQVg7QUFkZixvQkFtQkk7QUFBSyxNQUFBLFNBQVMsRUFBRSx5QkFBVyxrQkFBWCxFQUErQjtBQUMzQyxzQ0FBOEIsQ0FBQyxDQUFDLEtBQUtwQixLQUFMLENBQVdxQixZQURBO0FBRTNDLHNDQUE4QixDQUFDLENBQUNQO0FBRlcsT0FBL0I7QUFBaEIsb0JBSUk7QUFBSyxNQUFBLFNBQVMsRUFBRSx5QkFBVyxpQkFBWCxFQUE4QixLQUFLZCxLQUFMLENBQVdzQixVQUF6QyxDQUFoQjtBQUFzRSxNQUFBLEVBQUUsRUFBQztBQUF6RSxPQUNNTixXQUROLEVBRU0sS0FBS2hCLEtBQUwsQ0FBV3VCLEtBRmpCLENBSkosRUFRTSxLQUFLdkIsS0FBTCxDQUFXcUIsWUFSakIsRUFTTVAsWUFUTixDQW5CSixFQThCTSxLQUFLZCxLQUFMLENBQVd3QixRQTlCakIsQ0FESixDQURKO0FBb0NIOztBQTlFMkQsQyx5REFHL0I7QUFDekJyQixFQUFBQSxTQUFTLEVBQUUsSUFEYztBQUV6QmlCLEVBQUFBLFVBQVUsRUFBRTtBQUZhLEMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMTcgVmVjdG9yIENyZWF0aW9ucyBMdGRcbkNvcHlyaWdodCAyMDE4LCAyMDE5IE5ldyBWZWN0b3IgTHRkXG5Db3B5cmlnaHQgMjAxOSBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgRm9jdXNMb2NrIGZyb20gJ3JlYWN0LWZvY3VzLWxvY2snO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmltcG9ydCB7IEtleSB9IGZyb20gJy4uLy4uLy4uL0tleWJvYXJkJztcbmltcG9ydCBBY2Nlc3NpYmxlQnV0dG9uLCB7IEJ1dHRvbkV2ZW50IH0gZnJvbSAnLi4vZWxlbWVudHMvQWNjZXNzaWJsZUJ1dHRvbic7XG5pbXBvcnQgeyBNYXRyaXhDbGllbnRQZWcgfSBmcm9tICcuLi8uLi8uLi9NYXRyaXhDbGllbnRQZWcnO1xuaW1wb3J0IHsgX3QgfSBmcm9tIFwiLi4vLi4vLi4vbGFuZ3VhZ2VIYW5kbGVyXCI7XG5pbXBvcnQgTWF0cml4Q2xpZW50Q29udGV4dCBmcm9tIFwiLi4vLi4vLi4vY29udGV4dHMvTWF0cml4Q2xpZW50Q29udGV4dFwiO1xuaW1wb3J0IHsgcmVwbGFjZWFibGVDb21wb25lbnQgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvcmVwbGFjZWFibGVDb21wb25lbnRcIjtcbmltcG9ydCB7IE1hdHJpeENsaWVudCB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9jbGllbnRcIjtcbmltcG9ydCB7IElEaWFsb2dQcm9wcyB9IGZyb20gXCIuL0lEaWFsb2dQcm9wc1wiO1xuXG5pbnRlcmZhY2UgSVByb3BzIGV4dGVuZHMgSURpYWxvZ1Byb3BzIHtcbiAgICAvLyBXaGV0aGVyIHRoZSBkaWFsb2cgc2hvdWxkIGhhdmUgYSAnY2xvc2UnIGJ1dHRvbiB0aGF0IHdpbGxcbiAgICAvLyBjYXVzZSB0aGUgZGlhbG9nIHRvIGJlIGNhbmNlbGxlZC4gVGhpcyBzaG91bGQgb25seSBiZSBzZXRcbiAgICAvLyB0byBmYWxzZSBpZiB0aGVyZSBpcyBub3RoaW5nIHRoZSBhcHAgY2FuIHNlbnNpYmx5IGRvIGlmIHRoZVxuICAgIC8vIGRpYWxvZyBpcyBjYW5jZWxsZWQsIGVnLiBcIldlIGNhbid0IHJlc3RvcmUgeW91ciBzZXNzaW9uIGFuZFxuICAgIC8vIHRoZSBhcHAgY2Fubm90IHdvcmtcIi4gRGVmYXVsdDogdHJ1ZS5cbiAgICBoYXNDYW5jZWw/OiBib29sZWFuO1xuXG4gICAgLy8gY2FsbGVkIHdoZW4gYSBrZXkgaXMgcHJlc3NlZFxuICAgIG9uS2V5RG93bj86IChlOiBLZXlib2FyZEV2ZW50IHwgUmVhY3QuS2V5Ym9hcmRFdmVudCkgPT4gdm9pZDtcblxuICAgIC8vIENTUyBjbGFzcyB0byBhcHBseSB0byBkaWFsb2cgZGl2XG4gICAgY2xhc3NOYW1lPzogc3RyaW5nO1xuXG4gICAgLy8gaWYgdHJ1ZSwgZGlhbG9nIGNvbnRhaW5lciBpcyA2MCUgb2YgdGhlIHZpZXdwb3J0IHdpZHRoLiBPdGhlcndpc2UsXG4gICAgLy8gdGhlIGNvbnRhaW5lciB3aWxsIGhhdmUgbm8gZml4ZWQgc2l6ZSwgYWxsb3dpbmcgaXRzIGNvbnRlbnRzIHRvXG4gICAgLy8gZGV0ZXJtaW5lIGl0cyBzaXplLiBEZWZhdWx0OiB0cnVlLlxuICAgIGZpeGVkV2lkdGg/OiBib29sZWFuO1xuXG4gICAgLy8gVGl0bGUgZm9yIHRoZSBkaWFsb2cuXG4gICAgdGl0bGU/OiBKU1guRWxlbWVudCB8IHN0cmluZztcblxuICAgIC8vIFBhdGggdG8gYW4gaWNvbiB0byBwdXQgaW4gdGhlIGhlYWRlclxuICAgIGhlYWRlckltYWdlPzogc3RyaW5nO1xuXG4gICAgLy8gY2hpbGRyZW4gc2hvdWxkIGJlIHRoZSBjb250ZW50IG9mIHRoZSBkaWFsb2dcbiAgICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcblxuICAgIC8vIElkIG9mIGNvbnRlbnQgZWxlbWVudFxuICAgIC8vIElmIHByb3ZpZGVkLCB0aGlzIGlzIHVzZWQgdG8gYWRkIGEgYXJpYS1kZXNjcmliZWRieSBhdHRyaWJ1dGVcbiAgICBjb250ZW50SWQ/OiBzdHJpbmc7XG5cbiAgICAvLyBvcHRpb25hbCBhZGRpdGlvbmFsIGNsYXNzIGZvciB0aGUgdGl0bGUgZWxlbWVudCAoYmFzaWNhbGx5IGFueXRoaW5nIHRoYXQgY2FuIGJlIHBhc3NlZCB0byBjbGFzc25hbWVzKVxuICAgIHRpdGxlQ2xhc3M/OiBzdHJpbmcgfCBzdHJpbmdbXTtcblxuICAgIGhlYWRlckJ1dHRvbj86IEpTWC5FbGVtZW50O1xufVxuXG4vKlxuICogQmFzaWMgY29udGFpbmVyIGZvciBtb2RhbCBkaWFsb2dzLlxuICpcbiAqIEluY2x1ZGVzIGEgZGl2IGZvciB0aGUgdGl0bGUsIGFuZCBhIGtleXByZXNzIGhhbmRsZXIgd2hpY2ggY2FuY2VscyB0aGVcbiAqIGRpYWxvZyBvbiBlc2NhcGUuXG4gKi9cbkByZXBsYWNlYWJsZUNvbXBvbmVudChcInZpZXdzLmRpYWxvZ3MuQmFzZURpYWxvZ1wiKVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZURpYWxvZyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxJUHJvcHM+IHtcbiAgICBwcml2YXRlIG1hdHJpeENsaWVudDogTWF0cml4Q2xpZW50O1xuXG4gICAgcHVibGljIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGhhc0NhbmNlbDogdHJ1ZSxcbiAgICAgICAgZml4ZWRXaWR0aDogdHJ1ZSxcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMubWF0cml4Q2xpZW50ID0gTWF0cml4Q2xpZW50UGVnLmdldCgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgb25LZXlEb3duID0gKGU6IEtleWJvYXJkRXZlbnQgfCBSZWFjdC5LZXlib2FyZEV2ZW50KTogdm9pZCA9PiB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uS2V5RG93bikge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbktleURvd24oZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuaGFzQ2FuY2VsICYmIGUua2V5ID09PSBLZXkuRVNDQVBFKSB7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkZpbmlzaGVkKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcml2YXRlIG9uQ2FuY2VsQ2xpY2sgPSAoZTogQnV0dG9uRXZlbnQpOiB2b2lkID0+IHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkZpbmlzaGVkKGZhbHNlKTtcbiAgICB9O1xuXG4gICAgcHVibGljIHJlbmRlcigpOiBKU1guRWxlbWVudCB7XG4gICAgICAgIGxldCBjYW5jZWxCdXR0b247XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmhhc0NhbmNlbCkge1xuICAgICAgICAgICAgY2FuY2VsQnV0dG9uID0gKFxuICAgICAgICAgICAgICAgIDxBY2Nlc3NpYmxlQnV0dG9uIG9uQ2xpY2s9e3RoaXMub25DYW5jZWxDbGlja30gY2xhc3NOYW1lPVwibXhfRGlhbG9nX2NhbmNlbEJ1dHRvblwiIGFyaWEtbGFiZWw9e190KFwiQ2xvc2UgZGlhbG9nXCIpfSAvPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBoZWFkZXJJbWFnZTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuaGVhZGVySW1hZ2UpIHtcbiAgICAgICAgICAgIGhlYWRlckltYWdlID0gPGltZyBjbGFzc05hbWU9XCJteF9EaWFsb2dfdGl0bGVJbWFnZVwiIHNyYz17dGhpcy5wcm9wcy5oZWFkZXJJbWFnZX0gYWx0PVwiXCIgLz47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPE1hdHJpeENsaWVudENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3RoaXMubWF0cml4Q2xpZW50fT5cbiAgICAgICAgICAgICAgICA8Rm9jdXNMb2NrXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkZvY3VzPXt0cnVlfVxuICAgICAgICAgICAgICAgICAgICBsb2NrUHJvcHM9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uS2V5RG93bjogdGhpcy5vbktleURvd24sXG4gICAgICAgICAgICAgICAgICAgICAgICByb2xlOiBcImRpYWxvZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgW1wiYXJpYS1sYWJlbGxlZGJ5XCJdOiBcIm14X0Jhc2VEaWFsb2dfdGl0bGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIHBvaW50IHRvIGEgbm9kZSBkZXNjcmliaW5nIHRoZSBkaWFsb2cuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSB3ZXJlIGFib3V0IHRvIGNvbXBsZXRlbHkgZm9sbG93IHRoaXMgcmVjb21tZW5kYXRpb24gd2UnZCBuZWVkIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIGFsbCB0aGUgY29tcG9uZW50cyByZWx5aW5nIG9uIEJhc2VEaWFsb2cgdG8gYmUgYXdhcmUgb2YgaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTbyBpbnN0ZWFkIHdlIHdpbGwgdXNlIHRoZSB3aG9sZSBjb250ZW50IGFzIHRoZSBkZXNjcmlwdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlc2NyaXB0aW9uIGNvbWVzIGZpcnN0IGFuZCBpZiB0aGUgY29udGVudCBjb250YWlucyBtb3JlIHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBVCB1c2VycyBjYW4gc2tpcCBpdHMgcHJlc2VudGF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgW1wiYXJpYS1kZXNjcmliZWRieVwiXTogdGhpcy5wcm9wcy5jb250ZW50SWQsXG4gICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBbdGhpcy5wcm9wcy5jbGFzc05hbWVdOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ214X0RpYWxvZ19maXhlZFdpZHRoJzogdGhpcy5wcm9wcy5maXhlZFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWVzKCdteF9EaWFsb2dfaGVhZGVyJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ214X0RpYWxvZ19oZWFkZXJXaXRoQnV0dG9uJzogISF0aGlzLnByb3BzLmhlYWRlckJ1dHRvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICdteF9EaWFsb2dfaGVhZGVyV2l0aENhbmNlbCc6ICEhY2FuY2VsQnV0dG9uLFxuICAgICAgICAgICAgICAgICAgICB9KX0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lcygnbXhfRGlhbG9nX3RpdGxlJywgdGhpcy5wcm9wcy50aXRsZUNsYXNzKX0gaWQ9J214X0Jhc2VEaWFsb2dfdGl0bGUnPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaGVhZGVySW1hZ2UgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdGhpcy5wcm9wcy50aXRsZSB9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsgdGhpcy5wcm9wcy5oZWFkZXJCdXR0b24gfVxuICAgICAgICAgICAgICAgICAgICAgICAgeyBjYW5jZWxCdXR0b24gfVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgeyB0aGlzLnByb3BzLmNoaWxkcmVuIH1cbiAgICAgICAgICAgICAgICA8L0ZvY3VzTG9jaz5cbiAgICAgICAgICAgIDwvTWF0cml4Q2xpZW50Q29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgKTtcbiAgICB9XG59XG4iXX0=