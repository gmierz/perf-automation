"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

var _classnames = _interopRequireDefault(require("classnames"));

var _react = _interopRequireDefault(require("react"));

var sdk = _interopRequireWildcard(require("../../../../index"));

var _MatrixClientPeg = require("../../../../MatrixClientPeg");

var _Field = _interopRequireDefault(require("../../elements/Field"));

var _AccessibleButton = _interopRequireDefault(require("../../elements/AccessibleButton"));

var _languageHandler = require("../../../../languageHandler");

var _SecurityManager = require("../../../../SecurityManager");

var _Modal = _interopRequireDefault(require("../../../../Modal"));

var _logger = require("matrix-js-sdk/src/logger");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
Copyright 2018-2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// Maximum acceptable size of a key file. It's 59 characters including the spaces we encode,
// so this should be plenty and allow for people putting extra whitespace in the file because
// maybe that's a thing people would do?
const KEY_FILE_MAX_SIZE = 128; // Don't shout at the user that their key is invalid every time they type a key: wait a short time

const VALIDATION_THROTTLE_MS = 200;

/*
 * Access Secure Secret Storage by requesting the user's passphrase.
 */
class AccessSecretStorageDialog extends _react.default.PureComponent {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "fileUpload", /*#__PURE__*/_react.default.createRef());
    (0, _defineProperty2.default)(this, "onCancel", () => {
      if (this.state.resetting) {
        this.setState({
          resetting: false
        });
      }

      this.props.onFinished(false);
    });
    (0, _defineProperty2.default)(this, "onUseRecoveryKeyClick", () => {
      this.setState({
        forceRecoveryKey: true
      });
    });
    (0, _defineProperty2.default)(this, "validateRecoveryKeyOnChange", (0, _lodash.debounce)(async () => {
      await this.validateRecoveryKey();
    }, VALIDATION_THROTTLE_MS));
    (0, _defineProperty2.default)(this, "onRecoveryKeyChange", ev => {
      this.setState({
        recoveryKey: ev.target.value,
        recoveryKeyFileError: null
      }); // also clear the file upload control so that the user can upload the same file
      // the did before (otherwise the onchange wouldn't fire)

      if (this.fileUpload.current) this.fileUpload.current.value = null; // We don't use Field's validation here because a) we want it in a separate place rather
      // than in a tooltip and b) we want it to display feedback based on the uploaded file
      // as well as the text box. Ideally we would refactor Field's validation logic so we could
      // re-use some of it.

      this.validateRecoveryKeyOnChange();
    });
    (0, _defineProperty2.default)(this, "onRecoveryKeyFileChange", async ev => {
      if (ev.target.files.length === 0) return;
      const f = ev.target.files[0];

      if (f.size > KEY_FILE_MAX_SIZE) {
        this.setState({
          recoveryKeyFileError: true,
          recoveryKeyCorrect: false,
          recoveryKeyValid: false
        });
      } else {
        const contents = await f.text(); // test it's within the base58 alphabet. We could be more strict here, eg. require the
        // right number of characters, but it's really just to make sure that what we're reading is
        // text because we'll put it in the text field.

        if (/^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\s]+$/.test(contents)) {
          this.setState({
            recoveryKeyFileError: null,
            recoveryKey: contents.trim()
          });
          await this.validateRecoveryKey();
        } else {
          this.setState({
            recoveryKeyFileError: true,
            recoveryKeyCorrect: false,
            recoveryKeyValid: false,
            recoveryKey: ''
          });
        }
      }
    });
    (0, _defineProperty2.default)(this, "onRecoveryKeyFileUploadClick", () => {
      this.fileUpload.current.click();
    });
    (0, _defineProperty2.default)(this, "onPassPhraseNext", async ev => {
      ev.preventDefault();
      if (this.state.passPhrase.length <= 0) return;
      this.setState({
        keyMatches: null
      });
      const input = {
        passphrase: this.state.passPhrase
      };
      const keyMatches = await this.props.checkPrivateKey(input);

      if (keyMatches) {
        this.props.onFinished(input);
      } else {
        this.setState({
          keyMatches
        });
      }
    });
    (0, _defineProperty2.default)(this, "onRecoveryKeyNext", async ev => {
      ev.preventDefault();
      if (!this.state.recoveryKeyValid) return;
      this.setState({
        keyMatches: null
      });
      const input = {
        recoveryKey: this.state.recoveryKey
      };
      const keyMatches = await this.props.checkPrivateKey(input);

      if (keyMatches) {
        this.props.onFinished(input);
      } else {
        this.setState({
          keyMatches
        });
      }
    });
    (0, _defineProperty2.default)(this, "onPassPhraseChange", ev => {
      this.setState({
        passPhrase: ev.target.value,
        keyMatches: null
      });
    });
    (0, _defineProperty2.default)(this, "onResetAllClick", ev => {
      ev.preventDefault();
      this.setState({
        resetting: true
      });
    });
    (0, _defineProperty2.default)(this, "onConfirmResetAllClick", async () => {
      // Hide ourselves so the user can interact with the reset dialogs.
      // We don't conclude the promise chain (onFinished) yet to avoid confusing
      // any upstream code flows.
      //
      // Note: this will unmount us, so don't call `setState` or anything in the
      // rest of this function.
      _Modal.default.toggleCurrentDialogVisibility();

      try {
        // Force reset secret storage (which resets the key backup)
        await (0, _SecurityManager.accessSecretStorage)(async () => {
          // Now reset cross-signing so everything Just Worksâ„¢ again.
          const cli = _MatrixClientPeg.MatrixClientPeg.get();

          await cli.bootstrapCrossSigning({
            authUploadDeviceSigningKeys: async makeRequest => {
              // XXX: Making this an import breaks the app.
              const InteractiveAuthDialog = sdk.getComponent("views.dialogs.InteractiveAuthDialog");

              const {
                finished
              } = _Modal.default.createTrackedDialog('Cross-signing keys dialog', '', InteractiveAuthDialog, {
                title: (0, _languageHandler._t)("Setting up keys"),
                matrixClient: cli,
                makeRequest
              });

              const [confirmed] = await finished;

              if (!confirmed) {
                throw new Error("Cross-signing key upload auth canceled");
              }
            },
            setupNewCrossSigning: true
          }); // Now we can indicate that the user is done pressing buttons, finally.
          // Upstream flows will detect the new secret storage, key backup, etc and use it.

          this.props.onFinished(true);
        }, true);
      } catch (e) {
        _logger.logger.error(e);

        this.props.onFinished(false);
      }
    });
    this.state = {
      recoveryKey: "",
      recoveryKeyValid: null,
      recoveryKeyCorrect: null,
      recoveryKeyFileError: null,
      forceRecoveryKey: false,
      passPhrase: '',
      keyMatches: null,
      resetting: false
    };
  }

  async validateRecoveryKey() {
    if (this.state.recoveryKey === '') {
      this.setState({
        recoveryKeyValid: null,
        recoveryKeyCorrect: null
      });
      return;
    }

    try {
      const cli = _MatrixClientPeg.MatrixClientPeg.get();

      const decodedKey = cli.keyBackupKeyFromRecoveryKey(this.state.recoveryKey);
      const correct = await cli.checkSecretStorageKey(decodedKey, this.props.keyInfo);
      this.setState({
        recoveryKeyValid: true,
        recoveryKeyCorrect: correct
      });
    } catch (e) {
      this.setState({
        recoveryKeyValid: false,
        recoveryKeyCorrect: false
      });
    }
  }

  getKeyValidationText() {
    if (this.state.recoveryKeyFileError) {
      return (0, _languageHandler._t)("Wrong file type");
    } else if (this.state.recoveryKeyCorrect) {
      return (0, _languageHandler._t)("Looks good!");
    } else if (this.state.recoveryKeyValid) {
      return (0, _languageHandler._t)("Wrong Security Key");
    } else if (this.state.recoveryKeyValid === null) {
      return '';
    } else {
      return (0, _languageHandler._t)("Invalid Security Key");
    }
  }

  render() {
    // Caution: Making these an import will break tests.
    const BaseDialog = sdk.getComponent("views.dialogs.BaseDialog");
    const DialogButtons = sdk.getComponent("views.elements.DialogButtons");
    const hasPassphrase = this.props.keyInfo && this.props.keyInfo.passphrase && this.props.keyInfo.passphrase.salt && this.props.keyInfo.passphrase.iterations;

    const resetButton = /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_AccessSecretStorageDialog_reset"
    }, (0, _languageHandler._t)("Forgotten or lost all recovery methods? <a>Reset all</a>", null, {
      a: sub => /*#__PURE__*/_react.default.createElement("a", {
        href: "",
        onClick: this.onResetAllClick,
        className: "mx_AccessSecretStorageDialog_reset_link"
      }, sub)
    }));

    let content;
    let title;
    let titleClass;

    if (this.state.resetting) {
      title = (0, _languageHandler._t)("Reset everything");
      titleClass = ['mx_AccessSecretStorageDialog_titleWithIcon mx_AccessSecretStorageDialog_resetBadge'];
      content = /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("p", null, (0, _languageHandler._t)("Only do this if you have no other device to complete verification with.")), /*#__PURE__*/_react.default.createElement("p", null, (0, _languageHandler._t)("If you reset everything, you will restart with no trusted sessions, no trusted users, and " + "might not be able to see past messages.")), /*#__PURE__*/_react.default.createElement(DialogButtons, {
        primaryButton: (0, _languageHandler._t)('Reset'),
        onPrimaryButtonClick: this.onConfirmResetAllClick,
        hasCancel: true,
        onCancel: this.onCancel,
        focus: false,
        primaryButtonClass: "danger"
      }));
    } else if (hasPassphrase && !this.state.forceRecoveryKey) {
      const AccessibleButton = sdk.getComponent('elements.AccessibleButton');
      title = (0, _languageHandler._t)("Security Phrase");
      titleClass = ['mx_AccessSecretStorageDialog_titleWithIcon mx_AccessSecretStorageDialog_securePhraseTitle'];
      let keyStatus;

      if (this.state.keyMatches === false) {
        keyStatus = /*#__PURE__*/_react.default.createElement("div", {
          className: "mx_AccessSecretStorageDialog_keyStatus"
        }, "\uD83D\uDC4E ", (0, _languageHandler._t)("Unable to access secret storage. " + "Please verify that you entered the correct Security Phrase."));
      } else {
        keyStatus = /*#__PURE__*/_react.default.createElement("div", {
          className: "mx_AccessSecretStorageDialog_keyStatus"
        });
      }

      content = /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("p", null, (0, _languageHandler._t)("Enter your Security Phrase or <button>use your Security Key</button> to continue.", {}, {
        button: s => /*#__PURE__*/_react.default.createElement(AccessibleButton, {
          className: "mx_linkButton",
          element: "span",
          onClick: this.onUseRecoveryKeyClick
        }, s)
      })), /*#__PURE__*/_react.default.createElement("form", {
        className: "mx_AccessSecretStorageDialog_primaryContainer",
        onSubmit: this.onPassPhraseNext
      }, /*#__PURE__*/_react.default.createElement(_Field.default, {
        id: "mx_passPhraseInput",
        className: "mx_AccessSecretStorageDialog_passPhraseInput",
        type: "password",
        label: (0, _languageHandler._t)("Security Phrase"),
        value: this.state.passPhrase,
        onChange: this.onPassPhraseChange,
        autoFocus: true,
        autoComplete: "new-password"
      }), keyStatus, /*#__PURE__*/_react.default.createElement(DialogButtons, {
        primaryButton: (0, _languageHandler._t)('Continue'),
        onPrimaryButtonClick: this.onPassPhraseNext,
        hasCancel: true,
        onCancel: this.onCancel,
        focus: false,
        primaryDisabled: this.state.passPhrase.length === 0,
        additive: resetButton
      })));
    } else {
      title = (0, _languageHandler._t)("Security Key");
      titleClass = ['mx_AccessSecretStorageDialog_titleWithIcon mx_AccessSecretStorageDialog_secureBackupTitle'];
      const feedbackClasses = (0, _classnames.default)({
        'mx_AccessSecretStorageDialog_recoveryKeyFeedback': true,
        'mx_AccessSecretStorageDialog_recoveryKeyFeedback_valid': this.state.recoveryKeyCorrect === true,
        'mx_AccessSecretStorageDialog_recoveryKeyFeedback_invalid': this.state.recoveryKeyCorrect === false
      });

      const recoveryKeyFeedback = /*#__PURE__*/_react.default.createElement("div", {
        className: feedbackClasses
      }, this.getKeyValidationText());

      content = /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("p", null, (0, _languageHandler._t)("Use your Security Key to continue.")), /*#__PURE__*/_react.default.createElement("form", {
        className: "mx_AccessSecretStorageDialog_primaryContainer",
        onSubmit: this.onRecoveryKeyNext,
        spellCheck: false,
        autoComplete: "off"
      }, /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_AccessSecretStorageDialog_recoveryKeyEntry"
      }, /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_AccessSecretStorageDialog_recoveryKeyEntry_textInput"
      }, /*#__PURE__*/_react.default.createElement(_Field.default, {
        type: "password",
        label: (0, _languageHandler._t)('Security Key'),
        value: this.state.recoveryKey,
        onChange: this.onRecoveryKeyChange,
        forceValidity: this.state.recoveryKeyCorrect,
        autoComplete: "off"
      })), /*#__PURE__*/_react.default.createElement("span", {
        className: "mx_AccessSecretStorageDialog_recoveryKeyEntry_entryControlSeparatorText"
      }, (0, _languageHandler._t)("or")), /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("input", {
        type: "file",
        className: "mx_AccessSecretStorageDialog_recoveryKeyEntry_fileInput",
        ref: this.fileUpload,
        onChange: this.onRecoveryKeyFileChange
      }), /*#__PURE__*/_react.default.createElement(_AccessibleButton.default, {
        kind: "primary",
        onClick: this.onRecoveryKeyFileUploadClick
      }, (0, _languageHandler._t)("Upload")))), recoveryKeyFeedback, /*#__PURE__*/_react.default.createElement(DialogButtons, {
        primaryButton: (0, _languageHandler._t)('Continue'),
        onPrimaryButtonClick: this.onRecoveryKeyNext,
        hasCancel: true,
        cancelButton: (0, _languageHandler._t)("Go Back"),
        cancelButtonClass: "danger",
        onCancel: this.onCancel,
        focus: false,
        primaryDisabled: !this.state.recoveryKeyValid,
        additive: resetButton
      })));
    }

    return /*#__PURE__*/_react.default.createElement(BaseDialog, {
      className: "mx_AccessSecretStorageDialog",
      onFinished: this.props.onFinished,
      title: title,
      titleClass: titleClass
    }, /*#__PURE__*/_react.default.createElement("div", null, content));
  }

}

exports.default = AccessSecretStorageDialog;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2RpYWxvZ3Mvc2VjdXJpdHkvQWNjZXNzU2VjcmV0U3RvcmFnZURpYWxvZy50c3giXSwibmFtZXMiOlsiS0VZX0ZJTEVfTUFYX1NJWkUiLCJWQUxJREFUSU9OX1RIUk9UVExFX01TIiwiQWNjZXNzU2VjcmV0U3RvcmFnZURpYWxvZyIsIlJlYWN0IiwiUHVyZUNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJjcmVhdGVSZWYiLCJzdGF0ZSIsInJlc2V0dGluZyIsInNldFN0YXRlIiwib25GaW5pc2hlZCIsImZvcmNlUmVjb3ZlcnlLZXkiLCJ2YWxpZGF0ZVJlY292ZXJ5S2V5IiwiZXYiLCJyZWNvdmVyeUtleSIsInRhcmdldCIsInZhbHVlIiwicmVjb3ZlcnlLZXlGaWxlRXJyb3IiLCJmaWxlVXBsb2FkIiwiY3VycmVudCIsInZhbGlkYXRlUmVjb3ZlcnlLZXlPbkNoYW5nZSIsImZpbGVzIiwibGVuZ3RoIiwiZiIsInNpemUiLCJyZWNvdmVyeUtleUNvcnJlY3QiLCJyZWNvdmVyeUtleVZhbGlkIiwiY29udGVudHMiLCJ0ZXh0IiwidGVzdCIsInRyaW0iLCJjbGljayIsInByZXZlbnREZWZhdWx0IiwicGFzc1BocmFzZSIsImtleU1hdGNoZXMiLCJpbnB1dCIsInBhc3NwaHJhc2UiLCJjaGVja1ByaXZhdGVLZXkiLCJNb2RhbCIsInRvZ2dsZUN1cnJlbnREaWFsb2dWaXNpYmlsaXR5IiwiY2xpIiwiTWF0cml4Q2xpZW50UGVnIiwiZ2V0IiwiYm9vdHN0cmFwQ3Jvc3NTaWduaW5nIiwiYXV0aFVwbG9hZERldmljZVNpZ25pbmdLZXlzIiwibWFrZVJlcXVlc3QiLCJJbnRlcmFjdGl2ZUF1dGhEaWFsb2ciLCJzZGsiLCJnZXRDb21wb25lbnQiLCJmaW5pc2hlZCIsImNyZWF0ZVRyYWNrZWREaWFsb2ciLCJ0aXRsZSIsIm1hdHJpeENsaWVudCIsImNvbmZpcm1lZCIsIkVycm9yIiwic2V0dXBOZXdDcm9zc1NpZ25pbmciLCJlIiwibG9nZ2VyIiwiZXJyb3IiLCJkZWNvZGVkS2V5Iiwia2V5QmFja3VwS2V5RnJvbVJlY292ZXJ5S2V5IiwiY29ycmVjdCIsImNoZWNrU2VjcmV0U3RvcmFnZUtleSIsImtleUluZm8iLCJnZXRLZXlWYWxpZGF0aW9uVGV4dCIsInJlbmRlciIsIkJhc2VEaWFsb2ciLCJEaWFsb2dCdXR0b25zIiwiaGFzUGFzc3BocmFzZSIsInNhbHQiLCJpdGVyYXRpb25zIiwicmVzZXRCdXR0b24iLCJhIiwic3ViIiwib25SZXNldEFsbENsaWNrIiwiY29udGVudCIsInRpdGxlQ2xhc3MiLCJvbkNvbmZpcm1SZXNldEFsbENsaWNrIiwib25DYW5jZWwiLCJBY2Nlc3NpYmxlQnV0dG9uIiwia2V5U3RhdHVzIiwiYnV0dG9uIiwicyIsIm9uVXNlUmVjb3ZlcnlLZXlDbGljayIsIm9uUGFzc1BocmFzZU5leHQiLCJvblBhc3NQaHJhc2VDaGFuZ2UiLCJmZWVkYmFja0NsYXNzZXMiLCJyZWNvdmVyeUtleUZlZWRiYWNrIiwib25SZWNvdmVyeUtleU5leHQiLCJvblJlY292ZXJ5S2V5Q2hhbmdlIiwib25SZWNvdmVyeUtleUZpbGVDaGFuZ2UiLCJvblJlY292ZXJ5S2V5RmlsZVVwbG9hZENsaWNrIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWdCQTs7QUFDQTs7QUFDQTs7QUFHQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFFQTs7Ozs7O0FBOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQSxpQkFBaUIsR0FBRyxHQUExQixDLENBRUE7O0FBQ0EsTUFBTUMsc0JBQXNCLEdBQUcsR0FBL0I7O0FBa0JBO0FBQ0E7QUFDQTtBQUNlLE1BQU1DLHlCQUFOLFNBQXdDQyxlQUFNQyxhQUE5QyxDQUE0RTtBQUd2RkMsRUFBQUEsV0FB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RUFBQyx5REFEZDtBQUVJLFFBQUEsR0FBRyxFQUFFLEtBQUtQLFVBRmQ7QUFHSSxRQUFBLFFBQVEsRUFBRSxLQUFLd0U7QUFIbkIsUUFESixlQU1JLDZCQUFDLHlCQUFEO0FBQWtCLFFBQUEsSUFBSSxFQUFDLFNBQXZCO0FBQWlDLFFBQUEsT0FBTyxFQUFFLEtBQUtDO0FBQS9DLFNBQ00seUJBQUcsUUFBSCxDQUROLENBTkosQ0FkSixDQU5KLEVBK0JNSixtQkEvQk4sZUFnQ0ksNkJBQUMsYUFBRDtBQUNJLFFBQUEsYUFBYSxFQUFFLHlCQUFHLFVBQUgsQ0FEbkI7QUFFSSxRQUFBLG9CQUFvQixFQUFFLEtBQUtDLGlCQUYvQjtBQUdJLFFBQUEsU0FBUyxFQUFFLElBSGY7QUFJSSxRQUFBLFlBQVksRUFBRSx5QkFBRyxTQUFILENBSmxCO0FBS0ksUUFBQSxpQkFBaUIsRUFBQyxRQUx0QjtBQU1JLFFBQUEsUUFBUSxFQUFFLEtBQUtWLFFBTm5CO0FBT0ksUUFBQSxLQUFLLEVBQUUsS0FQWDtBQVFJLFFBQUEsZUFBZSxFQUFFLENBQUMsS0FBS3ZFLEtBQUwsQ0FBV21CLGdCQVJqQztBQVNJLFFBQUEsUUFBUSxFQUFFNkM7QUFUZCxRQWhDSixDQUhNLENBQVY7QUFnREg7O0FBRUQsd0JBQ0ksNkJBQUMsVUFBRDtBQUFZLE1BQUEsU0FBUyxFQUFDLDhCQUF0QjtBQUNJLE1BQUEsVUFBVSxFQUFFLEtBQUtsRSxLQUFMLENBQVdLLFVBRDNCO0FBRUksTUFBQSxLQUFLLEVBQUV5QyxLQUZYO0FBR0ksTUFBQSxVQUFVLEVBQUV5QjtBQUhoQixvQkFLSSwwQ0FDTUQsT0FETixDQUxKLENBREo7QUFXSDs7QUFqWXNGIiwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE4LTIwMjEgVGhlIE1hdHJpeC5vcmcgRm91bmRhdGlvbiBDLkkuQy5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgeyBkZWJvdW5jZSB9IGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFJlYWN0LCB7IENoYW5nZUV2ZW50LCBGb3JtRXZlbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBJU2VjcmV0U3RvcmFnZUtleUluZm8gfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvY3J5cHRvL2FwaVwiO1xuXG5pbXBvcnQgKiBhcyBzZGsgZnJvbSAnLi4vLi4vLi4vLi4vaW5kZXgnO1xuaW1wb3J0IHsgTWF0cml4Q2xpZW50UGVnIH0gZnJvbSAnLi4vLi4vLi4vLi4vTWF0cml4Q2xpZW50UGVnJztcbmltcG9ydCBGaWVsZCBmcm9tICcuLi8uLi9lbGVtZW50cy9GaWVsZCc7XG5pbXBvcnQgQWNjZXNzaWJsZUJ1dHRvbiBmcm9tICcuLi8uLi9lbGVtZW50cy9BY2Nlc3NpYmxlQnV0dG9uJztcbmltcG9ydCB7IF90IH0gZnJvbSAnLi4vLi4vLi4vLi4vbGFuZ3VhZ2VIYW5kbGVyJztcbmltcG9ydCB7IElEaWFsb2dQcm9wcyB9IGZyb20gXCIuLi9JRGlhbG9nUHJvcHNcIjtcbmltcG9ydCB7IGFjY2Vzc1NlY3JldFN0b3JhZ2UgfSBmcm9tIFwiLi4vLi4vLi4vLi4vU2VjdXJpdHlNYW5hZ2VyXCI7XG5pbXBvcnQgTW9kYWwgZnJvbSBcIi4uLy4uLy4uLy4uL01vZGFsXCI7XG5cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9sb2dnZXJcIjtcblxuLy8gTWF4aW11bSBhY2NlcHRhYmxlIHNpemUgb2YgYSBrZXkgZmlsZS4gSXQncyA1OSBjaGFyYWN0ZXJzIGluY2x1ZGluZyB0aGUgc3BhY2VzIHdlIGVuY29kZSxcbi8vIHNvIHRoaXMgc2hvdWxkIGJlIHBsZW50eSBhbmQgYWxsb3cgZm9yIHBlb3BsZSBwdXR0aW5nIGV4dHJhIHdoaXRlc3BhY2UgaW4gdGhlIGZpbGUgYmVjYXVzZVxuLy8gbWF5YmUgdGhhdCdzIGEgdGhpbmcgcGVvcGxlIHdvdWxkIGRvP1xuY29uc3QgS0VZX0ZJTEVfTUFYX1NJWkUgPSAxMjg7XG5cbi8vIERvbid0IHNob3V0IGF0IHRoZSB1c2VyIHRoYXQgdGhlaXIga2V5IGlzIGludmFsaWQgZXZlcnkgdGltZSB0aGV5IHR5cGUgYSBrZXk6IHdhaXQgYSBzaG9ydCB0aW1lXG5jb25zdCBWQUxJREFUSU9OX1RIUk9UVExFX01TID0gMjAwO1xuXG5pbnRlcmZhY2UgSVByb3BzIGV4dGVuZHMgSURpYWxvZ1Byb3BzIHtcbiAgICBrZXlJbmZvOiBJU2VjcmV0U3RvcmFnZUtleUluZm87XG4gICAgY2hlY2tQcml2YXRlS2V5OiAoazoge3Bhc3NwaHJhc2U/OiBzdHJpbmcsIHJlY292ZXJ5S2V5Pzogc3RyaW5nfSkgPT4gYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIElTdGF0ZSB7XG4gICAgcmVjb3ZlcnlLZXk6IHN0cmluZztcbiAgICByZWNvdmVyeUtleVZhbGlkOiBib29sZWFuIHwgbnVsbDtcbiAgICByZWNvdmVyeUtleUNvcnJlY3Q6IGJvb2xlYW4gfCBudWxsO1xuICAgIHJlY292ZXJ5S2V5RmlsZUVycm9yOiBib29sZWFuIHwgbnVsbDtcbiAgICBmb3JjZVJlY292ZXJ5S2V5OiBib29sZWFuO1xuICAgIHBhc3NQaHJhc2U6IHN0cmluZztcbiAgICBrZXlNYXRjaGVzOiBib29sZWFuIHwgbnVsbDtcbiAgICByZXNldHRpbmc6IGJvb2xlYW47XG59XG5cbi8qXG4gKiBBY2Nlc3MgU2VjdXJlIFNlY3JldCBTdG9yYWdlIGJ5IHJlcXVlc3RpbmcgdGhlIHVzZXIncyBwYXNzcGhyYXNlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBY2Nlc3NTZWNyZXRTdG9yYWdlRGlhbG9nIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxJUHJvcHMsIElTdGF0ZT4ge1xuICAgIHByaXZhdGUgZmlsZVVwbG9hZCA9IFJlYWN0LmNyZWF0ZVJlZjxIVE1MSW5wdXRFbGVtZW50PigpO1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICByZWNvdmVyeUtleTogXCJcIixcbiAgICAgICAgICAgIHJlY292ZXJ5S2V5VmFsaWQ6IG51bGwsXG4gICAgICAgICAgICByZWNvdmVyeUtleUNvcnJlY3Q6IG51bGwsXG4gICAgICAgICAgICByZWNvdmVyeUtleUZpbGVFcnJvcjogbnVsbCxcbiAgICAgICAgICAgIGZvcmNlUmVjb3ZlcnlLZXk6IGZhbHNlLFxuICAgICAgICAgICAgcGFzc1BocmFzZTogJycsXG4gICAgICAgICAgICBrZXlNYXRjaGVzOiBudWxsLFxuICAgICAgICAgICAgcmVzZXR0aW5nOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uQ2FuY2VsID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5yZXNldHRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyByZXNldHRpbmc6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvcHMub25GaW5pc2hlZChmYWxzZSk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25Vc2VSZWNvdmVyeUtleUNsaWNrID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZvcmNlUmVjb3ZlcnlLZXk6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBwcml2YXRlIHZhbGlkYXRlUmVjb3ZlcnlLZXlPbkNoYW5nZSA9IGRlYm91bmNlKGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZVJlY292ZXJ5S2V5KCk7XG4gICAgfSwgVkFMSURBVElPTl9USFJPVFRMRV9NUyk7XG5cbiAgICBwcml2YXRlIGFzeW5jIHZhbGlkYXRlUmVjb3ZlcnlLZXkoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnJlY292ZXJ5S2V5ID09PSAnJykge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgcmVjb3ZlcnlLZXlWYWxpZDogbnVsbCxcbiAgICAgICAgICAgICAgICByZWNvdmVyeUtleUNvcnJlY3Q6IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjbGkgPSBNYXRyaXhDbGllbnRQZWcuZ2V0KCk7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVkS2V5ID0gY2xpLmtleUJhY2t1cEtleUZyb21SZWNvdmVyeUtleSh0aGlzLnN0YXRlLnJlY292ZXJ5S2V5KTtcbiAgICAgICAgICAgIGNvbnN0IGNvcnJlY3QgPSBhd2FpdCBjbGkuY2hlY2tTZWNyZXRTdG9yYWdlS2V5KFxuICAgICAgICAgICAgICAgIGRlY29kZWRLZXksIHRoaXMucHJvcHMua2V5SW5mbyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICByZWNvdmVyeUtleVZhbGlkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHJlY292ZXJ5S2V5Q29ycmVjdDogY29ycmVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICByZWNvdmVyeUtleVZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZWNvdmVyeUtleUNvcnJlY3Q6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIG9uUmVjb3ZlcnlLZXlDaGFuZ2UgPSAoZXY6IENoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgcmVjb3ZlcnlLZXk6IGV2LnRhcmdldC52YWx1ZSxcbiAgICAgICAgICAgIHJlY292ZXJ5S2V5RmlsZUVycm9yOiBudWxsLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBhbHNvIGNsZWFyIHRoZSBmaWxlIHVwbG9hZCBjb250cm9sIHNvIHRoYXQgdGhlIHVzZXIgY2FuIHVwbG9hZCB0aGUgc2FtZSBmaWxlXG4gICAgICAgIC8vIHRoZSBkaWQgYmVmb3JlIChvdGhlcndpc2UgdGhlIG9uY2hhbmdlIHdvdWxkbid0IGZpcmUpXG4gICAgICAgIGlmICh0aGlzLmZpbGVVcGxvYWQuY3VycmVudCkgdGhpcy5maWxlVXBsb2FkLmN1cnJlbnQudmFsdWUgPSBudWxsO1xuXG4gICAgICAgIC8vIFdlIGRvbid0IHVzZSBGaWVsZCdzIHZhbGlkYXRpb24gaGVyZSBiZWNhdXNlIGEpIHdlIHdhbnQgaXQgaW4gYSBzZXBhcmF0ZSBwbGFjZSByYXRoZXJcbiAgICAgICAgLy8gdGhhbiBpbiBhIHRvb2x0aXAgYW5kIGIpIHdlIHdhbnQgaXQgdG8gZGlzcGxheSBmZWVkYmFjayBiYXNlZCBvbiB0aGUgdXBsb2FkZWQgZmlsZVxuICAgICAgICAvLyBhcyB3ZWxsIGFzIHRoZSB0ZXh0IGJveC4gSWRlYWxseSB3ZSB3b3VsZCByZWZhY3RvciBGaWVsZCdzIHZhbGlkYXRpb24gbG9naWMgc28gd2UgY291bGRcbiAgICAgICAgLy8gcmUtdXNlIHNvbWUgb2YgaXQuXG4gICAgICAgIHRoaXMudmFsaWRhdGVSZWNvdmVyeUtleU9uQ2hhbmdlKCk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25SZWNvdmVyeUtleUZpbGVDaGFuZ2UgPSBhc3luYyAoZXY6IENoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgICAgIGlmIChldi50YXJnZXQuZmlsZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgZiA9IGV2LnRhcmdldC5maWxlc1swXTtcblxuICAgICAgICBpZiAoZi5zaXplID4gS0VZX0ZJTEVfTUFYX1NJWkUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHJlY292ZXJ5S2V5RmlsZUVycm9yOiB0cnVlLFxuICAgICAgICAgICAgICAgIHJlY292ZXJ5S2V5Q29ycmVjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmVjb3ZlcnlLZXlWYWxpZDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRzID0gYXdhaXQgZi50ZXh0KCk7XG4gICAgICAgICAgICAvLyB0ZXN0IGl0J3Mgd2l0aGluIHRoZSBiYXNlNTggYWxwaGFiZXQuIFdlIGNvdWxkIGJlIG1vcmUgc3RyaWN0IGhlcmUsIGVnLiByZXF1aXJlIHRoZVxuICAgICAgICAgICAgLy8gcmlnaHQgbnVtYmVyIG9mIGNoYXJhY3RlcnMsIGJ1dCBpdCdzIHJlYWxseSBqdXN0IHRvIG1ha2Ugc3VyZSB0aGF0IHdoYXQgd2UncmUgcmVhZGluZyBpc1xuICAgICAgICAgICAgLy8gdGV4dCBiZWNhdXNlIHdlJ2xsIHB1dCBpdCBpbiB0aGUgdGV4dCBmaWVsZC5cbiAgICAgICAgICAgIGlmICgvXlsxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6XFxzXSskLy50ZXN0KGNvbnRlbnRzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICByZWNvdmVyeUtleUZpbGVFcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmVjb3ZlcnlLZXk6IGNvbnRlbnRzLnRyaW0oKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlUmVjb3ZlcnlLZXkoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHJlY292ZXJ5S2V5RmlsZUVycm9yOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICByZWNvdmVyeUtleUNvcnJlY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByZWNvdmVyeUtleVZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcmVjb3ZlcnlLZXk6ICcnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25SZWNvdmVyeUtleUZpbGVVcGxvYWRDbGljayA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5maWxlVXBsb2FkLmN1cnJlbnQuY2xpY2soKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvblBhc3NQaHJhc2VOZXh0ID0gYXN5bmMgKGV2OiBGb3JtRXZlbnQ8SFRNTEZvcm1FbGVtZW50PikgPT4ge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnBhc3NQaHJhc2UubGVuZ3RoIDw9IDApIHJldHVybjtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHsga2V5TWF0Y2hlczogbnVsbCB9KTtcbiAgICAgICAgY29uc3QgaW5wdXQgPSB7IHBhc3NwaHJhc2U6IHRoaXMuc3RhdGUucGFzc1BocmFzZSB9O1xuICAgICAgICBjb25zdCBrZXlNYXRjaGVzID0gYXdhaXQgdGhpcy5wcm9wcy5jaGVja1ByaXZhdGVLZXkoaW5wdXQpO1xuICAgICAgICBpZiAoa2V5TWF0Y2hlcykge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkZpbmlzaGVkKGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBrZXlNYXRjaGVzIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25SZWNvdmVyeUtleU5leHQgPSBhc3luYyAoZXY6IEZvcm1FdmVudDxIVE1MRm9ybUVsZW1lbnQ+KSA9PiB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLnJlY292ZXJ5S2V5VmFsaWQpIHJldHVybjtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHsga2V5TWF0Y2hlczogbnVsbCB9KTtcbiAgICAgICAgY29uc3QgaW5wdXQgPSB7IHJlY292ZXJ5S2V5OiB0aGlzLnN0YXRlLnJlY292ZXJ5S2V5IH07XG4gICAgICAgIGNvbnN0IGtleU1hdGNoZXMgPSBhd2FpdCB0aGlzLnByb3BzLmNoZWNrUHJpdmF0ZUtleShpbnB1dCk7XG4gICAgICAgIGlmIChrZXlNYXRjaGVzKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uRmluaXNoZWQoaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGtleU1hdGNoZXMgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvblBhc3NQaHJhc2VDaGFuZ2UgPSAoZXY6IENoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgcGFzc1BocmFzZTogZXYudGFyZ2V0LnZhbHVlLFxuICAgICAgICAgICAga2V5TWF0Y2hlczogbnVsbCxcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25SZXNldEFsbENsaWNrID0gKGV2OiBSZWFjdC5Nb3VzZUV2ZW50PEhUTUxBbmNob3JFbGVtZW50PikgPT4ge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgcmVzZXR0aW5nOiB0cnVlIH0pO1xuICAgIH07XG5cbiAgICBwcml2YXRlIG9uQ29uZmlybVJlc2V0QWxsQ2xpY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIEhpZGUgb3Vyc2VsdmVzIHNvIHRoZSB1c2VyIGNhbiBpbnRlcmFjdCB3aXRoIHRoZSByZXNldCBkaWFsb2dzLlxuICAgICAgICAvLyBXZSBkb24ndCBjb25jbHVkZSB0aGUgcHJvbWlzZSBjaGFpbiAob25GaW5pc2hlZCkgeWV0IHRvIGF2b2lkIGNvbmZ1c2luZ1xuICAgICAgICAvLyBhbnkgdXBzdHJlYW0gY29kZSBmbG93cy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gTm90ZTogdGhpcyB3aWxsIHVubW91bnQgdXMsIHNvIGRvbid0IGNhbGwgYHNldFN0YXRlYCBvciBhbnl0aGluZyBpbiB0aGVcbiAgICAgICAgLy8gcmVzdCBvZiB0aGlzIGZ1bmN0aW9uLlxuICAgICAgICBNb2RhbC50b2dnbGVDdXJyZW50RGlhbG9nVmlzaWJpbGl0eSgpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBGb3JjZSByZXNldCBzZWNyZXQgc3RvcmFnZSAod2hpY2ggcmVzZXRzIHRoZSBrZXkgYmFja3VwKVxuICAgICAgICAgICAgYXdhaXQgYWNjZXNzU2VjcmV0U3RvcmFnZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gTm93IHJlc2V0IGNyb3NzLXNpZ25pbmcgc28gZXZlcnl0aGluZyBKdXN0IFdvcmtz4oSiIGFnYWluLlxuICAgICAgICAgICAgICAgIGNvbnN0IGNsaSA9IE1hdHJpeENsaWVudFBlZy5nZXQoKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBjbGkuYm9vdHN0cmFwQ3Jvc3NTaWduaW5nKHtcbiAgICAgICAgICAgICAgICAgICAgYXV0aFVwbG9hZERldmljZVNpZ25pbmdLZXlzOiBhc3luYyAobWFrZVJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFhYWDogTWFraW5nIHRoaXMgYW4gaW1wb3J0IGJyZWFrcyB0aGUgYXBwLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgSW50ZXJhY3RpdmVBdXRoRGlhbG9nID0gc2RrLmdldENvbXBvbmVudChcInZpZXdzLmRpYWxvZ3MuSW50ZXJhY3RpdmVBdXRoRGlhbG9nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBmaW5pc2hlZCB9ID0gTW9kYWwuY3JlYXRlVHJhY2tlZERpYWxvZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ3Jvc3Mtc2lnbmluZyBrZXlzIGRpYWxvZycsICcnLCBJbnRlcmFjdGl2ZUF1dGhEaWFsb2csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogX3QoXCJTZXR0aW5nIHVwIGtleXNcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeENsaWVudDogY2xpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWtlUmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtjb25maXJtZWRdID0gYXdhaXQgZmluaXNoZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbmZpcm1lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNyb3NzLXNpZ25pbmcga2V5IHVwbG9hZCBhdXRoIGNhbmNlbGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzZXR1cE5ld0Nyb3NzU2lnbmluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIE5vdyB3ZSBjYW4gaW5kaWNhdGUgdGhhdCB0aGUgdXNlciBpcyBkb25lIHByZXNzaW5nIGJ1dHRvbnMsIGZpbmFsbHkuXG4gICAgICAgICAgICAgICAgLy8gVXBzdHJlYW0gZmxvd3Mgd2lsbCBkZXRlY3QgdGhlIG5ldyBzZWNyZXQgc3RvcmFnZSwga2V5IGJhY2t1cCwgZXRjIGFuZCB1c2UgaXQuXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkZpbmlzaGVkKHRydWUpO1xuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihlKTtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25GaW5pc2hlZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBnZXRLZXlWYWxpZGF0aW9uVGV4dCgpOiBzdHJpbmcge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5yZWNvdmVyeUtleUZpbGVFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIF90KFwiV3JvbmcgZmlsZSB0eXBlXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUucmVjb3ZlcnlLZXlDb3JyZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gX3QoXCJMb29rcyBnb29kIVwiKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLnJlY292ZXJ5S2V5VmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdChcIldyb25nIFNlY3VyaXR5IEtleVwiKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLnJlY292ZXJ5S2V5VmFsaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfdChcIkludmFsaWQgU2VjdXJpdHkgS2V5XCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvLyBDYXV0aW9uOiBNYWtpbmcgdGhlc2UgYW4gaW1wb3J0IHdpbGwgYnJlYWsgdGVzdHMuXG4gICAgICAgIGNvbnN0IEJhc2VEaWFsb2cgPSBzZGsuZ2V0Q29tcG9uZW50KFwidmlld3MuZGlhbG9ncy5CYXNlRGlhbG9nXCIpO1xuICAgICAgICBjb25zdCBEaWFsb2dCdXR0b25zID0gc2RrLmdldENvbXBvbmVudChcInZpZXdzLmVsZW1lbnRzLkRpYWxvZ0J1dHRvbnNcIik7XG5cbiAgICAgICAgY29uc3QgaGFzUGFzc3BocmFzZSA9IChcbiAgICAgICAgICAgIHRoaXMucHJvcHMua2V5SW5mbyAmJlxuICAgICAgICAgICAgdGhpcy5wcm9wcy5rZXlJbmZvLnBhc3NwaHJhc2UgJiZcbiAgICAgICAgICAgIHRoaXMucHJvcHMua2V5SW5mby5wYXNzcGhyYXNlLnNhbHQgJiZcbiAgICAgICAgICAgIHRoaXMucHJvcHMua2V5SW5mby5wYXNzcGhyYXNlLml0ZXJhdGlvbnNcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCByZXNldEJ1dHRvbiA9IChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXhfQWNjZXNzU2VjcmV0U3RvcmFnZURpYWxvZ19yZXNldFwiPlxuICAgICAgICAgICAgICAgIHsgX3QoXCJGb3Jnb3R0ZW4gb3IgbG9zdCBhbGwgcmVjb3ZlcnkgbWV0aG9kcz8gPGE+UmVzZXQgYWxsPC9hPlwiLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgIGE6IChzdWIpID0+IDxhXG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmPVwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMub25SZXNldEFsbENsaWNrfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibXhfQWNjZXNzU2VjcmV0U3RvcmFnZURpYWxvZ19yZXNldF9saW5rXCI+eyBzdWIgfTwvYT4sXG4gICAgICAgICAgICAgICAgfSkgfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG5cbiAgICAgICAgbGV0IGNvbnRlbnQ7XG4gICAgICAgIGxldCB0aXRsZTtcbiAgICAgICAgbGV0IHRpdGxlQ2xhc3M7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnJlc2V0dGluZykge1xuICAgICAgICAgICAgdGl0bGUgPSBfdChcIlJlc2V0IGV2ZXJ5dGhpbmdcIik7XG4gICAgICAgICAgICB0aXRsZUNsYXNzID0gWydteF9BY2Nlc3NTZWNyZXRTdG9yYWdlRGlhbG9nX3RpdGxlV2l0aEljb24gbXhfQWNjZXNzU2VjcmV0U3RvcmFnZURpYWxvZ19yZXNldEJhZGdlJ107XG4gICAgICAgICAgICBjb250ZW50ID0gPGRpdj5cbiAgICAgICAgICAgICAgICA8cD57IF90KFwiT25seSBkbyB0aGlzIGlmIHlvdSBoYXZlIG5vIG90aGVyIGRldmljZSB0byBjb21wbGV0ZSB2ZXJpZmljYXRpb24gd2l0aC5cIikgfTwvcD5cbiAgICAgICAgICAgICAgICA8cD57IF90KFwiSWYgeW91IHJlc2V0IGV2ZXJ5dGhpbmcsIHlvdSB3aWxsIHJlc3RhcnQgd2l0aCBubyB0cnVzdGVkIHNlc3Npb25zLCBubyB0cnVzdGVkIHVzZXJzLCBhbmQgXCJcbiAgICAgICAgICAgICAgICAgICAgKyBcIm1pZ2h0IG5vdCBiZSBhYmxlIHRvIHNlZSBwYXN0IG1lc3NhZ2VzLlwiKSB9PC9wPlxuICAgICAgICAgICAgICAgIDxEaWFsb2dCdXR0b25zXG4gICAgICAgICAgICAgICAgICAgIHByaW1hcnlCdXR0b249e190KCdSZXNldCcpfVxuICAgICAgICAgICAgICAgICAgICBvblByaW1hcnlCdXR0b25DbGljaz17dGhpcy5vbkNvbmZpcm1SZXNldEFsbENsaWNrfVxuICAgICAgICAgICAgICAgICAgICBoYXNDYW5jZWw9e3RydWV9XG4gICAgICAgICAgICAgICAgICAgIG9uQ2FuY2VsPXt0aGlzLm9uQ2FuY2VsfVxuICAgICAgICAgICAgICAgICAgICBmb2N1cz17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgIHByaW1hcnlCdXR0b25DbGFzcz1cImRhbmdlclwiXG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PjtcbiAgICAgICAgfSBlbHNlIGlmIChoYXNQYXNzcGhyYXNlICYmICF0aGlzLnN0YXRlLmZvcmNlUmVjb3ZlcnlLZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IEFjY2Vzc2libGVCdXR0b24gPSBzZGsuZ2V0Q29tcG9uZW50KCdlbGVtZW50cy5BY2Nlc3NpYmxlQnV0dG9uJyk7XG4gICAgICAgICAgICB0aXRsZSA9IF90KFwiU2VjdXJpdHkgUGhyYXNlXCIpO1xuICAgICAgICAgICAgdGl0bGVDbGFzcyA9IFsnbXhfQWNjZXNzU2VjcmV0U3RvcmFnZURpYWxvZ190aXRsZVdpdGhJY29uIG14X0FjY2Vzc1NlY3JldFN0b3JhZ2VEaWFsb2dfc2VjdXJlUGhyYXNlVGl0bGUnXTtcblxuICAgICAgICAgICAgbGV0IGtleVN0YXR1cztcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmtleU1hdGNoZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAga2V5U3RhdHVzID0gPGRpdiBjbGFzc05hbWU9XCJteF9BY2Nlc3NTZWNyZXRTdG9yYWdlRGlhbG9nX2tleVN0YXR1c1wiPlxuICAgICAgICAgICAgICAgICAgICB7IFwiXFx1RDgzRFxcdURDNEUgXCIgfXsgX3QoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlVuYWJsZSB0byBhY2Nlc3Mgc2VjcmV0IHN0b3JhZ2UuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiUGxlYXNlIHZlcmlmeSB0aGF0IHlvdSBlbnRlcmVkIHRoZSBjb3JyZWN0IFNlY3VyaXR5IFBocmFzZS5cIixcbiAgICAgICAgICAgICAgICAgICAgKSB9XG4gICAgICAgICAgICAgICAgPC9kaXY+O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXlTdGF0dXMgPSA8ZGl2IGNsYXNzTmFtZT1cIm14X0FjY2Vzc1NlY3JldFN0b3JhZ2VEaWFsb2dfa2V5U3RhdHVzXCIgLz47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSA8ZGl2PlxuICAgICAgICAgICAgICAgIDxwPnsgX3QoXG4gICAgICAgICAgICAgICAgICAgIFwiRW50ZXIgeW91ciBTZWN1cml0eSBQaHJhc2Ugb3IgPGJ1dHRvbj51c2UgeW91ciBTZWN1cml0eSBLZXk8L2J1dHRvbj4gdG8gY29udGludWUuXCIsIHt9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b246IHMgPT4gPEFjY2Vzc2libGVCdXR0b24gY2xhc3NOYW1lPVwibXhfbGlua0J1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudD1cInNwYW5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMub25Vc2VSZWNvdmVyeUtleUNsaWNrfVxuICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcyB9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L0FjY2Vzc2libGVCdXR0b24+LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICkgfTwvcD5cblxuICAgICAgICAgICAgICAgIDxmb3JtIGNsYXNzTmFtZT1cIm14X0FjY2Vzc1NlY3JldFN0b3JhZ2VEaWFsb2dfcHJpbWFyeUNvbnRhaW5lclwiIG9uU3VibWl0PXt0aGlzLm9uUGFzc1BocmFzZU5leHR9PlxuICAgICAgICAgICAgICAgICAgICA8RmllbGRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkPVwibXhfcGFzc1BocmFzZUlucHV0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIm14X0FjY2Vzc1NlY3JldFN0b3JhZ2VEaWFsb2dfcGFzc1BocmFzZUlucHV0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJwYXNzd29yZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD17X3QoXCJTZWN1cml0eSBQaHJhc2VcIil9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dGhpcy5zdGF0ZS5wYXNzUGhyYXNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25QYXNzUGhyYXNlQ2hhbmdlfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b0ZvY3VzPXt0cnVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b0NvbXBsZXRlPVwibmV3LXBhc3N3b3JkXCJcbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgeyBrZXlTdGF0dXMgfVxuICAgICAgICAgICAgICAgICAgICA8RGlhbG9nQnV0dG9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUJ1dHRvbj17X3QoJ0NvbnRpbnVlJyl9XG4gICAgICAgICAgICAgICAgICAgICAgICBvblByaW1hcnlCdXR0b25DbGljaz17dGhpcy5vblBhc3NQaHJhc2VOZXh0fVxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ2FuY2VsPXt0cnVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DYW5jZWw9e3RoaXMub25DYW5jZWx9XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1cz17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5RGlzYWJsZWQ9e3RoaXMuc3RhdGUucGFzc1BocmFzZS5sZW5ndGggPT09IDB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRpdGl2ZT17cmVzZXRCdXR0b259XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9mb3JtPlxuICAgICAgICAgICAgPC9kaXY+O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGl0bGUgPSBfdChcIlNlY3VyaXR5IEtleVwiKTtcbiAgICAgICAgICAgIHRpdGxlQ2xhc3MgPSBbJ214X0FjY2Vzc1NlY3JldFN0b3JhZ2VEaWFsb2dfdGl0bGVXaXRoSWNvbiBteF9BY2Nlc3NTZWNyZXRTdG9yYWdlRGlhbG9nX3NlY3VyZUJhY2t1cFRpdGxlJ107XG5cbiAgICAgICAgICAgIGNvbnN0IGZlZWRiYWNrQ2xhc3NlcyA9IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgICAgICdteF9BY2Nlc3NTZWNyZXRTdG9yYWdlRGlhbG9nX3JlY292ZXJ5S2V5RmVlZGJhY2snOiB0cnVlLFxuICAgICAgICAgICAgICAgICdteF9BY2Nlc3NTZWNyZXRTdG9yYWdlRGlhbG9nX3JlY292ZXJ5S2V5RmVlZGJhY2tfdmFsaWQnOiB0aGlzLnN0YXRlLnJlY292ZXJ5S2V5Q29ycmVjdCA9PT0gdHJ1ZSxcbiAgICAgICAgICAgICAgICAnbXhfQWNjZXNzU2VjcmV0U3RvcmFnZURpYWxvZ19yZWNvdmVyeUtleUZlZWRiYWNrX2ludmFsaWQnOiB0aGlzLnN0YXRlLnJlY292ZXJ5S2V5Q29ycmVjdCA9PT0gZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlY292ZXJ5S2V5RmVlZGJhY2sgPSA8ZGl2IGNsYXNzTmFtZT17ZmVlZGJhY2tDbGFzc2VzfT5cbiAgICAgICAgICAgICAgICB7IHRoaXMuZ2V0S2V5VmFsaWRhdGlvblRleHQoKSB9XG4gICAgICAgICAgICA8L2Rpdj47XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSA8ZGl2PlxuICAgICAgICAgICAgICAgIDxwPnsgX3QoXCJVc2UgeW91ciBTZWN1cml0eSBLZXkgdG8gY29udGludWUuXCIpIH08L3A+XG5cbiAgICAgICAgICAgICAgICA8Zm9ybVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJteF9BY2Nlc3NTZWNyZXRTdG9yYWdlRGlhbG9nX3ByaW1hcnlDb250YWluZXJcIlxuICAgICAgICAgICAgICAgICAgICBvblN1Ym1pdD17dGhpcy5vblJlY292ZXJ5S2V5TmV4dH1cbiAgICAgICAgICAgICAgICAgICAgc3BlbGxDaGVjaz17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgIGF1dG9Db21wbGV0ZT1cIm9mZlwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm14X0FjY2Vzc1NlY3JldFN0b3JhZ2VEaWFsb2dfcmVjb3ZlcnlLZXlFbnRyeVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJteF9BY2Nlc3NTZWNyZXRTdG9yYWdlRGlhbG9nX3JlY292ZXJ5S2V5RW50cnlfdGV4dElucHV0XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEZpZWxkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJwYXNzd29yZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPXtfdCgnU2VjdXJpdHkgS2V5Jyl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLnJlY292ZXJ5S2V5fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5vblJlY292ZXJ5S2V5Q2hhbmdlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZVZhbGlkaXR5PXt0aGlzLnN0YXRlLnJlY292ZXJ5S2V5Q29ycmVjdH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b0NvbXBsZXRlPVwib2ZmXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJteF9BY2Nlc3NTZWNyZXRTdG9yYWdlRGlhbG9nX3JlY292ZXJ5S2V5RW50cnlfZW50cnlDb250cm9sU2VwYXJhdG9yVGV4dFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgX3QoXCJvclwiKSB9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiZmlsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIm14X0FjY2Vzc1NlY3JldFN0b3JhZ2VEaWFsb2dfcmVjb3ZlcnlLZXlFbnRyeV9maWxlSW5wdXRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWY9e3RoaXMuZmlsZVVwbG9hZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25SZWNvdmVyeUtleUZpbGVDaGFuZ2V9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QWNjZXNzaWJsZUJ1dHRvbiBraW5kPVwicHJpbWFyeVwiIG9uQ2xpY2s9e3RoaXMub25SZWNvdmVyeUtleUZpbGVVcGxvYWRDbGlja30+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgX3QoXCJVcGxvYWRcIikgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvQWNjZXNzaWJsZUJ1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgeyByZWNvdmVyeUtleUZlZWRiYWNrIH1cbiAgICAgICAgICAgICAgICAgICAgPERpYWxvZ0J1dHRvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlCdXR0b249e190KCdDb250aW51ZScpfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25QcmltYXJ5QnV0dG9uQ2xpY2s9e3RoaXMub25SZWNvdmVyeUtleU5leHR9XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDYW5jZWw9e3RydWV9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxCdXR0b249e190KFwiR28gQmFja1wiKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbEJ1dHRvbkNsYXNzPSdkYW5nZXInXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNhbmNlbD17dGhpcy5vbkNhbmNlbH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzPXtmYWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlEaXNhYmxlZD17IXRoaXMuc3RhdGUucmVjb3ZlcnlLZXlWYWxpZH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZGl0aXZlPXtyZXNldEJ1dHRvbn1cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8L2Zvcm0+XG4gICAgICAgICAgICA8L2Rpdj47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPEJhc2VEaWFsb2cgY2xhc3NOYW1lPSdteF9BY2Nlc3NTZWNyZXRTdG9yYWdlRGlhbG9nJ1xuICAgICAgICAgICAgICAgIG9uRmluaXNoZWQ9e3RoaXMucHJvcHMub25GaW5pc2hlZH1cbiAgICAgICAgICAgICAgICB0aXRsZT17dGl0bGV9XG4gICAgICAgICAgICAgICAgdGl0bGVDbGFzcz17dGl0bGVDbGFzc31cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICB7IGNvbnRlbnQgfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9CYXNlRGlhbG9nPlxuICAgICAgICApO1xuICAgIH1cbn1cbiJdfQ==