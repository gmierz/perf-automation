"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _Spinner = _interopRequireDefault(require("../elements/Spinner"));

var _MatrixClientPeg = require("../../../MatrixClientPeg");

var _PushRules = require("matrix-js-sdk/src/@types/PushRules");

var _notifications = require("../../../notifications");

var _languageHandler = require("../../../languageHandler");

var _threepids = require("matrix-js-sdk/src/@types/threepids");

var _LabelledToggleSwitch = _interopRequireDefault(require("../elements/LabelledToggleSwitch"));

var _SettingsStore = _interopRequireDefault(require("../../../settings/SettingsStore"));

var _StyledRadioButton = _interopRequireDefault(require("../elements/StyledRadioButton"));

var _SettingLevel = require("../../../settings/SettingLevel");

var _Modal = _interopRequireDefault(require("../../../Modal"));

var _ErrorDialog = _interopRequireDefault(require("../dialogs/ErrorDialog"));

var _SdkConfig = _interopRequireDefault(require("../../../SdkConfig"));

var _AccessibleButton = _interopRequireDefault(require("../elements/AccessibleButton"));

var _TagComposer = _interopRequireDefault(require("../elements/TagComposer"));

var _objects = require("../../../utils/objects");

var _arrays = require("../../../utils/arrays");

var _logger = require("matrix-js-sdk/src/logger");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// TODO: this "view" component still has far too much application logic in it,
// which should be factored out to other files.
var Phase;

(function (Phase) {
  Phase["Loading"] = "loading";
  Phase["Ready"] = "ready";
  Phase["Persisting"] = "persisting";
  Phase["Error"] = "error";
})(Phase || (Phase = {}));

var RuleClass;

(function (RuleClass) {
  RuleClass["Master"] = "master";
  RuleClass["VectorGlobal"] = "vector_global";
  RuleClass["VectorMentions"] = "vector_mentions";
  RuleClass["VectorOther"] = "vector_other";
  RuleClass["Other"] = "other";
})(RuleClass || (RuleClass = {}));

const KEYWORD_RULE_ID = "_keywords"; // used as a placeholder "Rule ID" throughout this component

const KEYWORD_RULE_CATEGORY = RuleClass.VectorMentions; // This array doesn't care about categories: it's just used for a simple sort

const RULE_DISPLAY_ORDER = [// Global
_PushRules.RuleId.DM, _PushRules.RuleId.EncryptedDM, _PushRules.RuleId.Message, _PushRules.RuleId.EncryptedMessage, // Mentions
_PushRules.RuleId.ContainsDisplayName, _PushRules.RuleId.ContainsUserName, _PushRules.RuleId.AtRoomNotification, // Other
_PushRules.RuleId.InviteToSelf, _PushRules.RuleId.IncomingCall, _PushRules.RuleId.SuppressNotices, _PushRules.RuleId.Tombstone];

class Notifications extends _react.default.PureComponent {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "onMasterRuleChanged", async checked => {
      this.setState({
        phase: Phase.Persisting
      });

      try {
        const masterRule = this.state.masterPushRule;
        await _MatrixClientPeg.MatrixClientPeg.get().setPushRuleEnabled('global', masterRule.kind, masterRule.rule_id, !checked);
        await this.refreshFromServer();
      } catch (e) {
        this.setState({
          phase: Phase.Error
        });

        _logger.logger.error("Error updating master push rule:", e);

        this.showSaveError();
      }
    });
    (0, _defineProperty2.default)(this, "onEmailNotificationsChanged", async (email, checked) => {
      this.setState({
        phase: Phase.Persisting
      });

      try {
        if (checked) {
          await _MatrixClientPeg.MatrixClientPeg.get().setPusher({
            kind: "email",
            app_id: "m.email",
            pushkey: email,
            app_display_name: "Email Notifications",
            device_display_name: email,
            lang: navigator.language,
            data: {
              brand: _SdkConfig.default.get().brand
            },
            // We always append for email pushers since we don't want to stop other
            // accounts notifying to the same email address
            append: true
          });
        } else {
          const pusher = this.state.pushers.find(p => p.kind === "email" && p.pushkey === email);
          pusher.kind = null; // flag for delete

          await _MatrixClientPeg.MatrixClientPeg.get().setPusher(pusher);
        }

        await this.refreshFromServer();
      } catch (e) {
        this.setState({
          phase: Phase.Error
        });

        _logger.logger.error("Error updating email pusher:", e);

        this.showSaveError();
      }
    });
    (0, _defineProperty2.default)(this, "onDesktopNotificationsChanged", async checked => {
      await _SettingsStore.default.setValue("notificationsEnabled", null, _SettingLevel.SettingLevel.DEVICE, checked);
      this.forceUpdate(); // the toggle is controlled by SettingsStore#getValue()
    });
    (0, _defineProperty2.default)(this, "onDesktopShowBodyChanged", async checked => {
      await _SettingsStore.default.setValue("notificationBodyEnabled", null, _SettingLevel.SettingLevel.DEVICE, checked);
      this.forceUpdate(); // the toggle is controlled by SettingsStore#getValue()
    });
    (0, _defineProperty2.default)(this, "onAudioNotificationsChanged", async checked => {
      await _SettingsStore.default.setValue("audioNotificationsEnabled", null, _SettingLevel.SettingLevel.DEVICE, checked);
      this.forceUpdate(); // the toggle is controlled by SettingsStore#getValue()
    });
    (0, _defineProperty2.default)(this, "onRadioChecked", async (rule, checkedState) => {
      this.setState({
        phase: Phase.Persisting
      });

      try {
        const cli = _MatrixClientPeg.MatrixClientPeg.get();

        if (rule.ruleId === KEYWORD_RULE_ID) {
          // Update all the keywords
          for (const rule of this.state.vectorKeywordRuleInfo.rules) {
            let enabled;
            let actions;

            if (checkedState === _notifications.VectorState.On) {
              if (rule.actions.length !== 1) {
                // XXX: Magic number
                actions = _notifications.PushRuleVectorState.actionsFor(checkedState);
              }

              if (this.state.vectorKeywordRuleInfo.vectorState === _notifications.VectorState.Off) {
                enabled = true;
              }
            } else if (checkedState === _notifications.VectorState.Loud) {
              if (rule.actions.length !== 3) {
                // XXX: Magic number
                actions = _notifications.PushRuleVectorState.actionsFor(checkedState);
              }

              if (this.state.vectorKeywordRuleInfo.vectorState === _notifications.VectorState.Off) {
                enabled = true;
              }
            } else {
              enabled = false;
            }

            if (actions) {
              await cli.setPushRuleActions('global', rule.kind, rule.rule_id, actions);
            }

            if (enabled !== undefined) {
              await cli.setPushRuleEnabled('global', rule.kind, rule.rule_id, enabled);
            }
          }
        } else {
          const definition = _notifications.VectorPushRulesDefinitions[rule.ruleId];
          const actions = definition.vectorStateToActions[checkedState];

          if (!actions) {
            await cli.setPushRuleEnabled('global', rule.rule.kind, rule.rule.rule_id, false);
          } else {
            await cli.setPushRuleActions('global', rule.rule.kind, rule.rule.rule_id, actions);
            await cli.setPushRuleEnabled('global', rule.rule.kind, rule.rule.rule_id, true);
          }
        }

        await this.refreshFromServer();
      } catch (e) {
        this.setState({
          phase: Phase.Error
        });

        _logger.logger.error("Error updating push rule:", e);

        this.showSaveError();
      }
    });
    (0, _defineProperty2.default)(this, "onClearNotificationsClicked", () => {
      _MatrixClientPeg.MatrixClientPeg.get().getRooms().forEach(r => {
        if (r.getUnreadNotificationCount() > 0) {
          const events = r.getLiveTimeline().getEvents();

          if (events.length) {
            // noinspection JSIgnoredPromiseFromCall
            _MatrixClientPeg.MatrixClientPeg.get().sendReadReceipt(events[events.length - 1]);
          }
        }
      });
    });
    (0, _defineProperty2.default)(this, "onKeywordAdd", keyword => {
      const originalRules = (0, _objects.objectClone)(this.state.vectorKeywordRuleInfo.rules); // We add the keyword immediately as a sort of local echo effect

      this.setState({
        phase: Phase.Persisting,
        vectorKeywordRuleInfo: _objectSpread(_objectSpread({}, this.state.vectorKeywordRuleInfo), {}, {
          rules: [...this.state.vectorKeywordRuleInfo.rules, // XXX: Horrible assumption that we don't need the remaining fields
          {
            pattern: keyword
          }]
        })
      }, async () => {
        await this.setKeywords(this.state.vectorKeywordRuleInfo.rules.map(r => r.pattern), originalRules);
      });
    });
    (0, _defineProperty2.default)(this, "onKeywordRemove", keyword => {
      const originalRules = (0, _objects.objectClone)(this.state.vectorKeywordRuleInfo.rules); // We remove the keyword immediately as a sort of local echo effect

      this.setState({
        phase: Phase.Persisting,
        vectorKeywordRuleInfo: _objectSpread(_objectSpread({}, this.state.vectorKeywordRuleInfo), {}, {
          rules: this.state.vectorKeywordRuleInfo.rules.filter(r => r.pattern !== keyword)
        })
      }, async () => {
        await this.setKeywords(this.state.vectorKeywordRuleInfo.rules.map(r => r.pattern), originalRules);
      });
    });
    this.state = {
      phase: Phase.Loading
    };
  }

  get isInhibited() {
    var _this$state$masterPus;

    // Caution: The master rule's enabled state is inverted from expectation. When
    // the master rule is *enabled* it means all other rules are *disabled* (or
    // inhibited). Conversely, when the master rule is *disabled* then all other rules
    // are *enabled* (or operate fine).
    return (_this$state$masterPus = this.state.masterPushRule) === null || _this$state$masterPus === void 0 ? void 0 : _this$state$masterPus.enabled;
  }

  componentDidMount() {
    // noinspection JSIgnoredPromiseFromCall
    this.refreshFromServer();
  }

  async refreshFromServer() {
    try {
      const newState = (await Promise.all([this.refreshRules(), this.refreshPushers(), this.refreshThreepids()])).reduce((p, c) => Object.assign(c, p), {});
      this.setState(_objectSpread(_objectSpread({}, newState), {}, {
        phase: Phase.Ready
      }));
    } catch (e) {
      _logger.logger.error("Error setting up notifications for settings: ", e);

      this.setState({
        phase: Phase.Error
      });
    }
  }

  async refreshRules() {
    const ruleSets = await _MatrixClientPeg.MatrixClientPeg.get().getPushRules();
    const categories = {
      [_PushRules.RuleId.Master]: RuleClass.Master,
      [_PushRules.RuleId.DM]: RuleClass.VectorGlobal,
      [_PushRules.RuleId.EncryptedDM]: RuleClass.VectorGlobal,
      [_PushRules.RuleId.Message]: RuleClass.VectorGlobal,
      [_PushRules.RuleId.EncryptedMessage]: RuleClass.VectorGlobal,
      [_PushRules.RuleId.ContainsDisplayName]: RuleClass.VectorMentions,
      [_PushRules.RuleId.ContainsUserName]: RuleClass.VectorMentions,
      [_PushRules.RuleId.AtRoomNotification]: RuleClass.VectorMentions,
      [_PushRules.RuleId.InviteToSelf]: RuleClass.VectorOther,
      [_PushRules.RuleId.IncomingCall]: RuleClass.VectorOther,
      [_PushRules.RuleId.SuppressNotices]: RuleClass.VectorOther,
      [_PushRules.RuleId.Tombstone]: RuleClass.VectorOther // Everything maps to a generic "other" (unknown rule)

    };
    const defaultRules = {
      [RuleClass.Master]: [],
      [RuleClass.VectorGlobal]: [],
      [RuleClass.VectorMentions]: [],
      [RuleClass.VectorOther]: [],
      [RuleClass.Other]: []
    };

    for (const k in ruleSets.global) {
      // noinspection JSUnfilteredForInLoop
      const kind = k;

      for (const r of ruleSets.global[kind]) {
        const rule = Object.assign(r, {
          kind
        });
        const category = categories[rule.rule_id] ?? RuleClass.Other;

        if (rule.rule_id[0] === '.') {
          defaultRules[category].push(rule);
        }
      }
    }

    const preparedNewState = {};

    if (defaultRules.master.length > 0) {
      preparedNewState.masterPushRule = defaultRules.master[0];
    } else {
      // XXX: Can this even happen? How do we safely recover?
      throw new Error("Failed to locate a master push rule");
    } // Parse keyword rules


    preparedNewState.vectorKeywordRuleInfo = _notifications.ContentRules.parseContentRules(ruleSets); // Prepare rendering for all of our known rules

    preparedNewState.vectorPushRules = {};
    const vectorCategories = [RuleClass.VectorGlobal, RuleClass.VectorMentions, RuleClass.VectorOther];

    for (const category of vectorCategories) {
      preparedNewState.vectorPushRules[category] = [];

      for (const rule of defaultRules[category]) {
        const definition = _notifications.VectorPushRulesDefinitions[rule.rule_id];
        const vectorState = definition.ruleToVectorState(rule);
        preparedNewState.vectorPushRules[category].push({
          ruleId: rule.rule_id,
          rule,
          vectorState,
          description: (0, _languageHandler._t)(definition.description)
        });
      } // Quickly sort the rules for display purposes


      preparedNewState.vectorPushRules[category].sort((a, b) => {
        let idxA = RULE_DISPLAY_ORDER.indexOf(a.ruleId);
        let idxB = RULE_DISPLAY_ORDER.indexOf(b.ruleId); // Assume unknown things go at the end

        if (idxA < 0) idxA = RULE_DISPLAY_ORDER.length;
        if (idxB < 0) idxB = RULE_DISPLAY_ORDER.length;
        return idxA - idxB;
      });

      if (category === KEYWORD_RULE_CATEGORY) {
        preparedNewState.vectorPushRules[category].push({
          ruleId: KEYWORD_RULE_ID,
          description: (0, _languageHandler._t)("Messages containing keywords"),
          vectorState: preparedNewState.vectorKeywordRuleInfo.vectorState
        });
      }
    }

    return preparedNewState;
  }

  refreshPushers() {
    return _MatrixClientPeg.MatrixClientPeg.get().getPushers();
  }

  refreshThreepids() {
    return _MatrixClientPeg.MatrixClientPeg.get().getThreePids();
  }

  showSaveError() {
    _Modal.default.createTrackedDialog('Error saving notification preferences', '', _ErrorDialog.default, {
      title: (0, _languageHandler._t)('Error saving notification preferences'),
      description: (0, _languageHandler._t)('An error occurred whilst saving your notification preferences.')
    });
  }

  async setKeywords(keywords, originalRules) {
    try {
      // De-duplicate and remove empties
      keywords = Array.from(new Set(keywords)).filter(k => !!k);
      const oldKeywords = Array.from(new Set(originalRules.map(r => r.pattern))).filter(k => !!k); // Note: Technically because of the UI interaction (at the time of writing), the diff
      // will only ever be +/-1 so we don't really have to worry about efficiently handling
      // tons of keyword changes.

      const diff = (0, _arrays.arrayDiff)(oldKeywords, keywords);

      for (const word of diff.removed) {
        for (const rule of originalRules.filter(r => r.pattern === word)) {
          await _MatrixClientPeg.MatrixClientPeg.get().deletePushRule('global', rule.kind, rule.rule_id);
        }
      }

      let ruleVectorState = this.state.vectorKeywordRuleInfo.vectorState;

      if (ruleVectorState === _notifications.VectorState.Off) {
        // When the current global keywords rule is OFF, we need to look at
        // the flavor of existing rules to apply the same actions
        // when creating the new rule.
        if (originalRules.length) {
          ruleVectorState = _notifications.PushRuleVectorState.contentRuleVectorStateKind(originalRules[0]);
        } else {
          ruleVectorState = _notifications.VectorState.On; // default
        }
      }

      const kind = _PushRules.PushRuleKind.ContentSpecific;

      for (const word of diff.added) {
        await _MatrixClientPeg.MatrixClientPeg.get().addPushRule('global', kind, word, {
          actions: _notifications.PushRuleVectorState.actionsFor(ruleVectorState),
          pattern: word
        });

        if (ruleVectorState === _notifications.VectorState.Off) {
          await _MatrixClientPeg.MatrixClientPeg.get().setPushRuleEnabled('global', kind, word, false);
        }
      }

      await this.refreshFromServer();
    } catch (e) {
      this.setState({
        phase: Phase.Error
      });

      _logger.logger.error("Error updating keyword push rules:", e);

      this.showSaveError();
    }
  }

  renderTopSection() {
    const masterSwitch = /*#__PURE__*/_react.default.createElement(_LabelledToggleSwitch.default, {
      value: !this.isInhibited,
      label: (0, _languageHandler._t)("Enable for this account"),
      onChange: this.onMasterRuleChanged,
      disabled: this.state.phase === Phase.Persisting
    }); // If all the rules are inhibited, don't show anything.


    if (this.isInhibited) {
      return masterSwitch;
    }

    const emailSwitches = (this.state.threepids || []).filter(t => t.medium === _threepids.ThreepidMedium.Email).map(e => /*#__PURE__*/_react.default.createElement(_LabelledToggleSwitch.default, {
      key: e.address,
      value: this.state.pushers.some(p => p.kind === "email" && p.pushkey === e.address),
      label: (0, _languageHandler._t)("Enable email notifications for %(email)s", {
        email: e.address
      }),
      onChange: this.onEmailNotificationsChanged.bind(this, e.address),
      disabled: this.state.phase === Phase.Persisting
    }));
    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, masterSwitch, /*#__PURE__*/_react.default.createElement(_LabelledToggleSwitch.default, {
      value: _SettingsStore.default.getValue("notificationsEnabled"),
      onChange: this.onDesktopNotificationsChanged,
      label: (0, _languageHandler._t)('Enable desktop notifications for this session'),
      disabled: this.state.phase === Phase.Persisting
    }), /*#__PURE__*/_react.default.createElement(_LabelledToggleSwitch.default, {
      value: _SettingsStore.default.getValue("notificationBodyEnabled"),
      onChange: this.onDesktopShowBodyChanged,
      label: (0, _languageHandler._t)('Show message in desktop notification'),
      disabled: this.state.phase === Phase.Persisting
    }), /*#__PURE__*/_react.default.createElement(_LabelledToggleSwitch.default, {
      value: _SettingsStore.default.getValue("audioNotificationsEnabled"),
      onChange: this.onAudioNotificationsChanged,
      label: (0, _languageHandler._t)('Enable audible notifications for this session'),
      disabled: this.state.phase === Phase.Persisting
    }), emailSwitches);
  }

  renderCategory(category) {
    if (category !== RuleClass.VectorOther && this.isInhibited) {
      return null; // nothing to show for the section
    }

    let clearNotifsButton;

    if (category === RuleClass.VectorOther && _MatrixClientPeg.MatrixClientPeg.get().getRooms().some(r => r.getUnreadNotificationCount() > 0)) {
      clearNotifsButton = /*#__PURE__*/_react.default.createElement(_AccessibleButton.default, {
        onClick: this.onClearNotificationsClicked,
        kind: "danger",
        className: "mx_UserNotifSettings_clearNotifsButton"
      }, (0, _languageHandler._t)("Clear notifications"));
    }

    if (category === RuleClass.VectorOther && this.isInhibited) {
      // only render the utility buttons (if needed)
      if (clearNotifsButton) {
        return /*#__PURE__*/_react.default.createElement("div", {
          className: "mx_UserNotifSettings_floatingSection"
        }, /*#__PURE__*/_react.default.createElement("div", null, (0, _languageHandler._t)("Other")), clearNotifsButton);
      }

      return null;
    }

    let keywordComposer;

    if (category === RuleClass.VectorMentions) {
      var _this$state$vectorKey;

      keywordComposer = /*#__PURE__*/_react.default.createElement(_TagComposer.default, {
        tags: (_this$state$vectorKey = this.state.vectorKeywordRuleInfo) === null || _this$state$vectorKey === void 0 ? void 0 : _this$state$vectorKey.rules.map(r => r.pattern),
        onAdd: this.onKeywordAdd,
        onRemove: this.onKeywordRemove,
        disabled: this.state.phase === Phase.Persisting,
        label: (0, _languageHandler._t)("Keyword"),
        placeholder: (0, _languageHandler._t)("New keyword")
      });
    }

    const makeRadio = (r, s) => /*#__PURE__*/_react.default.createElement(_StyledRadioButton.default, {
      key: r.ruleId,
      name: r.ruleId,
      checked: r.vectorState === s,
      onChange: this.onRadioChecked.bind(this, r, s),
      disabled: this.state.phase === Phase.Persisting
    });

    const rows = this.state.vectorPushRules[category].map(r => /*#__PURE__*/_react.default.createElement("tr", {
      key: category + r.ruleId
    }, /*#__PURE__*/_react.default.createElement("td", null, r.description), /*#__PURE__*/_react.default.createElement("td", null, makeRadio(r, _notifications.VectorState.Off)), /*#__PURE__*/_react.default.createElement("td", null, makeRadio(r, _notifications.VectorState.On)), /*#__PURE__*/_react.default.createElement("td", null, makeRadio(r, _notifications.VectorState.Loud))));
    let sectionName;

    switch (category) {
      case RuleClass.VectorGlobal:
        sectionName = (0, _languageHandler._t)("Global");
        break;

      case RuleClass.VectorMentions:
        sectionName = (0, _languageHandler._t)("Mentions & keywords");
        break;

      case RuleClass.VectorOther:
        sectionName = (0, _languageHandler._t)("Other");
        break;

      default:
        throw new Error("Developer error: Unnamed notifications section: " + category);
    }

    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement("table", {
      className: "mx_UserNotifSettings_pushRulesTable"
    }, /*#__PURE__*/_react.default.createElement("thead", null, /*#__PURE__*/_react.default.createElement("tr", null, /*#__PURE__*/_react.default.createElement("th", null, sectionName), /*#__PURE__*/_react.default.createElement("th", null, (0, _languageHandler._t)("Off")), /*#__PURE__*/_react.default.createElement("th", null, (0, _languageHandler._t)("On")), /*#__PURE__*/_react.default.createElement("th", null, (0, _languageHandler._t)("Noisy")))), /*#__PURE__*/_react.default.createElement("tbody", null, rows)), clearNotifsButton, keywordComposer);
  }

  renderTargets() {
    if (this.isInhibited) return null; // no targets if there's no notifications

    const rows = this.state.pushers.map(p => /*#__PURE__*/_react.default.createElement("tr", {
      key: p.kind + p.pushkey
    }, /*#__PURE__*/_react.default.createElement("td", null, p.app_display_name), /*#__PURE__*/_react.default.createElement("td", null, p.device_display_name)));
    if (!rows.length) return null; // no targets to show

    return /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_UserNotifSettings_floatingSection"
    }, /*#__PURE__*/_react.default.createElement("div", null, (0, _languageHandler._t)("Notification targets")), /*#__PURE__*/_react.default.createElement("table", null, /*#__PURE__*/_react.default.createElement("tbody", null, rows)));
  }

  render() {
    if (this.state.phase === Phase.Loading) {
      // Ends up default centered
      return /*#__PURE__*/_react.default.createElement(_Spinner.default, null);
    } else if (this.state.phase === Phase.Error) {
      return /*#__PURE__*/_react.default.createElement("p", null, (0, _languageHandler._t)("There was an error loading your notification settings."));
    }

    return /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_UserNotifSettings"
    }, this.renderTopSection(), this.renderCategory(RuleClass.VectorGlobal), this.renderCategory(RuleClass.VectorMentions), this.renderCategory(RuleClass.VectorOther), this.renderTargets());
  }

}

exports.default = Notifications;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL3NldHRpbmdzL05vdGlmaWNhdGlvbnMudHN4Il0sIm5hbWVzIjpbIlBoYXNlIiwiUnVsZUNsYXNzIiwiS0VZV09SRF9SVUxFX0lEIiwiS0VZV09SRF9SVUxFX0NBVEVHT1JZIiwiVmVjdG9yTWVudGlvbnMiLCJSVUxFX0RJU1BMQVlfT1JERVIiLCJSdWxlSWQiLCJETSIsIkVuY3J5cHRlZERNIiwiTWVzc2FnZSIsIkVuY3J5cHRlZE1lc3NhZ2UiLCJDb250YWluc0Rpc3BsYXlOYW1lIiwiQ29udGFpbnNVc2VyTmFtZSIsIkF0Um9vbU5vdGlmaWNhdGlvbiIsIkludml0ZVRvU2VsZiIsIkluY29taW5nQ2FsbCIsIlN1cHByZXNzTm90aWNlcyIsIlRvbWJzdG9uZSIsIk5vdGlmaWNhdGlvbnMiLCJSZWFjdCIsIlB1cmVDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsInByb3BzIiwiY2hlY2tlZCIsInNldFN0YXRlIiwicGhhc2UiLCJQZXJzaXN0aW5nIiwibWFzdGVyUnVsZSIsInN0YXRlIiwibWFzdGVyUHVzaFJ1bGUiLCJNYXRyaXhDbGllbnRQZWciLCJnZXQiLCJzZXRQdXNoUnVsZUVuYWJsZWQiLCJraW5kIiwicnVsZV9pZCIsInJlZnJlc2hGcm9tU2VydmVyIiwiZSIsIkVycm9yIiwibG9nZ2VyIiwiZXJyb3IiLCJzaG93U2F2ZUVycm9yIiwiZW1haWwiLCJzZXRQdXNoZXIiLCJhcHBfaWQiLCJwdXNoa2V5IiwiYXBwX2Rpc3BsYXlfbmFtZSIsImRldmljZV9kaXNwbGF5X25hbWUiLCJsYW5nIiwibmF2aWdhdG9yIiwibGFuZ3VhZ2UiLCJkYXRhIiwiYnJhbmQiLCJTZGtDb25maWciLCJhcHBlbmQiLCJwdXNoZXIiLCJwdXNoZXJzIiwiZmluZCIsInAiLCJTZXR0aW5nc1N0b3JlIiwic2V0VmFsdWUiLCJTZXR0aW5nTGV2ZWwiLCJERVZJQ0UiLCJmb3JjZVVwZGF0ZSIsInJ1bGUiLCJjaGVja2VkU3RhdGUiLCJjbGkiLCJydWxlSWQiLCJ2ZWN0b3JLZXl3b3JkUnVsZUluZm8iLCJydWxlcyIsImVuYWJsZWQiLCJhY3Rpb25zIiwiVmVjdG9yU3RhdGUiLCJPbiIsImxlbmd0aCIsIlB1c2hSdWxlVmVjdG9yU3RhdGUiLCJhY3Rpb25zRm9yIiwidmVjdG9yU3RhdGUiLCJPZmYiLCJMb3VkIiwic2V0UHVzaFJ1bGVBY3Rpb25zIiwidW5kZWZpbmVkIiwiZGVmaW5pdGlvbiIsIlZlY3RvclB1c2hSdWxlc0RlZmluaXRpb25zIiwidmVjdG9yU3RhdGVUb0FjdGlvbnMiLCJnZXRSb29tcyIsImZvckVhY2giLCJyIiwiZ2V0VW5yZWFkTm90aWZpY2F0aW9uQ291bnQiLCJldmVudHMiLCJnZXRMaXZlVGltZWxpbmUiLCJnZXRFdmVudHMiLCJzZW5kUmVhZFJlY2VpcHQiLCJrZXl3b3JkIiwib3JpZ2luYWxSdWxlcyIsInBhdHRlcm4iLCJzZXRLZXl3b3JkcyIsIm1hcCIsImZpbHRlciIsIkxvYWRpbmciLCJpc0luaGliaXRlZCIsImNvbXBvbmVudERpZE1vdW50IiwibmV3U3RhdGUiLCJQcm9taXNlIiwiYWxsIiwicmVmcmVzaFJ1bGVzIiwicmVmcmVzaFB1c2hlcnMiLCJyZWZyZXNoVGhyZWVwaWRzIiwicmVkdWNlIiwiYyIsIk9iamVjdCIsImFzc2lnbiIsIlJlYWR5IiwicnVsZVNldHMiLCJnZXRQdXNoUnVsZXMiLCJjYXRlZ29yaWVzIiwiTWFzdGVyIiwiVmVjdG9yR2xvYmFsIiwiVmVjdG9yT3RoZXIiLCJkZWZhdWx0UnVsZXMiLCJPdGhlciIsImsiLCJnbG9iYWwiLCJjYXRlZ29yeSIsInB1c2giLCJwcmVwYXJlZE5ld1N0YXRlIiwibWFzdGVyIiwiQ29udGVudFJ1bGVzIiwicGFyc2VDb250ZW50UnVsZXMiLCJ2ZWN0b3JQdXNoUnVsZXMiLCJ2ZWN0b3JDYXRlZ29yaWVzIiwicnVsZVRvVmVjdG9yU3RhdGUiLCJkZXNjcmlwdGlvbiIsInNvcnQiLCJhIiwiYiIsImlkeEEiLCJpbmRleE9mIiwiaWR4QiIsImdldFB1c2hlcnMiLCJnZXRUaHJlZVBpZHMiLCJNb2RhbCIsImNyZWF0ZVRyYWNrZWREaWFsb2ciLCJFcnJvckRpYWxvZyIsInRpdGxlIiwia2V5d29yZHMiLCJBcnJheSIsImZyb20iLCJTZXQiLCJvbGRLZXl3b3JkcyIsImRpZmYiLCJ3b3JkIiwicmVtb3ZlZCIsImRlbGV0ZVB1c2hSdWxlIiwicnVsZVZlY3RvclN0YXRlIiwiY29udGVudFJ1bGVWZWN0b3JTdGF0ZUtpbmQiLCJQdXNoUnVsZUtpbmQiLCJDb250ZW50U3BlY2lmaWMiLCJhZGRlZCIsImFkZFB1c2hSdWxlIiwicmVuZGVyVG9wU2VjdGlvbiIsIm1hc3RlclN3aXRjaCIsIm9uTWFzdGVyUnVsZUNoYW5nZWQiLCJlbWFpbFN3aXRjaGVzIiwidGhyZWVwaWRzIiwidCIsIm1lZGl1bSIsIlRocmVlcGlkTWVkaXVtIiwiRW1haWwiLCJhZGRyZXNzIiwic29tZSIsIm9uRW1haWxOb3RpZmljYXRpb25zQ2hhbmdlZCIsImJpbmQiLCJnZXRWYWx1ZSIsIm9uRGVza3RvcE5vdGlmaWNhdGlvbnNDaGFuZ2VkIiwib25EZXNrdG9wU2hvd0JvZHlDaGFuZ2VkIiwib25BdWRpb05vdGlmaWNhdGlvbnNDaGFuZ2VkIiwicmVuZGVyQ2F0ZWdvcnkiLCJjbGVhck5vdGlmc0J1dHRvbiIsIm9uQ2xlYXJOb3RpZmljYXRpb25zQ2xpY2tlZCIsImtleXdvcmRDb21wb3NlciIsIm9uS2V5d29yZEFkZCIsIm9uS2V5d29yZFJlbW92ZSIsIm1ha2VSYWRpbyIsInMiLCJvblJhZGlvQ2hlY2tlZCIsInJvd3MiLCJzZWN0aW9uTmFtZSIsInJlbmRlclRhcmdldHMiLCJyZW5kZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBZ0JBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQU9BOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOzs7Ozs7QUFFQTtBQUNBO0lB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QUtBLFFBQUksQ0FBQzJJLElBQUksQ0FBQ2hILE1BQVYsRUFBa0IsT0FBTyxJQUFQLENBUkUsQ0FRVzs7QUFFL0Isd0JBQU87QUFBSyxNQUFBLFNBQVMsRUFBQztBQUFmLG9CQUNILDBDQUFPLHlCQUFHLHNCQUFILENBQVAsQ0FERyxlQUVILHlEQUNJLDRDQUNNZ0gsSUFETixDQURKLENBRkcsQ0FBUDtBQVFIOztBQUVNRyxFQUFBQSxNQUFNLEdBQUc7QUFDWixRQUFJLEtBQUtoSyxLQUFMLENBQVdILEtBQVgsS0FBcUJ6QixLQUFLLENBQUNrRyxPQUEvQixFQUF3QztBQUNwQztBQUNBLDBCQUFPLDZCQUFDLGdCQUFELE9BQVA7QUFDSCxLQUhELE1BR08sSUFBSSxLQUFLdEUsS0FBTCxDQUFXSCxLQUFYLEtBQXFCekIsS0FBSyxDQUFDcUMsS0FBL0IsRUFBc0M7QUFDekMsMEJBQU8sd0NBQUsseUJBQUcsd0RBQUgsQ0FBTCxDQUFQO0FBQ0g7O0FBRUQsd0JBQU87QUFBSyxNQUFBLFNBQVMsRUFBQztBQUFmLE9BQ0QsS0FBSzBILGdCQUFMLEVBREMsRUFFRCxLQUFLaUIsY0FBTCxDQUFvQi9LLFNBQVMsQ0FBQ21ILFlBQTlCLENBRkMsRUFHRCxLQUFLNEQsY0FBTCxDQUFvQi9LLFNBQVMsQ0FBQ0csY0FBOUIsQ0FIQyxFQUlELEtBQUs0SyxjQUFMLENBQW9CL0ssU0FBUyxDQUFDb0gsV0FBOUIsQ0FKQyxFQUtELEtBQUtzRSxhQUFMLEVBTEMsQ0FBUDtBQU9IOztBQTNoQjBFIiwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE2IC0gMjAyMSBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBTcGlubmVyIGZyb20gXCIuLi9lbGVtZW50cy9TcGlubmVyXCI7XG5pbXBvcnQgeyBNYXRyaXhDbGllbnRQZWcgfSBmcm9tIFwiLi4vLi4vLi4vTWF0cml4Q2xpZW50UGVnXCI7XG5pbXBvcnQgeyBJQW5ub3RhdGVkUHVzaFJ1bGUsIElQdXNoZXIsIFB1c2hSdWxlQWN0aW9uLCBQdXNoUnVsZUtpbmQsIFJ1bGVJZCB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9AdHlwZXMvUHVzaFJ1bGVzXCI7XG5pbXBvcnQge1xuICAgIENvbnRlbnRSdWxlcyxcbiAgICBJQ29udGVudFJ1bGVzLFxuICAgIFB1c2hSdWxlVmVjdG9yU3RhdGUsXG4gICAgVmVjdG9yUHVzaFJ1bGVzRGVmaW5pdGlvbnMsXG4gICAgVmVjdG9yU3RhdGUsXG59IGZyb20gXCIuLi8uLi8uLi9ub3RpZmljYXRpb25zXCI7XG5pbXBvcnQgeyBfdCwgVHJhbnNsYXRlZFN0cmluZyB9IGZyb20gXCIuLi8uLi8uLi9sYW5ndWFnZUhhbmRsZXJcIjtcbmltcG9ydCB7IElUaHJlZXBpZCwgVGhyZWVwaWRNZWRpdW0gfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvQHR5cGVzL3RocmVlcGlkc1wiO1xuaW1wb3J0IExhYmVsbGVkVG9nZ2xlU3dpdGNoIGZyb20gXCIuLi9lbGVtZW50cy9MYWJlbGxlZFRvZ2dsZVN3aXRjaFwiO1xuaW1wb3J0IFNldHRpbmdzU3RvcmUgZnJvbSBcIi4uLy4uLy4uL3NldHRpbmdzL1NldHRpbmdzU3RvcmVcIjtcbmltcG9ydCBTdHlsZWRSYWRpb0J1dHRvbiBmcm9tIFwiLi4vZWxlbWVudHMvU3R5bGVkUmFkaW9CdXR0b25cIjtcbmltcG9ydCB7IFNldHRpbmdMZXZlbCB9IGZyb20gXCIuLi8uLi8uLi9zZXR0aW5ncy9TZXR0aW5nTGV2ZWxcIjtcbmltcG9ydCBNb2RhbCBmcm9tIFwiLi4vLi4vLi4vTW9kYWxcIjtcbmltcG9ydCBFcnJvckRpYWxvZyBmcm9tIFwiLi4vZGlhbG9ncy9FcnJvckRpYWxvZ1wiO1xuaW1wb3J0IFNka0NvbmZpZyBmcm9tIFwiLi4vLi4vLi4vU2RrQ29uZmlnXCI7XG5pbXBvcnQgQWNjZXNzaWJsZUJ1dHRvbiBmcm9tIFwiLi4vZWxlbWVudHMvQWNjZXNzaWJsZUJ1dHRvblwiO1xuaW1wb3J0IFRhZ0NvbXBvc2VyIGZyb20gXCIuLi9lbGVtZW50cy9UYWdDb21wb3NlclwiO1xuaW1wb3J0IHsgb2JqZWN0Q2xvbmUgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvb2JqZWN0c1wiO1xuaW1wb3J0IHsgYXJyYXlEaWZmIH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL2FycmF5c1wiO1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvbG9nZ2VyXCI7XG5cbi8vIFRPRE86IHRoaXMgXCJ2aWV3XCIgY29tcG9uZW50IHN0aWxsIGhhcyBmYXIgdG9vIG11Y2ggYXBwbGljYXRpb24gbG9naWMgaW4gaXQsXG4vLyB3aGljaCBzaG91bGQgYmUgZmFjdG9yZWQgb3V0IHRvIG90aGVyIGZpbGVzLlxuXG5lbnVtIFBoYXNlIHtcbiAgICBMb2FkaW5nID0gXCJsb2FkaW5nXCIsXG4gICAgUmVhZHkgPSBcInJlYWR5XCIsXG4gICAgUGVyc2lzdGluZyA9IFwicGVyc2lzdGluZ1wiLCAvLyB0ZWNobmljYWxseSBhIG1ldGEtc3RhdGUgZm9yIFJlYWR5LCBidXQgd2hhdGV2ZXJcbiAgICBFcnJvciA9IFwiZXJyb3JcIixcbn1cblxuZW51bSBSdWxlQ2xhc3Mge1xuICAgIE1hc3RlciA9IFwibWFzdGVyXCIsXG5cbiAgICAvLyBUaGUgdmVjdG9yIHNlY3Rpb25zIG1hcCBhcHByb3hpbWF0ZWx5IHRvIFVJIHNlY3Rpb25zXG4gICAgVmVjdG9yR2xvYmFsID0gXCJ2ZWN0b3JfZ2xvYmFsXCIsXG4gICAgVmVjdG9yTWVudGlvbnMgPSBcInZlY3Rvcl9tZW50aW9uc1wiLFxuICAgIFZlY3Rvck90aGVyID0gXCJ2ZWN0b3Jfb3RoZXJcIixcbiAgICBPdGhlciA9IFwib3RoZXJcIiwgLy8gdW5rbm93biBydWxlcywgZXNzZW50aWFsbHlcbn1cblxuY29uc3QgS0VZV09SRF9SVUxFX0lEID0gXCJfa2V5d29yZHNcIjsgLy8gdXNlZCBhcyBhIHBsYWNlaG9sZGVyIFwiUnVsZSBJRFwiIHRocm91Z2hvdXQgdGhpcyBjb21wb25lbnRcbmNvbnN0IEtFWVdPUkRfUlVMRV9DQVRFR09SWSA9IFJ1bGVDbGFzcy5WZWN0b3JNZW50aW9ucztcblxuLy8gVGhpcyBhcnJheSBkb2Vzbid0IGNhcmUgYWJvdXQgY2F0ZWdvcmllczogaXQncyBqdXN0IHVzZWQgZm9yIGEgc2ltcGxlIHNvcnRcbmNvbnN0IFJVTEVfRElTUExBWV9PUkRFUjogc3RyaW5nW10gPSBbXG4gICAgLy8gR2xvYmFsXG4gICAgUnVsZUlkLkRNLFxuICAgIFJ1bGVJZC5FbmNyeXB0ZWRETSxcbiAgICBSdWxlSWQuTWVzc2FnZSxcbiAgICBSdWxlSWQuRW5jcnlwdGVkTWVzc2FnZSxcblxuICAgIC8vIE1lbnRpb25zXG4gICAgUnVsZUlkLkNvbnRhaW5zRGlzcGxheU5hbWUsXG4gICAgUnVsZUlkLkNvbnRhaW5zVXNlck5hbWUsXG4gICAgUnVsZUlkLkF0Um9vbU5vdGlmaWNhdGlvbixcblxuICAgIC8vIE90aGVyXG4gICAgUnVsZUlkLkludml0ZVRvU2VsZixcbiAgICBSdWxlSWQuSW5jb21pbmdDYWxsLFxuICAgIFJ1bGVJZC5TdXBwcmVzc05vdGljZXMsXG4gICAgUnVsZUlkLlRvbWJzdG9uZSxcbl07XG5cbmludGVyZmFjZSBJVmVjdG9yUHVzaFJ1bGUge1xuICAgIHJ1bGVJZDogUnVsZUlkIHwgdHlwZW9mIEtFWVdPUkRfUlVMRV9JRCB8IHN0cmluZztcbiAgICBydWxlPzogSUFubm90YXRlZFB1c2hSdWxlO1xuICAgIGRlc2NyaXB0aW9uOiBUcmFuc2xhdGVkU3RyaW5nIHwgc3RyaW5nO1xuICAgIHZlY3RvclN0YXRlOiBWZWN0b3JTdGF0ZTtcbn1cblxuaW50ZXJmYWNlIElQcm9wcyB7fVxuXG5pbnRlcmZhY2UgSVN0YXRlIHtcbiAgICBwaGFzZTogUGhhc2U7XG5cbiAgICAvLyBPcHRpb25hbCBzdHVmZiBpcyByZXF1aXJlZCB3aGVuIGBwaGFzZSA9PT0gUmVhZHlgXG4gICAgbWFzdGVyUHVzaFJ1bGU/OiBJQW5ub3RhdGVkUHVzaFJ1bGU7XG4gICAgdmVjdG9yS2V5d29yZFJ1bGVJbmZvPzogSUNvbnRlbnRSdWxlcztcbiAgICB2ZWN0b3JQdXNoUnVsZXM/OiB7XG4gICAgICAgIFtjYXRlZ29yeSBpbiBSdWxlQ2xhc3NdPzogSVZlY3RvclB1c2hSdWxlW107XG4gICAgfTtcbiAgICBwdXNoZXJzPzogSVB1c2hlcltdO1xuICAgIHRocmVlcGlkcz86IElUaHJlZXBpZFtdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb3RpZmljYXRpb25zIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxJUHJvcHMsIElTdGF0ZT4ge1xuICAgIHB1YmxpYyBjb25zdHJ1Y3Rvcihwcm9wczogSVByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcGhhc2U6IFBoYXNlLkxvYWRpbmcsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXQgaXNJbmhpYml0ZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIC8vIENhdXRpb246IFRoZSBtYXN0ZXIgcnVsZSdzIGVuYWJsZWQgc3RhdGUgaXMgaW52ZXJ0ZWQgZnJvbSBleHBlY3RhdGlvbi4gV2hlblxuICAgICAgICAvLyB0aGUgbWFzdGVyIHJ1bGUgaXMgKmVuYWJsZWQqIGl0IG1lYW5zIGFsbCBvdGhlciBydWxlcyBhcmUgKmRpc2FibGVkKiAob3JcbiAgICAgICAgLy8gaW5oaWJpdGVkKS4gQ29udmVyc2VseSwgd2hlbiB0aGUgbWFzdGVyIHJ1bGUgaXMgKmRpc2FibGVkKiB0aGVuIGFsbCBvdGhlciBydWxlc1xuICAgICAgICAvLyBhcmUgKmVuYWJsZWQqIChvciBvcGVyYXRlIGZpbmUpLlxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5tYXN0ZXJQdXNoUnVsZT8uZW5hYmxlZDtcbiAgICB9XG5cbiAgICBwdWJsaWMgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIC8vIG5vaW5zcGVjdGlvbiBKU0lnbm9yZWRQcm9taXNlRnJvbUNhbGxcbiAgICAgICAgdGhpcy5yZWZyZXNoRnJvbVNlcnZlcigpO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgcmVmcmVzaEZyb21TZXJ2ZXIoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IChhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoUnVsZXMoKSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hQdXNoZXJzKCksXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoVGhyZWVwaWRzKCksXG4gICAgICAgICAgICBdKSkucmVkdWNlKChwLCBjKSA9PiBPYmplY3QuYXNzaWduKGMsIHApLCB7fSk7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLFxuICAgICAgICAgICAgICAgIHBoYXNlOiBQaGFzZS5SZWFkeSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJFcnJvciBzZXR0aW5nIHVwIG5vdGlmaWNhdGlvbnMgZm9yIHNldHRpbmdzOiBcIiwgZSk7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgcGhhc2U6IFBoYXNlLkVycm9yIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyByZWZyZXNoUnVsZXMoKTogUHJvbWlzZTxQYXJ0aWFsPElTdGF0ZT4+IHtcbiAgICAgICAgY29uc3QgcnVsZVNldHMgPSBhd2FpdCBNYXRyaXhDbGllbnRQZWcuZ2V0KCkuZ2V0UHVzaFJ1bGVzKCk7XG5cbiAgICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IHtcbiAgICAgICAgICAgIFtSdWxlSWQuTWFzdGVyXTogUnVsZUNsYXNzLk1hc3RlcixcblxuICAgICAgICAgICAgW1J1bGVJZC5ETV06IFJ1bGVDbGFzcy5WZWN0b3JHbG9iYWwsXG4gICAgICAgICAgICBbUnVsZUlkLkVuY3J5cHRlZERNXTogUnVsZUNsYXNzLlZlY3Rvckdsb2JhbCxcbiAgICAgICAgICAgIFtSdWxlSWQuTWVzc2FnZV06IFJ1bGVDbGFzcy5WZWN0b3JHbG9iYWwsXG4gICAgICAgICAgICBbUnVsZUlkLkVuY3J5cHRlZE1lc3NhZ2VdOiBSdWxlQ2xhc3MuVmVjdG9yR2xvYmFsLFxuXG4gICAgICAgICAgICBbUnVsZUlkLkNvbnRhaW5zRGlzcGxheU5hbWVdOiBSdWxlQ2xhc3MuVmVjdG9yTWVudGlvbnMsXG4gICAgICAgICAgICBbUnVsZUlkLkNvbnRhaW5zVXNlck5hbWVdOiBSdWxlQ2xhc3MuVmVjdG9yTWVudGlvbnMsXG4gICAgICAgICAgICBbUnVsZUlkLkF0Um9vbU5vdGlmaWNhdGlvbl06IFJ1bGVDbGFzcy5WZWN0b3JNZW50aW9ucyxcblxuICAgICAgICAgICAgW1J1bGVJZC5JbnZpdGVUb1NlbGZdOiBSdWxlQ2xhc3MuVmVjdG9yT3RoZXIsXG4gICAgICAgICAgICBbUnVsZUlkLkluY29taW5nQ2FsbF06IFJ1bGVDbGFzcy5WZWN0b3JPdGhlcixcbiAgICAgICAgICAgIFtSdWxlSWQuU3VwcHJlc3NOb3RpY2VzXTogUnVsZUNsYXNzLlZlY3Rvck90aGVyLFxuICAgICAgICAgICAgW1J1bGVJZC5Ub21ic3RvbmVdOiBSdWxlQ2xhc3MuVmVjdG9yT3RoZXIsXG5cbiAgICAgICAgICAgIC8vIEV2ZXJ5dGhpbmcgbWFwcyB0byBhIGdlbmVyaWMgXCJvdGhlclwiICh1bmtub3duIHJ1bGUpXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgZGVmYXVsdFJ1bGVzOiB7XG4gICAgICAgICAgICBbayBpbiBSdWxlQ2xhc3NdOiBJQW5ub3RhdGVkUHVzaFJ1bGVbXTtcbiAgICAgICAgfSA9IHtcbiAgICAgICAgICAgIFtSdWxlQ2xhc3MuTWFzdGVyXTogW10sXG4gICAgICAgICAgICBbUnVsZUNsYXNzLlZlY3Rvckdsb2JhbF06IFtdLFxuICAgICAgICAgICAgW1J1bGVDbGFzcy5WZWN0b3JNZW50aW9uc106IFtdLFxuICAgICAgICAgICAgW1J1bGVDbGFzcy5WZWN0b3JPdGhlcl06IFtdLFxuICAgICAgICAgICAgW1J1bGVDbGFzcy5PdGhlcl06IFtdLFxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoY29uc3QgayBpbiBydWxlU2V0cy5nbG9iYWwpIHtcbiAgICAgICAgICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VuZmlsdGVyZWRGb3JJbkxvb3BcbiAgICAgICAgICAgIGNvbnN0IGtpbmQgPSBrIGFzIFB1c2hSdWxlS2luZDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgciBvZiBydWxlU2V0cy5nbG9iYWxba2luZF0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBydWxlOiBJQW5ub3RhdGVkUHVzaFJ1bGUgPSBPYmplY3QuYXNzaWduKHIsIHsga2luZCB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXRlZ29yeSA9IGNhdGVnb3JpZXNbcnVsZS5ydWxlX2lkXSA/PyBSdWxlQ2xhc3MuT3RoZXI7XG5cbiAgICAgICAgICAgICAgICBpZiAocnVsZS5ydWxlX2lkWzBdID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFJ1bGVzW2NhdGVnb3J5XS5wdXNoKHJ1bGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByZXBhcmVkTmV3U3RhdGU6IFBhcnRpYWw8SVN0YXRlPiA9IHt9O1xuICAgICAgICBpZiAoZGVmYXVsdFJ1bGVzLm1hc3Rlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwcmVwYXJlZE5ld1N0YXRlLm1hc3RlclB1c2hSdWxlID0gZGVmYXVsdFJ1bGVzLm1hc3RlclswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFhYWDogQ2FuIHRoaXMgZXZlbiBoYXBwZW4/IEhvdyBkbyB3ZSBzYWZlbHkgcmVjb3Zlcj9cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBsb2NhdGUgYSBtYXN0ZXIgcHVzaCBydWxlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGFyc2Uga2V5d29yZCBydWxlc1xuICAgICAgICBwcmVwYXJlZE5ld1N0YXRlLnZlY3RvcktleXdvcmRSdWxlSW5mbyA9IENvbnRlbnRSdWxlcy5wYXJzZUNvbnRlbnRSdWxlcyhydWxlU2V0cyk7XG5cbiAgICAgICAgLy8gUHJlcGFyZSByZW5kZXJpbmcgZm9yIGFsbCBvZiBvdXIga25vd24gcnVsZXNcbiAgICAgICAgcHJlcGFyZWROZXdTdGF0ZS52ZWN0b3JQdXNoUnVsZXMgPSB7fTtcbiAgICAgICAgY29uc3QgdmVjdG9yQ2F0ZWdvcmllcyA9IFtSdWxlQ2xhc3MuVmVjdG9yR2xvYmFsLCBSdWxlQ2xhc3MuVmVjdG9yTWVudGlvbnMsIFJ1bGVDbGFzcy5WZWN0b3JPdGhlcl07XG4gICAgICAgIGZvciAoY29uc3QgY2F0ZWdvcnkgb2YgdmVjdG9yQ2F0ZWdvcmllcykge1xuICAgICAgICAgICAgcHJlcGFyZWROZXdTdGF0ZS52ZWN0b3JQdXNoUnVsZXNbY2F0ZWdvcnldID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgZGVmYXVsdFJ1bGVzW2NhdGVnb3J5XSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBWZWN0b3JQdXNoUnVsZXNEZWZpbml0aW9uc1tydWxlLnJ1bGVfaWRdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZlY3RvclN0YXRlID0gZGVmaW5pdGlvbi5ydWxlVG9WZWN0b3JTdGF0ZShydWxlKTtcbiAgICAgICAgICAgICAgICBwcmVwYXJlZE5ld1N0YXRlLnZlY3RvclB1c2hSdWxlc1tjYXRlZ29yeV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVJZDogcnVsZS5ydWxlX2lkLFxuICAgICAgICAgICAgICAgICAgICBydWxlLCB2ZWN0b3JTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IF90KGRlZmluaXRpb24uZGVzY3JpcHRpb24pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBRdWlja2x5IHNvcnQgdGhlIHJ1bGVzIGZvciBkaXNwbGF5IHB1cnBvc2VzXG4gICAgICAgICAgICBwcmVwYXJlZE5ld1N0YXRlLnZlY3RvclB1c2hSdWxlc1tjYXRlZ29yeV0uc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBpZHhBID0gUlVMRV9ESVNQTEFZX09SREVSLmluZGV4T2YoYS5ydWxlSWQpO1xuICAgICAgICAgICAgICAgIGxldCBpZHhCID0gUlVMRV9ESVNQTEFZX09SREVSLmluZGV4T2YoYi5ydWxlSWQpO1xuXG4gICAgICAgICAgICAgICAgLy8gQXNzdW1lIHVua25vd24gdGhpbmdzIGdvIGF0IHRoZSBlbmRcbiAgICAgICAgICAgICAgICBpZiAoaWR4QSA8IDApIGlkeEEgPSBSVUxFX0RJU1BMQVlfT1JERVIubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChpZHhCIDwgMCkgaWR4QiA9IFJVTEVfRElTUExBWV9PUkRFUi5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaWR4QSAtIGlkeEI7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGNhdGVnb3J5ID09PSBLRVlXT1JEX1JVTEVfQ0FURUdPUlkpIHtcbiAgICAgICAgICAgICAgICBwcmVwYXJlZE5ld1N0YXRlLnZlY3RvclB1c2hSdWxlc1tjYXRlZ29yeV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVJZDogS0VZV09SRF9SVUxFX0lELFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogX3QoXCJNZXNzYWdlcyBjb250YWluaW5nIGtleXdvcmRzXCIpLFxuICAgICAgICAgICAgICAgICAgICB2ZWN0b3JTdGF0ZTogcHJlcGFyZWROZXdTdGF0ZS52ZWN0b3JLZXl3b3JkUnVsZUluZm8udmVjdG9yU3RhdGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJlcGFyZWROZXdTdGF0ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHJlZnJlc2hQdXNoZXJzKCk6IFByb21pc2U8UGFydGlhbDxJU3RhdGU+PiB7XG4gICAgICAgIHJldHVybiBNYXRyaXhDbGllbnRQZWcuZ2V0KCkuZ2V0UHVzaGVycygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgcmVmcmVzaFRocmVlcGlkcygpOiBQcm9taXNlPFBhcnRpYWw8SVN0YXRlPj4ge1xuICAgICAgICByZXR1cm4gTWF0cml4Q2xpZW50UGVnLmdldCgpLmdldFRocmVlUGlkcygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2hvd1NhdmVFcnJvcigpIHtcbiAgICAgICAgTW9kYWwuY3JlYXRlVHJhY2tlZERpYWxvZygnRXJyb3Igc2F2aW5nIG5vdGlmaWNhdGlvbiBwcmVmZXJlbmNlcycsICcnLCBFcnJvckRpYWxvZywge1xuICAgICAgICAgICAgdGl0bGU6IF90KCdFcnJvciBzYXZpbmcgbm90aWZpY2F0aW9uIHByZWZlcmVuY2VzJyksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogX3QoJ0FuIGVycm9yIG9jY3VycmVkIHdoaWxzdCBzYXZpbmcgeW91ciBub3RpZmljYXRpb24gcHJlZmVyZW5jZXMuJyksXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgb25NYXN0ZXJSdWxlQ2hhbmdlZCA9IGFzeW5jIChjaGVja2VkOiBib29sZWFuKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBwaGFzZTogUGhhc2UuUGVyc2lzdGluZyB9KTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbWFzdGVyUnVsZSA9IHRoaXMuc3RhdGUubWFzdGVyUHVzaFJ1bGU7XG4gICAgICAgICAgICBhd2FpdCBNYXRyaXhDbGllbnRQZWcuZ2V0KCkuc2V0UHVzaFJ1bGVFbmFibGVkKCdnbG9iYWwnLCBtYXN0ZXJSdWxlLmtpbmQsIG1hc3RlclJ1bGUucnVsZV9pZCwgIWNoZWNrZWQpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWZyZXNoRnJvbVNlcnZlcigpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgcGhhc2U6IFBoYXNlLkVycm9yIH0pO1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRXJyb3IgdXBkYXRpbmcgbWFzdGVyIHB1c2ggcnVsZTpcIiwgZSk7XG4gICAgICAgICAgICB0aGlzLnNob3dTYXZlRXJyb3IoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcml2YXRlIG9uRW1haWxOb3RpZmljYXRpb25zQ2hhbmdlZCA9IGFzeW5jIChlbWFpbDogc3RyaW5nLCBjaGVja2VkOiBib29sZWFuKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBwaGFzZTogUGhhc2UuUGVyc2lzdGluZyB9KTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBNYXRyaXhDbGllbnRQZWcuZ2V0KCkuc2V0UHVzaGVyKHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogXCJlbWFpbFwiLFxuICAgICAgICAgICAgICAgICAgICBhcHBfaWQ6IFwibS5lbWFpbFwiLFxuICAgICAgICAgICAgICAgICAgICBwdXNoa2V5OiBlbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgYXBwX2Rpc3BsYXlfbmFtZTogXCJFbWFpbCBOb3RpZmljYXRpb25zXCIsXG4gICAgICAgICAgICAgICAgICAgIGRldmljZV9kaXNwbGF5X25hbWU6IGVtYWlsLFxuICAgICAgICAgICAgICAgICAgICBsYW5nOiBuYXZpZ2F0b3IubGFuZ3VhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyYW5kOiBTZGtDb25maWcuZ2V0KCkuYnJhbmQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgYWx3YXlzIGFwcGVuZCBmb3IgZW1haWwgcHVzaGVycyBzaW5jZSB3ZSBkb24ndCB3YW50IHRvIHN0b3Agb3RoZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWNjb3VudHMgbm90aWZ5aW5nIHRvIHRoZSBzYW1lIGVtYWlsIGFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgYXBwZW5kOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwdXNoZXIgPSB0aGlzLnN0YXRlLnB1c2hlcnMuZmluZChwID0+IHAua2luZCA9PT0gXCJlbWFpbFwiICYmIHAucHVzaGtleSA9PT0gZW1haWwpO1xuICAgICAgICAgICAgICAgIHB1c2hlci5raW5kID0gbnVsbDsgLy8gZmxhZyBmb3IgZGVsZXRlXG4gICAgICAgICAgICAgICAgYXdhaXQgTWF0cml4Q2xpZW50UGVnLmdldCgpLnNldFB1c2hlcihwdXNoZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlZnJlc2hGcm9tU2VydmVyKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBwaGFzZTogUGhhc2UuRXJyb3IgfSk7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJFcnJvciB1cGRhdGluZyBlbWFpbCBwdXNoZXI6XCIsIGUpO1xuICAgICAgICAgICAgdGhpcy5zaG93U2F2ZUVycm9yKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbkRlc2t0b3BOb3RpZmljYXRpb25zQ2hhbmdlZCA9IGFzeW5jIChjaGVja2VkOiBib29sZWFuKSA9PiB7XG4gICAgICAgIGF3YWl0IFNldHRpbmdzU3RvcmUuc2V0VmFsdWUoXCJub3RpZmljYXRpb25zRW5hYmxlZFwiLCBudWxsLCBTZXR0aW5nTGV2ZWwuREVWSUNFLCBjaGVja2VkKTtcbiAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpOyAvLyB0aGUgdG9nZ2xlIGlzIGNvbnRyb2xsZWQgYnkgU2V0dGluZ3NTdG9yZSNnZXRWYWx1ZSgpXG4gICAgfTtcblxuICAgIHByaXZhdGUgb25EZXNrdG9wU2hvd0JvZHlDaGFuZ2VkID0gYXN5bmMgKGNoZWNrZWQ6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgYXdhaXQgU2V0dGluZ3NTdG9yZS5zZXRWYWx1ZShcIm5vdGlmaWNhdGlvbkJvZHlFbmFibGVkXCIsIG51bGwsIFNldHRpbmdMZXZlbC5ERVZJQ0UsIGNoZWNrZWQpO1xuICAgICAgICB0aGlzLmZvcmNlVXBkYXRlKCk7IC8vIHRoZSB0b2dnbGUgaXMgY29udHJvbGxlZCBieSBTZXR0aW5nc1N0b3JlI2dldFZhbHVlKClcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbkF1ZGlvTm90aWZpY2F0aW9uc0NoYW5nZWQgPSBhc3luYyAoY2hlY2tlZDogYm9vbGVhbikgPT4ge1xuICAgICAgICBhd2FpdCBTZXR0aW5nc1N0b3JlLnNldFZhbHVlKFwiYXVkaW9Ob3RpZmljYXRpb25zRW5hYmxlZFwiLCBudWxsLCBTZXR0aW5nTGV2ZWwuREVWSUNFLCBjaGVja2VkKTtcbiAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpOyAvLyB0aGUgdG9nZ2xlIGlzIGNvbnRyb2xsZWQgYnkgU2V0dGluZ3NTdG9yZSNnZXRWYWx1ZSgpXG4gICAgfTtcblxuICAgIHByaXZhdGUgb25SYWRpb0NoZWNrZWQgPSBhc3luYyAocnVsZTogSVZlY3RvclB1c2hSdWxlLCBjaGVja2VkU3RhdGU6IFZlY3RvclN0YXRlKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBwaGFzZTogUGhhc2UuUGVyc2lzdGluZyB9KTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY2xpID0gTWF0cml4Q2xpZW50UGVnLmdldCgpO1xuICAgICAgICAgICAgaWYgKHJ1bGUucnVsZUlkID09PSBLRVlXT1JEX1JVTEVfSUQpIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgYWxsIHRoZSBrZXl3b3Jkc1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcnVsZSBvZiB0aGlzLnN0YXRlLnZlY3RvcktleXdvcmRSdWxlSW5mby5ydWxlcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5hYmxlZDogYm9vbGVhbjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFjdGlvbnM6IFB1c2hSdWxlQWN0aW9uW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVja2VkU3RhdGUgPT09IFZlY3RvclN0YXRlLk9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVsZS5hY3Rpb25zLmxlbmd0aCAhPT0gMSkgeyAvLyBYWFg6IE1hZ2ljIG51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnMgPSBQdXNoUnVsZVZlY3RvclN0YXRlLmFjdGlvbnNGb3IoY2hlY2tlZFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnZlY3RvcktleXdvcmRSdWxlSW5mby52ZWN0b3JTdGF0ZSA9PT0gVmVjdG9yU3RhdGUuT2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hlY2tlZFN0YXRlID09PSBWZWN0b3JTdGF0ZS5Mb3VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVsZS5hY3Rpb25zLmxlbmd0aCAhPT0gMykgeyAvLyBYWFg6IE1hZ2ljIG51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnMgPSBQdXNoUnVsZVZlY3RvclN0YXRlLmFjdGlvbnNGb3IoY2hlY2tlZFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnZlY3RvcktleXdvcmRSdWxlSW5mby52ZWN0b3JTdGF0ZSA9PT0gVmVjdG9yU3RhdGUuT2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2xpLnNldFB1c2hSdWxlQWN0aW9ucygnZ2xvYmFsJywgcnVsZS5raW5kLCBydWxlLnJ1bGVfaWQsIGFjdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGNsaS5zZXRQdXNoUnVsZUVuYWJsZWQoJ2dsb2JhbCcsIHJ1bGUua2luZCwgcnVsZS5ydWxlX2lkLCBlbmFibGVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IFZlY3RvclB1c2hSdWxlc0RlZmluaXRpb25zW3J1bGUucnVsZUlkXTtcbiAgICAgICAgICAgICAgICBjb25zdCBhY3Rpb25zID0gZGVmaW5pdGlvbi52ZWN0b3JTdGF0ZVRvQWN0aW9uc1tjaGVja2VkU3RhdGVdO1xuICAgICAgICAgICAgICAgIGlmICghYWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjbGkuc2V0UHVzaFJ1bGVFbmFibGVkKCdnbG9iYWwnLCBydWxlLnJ1bGUua2luZCwgcnVsZS5ydWxlLnJ1bGVfaWQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjbGkuc2V0UHVzaFJ1bGVBY3Rpb25zKCdnbG9iYWwnLCBydWxlLnJ1bGUua2luZCwgcnVsZS5ydWxlLnJ1bGVfaWQsIGFjdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjbGkuc2V0UHVzaFJ1bGVFbmFibGVkKCdnbG9iYWwnLCBydWxlLnJ1bGUua2luZCwgcnVsZS5ydWxlLnJ1bGVfaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWZyZXNoRnJvbVNlcnZlcigpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgcGhhc2U6IFBoYXNlLkVycm9yIH0pO1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRXJyb3IgdXBkYXRpbmcgcHVzaCBydWxlOlwiLCBlKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd1NhdmVFcnJvcigpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25DbGVhck5vdGlmaWNhdGlvbnNDbGlja2VkID0gKCkgPT4ge1xuICAgICAgICBNYXRyaXhDbGllbnRQZWcuZ2V0KCkuZ2V0Um9vbXMoKS5mb3JFYWNoKHIgPT4ge1xuICAgICAgICAgICAgaWYgKHIuZ2V0VW5yZWFkTm90aWZpY2F0aW9uQ291bnQoKSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudHMgPSByLmdldExpdmVUaW1lbGluZSgpLmdldEV2ZW50cygpO1xuICAgICAgICAgICAgICAgIGlmIChldmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vaW5zcGVjdGlvbiBKU0lnbm9yZWRQcm9taXNlRnJvbUNhbGxcbiAgICAgICAgICAgICAgICAgICAgTWF0cml4Q2xpZW50UGVnLmdldCgpLnNlbmRSZWFkUmVjZWlwdChldmVudHNbZXZlbnRzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBwcml2YXRlIGFzeW5jIHNldEtleXdvcmRzKGtleXdvcmRzOiBzdHJpbmdbXSwgb3JpZ2luYWxSdWxlczogSUFubm90YXRlZFB1c2hSdWxlW10pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIERlLWR1cGxpY2F0ZSBhbmQgcmVtb3ZlIGVtcHRpZXNcbiAgICAgICAgICAgIGtleXdvcmRzID0gQXJyYXkuZnJvbShuZXcgU2V0KGtleXdvcmRzKSkuZmlsdGVyKGsgPT4gISFrKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZEtleXdvcmRzID0gQXJyYXkuZnJvbShuZXcgU2V0KG9yaWdpbmFsUnVsZXMubWFwKHIgPT4gci5wYXR0ZXJuKSkpLmZpbHRlcihrID0+ICEhayk7XG5cbiAgICAgICAgICAgIC8vIE5vdGU6IFRlY2huaWNhbGx5IGJlY2F1c2Ugb2YgdGhlIFVJIGludGVyYWN0aW9uIChhdCB0aGUgdGltZSBvZiB3cml0aW5nKSwgdGhlIGRpZmZcbiAgICAgICAgICAgIC8vIHdpbGwgb25seSBldmVyIGJlICsvLTEgc28gd2UgZG9uJ3QgcmVhbGx5IGhhdmUgdG8gd29ycnkgYWJvdXQgZWZmaWNpZW50bHkgaGFuZGxpbmdcbiAgICAgICAgICAgIC8vIHRvbnMgb2Yga2V5d29yZCBjaGFuZ2VzLlxuXG4gICAgICAgICAgICBjb25zdCBkaWZmID0gYXJyYXlEaWZmKG9sZEtleXdvcmRzLCBrZXl3b3Jkcyk7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3Qgd29yZCBvZiBkaWZmLnJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2Ygb3JpZ2luYWxSdWxlcy5maWx0ZXIociA9PiByLnBhdHRlcm4gPT09IHdvcmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IE1hdHJpeENsaWVudFBlZy5nZXQoKS5kZWxldGVQdXNoUnVsZSgnZ2xvYmFsJywgcnVsZS5raW5kLCBydWxlLnJ1bGVfaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHJ1bGVWZWN0b3JTdGF0ZSA9IHRoaXMuc3RhdGUudmVjdG9yS2V5d29yZFJ1bGVJbmZvLnZlY3RvclN0YXRlO1xuICAgICAgICAgICAgaWYgKHJ1bGVWZWN0b3JTdGF0ZSA9PT0gVmVjdG9yU3RhdGUuT2ZmKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgY3VycmVudCBnbG9iYWwga2V5d29yZHMgcnVsZSBpcyBPRkYsIHdlIG5lZWQgdG8gbG9vayBhdFxuICAgICAgICAgICAgICAgIC8vIHRoZSBmbGF2b3Igb2YgZXhpc3RpbmcgcnVsZXMgdG8gYXBwbHkgdGhlIHNhbWUgYWN0aW9uc1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gY3JlYXRpbmcgdGhlIG5ldyBydWxlLlxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbFJ1bGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBydWxlVmVjdG9yU3RhdGUgPSBQdXNoUnVsZVZlY3RvclN0YXRlLmNvbnRlbnRSdWxlVmVjdG9yU3RhdGVLaW5kKG9yaWdpbmFsUnVsZXNbMF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVWZWN0b3JTdGF0ZSA9IFZlY3RvclN0YXRlLk9uOyAvLyBkZWZhdWx0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qga2luZCA9IFB1c2hSdWxlS2luZC5Db250ZW50U3BlY2lmaWM7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHdvcmQgb2YgZGlmZi5hZGRlZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IE1hdHJpeENsaWVudFBlZy5nZXQoKS5hZGRQdXNoUnVsZSgnZ2xvYmFsJywga2luZCwgd29yZCwge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zOiBQdXNoUnVsZVZlY3RvclN0YXRlLmFjdGlvbnNGb3IocnVsZVZlY3RvclN0YXRlKSxcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogd29yZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocnVsZVZlY3RvclN0YXRlID09PSBWZWN0b3JTdGF0ZS5PZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgTWF0cml4Q2xpZW50UGVnLmdldCgpLnNldFB1c2hSdWxlRW5hYmxlZCgnZ2xvYmFsJywga2luZCwgd29yZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWZyZXNoRnJvbVNlcnZlcigpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgcGhhc2U6IFBoYXNlLkVycm9yIH0pO1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRXJyb3IgdXBkYXRpbmcga2V5d29yZCBwdXNoIHJ1bGVzOlwiLCBlKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd1NhdmVFcnJvcigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvbktleXdvcmRBZGQgPSAoa2V5d29yZDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsUnVsZXMgPSBvYmplY3RDbG9uZSh0aGlzLnN0YXRlLnZlY3RvcktleXdvcmRSdWxlSW5mby5ydWxlcyk7XG5cbiAgICAgICAgLy8gV2UgYWRkIHRoZSBrZXl3b3JkIGltbWVkaWF0ZWx5IGFzIGEgc29ydCBvZiBsb2NhbCBlY2hvIGVmZmVjdFxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHBoYXNlOiBQaGFzZS5QZXJzaXN0aW5nLFxuICAgICAgICAgICAgdmVjdG9yS2V5d29yZFJ1bGVJbmZvOiB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5zdGF0ZS52ZWN0b3JLZXl3b3JkUnVsZUluZm8sXG4gICAgICAgICAgICAgICAgcnVsZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5zdGF0ZS52ZWN0b3JLZXl3b3JkUnVsZUluZm8ucnVsZXMsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gWFhYOiBIb3JyaWJsZSBhc3N1bXB0aW9uIHRoYXQgd2UgZG9uJ3QgbmVlZCB0aGUgcmVtYWluaW5nIGZpZWxkc1xuICAgICAgICAgICAgICAgICAgICB7IHBhdHRlcm46IGtleXdvcmQgfSBhcyBJQW5ub3RhdGVkUHVzaFJ1bGUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0S2V5d29yZHModGhpcy5zdGF0ZS52ZWN0b3JLZXl3b3JkUnVsZUluZm8ucnVsZXMubWFwKHIgPT4gci5wYXR0ZXJuKSwgb3JpZ2luYWxSdWxlcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBwcml2YXRlIG9uS2V5d29yZFJlbW92ZSA9IChrZXl3b3JkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxSdWxlcyA9IG9iamVjdENsb25lKHRoaXMuc3RhdGUudmVjdG9yS2V5d29yZFJ1bGVJbmZvLnJ1bGVzKTtcblxuICAgICAgICAvLyBXZSByZW1vdmUgdGhlIGtleXdvcmQgaW1tZWRpYXRlbHkgYXMgYSBzb3J0IG9mIGxvY2FsIGVjaG8gZWZmZWN0XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgcGhhc2U6IFBoYXNlLlBlcnNpc3RpbmcsXG4gICAgICAgICAgICB2ZWN0b3JLZXl3b3JkUnVsZUluZm86IHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLnN0YXRlLnZlY3RvcktleXdvcmRSdWxlSW5mbyxcbiAgICAgICAgICAgICAgICBydWxlczogdGhpcy5zdGF0ZS52ZWN0b3JLZXl3b3JkUnVsZUluZm8ucnVsZXMuZmlsdGVyKHIgPT4gci5wYXR0ZXJuICE9PSBrZXl3b3JkKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0S2V5d29yZHModGhpcy5zdGF0ZS52ZWN0b3JLZXl3b3JkUnVsZUluZm8ucnVsZXMubWFwKHIgPT4gci5wYXR0ZXJuKSwgb3JpZ2luYWxSdWxlcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBwcml2YXRlIHJlbmRlclRvcFNlY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IG1hc3RlclN3aXRjaCA9IDxMYWJlbGxlZFRvZ2dsZVN3aXRjaFxuICAgICAgICAgICAgdmFsdWU9eyF0aGlzLmlzSW5oaWJpdGVkfVxuICAgICAgICAgICAgbGFiZWw9e190KFwiRW5hYmxlIGZvciB0aGlzIGFjY291bnRcIil9XG4gICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5vbk1hc3RlclJ1bGVDaGFuZ2VkfVxuICAgICAgICAgICAgZGlzYWJsZWQ9e3RoaXMuc3RhdGUucGhhc2UgPT09IFBoYXNlLlBlcnNpc3Rpbmd9XG4gICAgICAgIC8+O1xuXG4gICAgICAgIC8vIElmIGFsbCB0aGUgcnVsZXMgYXJlIGluaGliaXRlZCwgZG9uJ3Qgc2hvdyBhbnl0aGluZy5cbiAgICAgICAgaWYgKHRoaXMuaXNJbmhpYml0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXN0ZXJTd2l0Y2g7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlbWFpbFN3aXRjaGVzID0gKHRoaXMuc3RhdGUudGhyZWVwaWRzIHx8IFtdKS5maWx0ZXIodCA9PiB0Lm1lZGl1bSA9PT0gVGhyZWVwaWRNZWRpdW0uRW1haWwpXG4gICAgICAgICAgICAubWFwKGUgPT4gPExhYmVsbGVkVG9nZ2xlU3dpdGNoXG4gICAgICAgICAgICAgICAga2V5PXtlLmFkZHJlc3N9XG4gICAgICAgICAgICAgICAgdmFsdWU9e3RoaXMuc3RhdGUucHVzaGVycy5zb21lKHAgPT4gcC5raW5kID09PSBcImVtYWlsXCIgJiYgcC5wdXNoa2V5ID09PSBlLmFkZHJlc3MpfVxuICAgICAgICAgICAgICAgIGxhYmVsPXtfdChcIkVuYWJsZSBlbWFpbCBub3RpZmljYXRpb25zIGZvciAlKGVtYWlsKXNcIiwgeyBlbWFpbDogZS5hZGRyZXNzIH0pfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uRW1haWxOb3RpZmljYXRpb25zQ2hhbmdlZC5iaW5kKHRoaXMsIGUuYWRkcmVzcyl9XG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ9e3RoaXMuc3RhdGUucGhhc2UgPT09IFBoYXNlLlBlcnNpc3Rpbmd9XG4gICAgICAgICAgICAvPik7XG5cbiAgICAgICAgcmV0dXJuIDw+XG4gICAgICAgICAgICB7IG1hc3RlclN3aXRjaCB9XG5cbiAgICAgICAgICAgIDxMYWJlbGxlZFRvZ2dsZVN3aXRjaFxuICAgICAgICAgICAgICAgIHZhbHVlPXtTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFwibm90aWZpY2F0aW9uc0VuYWJsZWRcIil9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25EZXNrdG9wTm90aWZpY2F0aW9uc0NoYW5nZWR9XG4gICAgICAgICAgICAgICAgbGFiZWw9e190KCdFbmFibGUgZGVza3RvcCBub3RpZmljYXRpb25zIGZvciB0aGlzIHNlc3Npb24nKX1cbiAgICAgICAgICAgICAgICBkaXNhYmxlZD17dGhpcy5zdGF0ZS5waGFzZSA9PT0gUGhhc2UuUGVyc2lzdGluZ31cbiAgICAgICAgICAgIC8+XG5cbiAgICAgICAgICAgIDxMYWJlbGxlZFRvZ2dsZVN3aXRjaFxuICAgICAgICAgICAgICAgIHZhbHVlPXtTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFwibm90aWZpY2F0aW9uQm9keUVuYWJsZWRcIil9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25EZXNrdG9wU2hvd0JvZHlDaGFuZ2VkfVxuICAgICAgICAgICAgICAgIGxhYmVsPXtfdCgnU2hvdyBtZXNzYWdlIGluIGRlc2t0b3Agbm90aWZpY2F0aW9uJyl9XG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ9e3RoaXMuc3RhdGUucGhhc2UgPT09IFBoYXNlLlBlcnNpc3Rpbmd9XG4gICAgICAgICAgICAvPlxuXG4gICAgICAgICAgICA8TGFiZWxsZWRUb2dnbGVTd2l0Y2hcbiAgICAgICAgICAgICAgICB2YWx1ZT17U2V0dGluZ3NTdG9yZS5nZXRWYWx1ZShcImF1ZGlvTm90aWZpY2F0aW9uc0VuYWJsZWRcIil9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25BdWRpb05vdGlmaWNhdGlvbnNDaGFuZ2VkfVxuICAgICAgICAgICAgICAgIGxhYmVsPXtfdCgnRW5hYmxlIGF1ZGlibGUgbm90aWZpY2F0aW9ucyBmb3IgdGhpcyBzZXNzaW9uJyl9XG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ9e3RoaXMuc3RhdGUucGhhc2UgPT09IFBoYXNlLlBlcnNpc3Rpbmd9XG4gICAgICAgICAgICAvPlxuXG4gICAgICAgICAgICB7IGVtYWlsU3dpdGNoZXMgfVxuICAgICAgICA8Lz47XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZW5kZXJDYXRlZ29yeShjYXRlZ29yeTogUnVsZUNsYXNzKSB7XG4gICAgICAgIGlmIChjYXRlZ29yeSAhPT0gUnVsZUNsYXNzLlZlY3Rvck90aGVyICYmIHRoaXMuaXNJbmhpYml0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBub3RoaW5nIHRvIHNob3cgZm9yIHRoZSBzZWN0aW9uXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2xlYXJOb3RpZnNCdXR0b246IEpTWC5FbGVtZW50O1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjYXRlZ29yeSA9PT0gUnVsZUNsYXNzLlZlY3Rvck90aGVyXG4gICAgICAgICAgICAmJiBNYXRyaXhDbGllbnRQZWcuZ2V0KCkuZ2V0Um9vbXMoKS5zb21lKHIgPT4gci5nZXRVbnJlYWROb3RpZmljYXRpb25Db3VudCgpID4gMClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjbGVhck5vdGlmc0J1dHRvbiA9IDxBY2Nlc3NpYmxlQnV0dG9uXG4gICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5vbkNsZWFyTm90aWZpY2F0aW9uc0NsaWNrZWR9XG4gICAgICAgICAgICAgICAga2luZD0nZGFuZ2VyJ1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT0nbXhfVXNlck5vdGlmU2V0dGluZ3NfY2xlYXJOb3RpZnNCdXR0b24nXG4gICAgICAgICAgICA+eyBfdChcIkNsZWFyIG5vdGlmaWNhdGlvbnNcIikgfTwvQWNjZXNzaWJsZUJ1dHRvbj47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2F0ZWdvcnkgPT09IFJ1bGVDbGFzcy5WZWN0b3JPdGhlciAmJiB0aGlzLmlzSW5oaWJpdGVkKSB7XG4gICAgICAgICAgICAvLyBvbmx5IHJlbmRlciB0aGUgdXRpbGl0eSBidXR0b25zIChpZiBuZWVkZWQpXG4gICAgICAgICAgICBpZiAoY2xlYXJOb3RpZnNCdXR0b24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9J214X1VzZXJOb3RpZlNldHRpbmdzX2Zsb2F0aW5nU2VjdGlvbic+XG4gICAgICAgICAgICAgICAgICAgIDxkaXY+eyBfdChcIk90aGVyXCIpIH08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgeyBjbGVhck5vdGlmc0J1dHRvbiB9XG4gICAgICAgICAgICAgICAgPC9kaXY+O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQga2V5d29yZENvbXBvc2VyOiBKU1guRWxlbWVudDtcbiAgICAgICAgaWYgKGNhdGVnb3J5ID09PSBSdWxlQ2xhc3MuVmVjdG9yTWVudGlvbnMpIHtcbiAgICAgICAgICAgIGtleXdvcmRDb21wb3NlciA9IDxUYWdDb21wb3NlclxuICAgICAgICAgICAgICAgIHRhZ3M9e3RoaXMuc3RhdGUudmVjdG9yS2V5d29yZFJ1bGVJbmZvPy5ydWxlcy5tYXAociA9PiByLnBhdHRlcm4pfVxuICAgICAgICAgICAgICAgIG9uQWRkPXt0aGlzLm9uS2V5d29yZEFkZH1cbiAgICAgICAgICAgICAgICBvblJlbW92ZT17dGhpcy5vbktleXdvcmRSZW1vdmV9XG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ9e3RoaXMuc3RhdGUucGhhc2UgPT09IFBoYXNlLlBlcnNpc3Rpbmd9XG4gICAgICAgICAgICAgICAgbGFiZWw9e190KFwiS2V5d29yZFwiKX1cbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj17X3QoXCJOZXcga2V5d29yZFwiKX1cbiAgICAgICAgICAgIC8+O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWFrZVJhZGlvID0gKHI6IElWZWN0b3JQdXNoUnVsZSwgczogVmVjdG9yU3RhdGUpID0+IChcbiAgICAgICAgICAgIDxTdHlsZWRSYWRpb0J1dHRvblxuICAgICAgICAgICAgICAgIGtleT17ci5ydWxlSWR9XG4gICAgICAgICAgICAgICAgbmFtZT17ci5ydWxlSWR9XG4gICAgICAgICAgICAgICAgY2hlY2tlZD17ci52ZWN0b3JTdGF0ZSA9PT0gc31cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5vblJhZGlvQ2hlY2tlZC5iaW5kKHRoaXMsIHIsIHMpfVxuICAgICAgICAgICAgICAgIGRpc2FibGVkPXt0aGlzLnN0YXRlLnBoYXNlID09PSBQaGFzZS5QZXJzaXN0aW5nfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCByb3dzID0gdGhpcy5zdGF0ZS52ZWN0b3JQdXNoUnVsZXNbY2F0ZWdvcnldLm1hcChyID0+IDx0ciBrZXk9e2NhdGVnb3J5ICsgci5ydWxlSWR9PlxuICAgICAgICAgICAgPHRkPnsgci5kZXNjcmlwdGlvbiB9PC90ZD5cbiAgICAgICAgICAgIDx0ZD57IG1ha2VSYWRpbyhyLCBWZWN0b3JTdGF0ZS5PZmYpIH08L3RkPlxuICAgICAgICAgICAgPHRkPnsgbWFrZVJhZGlvKHIsIFZlY3RvclN0YXRlLk9uKSB9PC90ZD5cbiAgICAgICAgICAgIDx0ZD57IG1ha2VSYWRpbyhyLCBWZWN0b3JTdGF0ZS5Mb3VkKSB9PC90ZD5cbiAgICAgICAgPC90cj4pO1xuXG4gICAgICAgIGxldCBzZWN0aW9uTmFtZTogVHJhbnNsYXRlZFN0cmluZztcbiAgICAgICAgc3dpdGNoIChjYXRlZ29yeSkge1xuICAgICAgICAgICAgY2FzZSBSdWxlQ2xhc3MuVmVjdG9yR2xvYmFsOlxuICAgICAgICAgICAgICAgIHNlY3Rpb25OYW1lID0gX3QoXCJHbG9iYWxcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFJ1bGVDbGFzcy5WZWN0b3JNZW50aW9uczpcbiAgICAgICAgICAgICAgICBzZWN0aW9uTmFtZSA9IF90KFwiTWVudGlvbnMgJiBrZXl3b3Jkc1wiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUnVsZUNsYXNzLlZlY3Rvck90aGVyOlxuICAgICAgICAgICAgICAgIHNlY3Rpb25OYW1lID0gX3QoXCJPdGhlclwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGV2ZWxvcGVyIGVycm9yOiBVbm5hbWVkIG5vdGlmaWNhdGlvbnMgc2VjdGlvbjogXCIgKyBjYXRlZ29yeSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gPD5cbiAgICAgICAgICAgIDx0YWJsZSBjbGFzc05hbWU9J214X1VzZXJOb3RpZlNldHRpbmdzX3B1c2hSdWxlc1RhYmxlJz5cbiAgICAgICAgICAgICAgICA8dGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aD57IHNlY3Rpb25OYW1lIH08L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoPnsgX3QoXCJPZmZcIikgfTwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGg+eyBfdChcIk9uXCIpIH08L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoPnsgX3QoXCJOb2lzeVwiKSB9PC90aD5cbiAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICA8L3RoZWFkPlxuICAgICAgICAgICAgICAgIDx0Ym9keT5cbiAgICAgICAgICAgICAgICAgICAgeyByb3dzIH1cbiAgICAgICAgICAgICAgICA8L3Rib2R5PlxuICAgICAgICAgICAgPC90YWJsZT5cbiAgICAgICAgICAgIHsgY2xlYXJOb3RpZnNCdXR0b24gfVxuICAgICAgICAgICAgeyBrZXl3b3JkQ29tcG9zZXIgfVxuICAgICAgICA8Lz47XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZW5kZXJUYXJnZXRzKCkge1xuICAgICAgICBpZiAodGhpcy5pc0luaGliaXRlZCkgcmV0dXJuIG51bGw7IC8vIG5vIHRhcmdldHMgaWYgdGhlcmUncyBubyBub3RpZmljYXRpb25zXG5cbiAgICAgICAgY29uc3Qgcm93cyA9IHRoaXMuc3RhdGUucHVzaGVycy5tYXAocCA9PiA8dHIga2V5PXtwLmtpbmQrcC5wdXNoa2V5fT5cbiAgICAgICAgICAgIDx0ZD57IHAuYXBwX2Rpc3BsYXlfbmFtZSB9PC90ZD5cbiAgICAgICAgICAgIDx0ZD57IHAuZGV2aWNlX2Rpc3BsYXlfbmFtZSB9PC90ZD5cbiAgICAgICAgPC90cj4pO1xuXG4gICAgICAgIGlmICghcm93cy5sZW5ndGgpIHJldHVybiBudWxsOyAvLyBubyB0YXJnZXRzIHRvIHNob3dcblxuICAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9J214X1VzZXJOb3RpZlNldHRpbmdzX2Zsb2F0aW5nU2VjdGlvbic+XG4gICAgICAgICAgICA8ZGl2PnsgX3QoXCJOb3RpZmljYXRpb24gdGFyZ2V0c1wiKSB9PC9kaXY+XG4gICAgICAgICAgICA8dGFibGU+XG4gICAgICAgICAgICAgICAgPHRib2R5PlxuICAgICAgICAgICAgICAgICAgICB7IHJvd3MgfVxuICAgICAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICA8L2Rpdj47XG4gICAgfVxuXG4gICAgcHVibGljIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUucGhhc2UgPT09IFBoYXNlLkxvYWRpbmcpIHtcbiAgICAgICAgICAgIC8vIEVuZHMgdXAgZGVmYXVsdCBjZW50ZXJlZFxuICAgICAgICAgICAgcmV0dXJuIDxTcGlubmVyIC8+O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUucGhhc2UgPT09IFBoYXNlLkVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gPHA+eyBfdChcIlRoZXJlIHdhcyBhbiBlcnJvciBsb2FkaW5nIHlvdXIgbm90aWZpY2F0aW9uIHNldHRpbmdzLlwiKSB9PC9wPjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT0nbXhfVXNlck5vdGlmU2V0dGluZ3MnPlxuICAgICAgICAgICAgeyB0aGlzLnJlbmRlclRvcFNlY3Rpb24oKSB9XG4gICAgICAgICAgICB7IHRoaXMucmVuZGVyQ2F0ZWdvcnkoUnVsZUNsYXNzLlZlY3Rvckdsb2JhbCkgfVxuICAgICAgICAgICAgeyB0aGlzLnJlbmRlckNhdGVnb3J5KFJ1bGVDbGFzcy5WZWN0b3JNZW50aW9ucykgfVxuICAgICAgICAgICAgeyB0aGlzLnJlbmRlckNhdGVnb3J5KFJ1bGVDbGFzcy5WZWN0b3JPdGhlcikgfVxuICAgICAgICAgICAgeyB0aGlzLnJlbmRlclRhcmdldHMoKSB9XG4gICAgICAgIDwvZGl2PjtcbiAgICB9XG59XG4iXX0=