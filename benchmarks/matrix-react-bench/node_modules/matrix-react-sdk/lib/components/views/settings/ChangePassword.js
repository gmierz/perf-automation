"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _Field = _interopRequireDefault(require("../elements/Field"));

var _react = _interopRequireDefault(require("react"));

var _MatrixClientPeg = require("../../../MatrixClientPeg");

var _AccessibleButton = _interopRequireDefault(require("../elements/AccessibleButton"));

var _Spinner = _interopRequireDefault(require("../elements/Spinner"));

var _Validation = _interopRequireDefault(require("../elements/Validation"));

var _languageHandler = require("../../../languageHandler");

var _Modal = _interopRequireDefault(require("../../../Modal"));

var _PassphraseField = _interopRequireDefault(require("../auth/PassphraseField"));

var _CountlyAnalytics = _interopRequireDefault(require("../../../CountlyAnalytics"));

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _RegistrationForm = require("../auth/RegistrationForm");

var _SetEmailDialog = _interopRequireDefault(require("../dialogs/SetEmailDialog"));

var _QuestionDialog = _interopRequireDefault(require("../dialogs/QuestionDialog"));

var _dec, _class, _class2, _temp;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const FIELD_OLD_PASSWORD = 'field_old_password';
const FIELD_NEW_PASSWORD = 'field_new_password';
const FIELD_NEW_PASSWORD_CONFIRM = 'field_new_password_confirm';
var Phase;

(function (Phase) {
  Phase["Edit"] = "edit";
  Phase["Uploading"] = "uploading";
  Phase["Error"] = "error";
})(Phase || (Phase = {}));

let ChangePassword = (_dec = (0, _replaceableComponent.replaceableComponent)("views.settings.ChangePassword"), _dec(_class = (_temp = _class2 = class ChangePassword extends _react.default.Component {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "onExportE2eKeysClicked", () => {
      _Modal.default.createTrackedDialogAsync('Export E2E Keys', 'Change Password', Promise.resolve().then(() => _interopRequireWildcard(require('../../../async-components/views/dialogs/security/ExportE2eKeysDialog'))), {
        matrixClient: _MatrixClientPeg.MatrixClientPeg.get()
      });
    });
    (0, _defineProperty2.default)(this, "onChangeOldPassword", ev => {
      this.setState({
        oldPassword: ev.target.value
      });
    });
    (0, _defineProperty2.default)(this, "onOldPasswordValidate", async fieldState => {
      const result = await this.validateOldPasswordRules(fieldState);
      this.markFieldValid(FIELD_OLD_PASSWORD, result.valid);
      return result;
    });
    (0, _defineProperty2.default)(this, "validateOldPasswordRules", (0, _Validation.default)({
      rules: [{
        key: "required",
        test: ({
          value,
          allowEmpty
        }) => allowEmpty || !!value,
        invalid: () => (0, _languageHandler._t)("Passwords can't be empty")
      }]
    }));
    (0, _defineProperty2.default)(this, "onChangeNewPassword", ev => {
      this.setState({
        newPassword: ev.target.value
      });
    });
    (0, _defineProperty2.default)(this, "onNewPasswordValidate", result => {
      this.markFieldValid(FIELD_NEW_PASSWORD, result.valid);
    });
    (0, _defineProperty2.default)(this, "onChangeNewPasswordConfirm", ev => {
      this.setState({
        newPasswordConfirm: ev.target.value
      });
    });
    (0, _defineProperty2.default)(this, "onNewPasswordConfirmValidate", async fieldState => {
      const result = await this.validatePasswordConfirmRules(fieldState);
      this.markFieldValid(FIELD_NEW_PASSWORD_CONFIRM, result.valid);
      return result;
    });
    (0, _defineProperty2.default)(this, "validatePasswordConfirmRules", (0, _Validation.default)({
      rules: [{
        key: "required",
        test: ({
          value,
          allowEmpty
        }) => allowEmpty || !!value,
        invalid: () => (0, _languageHandler._t)("Confirm password")
      }, {
        key: "match",

        test({
          value
        }) {
          return !value || value === this.state.newPassword;
        },

        invalid: () => (0, _languageHandler._t)("Passwords don't match")
      }]
    }));
    (0, _defineProperty2.default)(this, "onClickChange", async ev => {
      ev.preventDefault();
      const allFieldsValid = await this.verifyFieldsBeforeSubmit();

      if (!allFieldsValid) {
        _CountlyAnalytics.default.instance.track("onboarding_registration_submit_failed");

        return;
      }

      const oldPassword = this.state.oldPassword;
      const newPassword = this.state.newPassword;
      const confirmPassword = this.state.newPasswordConfirm;
      const err = this.checkPassword(oldPassword, newPassword, confirmPassword);

      if (err) {
        this.props.onError(err);
      } else {
        this.onChangePassword(oldPassword, newPassword);
      }
    });
    this.state = {
      fieldValid: {},
      phase: Phase.Edit,
      oldPassword: "",
      newPassword: "",
      newPasswordConfirm: ""
    };
  }

  onChangePassword(oldPassword, newPassword) {
    const cli = _MatrixClientPeg.MatrixClientPeg.get();

    if (!this.props.confirm) {
      this.changePassword(cli, oldPassword, newPassword);
      return;
    }

    _Modal.default.createTrackedDialog('Change Password', '', _QuestionDialog.default, {
      title: (0, _languageHandler._t)("Warning!"),
      description: /*#__PURE__*/_react.default.createElement("div", null, (0, _languageHandler._t)('Changing password will currently reset any end-to-end encryption keys on all sessions, ' + 'making encrypted chat history unreadable, unless you first export your room keys ' + 'and re-import them afterwards. ' + 'In future this will be improved.'), ' ', /*#__PURE__*/_react.default.createElement("a", {
        href: "https://github.com/vector-im/element-web/issues/2671",
        target: "_blank",
        rel: "noreferrer noopener"
      }, "https://github.com/vector-im/element-web/issues/2671")),
      button: (0, _languageHandler._t)("Continue"),
      extraButtons: [/*#__PURE__*/_react.default.createElement("button", {
        key: "exportRoomKeys",
        className: "mx_Dialog_primary",
        onClick: this.onExportE2eKeysClicked
      }, (0, _languageHandler._t)('Export E2E room keys'))],
      onFinished: confirmed => {
        if (confirmed) {
          this.changePassword(cli, oldPassword, newPassword);
        }
      }
    });
  }

  changePassword(cli, oldPassword, newPassword) {
    const authDict = {
      type: 'm.login.password',
      identifier: {
        type: 'm.id.user',
        user: cli.credentials.userId
      },
      // TODO: Remove `user` once servers support proper UIA
      // See https://github.com/matrix-org/synapse/issues/5665
      user: cli.credentials.userId,
      password: oldPassword
    };
    this.setState({
      phase: Phase.Uploading
    });
    cli.setPassword(authDict, newPassword).then(() => {
      if (this.props.shouldAskForEmail) {
        return this.optionallySetEmail().then(confirmed => {
          this.props.onFinished({
            didSetEmail: confirmed
          });
        });
      } else {
        this.props.onFinished();
      }
    }, err => {
      this.props.onError(err);
    }).finally(() => {
      this.setState({
        phase: Phase.Edit,
        oldPassword: "",
        newPassword: "",
        newPasswordConfirm: ""
      });
    });
  }

  checkPassword(oldPass, newPass, confirmPass) {
    if (newPass !== confirmPass) {
      return {
        error: (0, _languageHandler._t)("New passwords don't match")
      };
    } else if (!newPass || newPass.length === 0) {
      return {
        error: (0, _languageHandler._t)("Passwords can't be empty")
      };
    }
  }

  optionallySetEmail() {
    // Ask for an email otherwise the user has no way to reset their password
    const modal = _Modal.default.createTrackedDialog('Do you want to set an email address?', '', _SetEmailDialog.default, {
      title: (0, _languageHandler._t)('Do you want to set an email address?')
    });

    return modal.finished.then(([confirmed]) => confirmed);
  }

  markFieldValid(fieldID, valid) {
    const {
      fieldValid
    } = this.state;
    fieldValid[fieldID] = valid;
    this.setState({
      fieldValid
    });
  }

  async verifyFieldsBeforeSubmit() {
    // Blur the active element if any, so we first run its blur validation,
    // which is less strict than the pass we're about to do below for all fields.
    const activeElement = document.activeElement;

    if (activeElement) {
      activeElement.blur();
    }

    const fieldIDsInDisplayOrder = [FIELD_OLD_PASSWORD, FIELD_NEW_PASSWORD, FIELD_NEW_PASSWORD_CONFIRM]; // Run all fields with stricter validation that no longer allows empty
    // values for required fields.

    for (const fieldID of fieldIDsInDisplayOrder) {
      const field = this[fieldID];

      if (!field) {
        continue;
      } // We must wait for these validations to finish before queueing
      // up the setState below so our setState goes in the queue after
      // all the setStates from these validate calls (that's how we
      // know they've finished).


      await field.validate({
        allowEmpty: false
      });
    } // Validation and state updates are async, so we need to wait for them to complete
    // first. Queue a `setState` callback and wait for it to resolve.


    await new Promise(resolve => this.setState({}, resolve));

    if (this.allFieldsValid()) {
      return true;
    }

    const invalidField = this.findFirstInvalidField(fieldIDsInDisplayOrder);

    if (!invalidField) {
      return true;
    } // Focus the first invalid field and show feedback in the stricter mode
    // that no longer allows empty values for required fields.


    invalidField.focus();
    invalidField.validate({
      allowEmpty: false,
      focused: true
    });
    return false;
  }

  allFieldsValid() {
    const keys = Object.keys(this.state.fieldValid);

    for (let i = 0; i < keys.length; ++i) {
      if (!this.state.fieldValid[keys[i]]) {
        return false;
      }
    }

    return true;
  }

  findFirstInvalidField(fieldIDs) {
    for (const fieldID of fieldIDs) {
      if (!this.state.fieldValid[fieldID] && this[fieldID]) {
        return this[fieldID];
      }
    }

    return null;
  }

  render() {
    const rowClassName = this.props.rowClassName;
    const buttonClassName = this.props.buttonClassName;

    switch (this.state.phase) {
      case Phase.Edit:
        return /*#__PURE__*/_react.default.createElement("form", {
          className: this.props.className,
          onSubmit: this.onClickChange
        }, /*#__PURE__*/_react.default.createElement("div", {
          className: rowClassName
        }, /*#__PURE__*/_react.default.createElement(_Field.default, {
          ref: field => this[FIELD_OLD_PASSWORD] = field,
          type: "password",
          label: (0, _languageHandler._t)('Current password'),
          value: this.state.oldPassword,
          onChange: this.onChangeOldPassword,
          onValidate: this.onOldPasswordValidate
        })), /*#__PURE__*/_react.default.createElement("div", {
          className: rowClassName
        }, /*#__PURE__*/_react.default.createElement(_PassphraseField.default, {
          fieldRef: field => this[FIELD_NEW_PASSWORD] = field,
          type: "password",
          label: "New Password",
          minScore: _RegistrationForm.PASSWORD_MIN_SCORE,
          value: this.state.newPassword,
          autoFocus: this.props.autoFocusNewPasswordInput,
          onChange: this.onChangeNewPassword,
          onValidate: this.onNewPasswordValidate,
          autoComplete: "new-password"
        })), /*#__PURE__*/_react.default.createElement("div", {
          className: rowClassName
        }, /*#__PURE__*/_react.default.createElement(_Field.default, {
          ref: field => this[FIELD_NEW_PASSWORD_CONFIRM] = field,
          type: "password",
          label: (0, _languageHandler._t)("Confirm password"),
          value: this.state.newPasswordConfirm,
          onChange: this.onChangeNewPasswordConfirm,
          onValidate: this.onNewPasswordConfirmValidate,
          autoComplete: "new-password"
        })), /*#__PURE__*/_react.default.createElement(_AccessibleButton.default, {
          className: buttonClassName,
          kind: this.props.buttonKind,
          onClick: this.onClickChange
        }, this.props.buttonLabel || (0, _languageHandler._t)('Change Password')));

      case Phase.Uploading:
        return /*#__PURE__*/_react.default.createElement("div", {
          className: "mx_Dialog_content"
        }, /*#__PURE__*/_react.default.createElement(_Spinner.default, null));
    }
  }

}, (0, _defineProperty2.default)(_class2, "defaultProps", {
  onFinished() {},

  onError() {},

  confirm: true
}), _temp)) || _class);
exports.default = ChangePassword;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL3NldHRpbmdzL0NoYW5nZVBhc3N3b3JkLnRzeCJdLCJuYW1lcyI6WyJGSUVMRF9PTERfUEFTU1dPUkQiLCJGSUVMRF9ORVdfUEFTU1dPUkQiLCJGSUVMRF9ORVdfUEFTU1dPUkRfQ09ORklSTSIsIlBoYXNlIiwiQ2hhbmdlUGFzc3dvcmQiLCJSZWFjdCIsIkNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJNb2RhbCIsImNyZWF0ZVRyYWNrZWREaWFsb2dBc3luYyIsIm1hdHJpeENsaWVudCIsIk1hdHJpeENsaWVudFBlZyIsImdldCIsImV2Iiwic2V0U3RhdGUiLCJvbGRQYXNzd29yZCIsInRhcmdldCIsInZhbHVlIiwiZmllbGRTdGF0ZSIsInJlc3VsdCIsInZhbGlkYXRlT2xkUGFzc3dvcmRSdWxlcyIsIm1hcmtGaWVsZFZhbGlkIiwidmFsaWQiLCJydWxlcyIsImtleSIsInRlc3QiLCJhbGxvd0VtcHR5IiwiaW52YWxpZCIsIm5ld1Bhc3N3b3JkIiwibmV3UGFzc3dvcmRDb25maXJtIiwidmFsaWRhdGVQYXNzd29yZENvbmZpcm1SdWxlcyIsInN0YXRlIiwicHJldmVudERlZmF1bHQiLCJhbGxGaWVsZHNWYWxpZCIsInZlcmlmeUZpZWxkc0JlZm9yZVN1Ym1pdCIsIkNvdW50bHlBbmFseXRpY3MiLCJpbnN0YW5jZSIsInRyYWNrIiwiY29uZmlybVBhc3N3b3JkIiwiZXJyIiwiY2hlY2tQYXNzd29yZCIsIm9uRXJyb3IiLCJvbkNoYW5nZVBhc3N3b3JkIiwiZmllbGRWYWxpZCIsInBoYXNlIiwiRWRpdCIsImNsaSIsImNvbmZpcm0iLCJjaGFuZ2VQYXNzd29yZCIsImNyZWF0ZVRyYWNrZWREaWFsb2ciLCJRdWVzdGlvbkRpYWxvZyIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJidXR0b24iLCJleHRyYUJ1dHRvbnMiLCJvbkV4cG9ydEUyZUtleXNDbGlja2VkIiwib25GaW5pc2hlZCIsImNvbmZpcm1lZCIsImF1dGhEaWN0IiwidHlwZSIsImlkZW50aWZpZXIiLCJ1c2VyIiwiY3JlZGVudGlhbHMiLCJ1c2VySWQiLCJwYXNzd29yZCIsIlVwbG9hZGluZyIsInNldFBhc3N3b3JkIiwidGhlbiIsInNob3VsZEFza0ZvckVtYWlsIiwib3B0aW9uYWxseVNldEVtYWlsIiwiZGlkU2V0RW1haWwiLCJmaW5hbGx5Iiwib2xkUGFzcyIsIm5ld1Bhc3MiLCJjb25maXJtUGFzcyIsImVycm9yIiwibGVuZ3RoIiwibW9kYWwiLCJTZXRFbWFpbERpYWxvZyIsImZpbmlzaGVkIiwiZmllbGRJRCIsImFjdGl2ZUVsZW1lbnQiLCJkb2N1bWVudCIsImJsdXIiLCJmaWVsZElEc0luRGlzcGxheU9yZGVyIiwiZmllbGQiLCJ2YWxpZGF0ZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiaW52YWxpZEZpZWxkIiwiZmluZEZpcnN0SW52YWxpZEZpZWxkIiwiZm9jdXMiLCJmb2N1c2VkIiwia2V5cyIsIk9iamVjdCIsImkiLCJmaWVsZElEcyIsInJlbmRlciIsInJvd0NsYXNzTmFtZSIsImJ1dHRvbkNsYXNzTmFtZSIsImNsYXNzTmFtZSIsIm9uQ2xpY2tDaGFuZ2UiLCJvbkNoYW5nZU9sZFBhc3N3b3JkIiwib25PbGRQYXNzd29yZFZhbGlkYXRlIiwiUEFTU1dPUkRfTUlOX1NDT1JFIiwiYXV0b0ZvY3VzTmV3UGFzc3dvcmRJbnB1dCIsIm9uQ2hhbmdlTmV3UGFzc3dvcmQiLCJvbk5ld1Bhc3N3b3JkVmFsaWRhdGUiLCJvbkNoYW5nZU5ld1Bhc3N3b3JkQ29uZmlybSIsIm9uTmV3UGFzc3dvcmRDb25maXJtVmFsaWRhdGUiLCJidXR0b25LaW5kIiwiYnV0dG9uTGFiZWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBaUJBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOzs7Ozs7OztBQUVBLE1BQU1BLGtCQUFrQixHQUFH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QTVDUjtBQWtESDs7QUF4VnVFLEMseURBQzFCO0FBQzFDVCxFQUFBQSxVQUFVLEdBQUcsQ0FBRSxDQUQyQjs7QUFFMUNmLEVBQUFBLE9BQU8sR0FBRyxDQUFFLENBRjhCOztBQUkxQ00sRUFBQUEsT0FBTyxFQUFFO0FBSmlDLEMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMTUsIDIwMTYgT3Blbk1hcmtldCBMdGRcbkNvcHlyaWdodCAyMDE4LTIwMTkgTmV3IFZlY3RvciBMdGRcblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgRmllbGQgZnJvbSBcIi4uL2VsZW1lbnRzL0ZpZWxkXCI7XG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50VHlwZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IE1hdHJpeENsaWVudFBlZyB9IGZyb20gXCIuLi8uLi8uLi9NYXRyaXhDbGllbnRQZWdcIjtcbmltcG9ydCBBY2Nlc3NpYmxlQnV0dG9uIGZyb20gJy4uL2VsZW1lbnRzL0FjY2Vzc2libGVCdXR0b24nO1xuaW1wb3J0IFNwaW5uZXIgZnJvbSAnLi4vZWxlbWVudHMvU3Bpbm5lcic7XG5pbXBvcnQgd2l0aFZhbGlkYXRpb24sIHsgSUZpZWxkU3RhdGUsIElWYWxpZGF0aW9uUmVzdWx0IH0gZnJvbSAnLi4vZWxlbWVudHMvVmFsaWRhdGlvbic7XG5pbXBvcnQgeyBfdCB9IGZyb20gJy4uLy4uLy4uL2xhbmd1YWdlSGFuZGxlcic7XG5pbXBvcnQgTW9kYWwgZnJvbSBcIi4uLy4uLy4uL01vZGFsXCI7XG5pbXBvcnQgUGFzc3BocmFzZUZpZWxkIGZyb20gXCIuLi9hdXRoL1Bhc3NwaHJhc2VGaWVsZFwiO1xuaW1wb3J0IENvdW50bHlBbmFseXRpY3MgZnJvbSBcIi4uLy4uLy4uL0NvdW50bHlBbmFseXRpY3NcIjtcbmltcG9ydCB7IHJlcGxhY2VhYmxlQ29tcG9uZW50IH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL3JlcGxhY2VhYmxlQ29tcG9uZW50XCI7XG5pbXBvcnQgeyBQQVNTV09SRF9NSU5fU0NPUkUgfSBmcm9tICcuLi9hdXRoL1JlZ2lzdHJhdGlvbkZvcm0nO1xuaW1wb3J0IHsgTWF0cml4Q2xpZW50IH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL2NsaWVudFwiO1xuaW1wb3J0IFNldEVtYWlsRGlhbG9nIGZyb20gXCIuLi9kaWFsb2dzL1NldEVtYWlsRGlhbG9nXCI7XG5pbXBvcnQgUXVlc3Rpb25EaWFsb2cgZnJvbSBcIi4uL2RpYWxvZ3MvUXVlc3Rpb25EaWFsb2dcIjtcblxuY29uc3QgRklFTERfT0xEX1BBU1NXT1JEID0gJ2ZpZWxkX29sZF9wYXNzd29yZCc7XG5jb25zdCBGSUVMRF9ORVdfUEFTU1dPUkQgPSAnZmllbGRfbmV3X3Bhc3N3b3JkJztcbmNvbnN0IEZJRUxEX05FV19QQVNTV09SRF9DT05GSVJNID0gJ2ZpZWxkX25ld19wYXNzd29yZF9jb25maXJtJztcblxuZW51bSBQaGFzZSB7XG4gICAgRWRpdCA9IFwiZWRpdFwiLFxuICAgIFVwbG9hZGluZyA9IFwidXBsb2FkaW5nXCIsXG4gICAgRXJyb3IgPSBcImVycm9yXCIsXG59XG5cbmludGVyZmFjZSBJUHJvcHMge1xuICAgIG9uRmluaXNoZWQ/OiAoeyBkaWRTZXRFbWFpbDogYm9vbGVhbiB9PykgPT4gdm9pZDtcbiAgICBvbkVycm9yPzogKGVycm9yOiB7ZXJyb3I6IHN0cmluZ30pID0+IHZvaWQ7XG4gICAgcm93Q2xhc3NOYW1lPzogc3RyaW5nO1xuICAgIGJ1dHRvbkNsYXNzTmFtZT86IHN0cmluZztcbiAgICBidXR0b25LaW5kPzogc3RyaW5nO1xuICAgIGJ1dHRvbkxhYmVsPzogc3RyaW5nO1xuICAgIGNvbmZpcm0/OiBib29sZWFuO1xuICAgIC8vIFdoZXRoZXIgdG8gYXV0b0ZvY3VzIHRoZSBuZXcgcGFzc3dvcmQgaW5wdXRcbiAgICBhdXRvRm9jdXNOZXdQYXNzd29yZElucHV0PzogYm9vbGVhbjtcbiAgICBjbGFzc05hbWU/OiBzdHJpbmc7XG4gICAgc2hvdWxkQXNrRm9yRW1haWw/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgSVN0YXRlIHtcbiAgICBmaWVsZFZhbGlkOiB7fTtcbiAgICBwaGFzZTogUGhhc2U7XG4gICAgb2xkUGFzc3dvcmQ6IHN0cmluZztcbiAgICBuZXdQYXNzd29yZDogc3RyaW5nO1xuICAgIG5ld1Bhc3N3b3JkQ29uZmlybTogc3RyaW5nO1xufVxuXG5AcmVwbGFjZWFibGVDb21wb25lbnQoXCJ2aWV3cy5zZXR0aW5ncy5DaGFuZ2VQYXNzd29yZFwiKVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hhbmdlUGFzc3dvcmQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8SVByb3BzLCBJU3RhdGU+IHtcbiAgICBwdWJsaWMgc3RhdGljIGRlZmF1bHRQcm9wczogUGFydGlhbDxJUHJvcHM+ID0ge1xuICAgICAgICBvbkZpbmlzaGVkKCkge30sXG4gICAgICAgIG9uRXJyb3IoKSB7fSxcblxuICAgICAgICBjb25maXJtOiB0cnVlLFxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wczogSVByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZmllbGRWYWxpZDoge30sXG4gICAgICAgICAgICBwaGFzZTogUGhhc2UuRWRpdCxcbiAgICAgICAgICAgIG9sZFBhc3N3b3JkOiBcIlwiLFxuICAgICAgICAgICAgbmV3UGFzc3dvcmQ6IFwiXCIsXG4gICAgICAgICAgICBuZXdQYXNzd29yZENvbmZpcm06IFwiXCIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvbkNoYW5nZVBhc3N3b3JkKG9sZFBhc3N3b3JkOiBzdHJpbmcsIG5ld1Bhc3N3b3JkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY2xpID0gTWF0cml4Q2xpZW50UGVnLmdldCgpO1xuXG4gICAgICAgIGlmICghdGhpcy5wcm9wcy5jb25maXJtKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVBhc3N3b3JkKGNsaSwgb2xkUGFzc3dvcmQsIG5ld1Bhc3N3b3JkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIE1vZGFsLmNyZWF0ZVRyYWNrZWREaWFsb2coJ0NoYW5nZSBQYXNzd29yZCcsICcnLCBRdWVzdGlvbkRpYWxvZywge1xuICAgICAgICAgICAgdGl0bGU6IF90KFwiV2FybmluZyFcIiksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICB7IF90KFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NoYW5naW5nIHBhc3N3b3JkIHdpbGwgY3VycmVudGx5IHJlc2V0IGFueSBlbmQtdG8tZW5kIGVuY3J5cHRpb24ga2V5cyBvbiBhbGwgc2Vzc2lvbnMsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21ha2luZyBlbmNyeXB0ZWQgY2hhdCBoaXN0b3J5IHVucmVhZGFibGUsIHVubGVzcyB5b3UgZmlyc3QgZXhwb3J0IHlvdXIgcm9vbSBrZXlzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FuZCByZS1pbXBvcnQgdGhlbSBhZnRlcndhcmRzLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdJbiBmdXR1cmUgdGhpcyB3aWxsIGJlIGltcHJvdmVkLicsXG4gICAgICAgICAgICAgICAgICAgICkgfVxuICAgICAgICAgICAgICAgICAgICB7ICcgJyB9XG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vdmVjdG9yLWltL2VsZW1lbnQtd2ViL2lzc3Vlcy8yNjcxXCIgdGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9yZWZlcnJlciBub29wZW5lclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZlY3Rvci1pbS9lbGVtZW50LXdlYi9pc3N1ZXMvMjY3MVxuICAgICAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgPC9kaXY+LFxuICAgICAgICAgICAgYnV0dG9uOiBfdChcIkNvbnRpbnVlXCIpLFxuICAgICAgICAgICAgZXh0cmFCdXR0b25zOiBbXG4gICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICBrZXk9XCJleHBvcnRSb29tS2V5c1wiXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIm14X0RpYWxvZ19wcmltYXJ5XCJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5vbkV4cG9ydEUyZUtleXNDbGlja2VkfVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgeyBfdCgnRXhwb3J0IEUyRSByb29tIGtleXMnKSB9XG4gICAgICAgICAgICAgICAgPC9idXR0b24+LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIG9uRmluaXNoZWQ6IChjb25maXJtZWQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlybWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlUGFzc3dvcmQoY2xpLCBvbGRQYXNzd29yZCwgbmV3UGFzc3dvcmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgY2hhbmdlUGFzc3dvcmQoY2xpOiBNYXRyaXhDbGllbnQsIG9sZFBhc3N3b3JkOiBzdHJpbmcsIG5ld1Bhc3N3b3JkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgYXV0aERpY3QgPSB7XG4gICAgICAgICAgICB0eXBlOiAnbS5sb2dpbi5wYXNzd29yZCcsXG4gICAgICAgICAgICBpZGVudGlmaWVyOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ20uaWQudXNlcicsXG4gICAgICAgICAgICAgICAgdXNlcjogY2xpLmNyZWRlbnRpYWxzLnVzZXJJZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgYHVzZXJgIG9uY2Ugc2VydmVycyBzdXBwb3J0IHByb3BlciBVSUFcbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWF0cml4LW9yZy9zeW5hcHNlL2lzc3Vlcy81NjY1XG4gICAgICAgICAgICB1c2VyOiBjbGkuY3JlZGVudGlhbHMudXNlcklkLFxuICAgICAgICAgICAgcGFzc3dvcmQ6IG9sZFBhc3N3b3JkLFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgcGhhc2U6IFBoYXNlLlVwbG9hZGluZyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2xpLnNldFBhc3N3b3JkKGF1dGhEaWN0LCBuZXdQYXNzd29yZCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5zaG91bGRBc2tGb3JFbWFpbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbmFsbHlTZXRFbWFpbCgpLnRoZW4oKGNvbmZpcm1lZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uRmluaXNoZWQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlkU2V0RW1haWw6IGNvbmZpcm1lZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25GaW5pc2hlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBwaGFzZTogUGhhc2UuRWRpdCxcbiAgICAgICAgICAgICAgICBvbGRQYXNzd29yZDogXCJcIixcbiAgICAgICAgICAgICAgICBuZXdQYXNzd29yZDogXCJcIixcbiAgICAgICAgICAgICAgICBuZXdQYXNzd29yZENvbmZpcm06IFwiXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjaGVja1Bhc3N3b3JkKG9sZFBhc3M6IHN0cmluZywgbmV3UGFzczogc3RyaW5nLCBjb25maXJtUGFzczogc3RyaW5nKToge2Vycm9yOiBzdHJpbmd9IHtcbiAgICAgICAgaWYgKG5ld1Bhc3MgIT09IGNvbmZpcm1QYXNzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGVycm9yOiBfdChcIk5ldyBwYXNzd29yZHMgZG9uJ3QgbWF0Y2hcIiksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKCFuZXdQYXNzIHx8IG5ld1Bhc3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGVycm9yOiBfdChcIlBhc3N3b3JkcyBjYW4ndCBiZSBlbXB0eVwiKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIG9wdGlvbmFsbHlTZXRFbWFpbCgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgLy8gQXNrIGZvciBhbiBlbWFpbCBvdGhlcndpc2UgdGhlIHVzZXIgaGFzIG5vIHdheSB0byByZXNldCB0aGVpciBwYXNzd29yZFxuICAgICAgICBjb25zdCBtb2RhbCA9IE1vZGFsLmNyZWF0ZVRyYWNrZWREaWFsb2coJ0RvIHlvdSB3YW50IHRvIHNldCBhbiBlbWFpbCBhZGRyZXNzPycsICcnLCBTZXRFbWFpbERpYWxvZywge1xuICAgICAgICAgICAgdGl0bGU6IF90KCdEbyB5b3Ugd2FudCB0byBzZXQgYW4gZW1haWwgYWRkcmVzcz8nKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtb2RhbC5maW5pc2hlZC50aGVuKChbY29uZmlybWVkXSkgPT4gY29uZmlybWVkKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uRXhwb3J0RTJlS2V5c0NsaWNrZWQgPSAoKTogdm9pZCA9PiB7XG4gICAgICAgIE1vZGFsLmNyZWF0ZVRyYWNrZWREaWFsb2dBc3luYygnRXhwb3J0IEUyRSBLZXlzJywgJ0NoYW5nZSBQYXNzd29yZCcsXG4gICAgICAgICAgICBpbXBvcnQoXG4gICAgICAgICAgICAgICAgJy4uLy4uLy4uL2FzeW5jLWNvbXBvbmVudHMvdmlld3MvZGlhbG9ncy9zZWN1cml0eS9FeHBvcnRFMmVLZXlzRGlhbG9nJ1xuICAgICAgICAgICAgKSBhcyB1bmtub3duIGFzIFByb21pc2U8Q29tcG9uZW50VHlwZTx7fT4+LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1hdHJpeENsaWVudDogTWF0cml4Q2xpZW50UGVnLmdldCgpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBtYXJrRmllbGRWYWxpZChmaWVsZElEOiBzdHJpbmcsIHZhbGlkOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHsgZmllbGRWYWxpZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgZmllbGRWYWxpZFtmaWVsZElEXSA9IHZhbGlkO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZpZWxkVmFsaWQsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgb25DaGFuZ2VPbGRQYXNzd29yZCA9IChldjogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pOiB2b2lkID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBvbGRQYXNzd29yZDogZXYudGFyZ2V0LnZhbHVlLFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbk9sZFBhc3N3b3JkVmFsaWRhdGUgPSBhc3luYyAoZmllbGRTdGF0ZTogSUZpZWxkU3RhdGUpOiBQcm9taXNlPElWYWxpZGF0aW9uUmVzdWx0PiA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMudmFsaWRhdGVPbGRQYXNzd29yZFJ1bGVzKGZpZWxkU3RhdGUpO1xuICAgICAgICB0aGlzLm1hcmtGaWVsZFZhbGlkKEZJRUxEX09MRF9QQVNTV09SRCwgcmVzdWx0LnZhbGlkKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSB2YWxpZGF0ZU9sZFBhc3N3b3JkUnVsZXMgPSB3aXRoVmFsaWRhdGlvbih7XG4gICAgICAgIHJ1bGVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAga2V5OiBcInJlcXVpcmVkXCIsXG4gICAgICAgICAgICAgICAgdGVzdDogKHsgdmFsdWUsIGFsbG93RW1wdHkgfSkgPT4gYWxsb3dFbXB0eSB8fCAhIXZhbHVlLFxuICAgICAgICAgICAgICAgIGludmFsaWQ6ICgpID0+IF90KFwiUGFzc3dvcmRzIGNhbid0IGJlIGVtcHR5XCIpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICB9KTtcblxuICAgIHByaXZhdGUgb25DaGFuZ2VOZXdQYXNzd29yZCA9IChldjogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pOiB2b2lkID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBuZXdQYXNzd29yZDogZXYudGFyZ2V0LnZhbHVlLFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbk5ld1Bhc3N3b3JkVmFsaWRhdGUgPSAocmVzdWx0OiBJVmFsaWRhdGlvblJlc3VsdCk6IHZvaWQgPT4ge1xuICAgICAgICB0aGlzLm1hcmtGaWVsZFZhbGlkKEZJRUxEX05FV19QQVNTV09SRCwgcmVzdWx0LnZhbGlkKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbkNoYW5nZU5ld1Bhc3N3b3JkQ29uZmlybSA9IChldjogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pOiB2b2lkID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBuZXdQYXNzd29yZENvbmZpcm06IGV2LnRhcmdldC52YWx1ZSxcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25OZXdQYXNzd29yZENvbmZpcm1WYWxpZGF0ZSA9IGFzeW5jIChmaWVsZFN0YXRlOiBJRmllbGRTdGF0ZSk6IFByb21pc2U8SVZhbGlkYXRpb25SZXN1bHQ+ID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy52YWxpZGF0ZVBhc3N3b3JkQ29uZmlybVJ1bGVzKGZpZWxkU3RhdGUpO1xuICAgICAgICB0aGlzLm1hcmtGaWVsZFZhbGlkKEZJRUxEX05FV19QQVNTV09SRF9DT05GSVJNLCByZXN1bHQudmFsaWQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBwcml2YXRlIHZhbGlkYXRlUGFzc3dvcmRDb25maXJtUnVsZXMgPSB3aXRoVmFsaWRhdGlvbjx0aGlzPih7XG4gICAgICAgIHJ1bGVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAga2V5OiBcInJlcXVpcmVkXCIsXG4gICAgICAgICAgICAgICAgdGVzdDogKHsgdmFsdWUsIGFsbG93RW1wdHkgfSkgPT4gYWxsb3dFbXB0eSB8fCAhIXZhbHVlLFxuICAgICAgICAgICAgICAgIGludmFsaWQ6ICgpID0+IF90KFwiQ29uZmlybSBwYXNzd29yZFwiKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAga2V5OiBcIm1hdGNoXCIsXG4gICAgICAgICAgICAgICAgdGVzdCh7IHZhbHVlIH0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICF2YWx1ZSB8fCB2YWx1ZSA9PT0gdGhpcy5zdGF0ZS5uZXdQYXNzd29yZDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGludmFsaWQ6ICgpID0+IF90KFwiUGFzc3dvcmRzIGRvbid0IG1hdGNoXCIpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICB9KTtcblxuICAgIHByaXZhdGUgb25DbGlja0NoYW5nZSA9IGFzeW5jIChldjogUmVhY3QuTW91c2VFdmVudCB8IFJlYWN0LkZvcm1FdmVudCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGNvbnN0IGFsbEZpZWxkc1ZhbGlkID0gYXdhaXQgdGhpcy52ZXJpZnlGaWVsZHNCZWZvcmVTdWJtaXQoKTtcbiAgICAgICAgaWYgKCFhbGxGaWVsZHNWYWxpZCkge1xuICAgICAgICAgICAgQ291bnRseUFuYWx5dGljcy5pbnN0YW5jZS50cmFjayhcIm9uYm9hcmRpbmdfcmVnaXN0cmF0aW9uX3N1Ym1pdF9mYWlsZWRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvbGRQYXNzd29yZCA9IHRoaXMuc3RhdGUub2xkUGFzc3dvcmQ7XG4gICAgICAgIGNvbnN0IG5ld1Bhc3N3b3JkID0gdGhpcy5zdGF0ZS5uZXdQYXNzd29yZDtcbiAgICAgICAgY29uc3QgY29uZmlybVBhc3N3b3JkID0gdGhpcy5zdGF0ZS5uZXdQYXNzd29yZENvbmZpcm07XG4gICAgICAgIGNvbnN0IGVyciA9IHRoaXMuY2hlY2tQYXNzd29yZChcbiAgICAgICAgICAgIG9sZFBhc3N3b3JkLCBuZXdQYXNzd29yZCwgY29uZmlybVBhc3N3b3JkLFxuICAgICAgICApO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2VQYXNzd29yZChvbGRQYXNzd29yZCwgbmV3UGFzc3dvcmQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByaXZhdGUgYXN5bmMgdmVyaWZ5RmllbGRzQmVmb3JlU3VibWl0KCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICAvLyBCbHVyIHRoZSBhY3RpdmUgZWxlbWVudCBpZiBhbnksIHNvIHdlIGZpcnN0IHJ1biBpdHMgYmx1ciB2YWxpZGF0aW9uLFxuICAgICAgICAvLyB3aGljaCBpcyBsZXNzIHN0cmljdCB0aGFuIHRoZSBwYXNzIHdlJ3JlIGFib3V0IHRvIGRvIGJlbG93IGZvciBhbGwgZmllbGRzLlxuICAgICAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBhcyBIVE1MRWxlbWVudDtcbiAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmllbGRJRHNJbkRpc3BsYXlPcmRlciA9IFtcbiAgICAgICAgICAgIEZJRUxEX09MRF9QQVNTV09SRCxcbiAgICAgICAgICAgIEZJRUxEX05FV19QQVNTV09SRCxcbiAgICAgICAgICAgIEZJRUxEX05FV19QQVNTV09SRF9DT05GSVJNLFxuICAgICAgICBdO1xuXG4gICAgICAgIC8vIFJ1biBhbGwgZmllbGRzIHdpdGggc3RyaWN0ZXIgdmFsaWRhdGlvbiB0aGF0IG5vIGxvbmdlciBhbGxvd3MgZW1wdHlcbiAgICAgICAgLy8gdmFsdWVzIGZvciByZXF1aXJlZCBmaWVsZHMuXG4gICAgICAgIGZvciAoY29uc3QgZmllbGRJRCBvZiBmaWVsZElEc0luRGlzcGxheU9yZGVyKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXNbZmllbGRJRF07XG4gICAgICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBtdXN0IHdhaXQgZm9yIHRoZXNlIHZhbGlkYXRpb25zIHRvIGZpbmlzaCBiZWZvcmUgcXVldWVpbmdcbiAgICAgICAgICAgIC8vIHVwIHRoZSBzZXRTdGF0ZSBiZWxvdyBzbyBvdXIgc2V0U3RhdGUgZ29lcyBpbiB0aGUgcXVldWUgYWZ0ZXJcbiAgICAgICAgICAgIC8vIGFsbCB0aGUgc2V0U3RhdGVzIGZyb20gdGhlc2UgdmFsaWRhdGUgY2FsbHMgKHRoYXQncyBob3cgd2VcbiAgICAgICAgICAgIC8vIGtub3cgdGhleSd2ZSBmaW5pc2hlZCkuXG4gICAgICAgICAgICBhd2FpdCBmaWVsZC52YWxpZGF0ZSh7IGFsbG93RW1wdHk6IGZhbHNlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGlvbiBhbmQgc3RhdGUgdXBkYXRlcyBhcmUgYXN5bmMsIHNvIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlbSB0byBjb21wbGV0ZVxuICAgICAgICAvLyBmaXJzdC4gUXVldWUgYSBgc2V0U3RhdGVgIGNhbGxiYWNrIGFuZCB3YWl0IGZvciBpdCB0byByZXNvbHZlLlxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4gdGhpcy5zZXRTdGF0ZSh7fSwgcmVzb2x2ZSkpO1xuXG4gICAgICAgIGlmICh0aGlzLmFsbEZpZWxkc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW52YWxpZEZpZWxkID0gdGhpcy5maW5kRmlyc3RJbnZhbGlkRmllbGQoZmllbGRJRHNJbkRpc3BsYXlPcmRlcik7XG5cbiAgICAgICAgaWYgKCFpbnZhbGlkRmllbGQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9jdXMgdGhlIGZpcnN0IGludmFsaWQgZmllbGQgYW5kIHNob3cgZmVlZGJhY2sgaW4gdGhlIHN0cmljdGVyIG1vZGVcbiAgICAgICAgLy8gdGhhdCBubyBsb25nZXIgYWxsb3dzIGVtcHR5IHZhbHVlcyBmb3IgcmVxdWlyZWQgZmllbGRzLlxuICAgICAgICBpbnZhbGlkRmllbGQuZm9jdXMoKTtcbiAgICAgICAgaW52YWxpZEZpZWxkLnZhbGlkYXRlKHsgYWxsb3dFbXB0eTogZmFsc2UsIGZvY3VzZWQ6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFsbEZpZWxkc1ZhbGlkKCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5zdGF0ZS5maWVsZFZhbGlkKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhdGUuZmllbGRWYWxpZFtrZXlzW2ldXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGZpbmRGaXJzdEludmFsaWRGaWVsZChmaWVsZElEczogc3RyaW5nW10pOiBGaWVsZCB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGRJRCBvZiBmaWVsZElEcykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmZpZWxkVmFsaWRbZmllbGRJRF0gJiYgdGhpc1tmaWVsZElEXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2ZpZWxkSURdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHB1YmxpYyByZW5kZXIoKTogSlNYLkVsZW1lbnQge1xuICAgICAgICBjb25zdCByb3dDbGFzc05hbWUgPSB0aGlzLnByb3BzLnJvd0NsYXNzTmFtZTtcbiAgICAgICAgY29uc3QgYnV0dG9uQ2xhc3NOYW1lID0gdGhpcy5wcm9wcy5idXR0b25DbGFzc05hbWU7XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlLnBoYXNlKSB7XG4gICAgICAgICAgICBjYXNlIFBoYXNlLkVkaXQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgPGZvcm0gY2xhc3NOYW1lPXt0aGlzLnByb3BzLmNsYXNzTmFtZX0gb25TdWJtaXQ9e3RoaXMub25DbGlja0NoYW5nZX0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17cm93Q2xhc3NOYW1lfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RmllbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmPXtmaWVsZCA9PiB0aGlzW0ZJRUxEX09MRF9QQVNTV09SRF0gPSBmaWVsZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInBhc3N3b3JkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9e190KCdDdXJyZW50IHBhc3N3b3JkJyl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLm9sZFBhc3N3b3JkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5vbkNoYW5nZU9sZFBhc3N3b3JkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblZhbGlkYXRlPXt0aGlzLm9uT2xkUGFzc3dvcmRWYWxpZGF0ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17cm93Q2xhc3NOYW1lfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UGFzc3BocmFzZUZpZWxkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkUmVmPXtmaWVsZCA9PiB0aGlzW0ZJRUxEX05FV19QQVNTV09SRF0gPSBmaWVsZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInBhc3N3b3JkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9J05ldyBQYXNzd29yZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluU2NvcmU9e1BBU1NXT1JEX01JTl9TQ09SRX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3RoaXMuc3RhdGUubmV3UGFzc3dvcmR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9Gb2N1cz17dGhpcy5wcm9wcy5hdXRvRm9jdXNOZXdQYXNzd29yZElucHV0fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5vbkNoYW5nZU5ld1Bhc3N3b3JkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblZhbGlkYXRlPXt0aGlzLm9uTmV3UGFzc3dvcmRWYWxpZGF0ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b0NvbXBsZXRlPVwibmV3LXBhc3N3b3JkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17cm93Q2xhc3NOYW1lfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RmllbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmPXtmaWVsZCA9PiB0aGlzW0ZJRUxEX05FV19QQVNTV09SRF9DT05GSVJNXSA9IGZpZWxkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwicGFzc3dvcmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD17X3QoXCJDb25maXJtIHBhc3N3b3JkXCIpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dGhpcy5zdGF0ZS5uZXdQYXNzd29yZENvbmZpcm19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uQ2hhbmdlTmV3UGFzc3dvcmRDb25maXJtfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblZhbGlkYXRlPXt0aGlzLm9uTmV3UGFzc3dvcmRDb25maXJtVmFsaWRhdGV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9Db21wbGV0ZT1cIm5ldy1wYXNzd29yZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPEFjY2Vzc2libGVCdXR0b24gY2xhc3NOYW1lPXtidXR0b25DbGFzc05hbWV9IGtpbmQ9e3RoaXMucHJvcHMuYnV0dG9uS2luZH0gb25DbGljaz17dGhpcy5vbkNsaWNrQ2hhbmdlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHRoaXMucHJvcHMuYnV0dG9uTGFiZWwgfHwgX3QoJ0NoYW5nZSBQYXNzd29yZCcpIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvQWNjZXNzaWJsZUJ1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPC9mb3JtPlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjYXNlIFBoYXNlLlVwbG9hZGluZzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm14X0RpYWxvZ19jb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8U3Bpbm5lciAvPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19