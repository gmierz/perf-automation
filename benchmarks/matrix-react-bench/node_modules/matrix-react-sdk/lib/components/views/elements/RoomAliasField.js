"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _languageHandler = require("../../../languageHandler");

var _Validation = _interopRequireDefault(require("./Validation"));

var _MatrixClientPeg = require("../../../MatrixClientPeg");

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _Field = _interopRequireDefault(require("./Field"));

var _dec, _class;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

let RoomAliasField = ( // Controlled form component wrapping Field for inputting a room alias scoped to a given domain
_dec = (0, _replaceableComponent.replaceableComponent)("views.elements.RoomAliasField"), _dec(_class = class RoomAliasField extends _react.default.PureComponent {
  constructor(props, context) {
    super(props, context);
    (0, _defineProperty2.default)(this, "fieldRef", /*#__PURE__*/(0, _react.createRef)());
    (0, _defineProperty2.default)(this, "onChange", ev => {
      if (this.props.onChange) {
        this.props.onChange(this.asFullAlias(ev.target.value));
      }
    });
    (0, _defineProperty2.default)(this, "onValidate", async fieldState => {
      const result = await this.validationRules(fieldState);
      this.setState({
        isValid: result.valid
      });
      return result;
    });
    (0, _defineProperty2.default)(this, "validationRules", (0, _Validation.default)({
      rules: [{
        key: "safeLocalpart",
        test: async ({
          value
        }) => {
          if (!value) {
            return true;
          }

          const fullAlias = this.asFullAlias(value); // XXX: FIXME https://github.com/matrix-org/matrix-doc/issues/668

          return !value.includes("#") && !value.includes(":") && !value.includes(",") && encodeURI(fullAlias) === fullAlias;
        },
        invalid: () => (0, _languageHandler._t)("Some characters not allowed")
      }, {
        key: "required",
        test: async ({
          value,
          allowEmpty
        }) => allowEmpty || !!value,
        invalid: () => (0, _languageHandler._t)("Please provide an address")
      }, {
        key: "taken",
        final: true,
        test: async ({
          value
        }) => {
          if (!value) {
            return true;
          }

          const client = _MatrixClientPeg.MatrixClientPeg.get();

          try {
            await client.getRoomIdForAlias(this.asFullAlias(value)); // we got a room id, so the alias is taken

            return false;
          } catch (err) {
            // any server error code will do,
            // either it M_NOT_FOUND or the alias is invalid somehow,
            // in which case we don't want to show the invalid message
            return !!err.errcode;
          }
        },
        valid: () => (0, _languageHandler._t)("This address is available to use"),
        invalid: () => (0, _languageHandler._t)("This address is already in use")
      }]
    }));
    this.state = {
      isValid: true
    };
  }

  asFullAlias(localpart) {
    return `#${localpart}:${this.props.domain}`;
  }

  render() {
    const poundSign = /*#__PURE__*/_react.default.createElement("span", null, "#");

    const aliasPostfix = ":" + this.props.domain;

    const domain = /*#__PURE__*/_react.default.createElement("span", {
      title: aliasPostfix
    }, aliasPostfix);

    const maxlength = 255 - this.props.domain.length - 2; // 2 for # and :

    return /*#__PURE__*/_react.default.createElement(_Field.default, {
      label: this.props.label || (0, _languageHandler._t)("Room address"),
      className: "mx_RoomAliasField",
      prefixComponent: poundSign,
      postfixComponent: domain,
      ref: this.fieldRef,
      onValidate: this.onValidate,
      placeholder: this.props.placeholder || (0, _languageHandler._t)("e.g. my-room"),
      onChange: this.onChange,
      value: this.props.value.substring(1, this.props.value.length - this.props.domain.length - 1),
      maxLength: maxlength,
      disabled: this.props.disabled,
      autoComplete: "off",
      onKeyDown: this.props.onKeyDown
    });
  }

  get isValid() {
    return this.state.isValid;
  }

  validate(options) {
    var _this$fieldRef$curren;

    return (_this$fieldRef$curren = this.fieldRef.current) === null || _this$fieldRef$curren === void 0 ? void 0 : _this$fieldRef$curren.validate(options);
  }

  focus() {
    var _this$fieldRef$curren2;

    (_this$fieldRef$curren2 = this.fieldRef.current) === null || _this$fieldRef$curren2 === void 0 ? void 0 : _this$fieldRef$curren2.focus();
  }

}) || _class);
exports.default = RoomAliasField;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2VsZW1lbnRzL1Jvb21BbGlhc0ZpZWxkLnRzeCJdLCJuYW1lcyI6WyJSb29tQWxpYXNGaWVsZCIsIlJlYWN0IiwiUHVyZUNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJjb250ZXh0IiwiZXYiLCJvbkNoYW5nZSIsImFzRnVsbEFsaWFzIiwidGFyZ2V0IiwidmFsdWUiLCJmaWVsZFN0YXRlIiwicmVzdWx0IiwidmFsaWRhdGlvblJ1bGVzIiwic2V0U3RhdGUiLCJpc1ZhbGlkIiwidmFsaWQiLCJydWxlcyIsImtleSIsInRlc3QiLCJmdWxsQWxpYXMiLCJpbmNsdWRlcyIsImVuY29kZVVSSSIsImludmFsaWQiLCJhbGxvd0VtcHR5IiwiZmluYWwiLCJjbGllbnQiLCJNYXRyaXhDbGllbnRQZWciLCJnZXQiLCJnZXRSb29tSWRGb3JBbGlhcyIsImVyciIsImVycmNvZGUiLCJzdGF0ZSIsImxvY2FscGFydCIsImRvbWFpbiIsInJlbmRlciIsInBvdW5kU2lnbiIsImFsaWFzUG9zdGZpeCIsIm1heGxlbmd0aCIsImxlbmd0aCIsImxhYmVsIiwiZmllbGRSZWYiLCJvblZhbGlkYXRlIiwicGxhY2Vob2xkZXIiLCJzdWJzdHJpbmciLCJkaXNhYmxlZCIsIm9uS2V5RG93biIsInZhbGlkYXRlIiwib3B0aW9ucyIsImN1cnJlbnQiLCJmb2N1cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFnQkE7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7O0lBa0JxQkEsYyxLQUZyQjtPQUNDLGdEQUFxQiwrQkFBckIsQyxnQkFBRCxNQUNxQkEsY0FEckIsU0FDNENDLGVBQU1DLGFBRGxELENBQ2dGO0FBRzVFQyxFQUFBQSxXQUFXLENBQUNDLEtBQUQsRUFBUUMsT0FBUixFQUFpQjtBQUN4QixVQUFNRCxLQUFOLEVBQWFDLE9BQWI7QUFEd0IsaUVBRlQsdUJBRVM7QUFBQSxvREFvQ1JD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QUF5QjtBQUFBOztBQUNwQyxvQ0FBTyxLQUFLUCxRQUFMLENBQWNRLE9BQXJCLDBEQUFPLHNCQUF1QkYsUUFBdkIsQ0FBZ0NDLE9BQWhDLENBQVA7QUFDSDs7QUFFTUUsRUFBQUEsS0FBSyxHQUFHO0FBQUE7O0FBQ1gsbUNBQUtULFFBQUwsQ0FBY1EsT0FBZCxrRkFBdUJDLEtBQXZCO0FBQ0g7O0FBeEcyRSxDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE5IC0gMjAyMSBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVSZWYsIEtleWJvYXJkRXZlbnRIYW5kbGVyIH0gZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCB7IF90IH0gZnJvbSAnLi4vLi4vLi4vbGFuZ3VhZ2VIYW5kbGVyJztcbmltcG9ydCB3aXRoVmFsaWRhdGlvbiBmcm9tICcuL1ZhbGlkYXRpb24nO1xuaW1wb3J0IHsgTWF0cml4Q2xpZW50UGVnIH0gZnJvbSAnLi4vLi4vLi4vTWF0cml4Q2xpZW50UGVnJztcbmltcG9ydCB7IHJlcGxhY2VhYmxlQ29tcG9uZW50IH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL3JlcGxhY2VhYmxlQ29tcG9uZW50XCI7XG5pbXBvcnQgRmllbGQsIHsgSVZhbGlkYXRlT3B0cyB9IGZyb20gXCIuL0ZpZWxkXCI7XG5cbmludGVyZmFjZSBJUHJvcHMge1xuICAgIGRvbWFpbjogc3RyaW5nO1xuICAgIHZhbHVlOiBzdHJpbmc7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gICAgZGlzYWJsZWQ/OiBib29sZWFuO1xuICAgIG9uS2V5RG93bj86IEtleWJvYXJkRXZlbnRIYW5kbGVyO1xuICAgIG9uQ2hhbmdlPyh2YWx1ZTogc3RyaW5nKTogdm9pZDtcbn1cblxuaW50ZXJmYWNlIElTdGF0ZSB7XG4gICAgaXNWYWxpZDogYm9vbGVhbjtcbn1cblxuLy8gQ29udHJvbGxlZCBmb3JtIGNvbXBvbmVudCB3cmFwcGluZyBGaWVsZCBmb3IgaW5wdXR0aW5nIGEgcm9vbSBhbGlhcyBzY29wZWQgdG8gYSBnaXZlbiBkb21haW5cbkByZXBsYWNlYWJsZUNvbXBvbmVudChcInZpZXdzLmVsZW1lbnRzLlJvb21BbGlhc0ZpZWxkXCIpXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb29tQWxpYXNGaWVsZCBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8SVByb3BzLCBJU3RhdGU+IHtcbiAgICBwcml2YXRlIGZpZWxkUmVmID0gY3JlYXRlUmVmPEZpZWxkPigpO1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIocHJvcHMsIGNvbnRleHQpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBpc1ZhbGlkOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgYXNGdWxsQWxpYXMobG9jYWxwYXJ0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gYCMke2xvY2FscGFydH06JHt0aGlzLnByb3BzLmRvbWFpbn1gO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgcG91bmRTaWduID0gKDxzcGFuPiM8L3NwYW4+KTtcbiAgICAgICAgY29uc3QgYWxpYXNQb3N0Zml4ID0gXCI6XCIgKyB0aGlzLnByb3BzLmRvbWFpbjtcbiAgICAgICAgY29uc3QgZG9tYWluID0gKDxzcGFuIHRpdGxlPXthbGlhc1Bvc3RmaXh9PnsgYWxpYXNQb3N0Zml4IH08L3NwYW4+KTtcbiAgICAgICAgY29uc3QgbWF4bGVuZ3RoID0gMjU1IC0gdGhpcy5wcm9wcy5kb21haW4ubGVuZ3RoIC0gMjsgICAvLyAyIGZvciAjIGFuZCA6XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8RmllbGRcbiAgICAgICAgICAgICAgICBsYWJlbD17dGhpcy5wcm9wcy5sYWJlbCB8fCBfdChcIlJvb20gYWRkcmVzc1wiKX1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJteF9Sb29tQWxpYXNGaWVsZFwiXG4gICAgICAgICAgICAgICAgcHJlZml4Q29tcG9uZW50PXtwb3VuZFNpZ259XG4gICAgICAgICAgICAgICAgcG9zdGZpeENvbXBvbmVudD17ZG9tYWlufVxuICAgICAgICAgICAgICAgIHJlZj17dGhpcy5maWVsZFJlZn1cbiAgICAgICAgICAgICAgICBvblZhbGlkYXRlPXt0aGlzLm9uVmFsaWRhdGV9XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9e3RoaXMucHJvcHMucGxhY2Vob2xkZXIgfHwgX3QoXCJlLmcuIG15LXJvb21cIil9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25DaGFuZ2V9XG4gICAgICAgICAgICAgICAgdmFsdWU9e3RoaXMucHJvcHMudmFsdWUuc3Vic3RyaW5nKDEsIHRoaXMucHJvcHMudmFsdWUubGVuZ3RoIC0gdGhpcy5wcm9wcy5kb21haW4ubGVuZ3RoIC0gMSl9XG4gICAgICAgICAgICAgICAgbWF4TGVuZ3RoPXttYXhsZW5ndGh9XG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ9e3RoaXMucHJvcHMuZGlzYWJsZWR9XG4gICAgICAgICAgICAgICAgYXV0b0NvbXBsZXRlPVwib2ZmXCJcbiAgICAgICAgICAgICAgICBvbktleURvd249e3RoaXMucHJvcHMub25LZXlEb3dufVxuICAgICAgICAgICAgLz5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uQ2hhbmdlID0gKGV2KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHRoaXMuYXNGdWxsQWxpYXMoZXYudGFyZ2V0LnZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvblZhbGlkYXRlID0gYXN5bmMgKGZpZWxkU3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy52YWxpZGF0aW9uUnVsZXMoZmllbGRTdGF0ZSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBpc1ZhbGlkOiByZXN1bHQudmFsaWQgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHByaXZhdGUgdmFsaWRhdGlvblJ1bGVzID0gd2l0aFZhbGlkYXRpb24oe1xuICAgICAgICBydWxlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGtleTogXCJzYWZlTG9jYWxwYXJ0XCIsXG4gICAgICAgICAgICAgICAgdGVzdDogYXN5bmMgKHsgdmFsdWUgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmdWxsQWxpYXMgPSB0aGlzLmFzRnVsbEFsaWFzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gWFhYOiBGSVhNRSBodHRwczovL2dpdGh1Yi5jb20vbWF0cml4LW9yZy9tYXRyaXgtZG9jL2lzc3Vlcy82NjhcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICF2YWx1ZS5pbmNsdWRlcyhcIiNcIikgJiYgIXZhbHVlLmluY2x1ZGVzKFwiOlwiKSAmJiAhdmFsdWUuaW5jbHVkZXMoXCIsXCIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUkkoZnVsbEFsaWFzKSA9PT0gZnVsbEFsaWFzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW52YWxpZDogKCkgPT4gX3QoXCJTb21lIGNoYXJhY3RlcnMgbm90IGFsbG93ZWRcIiksXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAga2V5OiBcInJlcXVpcmVkXCIsXG4gICAgICAgICAgICAgICAgdGVzdDogYXN5bmMgKHsgdmFsdWUsIGFsbG93RW1wdHkgfSkgPT4gYWxsb3dFbXB0eSB8fCAhIXZhbHVlLFxuICAgICAgICAgICAgICAgIGludmFsaWQ6ICgpID0+IF90KFwiUGxlYXNlIHByb3ZpZGUgYW4gYWRkcmVzc1wiKSxcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXk6IFwidGFrZW5cIixcbiAgICAgICAgICAgICAgICBmaW5hbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0ZXN0OiBhc3luYyAoeyB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IE1hdHJpeENsaWVudFBlZy5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGNsaWVudC5nZXRSb29tSWRGb3JBbGlhcyh0aGlzLmFzRnVsbEFsaWFzKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBnb3QgYSByb29tIGlkLCBzbyB0aGUgYWxpYXMgaXMgdGFrZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbnkgc2VydmVyIGVycm9yIGNvZGUgd2lsbCBkbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVpdGhlciBpdCBNX05PVF9GT1VORCBvciB0aGUgYWxpYXMgaXMgaW52YWxpZCBzb21laG93LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gd2hpY2ggY2FzZSB3ZSBkb24ndCB3YW50IHRvIHNob3cgdGhlIGludmFsaWQgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhZXJyLmVycmNvZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHZhbGlkOiAoKSA9PiBfdChcIlRoaXMgYWRkcmVzcyBpcyBhdmFpbGFibGUgdG8gdXNlXCIpLFxuICAgICAgICAgICAgICAgIGludmFsaWQ6ICgpID0+IF90KFwiVGhpcyBhZGRyZXNzIGlzIGFscmVhZHkgaW4gdXNlXCIpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICB9KTtcblxuICAgIHB1YmxpYyBnZXQgaXNWYWxpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaXNWYWxpZDtcbiAgICB9XG5cbiAgICBwdWJsaWMgdmFsaWRhdGUob3B0aW9uczogSVZhbGlkYXRlT3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZFJlZi5jdXJyZW50Py52YWxpZGF0ZShvcHRpb25zKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZm9jdXMoKSB7XG4gICAgICAgIHRoaXMuZmllbGRSZWYuY3VycmVudD8uZm9jdXMoKTtcbiAgICB9XG59XG4iXX0=