"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _languageHandler = require("../../../languageHandler");

var _FormattingUtils = require("../../../utils/FormattingUtils");

var _RoomInvite = require("../../../RoomInvite");

var _EventListSummary = _interopRequireDefault(require("./EventListSummary"));

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _dispatcher = _interopRequireDefault(require("../../../dispatcher/dispatcher"));

var _RightPanelStorePhases = require("../../../stores/RightPanelStorePhases");

var _actions = require("../../../dispatcher/actions");

var _ReactUtils = require("../../../utils/ReactUtils");

var _event = require("matrix-js-sdk/src/@types/event");

var _Layout = require("../../../settings/enums/Layout");

var _dec, _class, _class2, _temp;

const onPinnedMessagesClick = () => {
  _dispatcher.default.dispatch({
    action: _actions.Action.SetRightPanelPhase,
    phase: _RightPanelStorePhases.RightPanelPhases.PinnedMessages,
    allowClose: false
  });
};

const SENDER_AS_DISPLAY_NAME_EVENTS = [_event.EventType.RoomServerAcl, _event.EventType.RoomPinnedEvents];
var TransitionType;

(function (TransitionType) {
  TransitionType["Joined"] = "joined";
  TransitionType["Left"] = "left";
  TransitionType["JoinedAndLeft"] = "joined_and_left";
  TransitionType["LeftAndJoined"] = "left_and_joined";
  TransitionType["InviteReject"] = "invite_reject";
  TransitionType["InviteWithdrawal"] = "invite_withdrawal";
  TransitionType["Invited"] = "invited";
  TransitionType["Banned"] = "banned";
  TransitionType["Unbanned"] = "unbanned";
  TransitionType["Kicked"] = "kicked";
  TransitionType["ChangedName"] = "changed_name";
  TransitionType["ChangedAvatar"] = "changed_avatar";
  TransitionType["NoChange"] = "no_change";
  TransitionType["ServerAcl"] = "server_acl";
  TransitionType["ChangedPins"] = "pinned_messages";
})(TransitionType || (TransitionType = {}));

const SEP = ",";
let MemberEventListSummary = (_dec = (0, _replaceableComponent.replaceableComponent)("views.elements.MemberEventListSummary"), _dec(_class = (_temp = _class2 = class MemberEventListSummary extends _react.default.Component {
  shouldComponentUpdate(nextProps) {
    // Update if
    //  - The number of summarised events has changed
    //  - or if the summary is about to toggle to become collapsed
    //  - or if there are fewEvents, meaning the child eventTiles are shown as-is
    return nextProps.events.length !== this.props.events.length || nextProps.events.length < this.props.threshold;
  }
  /**
   * Generate the text for users aggregated by their transition sequences (`eventAggregates`) where
   * the sequences are ordered by `orderedTransitionSequences`.
   * @param {object} eventAggregates a map of transition sequence to array of user display names
   * or user IDs.
   * @param {string[]} orderedTransitionSequences an array which is some ordering of
   * `Object.keys(eventAggregates)`.
   * @returns {string} the textual summary of the aggregated events that occurred.
   */


  generateSummary(eventAggregates, orderedTransitionSequences) {
    const summaries = orderedTransitionSequences.map(transitions => {
      const userNames = eventAggregates[transitions];
      const nameList = this.renderNameList(userNames);
      const splitTransitions = transitions.split(SEP); // Some neighbouring transitions are common, so canonicalise some into "pair"
      // transitions

      const canonicalTransitions = MemberEventListSummary.getCanonicalTransitions(splitTransitions); // Transform into consecutive repetitions of the same transition (like 5
      // consecutive 'joined_and_left's)

      const coalescedTransitions = MemberEventListSummary.coalesceRepeatedTransitions(canonicalTransitions);
      const descs = coalescedTransitions.map(t => {
        return MemberEventListSummary.getDescriptionForTransition(t.transitionType, userNames.length, t.repeats);
      });
      const desc = (0, _FormattingUtils.formatCommaSeparatedList)(descs);
      return (0, _languageHandler._t)('%(nameList)s %(transitionList)s', {
        nameList,
        transitionList: desc
      });
    });

    if (!summaries) {
      return null;
    }

    return (0, _ReactUtils.jsxJoin)(summaries, ", ");
  }
  /**
   * @param {string[]} users an array of user display names or user IDs.
   * @returns {string} a comma-separated list that ends with "and [n] others" if there are
   * more items in `users` than `this.props.summaryLength`, which is the number of names
   * included before "and [n] others".
   */


  renderNameList(users) {
    return (0, _FormattingUtils.formatCommaSeparatedList)(users, this.props.summaryLength);
  }
  /**
   * Canonicalise an array of transitions such that some pairs of transitions become
   * single transitions. For example an input ['joined','left'] would result in an output
   * ['joined_and_left'].
   * @param {string[]} transitions an array of transitions.
   * @returns {string[]} an array of transitions.
   */


  static getCanonicalTransitions(transitions) {
    const modMap = {
      [TransitionType.Joined]: {
        after: TransitionType.Left,
        newTransition: TransitionType.JoinedAndLeft
      },
      [TransitionType.Left]: {
        after: TransitionType.Joined,
        newTransition: TransitionType.LeftAndJoined
      } // $currentTransition : {
      //     'after' : $nextTransition,
      //     'newTransition' : 'new_transition_type',
      // },

    };
    const res = [];

    for (let i = 0; i < transitions.length; i++) {
      const t = transitions[i];
      const t2 = transitions[i + 1];
      let transition = t;

      if (i < transitions.length - 1 && modMap[t] && modMap[t].after === t2) {
        transition = modMap[t].newTransition;
        i++;
      }

      res.push(transition);
    }

    return res;
  }
  /**
   * Transform an array of transitions into an array of transitions and how many times
   * they are repeated consecutively.
   *
   * An array of 123 "joined_and_left" transitions, would result in:
   * ```
   * [{
   *   transitionType: "joined_and_left"
   *   repeats: 123
   * }]
   * ```
   * @param {string[]} transitions the array of transitions to transform.
   * @returns {object[]} an array of coalesced transitions.
   */


  static coalesceRepeatedTransitions(transitions) {
    const res = [];

    for (let i = 0; i < transitions.length; i++) {
      if (res.length > 0 && res[res.length - 1].transitionType === transitions[i]) {
        res[res.length - 1].repeats += 1;
      } else {
        res.push({
          transitionType: transitions[i],
          repeats: 1
        });
      }
    }

    return res;
  }
  /**
   * For a certain transition, t, describe what happened to the users that
   * underwent the transition.
   * @param {string} t the transition type.
   * @param {number} userCount number of usernames
   * @param {number} repeats the number of times the transition was repeated in a row.
   * @returns {string} the written Human Readable equivalent of the transition.
   */


  static getDescriptionForTransition(t, userCount, repeats) {
    // The empty interpolations 'severalUsers' and 'oneUser'
    // are there only to show translators to non-English languages
    // that the verb is conjugated to plural or singular Subject.
    let res = null;

    switch (t) {
      case "joined":
        res = userCount > 1 ? (0, _languageHandler._t)("%(severalUsers)sjoined %(count)s times", {
          severalUsers: "",
          count: repeats
        }) : (0, _languageHandler._t)("%(oneUser)sjoined %(count)s times", {
          oneUser: "",
          count: repeats
        });
        break;

      case "left":
        res = userCount > 1 ? (0, _languageHandler._t)("%(severalUsers)sleft %(count)s times", {
          severalUsers: "",
          count: repeats
        }) : (0, _languageHandler._t)("%(oneUser)sleft %(count)s times", {
          oneUser: "",
          count: repeats
        });
        break;

      case "joined_and_left":
        res = userCount > 1 ? (0, _languageHandler._t)("%(severalUsers)sjoined and left %(count)s times", {
          severalUsers: "",
          count: repeats
        }) : (0, _languageHandler._t)("%(oneUser)sjoined and left %(count)s times", {
          oneUser: "",
          count: repeats
        });
        break;

      case "left_and_joined":
        res = userCount > 1 ? (0, _languageHandler._t)("%(severalUsers)sleft and rejoined %(count)s times", {
          severalUsers: "",
          count: repeats
        }) : (0, _languageHandler._t)("%(oneUser)sleft and rejoined %(count)s times", {
          oneUser: "",
          count: repeats
        });
        break;

      case "invite_reject":
        res = userCount > 1 ? (0, _languageHandler._t)("%(severalUsers)srejected their invitations %(count)s times", {
          severalUsers: "",
          count: repeats
        }) : (0, _languageHandler._t)("%(oneUser)srejected their invitation %(count)s times", {
          oneUser: "",
          count: repeats
        });
        break;

      case "invite_withdrawal":
        res = userCount > 1 ? (0, _languageHandler._t)("%(severalUsers)shad their invitations withdrawn %(count)s times", {
          severalUsers: "",
          count: repeats
        }) : (0, _languageHandler._t)("%(oneUser)shad their invitation withdrawn %(count)s times", {
          oneUser: "",
          count: repeats
        });
        break;

      case "invited":
        res = userCount > 1 ? (0, _languageHandler._t)("were invited %(count)s times", {
          count: repeats
        }) : (0, _languageHandler._t)("was invited %(count)s times", {
          count: repeats
        });
        break;

      case "banned":
        res = userCount > 1 ? (0, _languageHandler._t)("were banned %(count)s times", {
          count: repeats
        }) : (0, _languageHandler._t)("was banned %(count)s times", {
          count: repeats
        });
        break;

      case "unbanned":
        res = userCount > 1 ? (0, _languageHandler._t)("were unbanned %(count)s times", {
          count: repeats
        }) : (0, _languageHandler._t)("was unbanned %(count)s times", {
          count: repeats
        });
        break;

      case "kicked":
        res = userCount > 1 ? (0, _languageHandler._t)("were kicked %(count)s times", {
          count: repeats
        }) : (0, _languageHandler._t)("was kicked %(count)s times", {
          count: repeats
        });
        break;

      case "changed_name":
        res = userCount > 1 ? (0, _languageHandler._t)("%(severalUsers)schanged their name %(count)s times", {
          severalUsers: "",
          count: repeats
        }) : (0, _languageHandler._t)("%(oneUser)schanged their name %(count)s times", {
          oneUser: "",
          count: repeats
        });
        break;

      case "changed_avatar":
        res = userCount > 1 ? (0, _languageHandler._t)("%(severalUsers)schanged their avatar %(count)s times", {
          severalUsers: "",
          count: repeats
        }) : (0, _languageHandler._t)("%(oneUser)schanged their avatar %(count)s times", {
          oneUser: "",
          count: repeats
        });
        break;

      case "no_change":
        res = userCount > 1 ? (0, _languageHandler._t)("%(severalUsers)smade no changes %(count)s times", {
          severalUsers: "",
          count: repeats
        }) : (0, _languageHandler._t)("%(oneUser)smade no changes %(count)s times", {
          oneUser: "",
          count: repeats
        });
        break;

      case "server_acl":
        res = userCount > 1 ? (0, _languageHandler._t)("%(severalUsers)schanged the server ACLs %(count)s times", {
          severalUsers: "",
          count: repeats
        }) : (0, _languageHandler._t)("%(oneUser)schanged the server ACLs %(count)s times", {
          oneUser: "",
          count: repeats
        });
        break;

      case "pinned_messages":
        res = userCount > 1 ? (0, _languageHandler._t)("%(severalUsers)schanged the <a>pinned messages</a> for the room %(count)s times.", {
          severalUsers: "",
          count: repeats
        }, {
          "a": sub => /*#__PURE__*/_react.default.createElement("a", {
            onClick: onPinnedMessagesClick
          }, " ", sub, " ")
        }) : (0, _languageHandler._t)("%(oneUser)schanged the <a>pinned messages</a> for the room %(count)s times.", {
          oneUser: "",
          count: repeats
        }, {
          "a": sub => /*#__PURE__*/_react.default.createElement("a", {
            onClick: onPinnedMessagesClick
          }, " ", sub, " ")
        });
        break;
    }

    return res;
  }

  static getTransitionSequence(events) {
    return events.map(MemberEventListSummary.getTransition);
  }
  /**
   * Label a given membership event, `e`, where `getContent().membership` has
   * changed for each transition allowed by the Matrix protocol. This attempts to
   * label the membership changes that occur in `../../../TextForEvent.js`.
   * @param {MatrixEvent} e the membership change event to label.
   * @returns {string?} the transition type given to this event. This defaults to `null`
   * if a transition is not recognised.
   */


  static getTransition(e) {
    const type = e.mxEvent.getType();

    if (type === _event.EventType.RoomThirdPartyInvite) {
      // Handle 3pid invites the same as invites so they get bundled together
      if (!(0, _RoomInvite.isValid3pidInvite)(e.mxEvent)) {
        return TransitionType.InviteWithdrawal;
      }

      return TransitionType.Invited;
    } else if (type === _event.EventType.RoomServerAcl) {
      return TransitionType.ServerAcl;
    } else if (type === _event.EventType.RoomPinnedEvents) {
      return TransitionType.ChangedPins;
    }

    switch (e.mxEvent.getContent().membership) {
      case 'invite':
        return TransitionType.Invited;

      case 'ban':
        return TransitionType.Banned;

      case 'join':
        if (e.mxEvent.getPrevContent().membership === 'join') {
          if (e.mxEvent.getContent().displayname !== e.mxEvent.getPrevContent().displayname) {
            return TransitionType.ChangedName;
          } else if (e.mxEvent.getContent().avatar_url !== e.mxEvent.getPrevContent().avatar_url) {
            return TransitionType.ChangedAvatar;
          } // console.log("MELS ignoring duplicate membership join event");


          return TransitionType.NoChange;
        } else {
          return TransitionType.Joined;
        }

      case 'leave':
        if (e.mxEvent.getSender() === e.mxEvent.getStateKey()) {
          switch (e.mxEvent.getPrevContent().membership) {
            case 'invite':
              return TransitionType.InviteReject;

            default:
              return TransitionType.Left;
          }
        }

        switch (e.mxEvent.getPrevContent().membership) {
          case 'invite':
            return TransitionType.InviteWithdrawal;

          case 'ban':
            return TransitionType.Unbanned;
          // sender is not target and made the target leave, if not from invite/ban then this is a kick

          default:
            return TransitionType.Kicked;
        }

      default:
        return null;
    }
  }

  getAggregate(userEvents) {
    // A map of aggregate type to arrays of display names. Each aggregate type
    // is a comma-delimited string of transitions, e.g. "joined,left,kicked".
    // The array of display names is the array of users who went through that
    // sequence during eventsToRender.
    const aggregate = {// $aggregateType : []:string
    }; // A map of aggregate types to the indices that order them (the index of
    // the first event for a given transition sequence)

    const aggregateIndices = {// $aggregateType : int
    };
    const users = Object.keys(userEvents);
    users.forEach(userId => {
      const firstEvent = userEvents[userId][0];
      const displayName = firstEvent.displayName;
      const seq = MemberEventListSummary.getTransitionSequence(userEvents[userId]).join(SEP);

      if (!aggregate[seq]) {
        aggregate[seq] = [];
        aggregateIndices[seq] = -1;
      }

      aggregate[seq].push(displayName);

      if (aggregateIndices[seq] === -1 || firstEvent.index < aggregateIndices[seq]) {
        aggregateIndices[seq] = firstEvent.index;
      }
    });
    return {
      names: aggregate,
      indices: aggregateIndices
    };
  }

  render() {
    const eventsToRender = this.props.events; // Map user IDs to latest Avatar Member. ES6 Maps are ordered by when the key was created,
    // so this works perfectly for us to match event order whilst storing the latest Avatar Member

    const latestUserAvatarMember = new Map(); // Object mapping user IDs to an array of IUserEvents

    const userEvents = {};
    eventsToRender.forEach((e, index) => {
      const type = e.getType();
      const userId = type === _event.EventType.RoomServerAcl ? e.getSender() : e.getStateKey(); // Initialise a user's events

      if (!userEvents[userId]) {
        userEvents[userId] = [];
      }

      if (SENDER_AS_DISPLAY_NAME_EVENTS.includes(type)) {
        latestUserAvatarMember.set(userId, e.sender);
      } else if (e.target) {
        latestUserAvatarMember.set(userId, e.target);
      }

      let displayName = userId;

      if (type === _event.EventType.RoomThirdPartyInvite) {
        displayName = e.getContent().display_name;
      } else if (SENDER_AS_DISPLAY_NAME_EVENTS.includes(type)) {
        displayName = e.sender.name;
      } else if (e.target) {
        displayName = e.target.name;
      }

      userEvents[userId].push({
        mxEvent: e,
        displayName,
        index: index
      });
    });
    const aggregate = this.getAggregate(userEvents); // Sort types by order of lowest event index within sequence

    const orderedTransitionSequences = Object.keys(aggregate.names).sort((seq1, seq2) => aggregate.indices[seq1] - aggregate.indices[seq2]);
    return /*#__PURE__*/_react.default.createElement(_EventListSummary.default, {
      events: this.props.events,
      threshold: this.props.threshold,
      onToggle: this.props.onToggle,
      startExpanded: this.props.startExpanded,
      children: this.props.children,
      summaryMembers: [...latestUserAvatarMember.values()],
      layout: this.props.layout,
      summaryText: this.generateSummary(aggregate.names, orderedTransitionSequences)
    });
  }

}, (0, _defineProperty2.default)(_class2, "defaultProps", {
  summaryLength: 1,
  threshold: 3,
  avatarsMaxLength: 5,
  layout: _Layout.Layout.Group
}), _temp)) || _class);
exports.default = MemberEventListSummary;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2VsZW1lbnRzL01lbWJlckV2ZW50TGlzdFN1bW1hcnkudHN4Il0sIm5hbWVzIjpbIm9uUGlubmVkTWVzc2FnZXNDbGljayIsImRlZmF1bHREaXNwYXRjaGVyIiwiZGlzcGF0Y2giLCJhY3Rpb24iLCJBY3Rpb24iLCJTZXRSaWdodFBhbmVsUGhhc2UiLCJwaGFzZSIsIlJpZ2h0UGFuZWxQaGFzZXMiLCJQaW5uZWRNZXNzYWdlcyIsImFsbG93Q2xvc2UiLCJTRU5ERVJfQVNfRElTUExBWV9OQU1FX0VWRU5UUyIsIkV2ZW50VHlwZSIsIlJvb21TZXJ2ZXJBY2wiLCJSb29tUGlubmVkRXZlbnRzIiwiVHJhbnNpdGlvblR5cGUiLCJTRVAiLCJNZW1iZXJFdmVudExpc3RTdW1tYXJ5IiwiUmVhY3QiLCJDb21wb25lbnQiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJuZXh0UHJvcHMiLCJldmVudHMiLCJsZW5ndGgiLCJwcm9wcyIsInRocmVzaG9sZCIsImdlbmVyYXRlU3VtbWFyeSIsImV2ZW50QWdncmVnYXRlcyIsIm9yZGVyZWRUcmFuc2l0aW9uU2VxdWVuY2VzIiwic3VtbWFyaWVzIiwibWFwIiwidHJhbnNpdGlvbnMiLCJ1c2VyTmFtZXMiLCJuYW1lTGlzdCIsInJlbmRlck5hbWVMaXN0Iiwic3BsaXRUcmFuc2l0aW9ucyIsInNwbGl0IiwiY2Fub25pY2FsVHJhbnNpdGlvbnMiLCJnZXRDYW5vbmljYWxUcmFuc2l0aW9ucyIsImNvYWxlc2NlZFRyYW5zaXRpb25zIiwiY29hbGVzY2VSZXBlYXRlZFRyYW5zaXRpb25zIiwiZGVzY3MiLCJ0IiwiZ2V0RGVzY3JpcHRpb25Gb3JUcmFuc2l0aW9uIiwidHJhbnNpdGlvblR5cGUiLCJyZXBlYXRzIiwiZGVzYyIsInRyYW5zaXRpb25MaXN0IiwidXNlcnMiLCJzdW1tYXJ5TGVuZ3RoIiwibW9kTWFwIiwiSm9pbmVkIiwiYWZ0ZXIiLCJMZWZ0IiwibmV3VHJhbnNpdGlvbiIsIkpvaW5lZEFuZExlZnQiLCJMZWZ0QW5kSm9pbmVkIiwicmVzIiwiaSIsInQyIiwidHJhbnNpdGlvbiIsInB1c2giLCJ1c2VyQ291bnQiLCJzZXZlcmFsVXNlcnMiLCJjb3VudCIsIm9uZVVzZXIiLCJzdWIiLCJnZXRUcmFuc2l0aW9uU2VxdWVuY2UiLCJnZXRUcmFuc2l0aW9uIiwiZSIsInR5cGUiLCJteEV2ZW50IiwiZ2V0VHlwZSIsIlJvb21UaGlyZFBhcnR5SW52aXRlIiwiSW52aXRlV2l0aGRyYXdhbCIsIkludml0ZWQiLCJTZXJ2ZXJBY2wiLCJDaGFuZ2VkUGlucyIsImdldENvbnRlbnQiLCJtZW1iZXJzaGlwIiwiQmFubmVkIiwiZ2V0UHJldkNvbnRlbnQiLCJkaXNwbGF5bmFtZSIsIkNoYW5nZWROYW1lIiwiYXZhdGFyX3VybCIsIkNoYW5nZWRBdmF0YXIiLCJOb0NoYW5nZSIsImdldFNlbmRlciIsImdldFN0YXRlS2V5IiwiSW52aXRlUmVqZWN0IiwiVW5iYW5uZWQiLCJLaWNrZWQiLCJnZXRBZ2dyZWdhdGUiLCJ1c2VyRXZlbnRzIiwiYWdncmVnYXRlIiwiYWdncmVnYXRlSW5kaWNlcyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwidXNlcklkIiwiZmlyc3RFdmVudCIsImRpc3BsYXlOYW1lIiwic2VxIiwiam9pbiIsImluZGV4IiwibmFtZXMiLCJpbmRpY2VzIiwicmVuZGVyIiwiZXZlbnRzVG9SZW5kZXIiLCJsYXRlc3RVc2VyQXZhdGFyTWVtYmVyIiwiTWFwIiwiaW5jbHVkZXMiLCJzZXQiLCJzZW5kZXIiLCJ0YXJnZXQiLCJkaXNwbGF5X25hbWUiLCJuYW1lIiwic29ydCIsInNlcTEiLCJzZXEyIiwib25Ub2dnbGUiLCJzdGFydEV4cGFuZGVkIiwiY2hpbGRyZW4iLCJ2YWx1ZXMiLCJsYXlvdXQiLCJhdmF0YXJzTWF4TGVuZ3RoIiwiTGF5b3V0IiwiR3JvdXAiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBa0JBOztBQUlBOztBQUNBOztBQUNBOztBQUNBOztB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LEVBQXNDN0UsMEJBQXRDO0FBUlYsTUFBUDtBQVNIOztBQTdadUUsQyx5REFDbEQ7QUFDbEJxQixFQUFBQSxhQUFhLEVBQUUsQ0FERztBQUVsQnhCLEVBQUFBLFNBQVMsRUFBRSxDQUZPO0FBR2xCb0csRUFBQUEsZ0JBQWdCLEVBQUUsQ0FIQTtBQUlsQkQsRUFBQUEsTUFBTSxFQUFFRSxlQUFPQztBQUpHLEMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMTYgT3Blbk1hcmtldCBMdGRcbkNvcHlyaWdodCAyMDE5LCAyMDIwIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5Db3B5cmlnaHQgMjAxOSBNaWNoYWVsIFRlbGF0eW5za2kgPDd0M2NoZ3V5QGdtYWlsLmNvbT5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50UHJvcHMgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBNYXRyaXhFdmVudCB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9tb2RlbHMvZXZlbnRcIjtcbmltcG9ydCB7IFJvb21NZW1iZXIgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvbW9kZWxzL3Jvb20tbWVtYmVyXCI7XG5cbmltcG9ydCB7IF90IH0gZnJvbSAnLi4vLi4vLi4vbGFuZ3VhZ2VIYW5kbGVyJztcbmltcG9ydCB7IGZvcm1hdENvbW1hU2VwYXJhdGVkTGlzdCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL0Zvcm1hdHRpbmdVdGlscyc7XG5pbXBvcnQgeyBpc1ZhbGlkM3BpZEludml0ZSB9IGZyb20gXCIuLi8uLi8uLi9Sb29tSW52aXRlXCI7XG5pbXBvcnQgRXZlbnRMaXN0U3VtbWFyeSBmcm9tIFwiLi9FdmVudExpc3RTdW1tYXJ5XCI7XG5pbXBvcnQgeyByZXBsYWNlYWJsZUNvbXBvbmVudCB9IGZyb20gXCIuLi8uLi8uLi91dGlscy9yZXBsYWNlYWJsZUNvbXBvbmVudFwiO1xuaW1wb3J0IGRlZmF1bHREaXNwYXRjaGVyIGZyb20gJy4uLy4uLy4uL2Rpc3BhdGNoZXIvZGlzcGF0Y2hlcic7XG5pbXBvcnQgeyBSaWdodFBhbmVsUGhhc2VzIH0gZnJvbSAnLi4vLi4vLi4vc3RvcmVzL1JpZ2h0UGFuZWxTdG9yZVBoYXNlcyc7XG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tICcuLi8uLi8uLi9kaXNwYXRjaGVyL2FjdGlvbnMnO1xuaW1wb3J0IHsgU2V0UmlnaHRQYW5lbFBoYXNlUGF5bG9hZCB9IGZyb20gJy4uLy4uLy4uL2Rpc3BhdGNoZXIvcGF5bG9hZHMvU2V0UmlnaHRQYW5lbFBoYXNlUGF5bG9hZCc7XG5pbXBvcnQgeyBqc3hKb2luIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvUmVhY3RVdGlscyc7XG5pbXBvcnQgeyBFdmVudFR5cGUgfSBmcm9tICdtYXRyaXgtanMtc2RrL3NyYy9AdHlwZXMvZXZlbnQnO1xuaW1wb3J0IHsgTGF5b3V0IH0gZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvZW51bXMvTGF5b3V0JztcblxuY29uc3Qgb25QaW5uZWRNZXNzYWdlc0NsaWNrID0gKCk6IHZvaWQgPT4ge1xuICAgIGRlZmF1bHREaXNwYXRjaGVyLmRpc3BhdGNoPFNldFJpZ2h0UGFuZWxQaGFzZVBheWxvYWQ+KHtcbiAgICAgICAgYWN0aW9uOiBBY3Rpb24uU2V0UmlnaHRQYW5lbFBoYXNlLFxuICAgICAgICBwaGFzZTogUmlnaHRQYW5lbFBoYXNlcy5QaW5uZWRNZXNzYWdlcyxcbiAgICAgICAgYWxsb3dDbG9zZTogZmFsc2UsXG4gICAgfSk7XG59O1xuXG5jb25zdCBTRU5ERVJfQVNfRElTUExBWV9OQU1FX0VWRU5UUyA9IFtFdmVudFR5cGUuUm9vbVNlcnZlckFjbCwgRXZlbnRUeXBlLlJvb21QaW5uZWRFdmVudHNdO1xuXG5pbnRlcmZhY2UgSVByb3BzIGV4dGVuZHMgT21pdDxDb21wb25lbnRQcm9wczx0eXBlb2YgRXZlbnRMaXN0U3VtbWFyeT4sIFwic3VtbWFyeVRleHRcIiB8IFwic3VtbWFyeU1lbWJlcnNcIj4ge1xuICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBuYW1lcyB0byBzaG93IGluIGVpdGhlciBlYWNoIHN1bW1hcnkgZS5nLiAyIHdvdWxkIHJlc3VsdCBcIkEsIEIgYW5kIDIzNCBvdGhlcnMgbGVmdFwiXG4gICAgc3VtbWFyeUxlbmd0aD86IG51bWJlcjtcbiAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXZhdGFycyB0byBkaXNwbGF5IGluIHRoZSBzdW1tYXJ5XG4gICAgYXZhdGFyc01heExlbmd0aD86IG51bWJlcjtcbiAgICAvLyBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGxheW91dFxuICAgIGxheW91dDogTGF5b3V0O1xufVxuXG5pbnRlcmZhY2UgSVVzZXJFdmVudHMge1xuICAgIC8vIFRoZSBvcmlnaW5hbCBldmVudFxuICAgIG14RXZlbnQ6IE1hdHJpeEV2ZW50O1xuICAgIC8vIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIHVzZXIgKGlmIG5vdCwgdGhlbiB1c2VyIElEKVxuICAgIGRpc3BsYXlOYW1lOiBzdHJpbmc7XG4gICAgLy8gVGhlIG9yaWdpbmFsIGluZGV4IG9mIHRoZSBldmVudCBpbiB0aGlzLnByb3BzLmV2ZW50c1xuICAgIGluZGV4OiBudW1iZXI7XG59XG5cbmVudW0gVHJhbnNpdGlvblR5cGUge1xuICAgIEpvaW5lZCA9IFwiam9pbmVkXCIsXG4gICAgTGVmdCA9IFwibGVmdFwiLFxuICAgIEpvaW5lZEFuZExlZnQgPSBcImpvaW5lZF9hbmRfbGVmdFwiLFxuICAgIExlZnRBbmRKb2luZWQgPSBcImxlZnRfYW5kX2pvaW5lZFwiLFxuICAgIEludml0ZVJlamVjdCA9IFwiaW52aXRlX3JlamVjdFwiLFxuICAgIEludml0ZVdpdGhkcmF3YWwgPSBcImludml0ZV93aXRoZHJhd2FsXCIsXG4gICAgSW52aXRlZCA9IFwiaW52aXRlZFwiLFxuICAgIEJhbm5lZCA9IFwiYmFubmVkXCIsXG4gICAgVW5iYW5uZWQgPSBcInVuYmFubmVkXCIsXG4gICAgS2lja2VkID0gXCJraWNrZWRcIixcbiAgICBDaGFuZ2VkTmFtZSA9IFwiY2hhbmdlZF9uYW1lXCIsXG4gICAgQ2hhbmdlZEF2YXRhciA9IFwiY2hhbmdlZF9hdmF0YXJcIixcbiAgICBOb0NoYW5nZSA9IFwibm9fY2hhbmdlXCIsXG4gICAgU2VydmVyQWNsID0gXCJzZXJ2ZXJfYWNsXCIsXG4gICAgQ2hhbmdlZFBpbnMgPSBcInBpbm5lZF9tZXNzYWdlc1wiXG59XG5cbmNvbnN0IFNFUCA9IFwiLFwiO1xuXG5AcmVwbGFjZWFibGVDb21wb25lbnQoXCJ2aWV3cy5lbGVtZW50cy5NZW1iZXJFdmVudExpc3RTdW1tYXJ5XCIpXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNZW1iZXJFdmVudExpc3RTdW1tYXJ5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PElQcm9wcz4ge1xuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIHN1bW1hcnlMZW5ndGg6IDEsXG4gICAgICAgIHRocmVzaG9sZDogMyxcbiAgICAgICAgYXZhdGFyc01heExlbmd0aDogNSxcbiAgICAgICAgbGF5b3V0OiBMYXlvdXQuR3JvdXAsXG4gICAgfTtcblxuICAgIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMpIHtcbiAgICAgICAgLy8gVXBkYXRlIGlmXG4gICAgICAgIC8vICAtIFRoZSBudW1iZXIgb2Ygc3VtbWFyaXNlZCBldmVudHMgaGFzIGNoYW5nZWRcbiAgICAgICAgLy8gIC0gb3IgaWYgdGhlIHN1bW1hcnkgaXMgYWJvdXQgdG8gdG9nZ2xlIHRvIGJlY29tZSBjb2xsYXBzZWRcbiAgICAgICAgLy8gIC0gb3IgaWYgdGhlcmUgYXJlIGZld0V2ZW50cywgbWVhbmluZyB0aGUgY2hpbGQgZXZlbnRUaWxlcyBhcmUgc2hvd24gYXMtaXNcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG5leHRQcm9wcy5ldmVudHMubGVuZ3RoICE9PSB0aGlzLnByb3BzLmV2ZW50cy5sZW5ndGggfHxcbiAgICAgICAgICAgIG5leHRQcm9wcy5ldmVudHMubGVuZ3RoIDwgdGhpcy5wcm9wcy50aHJlc2hvbGRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgdGV4dCBmb3IgdXNlcnMgYWdncmVnYXRlZCBieSB0aGVpciB0cmFuc2l0aW9uIHNlcXVlbmNlcyAoYGV2ZW50QWdncmVnYXRlc2ApIHdoZXJlXG4gICAgICogdGhlIHNlcXVlbmNlcyBhcmUgb3JkZXJlZCBieSBgb3JkZXJlZFRyYW5zaXRpb25TZXF1ZW5jZXNgLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudEFnZ3JlZ2F0ZXMgYSBtYXAgb2YgdHJhbnNpdGlvbiBzZXF1ZW5jZSB0byBhcnJheSBvZiB1c2VyIGRpc3BsYXkgbmFtZXNcbiAgICAgKiBvciB1c2VyIElEcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBvcmRlcmVkVHJhbnNpdGlvblNlcXVlbmNlcyBhbiBhcnJheSB3aGljaCBpcyBzb21lIG9yZGVyaW5nIG9mXG4gICAgICogYE9iamVjdC5rZXlzKGV2ZW50QWdncmVnYXRlcylgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSB0ZXh0dWFsIHN1bW1hcnkgb2YgdGhlIGFnZ3JlZ2F0ZWQgZXZlbnRzIHRoYXQgb2NjdXJyZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZW5lcmF0ZVN1bW1hcnkoXG4gICAgICAgIGV2ZW50QWdncmVnYXRlczogUmVjb3JkPHN0cmluZywgc3RyaW5nW10+LFxuICAgICAgICBvcmRlcmVkVHJhbnNpdGlvblNlcXVlbmNlczogc3RyaW5nW10sXG4gICAgKTogc3RyaW5nIHwgSlNYLkVsZW1lbnQge1xuICAgICAgICBjb25zdCBzdW1tYXJpZXMgPSBvcmRlcmVkVHJhbnNpdGlvblNlcXVlbmNlcy5tYXAoKHRyYW5zaXRpb25zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1c2VyTmFtZXMgPSBldmVudEFnZ3JlZ2F0ZXNbdHJhbnNpdGlvbnNdO1xuICAgICAgICAgICAgY29uc3QgbmFtZUxpc3QgPSB0aGlzLnJlbmRlck5hbWVMaXN0KHVzZXJOYW1lcyk7XG5cbiAgICAgICAgICAgIGNvbnN0IHNwbGl0VHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9ucy5zcGxpdChTRVApIGFzIFRyYW5zaXRpb25UeXBlW107XG5cbiAgICAgICAgICAgIC8vIFNvbWUgbmVpZ2hib3VyaW5nIHRyYW5zaXRpb25zIGFyZSBjb21tb24sIHNvIGNhbm9uaWNhbGlzZSBzb21lIGludG8gXCJwYWlyXCJcbiAgICAgICAgICAgIC8vIHRyYW5zaXRpb25zXG4gICAgICAgICAgICBjb25zdCBjYW5vbmljYWxUcmFuc2l0aW9ucyA9IE1lbWJlckV2ZW50TGlzdFN1bW1hcnkuZ2V0Q2Fub25pY2FsVHJhbnNpdGlvbnMoc3BsaXRUcmFuc2l0aW9ucyk7XG4gICAgICAgICAgICAvLyBUcmFuc2Zvcm0gaW50byBjb25zZWN1dGl2ZSByZXBldGl0aW9ucyBvZiB0aGUgc2FtZSB0cmFuc2l0aW9uIChsaWtlIDVcbiAgICAgICAgICAgIC8vIGNvbnNlY3V0aXZlICdqb2luZWRfYW5kX2xlZnQncylcbiAgICAgICAgICAgIGNvbnN0IGNvYWxlc2NlZFRyYW5zaXRpb25zID0gTWVtYmVyRXZlbnRMaXN0U3VtbWFyeS5jb2FsZXNjZVJlcGVhdGVkVHJhbnNpdGlvbnMoY2Fub25pY2FsVHJhbnNpdGlvbnMpO1xuXG4gICAgICAgICAgICBjb25zdCBkZXNjcyA9IGNvYWxlc2NlZFRyYW5zaXRpb25zLm1hcCgodCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBNZW1iZXJFdmVudExpc3RTdW1tYXJ5LmdldERlc2NyaXB0aW9uRm9yVHJhbnNpdGlvbihcbiAgICAgICAgICAgICAgICAgICAgdC50cmFuc2l0aW9uVHlwZSwgdXNlck5hbWVzLmxlbmd0aCwgdC5yZXBlYXRzLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgZGVzYyA9IGZvcm1hdENvbW1hU2VwYXJhdGVkTGlzdChkZXNjcyk7XG5cbiAgICAgICAgICAgIHJldHVybiBfdCgnJShuYW1lTGlzdClzICUodHJhbnNpdGlvbkxpc3QpcycsIHsgbmFtZUxpc3QsIHRyYW5zaXRpb25MaXN0OiBkZXNjIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXN1bW1hcmllcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ganN4Sm9pbihzdW1tYXJpZXMsIFwiLCBcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gdXNlcnMgYW4gYXJyYXkgb2YgdXNlciBkaXNwbGF5IG5hbWVzIG9yIHVzZXIgSURzLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGEgY29tbWEtc2VwYXJhdGVkIGxpc3QgdGhhdCBlbmRzIHdpdGggXCJhbmQgW25dIG90aGVyc1wiIGlmIHRoZXJlIGFyZVxuICAgICAqIG1vcmUgaXRlbXMgaW4gYHVzZXJzYCB0aGFuIGB0aGlzLnByb3BzLnN1bW1hcnlMZW5ndGhgLCB3aGljaCBpcyB0aGUgbnVtYmVyIG9mIG5hbWVzXG4gICAgICogaW5jbHVkZWQgYmVmb3JlIFwiYW5kIFtuXSBvdGhlcnNcIi5cbiAgICAgKi9cbiAgICBwcml2YXRlIHJlbmRlck5hbWVMaXN0KHVzZXJzOiBzdHJpbmdbXSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0Q29tbWFTZXBhcmF0ZWRMaXN0KHVzZXJzLCB0aGlzLnByb3BzLnN1bW1hcnlMZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbm9uaWNhbGlzZSBhbiBhcnJheSBvZiB0cmFuc2l0aW9ucyBzdWNoIHRoYXQgc29tZSBwYWlycyBvZiB0cmFuc2l0aW9ucyBiZWNvbWVcbiAgICAgKiBzaW5nbGUgdHJhbnNpdGlvbnMuIEZvciBleGFtcGxlIGFuIGlucHV0IFsnam9pbmVkJywnbGVmdCddIHdvdWxkIHJlc3VsdCBpbiBhbiBvdXRwdXRcbiAgICAgKiBbJ2pvaW5lZF9hbmRfbGVmdCddLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHRyYW5zaXRpb25zIGFuIGFycmF5IG9mIHRyYW5zaXRpb25zLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gYW4gYXJyYXkgb2YgdHJhbnNpdGlvbnMuXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0Q2Fub25pY2FsVHJhbnNpdGlvbnModHJhbnNpdGlvbnM6IFRyYW5zaXRpb25UeXBlW10pOiBUcmFuc2l0aW9uVHlwZVtdIHtcbiAgICAgICAgY29uc3QgbW9kTWFwID0ge1xuICAgICAgICAgICAgW1RyYW5zaXRpb25UeXBlLkpvaW5lZF06IHtcbiAgICAgICAgICAgICAgICBhZnRlcjogVHJhbnNpdGlvblR5cGUuTGVmdCxcbiAgICAgICAgICAgICAgICBuZXdUcmFuc2l0aW9uOiBUcmFuc2l0aW9uVHlwZS5Kb2luZWRBbmRMZWZ0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtUcmFuc2l0aW9uVHlwZS5MZWZ0XToge1xuICAgICAgICAgICAgICAgIGFmdGVyOiBUcmFuc2l0aW9uVHlwZS5Kb2luZWQsXG4gICAgICAgICAgICAgICAgbmV3VHJhbnNpdGlvbjogVHJhbnNpdGlvblR5cGUuTGVmdEFuZEpvaW5lZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyAkY3VycmVudFRyYW5zaXRpb24gOiB7XG4gICAgICAgICAgICAvLyAgICAgJ2FmdGVyJyA6ICRuZXh0VHJhbnNpdGlvbixcbiAgICAgICAgICAgIC8vICAgICAnbmV3VHJhbnNpdGlvbicgOiAnbmV3X3RyYW5zaXRpb25fdHlwZScsXG4gICAgICAgICAgICAvLyB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXM6IFRyYW5zaXRpb25UeXBlW10gPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYW5zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0ID0gdHJhbnNpdGlvbnNbaV07XG4gICAgICAgICAgICBjb25zdCB0MiA9IHRyYW5zaXRpb25zW2kgKyAxXTtcblxuICAgICAgICAgICAgbGV0IHRyYW5zaXRpb24gPSB0O1xuXG4gICAgICAgICAgICBpZiAoaSA8IHRyYW5zaXRpb25zLmxlbmd0aCAtIDEgJiYgbW9kTWFwW3RdICYmIG1vZE1hcFt0XS5hZnRlciA9PT0gdDIpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uID0gbW9kTWFwW3RdLm5ld1RyYW5zaXRpb247XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXMucHVzaCh0cmFuc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBhbiBhcnJheSBvZiB0cmFuc2l0aW9ucyBpbnRvIGFuIGFycmF5IG9mIHRyYW5zaXRpb25zIGFuZCBob3cgbWFueSB0aW1lc1xuICAgICAqIHRoZXkgYXJlIHJlcGVhdGVkIGNvbnNlY3V0aXZlbHkuXG4gICAgICpcbiAgICAgKiBBbiBhcnJheSBvZiAxMjMgXCJqb2luZWRfYW5kX2xlZnRcIiB0cmFuc2l0aW9ucywgd291bGQgcmVzdWx0IGluOlxuICAgICAqIGBgYFxuICAgICAqIFt7XG4gICAgICogICB0cmFuc2l0aW9uVHlwZTogXCJqb2luZWRfYW5kX2xlZnRcIlxuICAgICAqICAgcmVwZWF0czogMTIzXG4gICAgICogfV1cbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB0cmFuc2l0aW9ucyB0aGUgYXJyYXkgb2YgdHJhbnNpdGlvbnMgdG8gdHJhbnNmb3JtLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3RbXX0gYW4gYXJyYXkgb2YgY29hbGVzY2VkIHRyYW5zaXRpb25zLlxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIGNvYWxlc2NlUmVwZWF0ZWRUcmFuc2l0aW9ucyh0cmFuc2l0aW9uczogVHJhbnNpdGlvblR5cGVbXSkge1xuICAgICAgICBjb25zdCByZXM6IHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25UeXBlOiBUcmFuc2l0aW9uVHlwZTtcbiAgICAgICAgICAgIHJlcGVhdHM6IG51bWJlcjtcbiAgICAgICAgfVtdID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc2l0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAwICYmIHJlc1tyZXMubGVuZ3RoIC0gMV0udHJhbnNpdGlvblR5cGUgPT09IHRyYW5zaXRpb25zW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVzW3Jlcy5sZW5ndGggLSAxXS5yZXBlYXRzICs9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvblR5cGU6IHRyYW5zaXRpb25zW2ldLFxuICAgICAgICAgICAgICAgICAgICByZXBlYXRzOiAxLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yIGEgY2VydGFpbiB0cmFuc2l0aW9uLCB0LCBkZXNjcmliZSB3aGF0IGhhcHBlbmVkIHRvIHRoZSB1c2VycyB0aGF0XG4gICAgICogdW5kZXJ3ZW50IHRoZSB0cmFuc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0IHRoZSB0cmFuc2l0aW9uIHR5cGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVzZXJDb3VudCBudW1iZXIgb2YgdXNlcm5hbWVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlcGVhdHMgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUgdHJhbnNpdGlvbiB3YXMgcmVwZWF0ZWQgaW4gYSByb3cuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdGhlIHdyaXR0ZW4gSHVtYW4gUmVhZGFibGUgZXF1aXZhbGVudCBvZiB0aGUgdHJhbnNpdGlvbi5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBnZXREZXNjcmlwdGlvbkZvclRyYW5zaXRpb24oXG4gICAgICAgIHQ6IFRyYW5zaXRpb25UeXBlLFxuICAgICAgICB1c2VyQ291bnQ6IG51bWJlcixcbiAgICAgICAgcmVwZWF0czogbnVtYmVyLFxuICAgICk6IHN0cmluZyB8IEpTWC5FbGVtZW50IHtcbiAgICAgICAgLy8gVGhlIGVtcHR5IGludGVycG9sYXRpb25zICdzZXZlcmFsVXNlcnMnIGFuZCAnb25lVXNlcidcbiAgICAgICAgLy8gYXJlIHRoZXJlIG9ubHkgdG8gc2hvdyB0cmFuc2xhdG9ycyB0byBub24tRW5nbGlzaCBsYW5ndWFnZXNcbiAgICAgICAgLy8gdGhhdCB0aGUgdmVyYiBpcyBjb25qdWdhdGVkIHRvIHBsdXJhbCBvciBzaW5ndWxhciBTdWJqZWN0LlxuICAgICAgICBsZXQgcmVzID0gbnVsbDtcbiAgICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgICAgICBjYXNlIFwiam9pbmVkXCI6XG4gICAgICAgICAgICAgICAgcmVzID0gKHVzZXJDb3VudCA+IDEpXG4gICAgICAgICAgICAgICAgICAgID8gX3QoXCIlKHNldmVyYWxVc2Vycylzam9pbmVkICUoY291bnQpcyB0aW1lc1wiLCB7IHNldmVyYWxVc2VyczogXCJcIiwgY291bnQ6IHJlcGVhdHMgfSlcbiAgICAgICAgICAgICAgICAgICAgOiBfdChcIiUob25lVXNlcilzam9pbmVkICUoY291bnQpcyB0aW1lc1wiLCB7IG9uZVVzZXI6IFwiXCIsIGNvdW50OiByZXBlYXRzIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICAgICAgICByZXMgPSAodXNlckNvdW50ID4gMSlcbiAgICAgICAgICAgICAgICAgICAgPyBfdChcIiUoc2V2ZXJhbFVzZXJzKXNsZWZ0ICUoY291bnQpcyB0aW1lc1wiLCB7IHNldmVyYWxVc2VyczogXCJcIiwgY291bnQ6IHJlcGVhdHMgfSlcbiAgICAgICAgICAgICAgICAgICAgOiBfdChcIiUob25lVXNlcilzbGVmdCAlKGNvdW50KXMgdGltZXNcIiwgeyBvbmVVc2VyOiBcIlwiLCBjb3VudDogcmVwZWF0cyB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJqb2luZWRfYW5kX2xlZnRcIjpcbiAgICAgICAgICAgICAgICByZXMgPSAodXNlckNvdW50ID4gMSlcbiAgICAgICAgICAgICAgICAgICAgPyBfdChcIiUoc2V2ZXJhbFVzZXJzKXNqb2luZWQgYW5kIGxlZnQgJShjb3VudClzIHRpbWVzXCIsIHsgc2V2ZXJhbFVzZXJzOiBcIlwiLCBjb3VudDogcmVwZWF0cyB9KVxuICAgICAgICAgICAgICAgICAgICA6IF90KFwiJShvbmVVc2VyKXNqb2luZWQgYW5kIGxlZnQgJShjb3VudClzIHRpbWVzXCIsIHsgb25lVXNlcjogXCJcIiwgY291bnQ6IHJlcGVhdHMgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibGVmdF9hbmRfam9pbmVkXCI6XG4gICAgICAgICAgICAgICAgcmVzID0gKHVzZXJDb3VudCA+IDEpXG4gICAgICAgICAgICAgICAgICAgID8gX3QoXCIlKHNldmVyYWxVc2VycylzbGVmdCBhbmQgcmVqb2luZWQgJShjb3VudClzIHRpbWVzXCIsIHsgc2V2ZXJhbFVzZXJzOiBcIlwiLCBjb3VudDogcmVwZWF0cyB9KVxuICAgICAgICAgICAgICAgICAgICA6IF90KFwiJShvbmVVc2VyKXNsZWZ0IGFuZCByZWpvaW5lZCAlKGNvdW50KXMgdGltZXNcIiwgeyBvbmVVc2VyOiBcIlwiLCBjb3VudDogcmVwZWF0cyB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpbnZpdGVfcmVqZWN0XCI6XG4gICAgICAgICAgICAgICAgcmVzID0gKHVzZXJDb3VudCA+IDEpXG4gICAgICAgICAgICAgICAgICAgID8gX3QoXCIlKHNldmVyYWxVc2VycylzcmVqZWN0ZWQgdGhlaXIgaW52aXRhdGlvbnMgJShjb3VudClzIHRpbWVzXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldmVyYWxVc2VyczogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiByZXBlYXRzLFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICA6IF90KFwiJShvbmVVc2VyKXNyZWplY3RlZCB0aGVpciBpbnZpdGF0aW9uICUoY291bnQpcyB0aW1lc1wiLCB7IG9uZVVzZXI6IFwiXCIsIGNvdW50OiByZXBlYXRzIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImludml0ZV93aXRoZHJhd2FsXCI6XG4gICAgICAgICAgICAgICAgcmVzID0gKHVzZXJDb3VudCA+IDEpXG4gICAgICAgICAgICAgICAgICAgID8gX3QoXCIlKHNldmVyYWxVc2VycylzaGFkIHRoZWlyIGludml0YXRpb25zIHdpdGhkcmF3biAlKGNvdW50KXMgdGltZXNcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V2ZXJhbFVzZXJzOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IHJlcGVhdHMsXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIDogX3QoXCIlKG9uZVVzZXIpc2hhZCB0aGVpciBpbnZpdGF0aW9uIHdpdGhkcmF3biAlKGNvdW50KXMgdGltZXNcIiwgeyBvbmVVc2VyOiBcIlwiLCBjb3VudDogcmVwZWF0cyB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpbnZpdGVkXCI6XG4gICAgICAgICAgICAgICAgcmVzID0gKHVzZXJDb3VudCA+IDEpXG4gICAgICAgICAgICAgICAgICAgID8gX3QoXCJ3ZXJlIGludml0ZWQgJShjb3VudClzIHRpbWVzXCIsIHsgY291bnQ6IHJlcGVhdHMgfSlcbiAgICAgICAgICAgICAgICAgICAgOiBfdChcIndhcyBpbnZpdGVkICUoY291bnQpcyB0aW1lc1wiLCB7IGNvdW50OiByZXBlYXRzIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImJhbm5lZFwiOlxuICAgICAgICAgICAgICAgIHJlcyA9ICh1c2VyQ291bnQgPiAxKVxuICAgICAgICAgICAgICAgICAgICA/IF90KFwid2VyZSBiYW5uZWQgJShjb3VudClzIHRpbWVzXCIsIHsgY291bnQ6IHJlcGVhdHMgfSlcbiAgICAgICAgICAgICAgICAgICAgOiBfdChcIndhcyBiYW5uZWQgJShjb3VudClzIHRpbWVzXCIsIHsgY291bnQ6IHJlcGVhdHMgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidW5iYW5uZWRcIjpcbiAgICAgICAgICAgICAgICByZXMgPSAodXNlckNvdW50ID4gMSlcbiAgICAgICAgICAgICAgICAgICAgPyBfdChcIndlcmUgdW5iYW5uZWQgJShjb3VudClzIHRpbWVzXCIsIHsgY291bnQ6IHJlcGVhdHMgfSlcbiAgICAgICAgICAgICAgICAgICAgOiBfdChcIndhcyB1bmJhbm5lZCAlKGNvdW50KXMgdGltZXNcIiwgeyBjb3VudDogcmVwZWF0cyB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJraWNrZWRcIjpcbiAgICAgICAgICAgICAgICByZXMgPSAodXNlckNvdW50ID4gMSlcbiAgICAgICAgICAgICAgICAgICAgPyBfdChcIndlcmUga2lja2VkICUoY291bnQpcyB0aW1lc1wiLCB7IGNvdW50OiByZXBlYXRzIH0pXG4gICAgICAgICAgICAgICAgICAgIDogX3QoXCJ3YXMga2lja2VkICUoY291bnQpcyB0aW1lc1wiLCB7IGNvdW50OiByZXBlYXRzIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNoYW5nZWRfbmFtZVwiOlxuICAgICAgICAgICAgICAgIHJlcyA9ICh1c2VyQ291bnQgPiAxKVxuICAgICAgICAgICAgICAgICAgICA/IF90KFwiJShzZXZlcmFsVXNlcnMpc2NoYW5nZWQgdGhlaXIgbmFtZSAlKGNvdW50KXMgdGltZXNcIiwgeyBzZXZlcmFsVXNlcnM6IFwiXCIsIGNvdW50OiByZXBlYXRzIH0pXG4gICAgICAgICAgICAgICAgICAgIDogX3QoXCIlKG9uZVVzZXIpc2NoYW5nZWQgdGhlaXIgbmFtZSAlKGNvdW50KXMgdGltZXNcIiwgeyBvbmVVc2VyOiBcIlwiLCBjb3VudDogcmVwZWF0cyB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjaGFuZ2VkX2F2YXRhclwiOlxuICAgICAgICAgICAgICAgIHJlcyA9ICh1c2VyQ291bnQgPiAxKVxuICAgICAgICAgICAgICAgICAgICA/IF90KFwiJShzZXZlcmFsVXNlcnMpc2NoYW5nZWQgdGhlaXIgYXZhdGFyICUoY291bnQpcyB0aW1lc1wiLCB7IHNldmVyYWxVc2VyczogXCJcIiwgY291bnQ6IHJlcGVhdHMgfSlcbiAgICAgICAgICAgICAgICAgICAgOiBfdChcIiUob25lVXNlcilzY2hhbmdlZCB0aGVpciBhdmF0YXIgJShjb3VudClzIHRpbWVzXCIsIHsgb25lVXNlcjogXCJcIiwgY291bnQ6IHJlcGVhdHMgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibm9fY2hhbmdlXCI6XG4gICAgICAgICAgICAgICAgcmVzID0gKHVzZXJDb3VudCA+IDEpXG4gICAgICAgICAgICAgICAgICAgID8gX3QoXCIlKHNldmVyYWxVc2VycylzbWFkZSBubyBjaGFuZ2VzICUoY291bnQpcyB0aW1lc1wiLCB7IHNldmVyYWxVc2VyczogXCJcIiwgY291bnQ6IHJlcGVhdHMgfSlcbiAgICAgICAgICAgICAgICAgICAgOiBfdChcIiUob25lVXNlcilzbWFkZSBubyBjaGFuZ2VzICUoY291bnQpcyB0aW1lc1wiLCB7IG9uZVVzZXI6IFwiXCIsIGNvdW50OiByZXBlYXRzIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInNlcnZlcl9hY2xcIjpcbiAgICAgICAgICAgICAgICByZXMgPSAodXNlckNvdW50ID4gMSlcbiAgICAgICAgICAgICAgICAgICAgPyBfdChcIiUoc2V2ZXJhbFVzZXJzKXNjaGFuZ2VkIHRoZSBzZXJ2ZXIgQUNMcyAlKGNvdW50KXMgdGltZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgc2V2ZXJhbFVzZXJzOiBcIlwiLCBjb3VudDogcmVwZWF0cyB9KVxuICAgICAgICAgICAgICAgICAgICA6IF90KFwiJShvbmVVc2VyKXNjaGFuZ2VkIHRoZSBzZXJ2ZXIgQUNMcyAlKGNvdW50KXMgdGltZXNcIiwgeyBvbmVVc2VyOiBcIlwiLCBjb3VudDogcmVwZWF0cyB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJwaW5uZWRfbWVzc2FnZXNcIjpcbiAgICAgICAgICAgICAgICByZXMgPSAodXNlckNvdW50ID4gMSlcbiAgICAgICAgICAgICAgICAgICAgPyBfdChcIiUoc2V2ZXJhbFVzZXJzKXNjaGFuZ2VkIHRoZSA8YT5waW5uZWQgbWVzc2FnZXM8L2E+IGZvciB0aGUgcm9vbSAlKGNvdW50KXMgdGltZXMuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHNldmVyYWxVc2VyczogXCJcIiwgY291bnQ6IHJlcGVhdHMgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJhXCI6IChzdWIpID0+IDxhIG9uQ2xpY2s9e29uUGlubmVkTWVzc2FnZXNDbGlja30+IHsgc3ViIH0gPC9hPiB9KVxuICAgICAgICAgICAgICAgICAgICA6IF90KFwiJShvbmVVc2VyKXNjaGFuZ2VkIHRoZSA8YT5waW5uZWQgbWVzc2FnZXM8L2E+IGZvciB0aGUgcm9vbSAlKGNvdW50KXMgdGltZXMuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG9uZVVzZXI6IFwiXCIsIGNvdW50OiByZXBlYXRzIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IFwiYVwiOiAoc3ViKSA9PiA8YSBvbkNsaWNrPXtvblBpbm5lZE1lc3NhZ2VzQ2xpY2t9PiB7IHN1YiB9IDwvYT4gfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdldFRyYW5zaXRpb25TZXF1ZW5jZShldmVudHM6IElVc2VyRXZlbnRzW10pIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50cy5tYXAoTWVtYmVyRXZlbnRMaXN0U3VtbWFyeS5nZXRUcmFuc2l0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMYWJlbCBhIGdpdmVuIG1lbWJlcnNoaXAgZXZlbnQsIGBlYCwgd2hlcmUgYGdldENvbnRlbnQoKS5tZW1iZXJzaGlwYCBoYXNcbiAgICAgKiBjaGFuZ2VkIGZvciBlYWNoIHRyYW5zaXRpb24gYWxsb3dlZCBieSB0aGUgTWF0cml4IHByb3RvY29sLiBUaGlzIGF0dGVtcHRzIHRvXG4gICAgICogbGFiZWwgdGhlIG1lbWJlcnNoaXAgY2hhbmdlcyB0aGF0IG9jY3VyIGluIGAuLi8uLi8uLi9UZXh0Rm9yRXZlbnQuanNgLlxuICAgICAqIEBwYXJhbSB7TWF0cml4RXZlbnR9IGUgdGhlIG1lbWJlcnNoaXAgY2hhbmdlIGV2ZW50IHRvIGxhYmVsLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmc/fSB0aGUgdHJhbnNpdGlvbiB0eXBlIGdpdmVuIHRvIHRoaXMgZXZlbnQuIFRoaXMgZGVmYXVsdHMgdG8gYG51bGxgXG4gICAgICogaWYgYSB0cmFuc2l0aW9uIGlzIG5vdCByZWNvZ25pc2VkLlxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIGdldFRyYW5zaXRpb24oZTogSVVzZXJFdmVudHMpOiBUcmFuc2l0aW9uVHlwZSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBlLm14RXZlbnQuZ2V0VHlwZSgpO1xuXG4gICAgICAgIGlmICh0eXBlID09PSBFdmVudFR5cGUuUm9vbVRoaXJkUGFydHlJbnZpdGUpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSAzcGlkIGludml0ZXMgdGhlIHNhbWUgYXMgaW52aXRlcyBzbyB0aGV5IGdldCBidW5kbGVkIHRvZ2V0aGVyXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQzcGlkSW52aXRlKGUubXhFdmVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhbnNpdGlvblR5cGUuSW52aXRlV2l0aGRyYXdhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBUcmFuc2l0aW9uVHlwZS5JbnZpdGVkO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IEV2ZW50VHlwZS5Sb29tU2VydmVyQWNsKSB7XG4gICAgICAgICAgICByZXR1cm4gVHJhbnNpdGlvblR5cGUuU2VydmVyQWNsO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IEV2ZW50VHlwZS5Sb29tUGlubmVkRXZlbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gVHJhbnNpdGlvblR5cGUuQ2hhbmdlZFBpbnM7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGUubXhFdmVudC5nZXRDb250ZW50KCkubWVtYmVyc2hpcCkge1xuICAgICAgICAgICAgY2FzZSAnaW52aXRlJzogcmV0dXJuIFRyYW5zaXRpb25UeXBlLkludml0ZWQ7XG4gICAgICAgICAgICBjYXNlICdiYW4nOiByZXR1cm4gVHJhbnNpdGlvblR5cGUuQmFubmVkO1xuICAgICAgICAgICAgY2FzZSAnam9pbic6XG4gICAgICAgICAgICAgICAgaWYgKGUubXhFdmVudC5nZXRQcmV2Q29udGVudCgpLm1lbWJlcnNoaXAgPT09ICdqb2luJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5teEV2ZW50LmdldENvbnRlbnQoKS5kaXNwbGF5bmFtZSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgIGUubXhFdmVudC5nZXRQcmV2Q29udGVudCgpLmRpc3BsYXluYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gVHJhbnNpdGlvblR5cGUuQ2hhbmdlZE5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5teEV2ZW50LmdldENvbnRlbnQoKS5hdmF0YXJfdXJsICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5teEV2ZW50LmdldFByZXZDb250ZW50KCkuYXZhdGFyX3VybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRyYW5zaXRpb25UeXBlLkNoYW5nZWRBdmF0YXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJNRUxTIGlnbm9yaW5nIGR1cGxpY2F0ZSBtZW1iZXJzaGlwIGpvaW4gZXZlbnRcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUcmFuc2l0aW9uVHlwZS5Ob0NoYW5nZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVHJhbnNpdGlvblR5cGUuSm9pbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2xlYXZlJzpcbiAgICAgICAgICAgICAgICBpZiAoZS5teEV2ZW50LmdldFNlbmRlcigpID09PSBlLm14RXZlbnQuZ2V0U3RhdGVLZXkoKSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGUubXhFdmVudC5nZXRQcmV2Q29udGVudCgpLm1lbWJlcnNoaXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ludml0ZSc6IHJldHVybiBUcmFuc2l0aW9uVHlwZS5JbnZpdGVSZWplY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gVHJhbnNpdGlvblR5cGUuTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGUubXhFdmVudC5nZXRQcmV2Q29udGVudCgpLm1lbWJlcnNoaXApIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaW52aXRlJzogcmV0dXJuIFRyYW5zaXRpb25UeXBlLkludml0ZVdpdGhkcmF3YWw7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Jhbic6IHJldHVybiBUcmFuc2l0aW9uVHlwZS5VbmJhbm5lZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VuZGVyIGlzIG5vdCB0YXJnZXQgYW5kIG1hZGUgdGhlIHRhcmdldCBsZWF2ZSwgaWYgbm90IGZyb20gaW52aXRlL2JhbiB0aGVuIHRoaXMgaXMgYSBraWNrXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBUcmFuc2l0aW9uVHlwZS5LaWNrZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRBZ2dyZWdhdGUodXNlckV2ZW50czogUmVjb3JkPHN0cmluZywgSVVzZXJFdmVudHNbXT4pIHtcbiAgICAgICAgLy8gQSBtYXAgb2YgYWdncmVnYXRlIHR5cGUgdG8gYXJyYXlzIG9mIGRpc3BsYXkgbmFtZXMuIEVhY2ggYWdncmVnYXRlIHR5cGVcbiAgICAgICAgLy8gaXMgYSBjb21tYS1kZWxpbWl0ZWQgc3RyaW5nIG9mIHRyYW5zaXRpb25zLCBlLmcuIFwiam9pbmVkLGxlZnQsa2lja2VkXCIuXG4gICAgICAgIC8vIFRoZSBhcnJheSBvZiBkaXNwbGF5IG5hbWVzIGlzIHRoZSBhcnJheSBvZiB1c2VycyB3aG8gd2VudCB0aHJvdWdoIHRoYXRcbiAgICAgICAgLy8gc2VxdWVuY2UgZHVyaW5nIGV2ZW50c1RvUmVuZGVyLlxuICAgICAgICBjb25zdCBhZ2dyZWdhdGU6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPiA9IHtcbiAgICAgICAgICAgIC8vICRhZ2dyZWdhdGVUeXBlIDogW106c3RyaW5nXG4gICAgICAgIH07XG4gICAgICAgIC8vIEEgbWFwIG9mIGFnZ3JlZ2F0ZSB0eXBlcyB0byB0aGUgaW5kaWNlcyB0aGF0IG9yZGVyIHRoZW0gKHRoZSBpbmRleCBvZlxuICAgICAgICAvLyB0aGUgZmlyc3QgZXZlbnQgZm9yIGEgZ2l2ZW4gdHJhbnNpdGlvbiBzZXF1ZW5jZSlcbiAgICAgICAgY29uc3QgYWdncmVnYXRlSW5kaWNlczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHtcbiAgICAgICAgICAgIC8vICRhZ2dyZWdhdGVUeXBlIDogaW50XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgdXNlcnMgPSBPYmplY3Qua2V5cyh1c2VyRXZlbnRzKTtcbiAgICAgICAgdXNlcnMuZm9yRWFjaChcbiAgICAgICAgICAgICh1c2VySWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdEV2ZW50ID0gdXNlckV2ZW50c1t1c2VySWRdWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gZmlyc3RFdmVudC5kaXNwbGF5TmFtZTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcSA9IE1lbWJlckV2ZW50TGlzdFN1bW1hcnkuZ2V0VHJhbnNpdGlvblNlcXVlbmNlKHVzZXJFdmVudHNbdXNlcklkXSkuam9pbihTRVApO1xuICAgICAgICAgICAgICAgIGlmICghYWdncmVnYXRlW3NlcV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWdncmVnYXRlW3NlcV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgYWdncmVnYXRlSW5kaWNlc1tzZXFdID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYWdncmVnYXRlW3NlcV0ucHVzaChkaXNwbGF5TmFtZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYWdncmVnYXRlSW5kaWNlc1tzZXFdID09PSAtMSB8fFxuICAgICAgICAgICAgICAgICAgICBmaXJzdEV2ZW50LmluZGV4IDwgYWdncmVnYXRlSW5kaWNlc1tzZXFdXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGFnZ3JlZ2F0ZUluZGljZXNbc2VxXSA9IGZpcnN0RXZlbnQuaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZXM6IGFnZ3JlZ2F0ZSxcbiAgICAgICAgICAgIGluZGljZXM6IGFnZ3JlZ2F0ZUluZGljZXMsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBldmVudHNUb1JlbmRlciA9IHRoaXMucHJvcHMuZXZlbnRzO1xuXG4gICAgICAgIC8vIE1hcCB1c2VyIElEcyB0byBsYXRlc3QgQXZhdGFyIE1lbWJlci4gRVM2IE1hcHMgYXJlIG9yZGVyZWQgYnkgd2hlbiB0aGUga2V5IHdhcyBjcmVhdGVkLFxuICAgICAgICAvLyBzbyB0aGlzIHdvcmtzIHBlcmZlY3RseSBmb3IgdXMgdG8gbWF0Y2ggZXZlbnQgb3JkZXIgd2hpbHN0IHN0b3JpbmcgdGhlIGxhdGVzdCBBdmF0YXIgTWVtYmVyXG4gICAgICAgIGNvbnN0IGxhdGVzdFVzZXJBdmF0YXJNZW1iZXIgPSBuZXcgTWFwPHN0cmluZywgUm9vbU1lbWJlcj4oKTtcblxuICAgICAgICAvLyBPYmplY3QgbWFwcGluZyB1c2VyIElEcyB0byBhbiBhcnJheSBvZiBJVXNlckV2ZW50c1xuICAgICAgICBjb25zdCB1c2VyRXZlbnRzOiBSZWNvcmQ8c3RyaW5nLCBJVXNlckV2ZW50c1tdPiA9IHt9O1xuICAgICAgICBldmVudHNUb1JlbmRlci5mb3JFYWNoKChlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGUuZ2V0VHlwZSgpO1xuICAgICAgICAgICAgY29uc3QgdXNlcklkID0gdHlwZSA9PT0gRXZlbnRUeXBlLlJvb21TZXJ2ZXJBY2wgPyBlLmdldFNlbmRlcigpIDogZS5nZXRTdGF0ZUtleSgpO1xuICAgICAgICAgICAgLy8gSW5pdGlhbGlzZSBhIHVzZXIncyBldmVudHNcbiAgICAgICAgICAgIGlmICghdXNlckV2ZW50c1t1c2VySWRdKSB7XG4gICAgICAgICAgICAgICAgdXNlckV2ZW50c1t1c2VySWRdID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChTRU5ERVJfQVNfRElTUExBWV9OQU1FX0VWRU5UUy5pbmNsdWRlcyh0eXBlIGFzIEV2ZW50VHlwZSkpIHtcbiAgICAgICAgICAgICAgICBsYXRlc3RVc2VyQXZhdGFyTWVtYmVyLnNldCh1c2VySWQsIGUuc2VuZGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBsYXRlc3RVc2VyQXZhdGFyTWVtYmVyLnNldCh1c2VySWQsIGUudGFyZ2V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGRpc3BsYXlOYW1lID0gdXNlcklkO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IEV2ZW50VHlwZS5Sb29tVGhpcmRQYXJ0eUludml0ZSkge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lID0gZS5nZXRDb250ZW50KCkuZGlzcGxheV9uYW1lO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChTRU5ERVJfQVNfRElTUExBWV9OQU1FX0VWRU5UUy5pbmNsdWRlcyh0eXBlIGFzIEV2ZW50VHlwZSkpIHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZSA9IGUuc2VuZGVyLm5hbWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgZGlzcGxheU5hbWUgPSBlLnRhcmdldC5uYW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1c2VyRXZlbnRzW3VzZXJJZF0ucHVzaCh7XG4gICAgICAgICAgICAgICAgbXhFdmVudDogZSxcbiAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZSxcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgYWdncmVnYXRlID0gdGhpcy5nZXRBZ2dyZWdhdGUodXNlckV2ZW50cyk7XG5cbiAgICAgICAgLy8gU29ydCB0eXBlcyBieSBvcmRlciBvZiBsb3dlc3QgZXZlbnQgaW5kZXggd2l0aGluIHNlcXVlbmNlXG4gICAgICAgIGNvbnN0IG9yZGVyZWRUcmFuc2l0aW9uU2VxdWVuY2VzID0gT2JqZWN0LmtleXMoYWdncmVnYXRlLm5hbWVzKS5zb3J0KFxuICAgICAgICAgICAgKHNlcTEsIHNlcTIpID0+IGFnZ3JlZ2F0ZS5pbmRpY2VzW3NlcTFdIC0gYWdncmVnYXRlLmluZGljZXNbc2VxMl0sXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIDxFdmVudExpc3RTdW1tYXJ5XG4gICAgICAgICAgICBldmVudHM9e3RoaXMucHJvcHMuZXZlbnRzfVxuICAgICAgICAgICAgdGhyZXNob2xkPXt0aGlzLnByb3BzLnRocmVzaG9sZH1cbiAgICAgICAgICAgIG9uVG9nZ2xlPXt0aGlzLnByb3BzLm9uVG9nZ2xlfVxuICAgICAgICAgICAgc3RhcnRFeHBhbmRlZD17dGhpcy5wcm9wcy5zdGFydEV4cGFuZGVkfVxuICAgICAgICAgICAgY2hpbGRyZW49e3RoaXMucHJvcHMuY2hpbGRyZW59XG4gICAgICAgICAgICBzdW1tYXJ5TWVtYmVycz17Wy4uLmxhdGVzdFVzZXJBdmF0YXJNZW1iZXIudmFsdWVzKCldfVxuICAgICAgICAgICAgbGF5b3V0PXt0aGlzLnByb3BzLmxheW91dH1cbiAgICAgICAgICAgIHN1bW1hcnlUZXh0PXt0aGlzLmdlbmVyYXRlU3VtbWFyeShhZ2dyZWdhdGUubmFtZXMsIG9yZGVyZWRUcmFuc2l0aW9uU2VxdWVuY2VzKX0gLz47XG4gICAgfVxufVxuIl19