"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _languageHandler = require("../../../languageHandler");

var _dispatcher = _interopRequireDefault(require("../../../dispatcher/dispatcher"));

var _Permalinks = require("../../../utils/permalinks/Permalinks");

var _SettingsStore = _interopRequireDefault(require("../../../settings/SettingsStore"));

var _escapeHtml = _interopRequireDefault(require("escape-html"));

var _MatrixClientContext = _interopRequireDefault(require("../../../contexts/MatrixClientContext"));

var _FormattingUtils = require("../../../utils/FormattingUtils");

var _actions = require("../../../dispatcher/actions");

var _sanitizeHtml = _interopRequireDefault(require("sanitize-html"));

var _HtmlUtils = require("../../../HtmlUtils");

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _Spinner = _interopRequireDefault(require("./Spinner"));

var _ReplyTile = _interopRequireDefault(require("../rooms/ReplyTile"));

var _Pill = _interopRequireDefault(require("./Pill"));

var _event = require("matrix-js-sdk/src/@types/event");

var _dec, _class, _class2, _temp;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * This number is based on the previous behavior - if we have message of height
 * over 60px then we want to show button that will allow to expand it.
 */
const SHOW_EXPAND_QUOTE_PIXELS = 60;
let ReplyChain = ( // This component does no cycle detection, simply because the only way to make such a cycle would be to
// craft event_id's, using a homeserver that generates predictable event IDs; even then the impact would
// be low as each event being loaded (after the first) is triggered by an explicit user action.
_dec = (0, _replaceableComponent.replaceableComponent)("views.elements.ReplyChain"), _dec(_class = (_temp = _class2 = class ReplyChain extends _react.default.Component {
  constructor(props, context) {
    super(props, context);
    (0, _defineProperty2.default)(this, "unmounted", false);
    (0, _defineProperty2.default)(this, "room", void 0);
    (0, _defineProperty2.default)(this, "blockquoteRef", /*#__PURE__*/_react.default.createRef());
    (0, _defineProperty2.default)(this, "canCollapse", () => {
      return this.state.events.length > 1;
    });
    (0, _defineProperty2.default)(this, "collapse", () => {
      this.initialize();
    });
    (0, _defineProperty2.default)(this, "onQuoteClick", async event => {
      const events = [this.state.loadedEv, ...this.state.events];
      let loadedEv = null;

      if (events.length > 0) {
        loadedEv = await this.getNextEvent(events[0]);
      }

      this.setState({
        loadedEv,
        events
      });

      _dispatcher.default.fire(_actions.Action.FocusSendMessageComposer);
    });
    this.state = {
      events: [],
      loadedEv: null,
      loading: true,
      err: false
    };
    this.room = this.context.getRoom(this.props.parentEv.getRoomId());
  }

  static getParentEventId(ev) {
    if (!ev || ev.isRedacted()) return; // XXX: For newer relations (annotations, replacements, etc.), we now
    // have a `getRelation` helper on the event, and you might assume it
    // could be used here for replies as well... However, the helper
    // currently assumes the relation has a `rel_type`, which older replies
    // do not, so this block is left as-is for now.
    //
    // We're prefer ev.getContent() over ev.getWireContent() to make sure
    // we grab the latest edit with potentially new relations. But we also
    // can't just rely on ev.getContent() by itself because historically we
    // still show the reply from the original message even though the edit
    // event does not include the relation reply.

    const mRelatesTo = ev.getContent()['m.relates_to'] || ev.getWireContent()['m.relates_to'];

    if (mRelatesTo && mRelatesTo['m.in_reply_to']) {
      const mInReplyTo = mRelatesTo['m.in_reply_to'];
      if (mInReplyTo && mInReplyTo['event_id']) return mInReplyTo['event_id'];
    } else if (!_SettingsStore.default.getValue("feature_thread") && ev.isThreadRelation) {
      return ev.threadRootId;
    }
  } // Part of Replies fallback support


  static stripPlainReply(body) {
    // Removes lines beginning with `> ` until you reach one that doesn't.
    const lines = body.split('\n');

    while (lines.length && lines[0].startsWith('> ')) lines.shift(); // Reply fallback has a blank line after it, so remove it to prevent leading newline


    if (lines[0] === '') lines.shift();
    return lines.join('\n');
  } // Part of Replies fallback support


  static stripHTMLReply(html) {
    // Sanitize the original HTML for inclusion in <mx-reply>.  We allow
    // any HTML, since the original sender could use special tags that we
    // don't recognize, but want to pass along to any recipients who do
    // recognize them -- recipients should be sanitizing before displaying
    // anyways.  However, we sanitize to 1) remove any mx-reply, so that we
    // don't generate a nested mx-reply, and 2) make sure that the HTML is
    // properly formatted (e.g. tags are closed where necessary)
    return (0, _sanitizeHtml.default)(html, {
      allowedTags: false,
      // false means allow everything
      allowedAttributes: false,
      // we somehow can't allow all schemes, so we allow all that we
      // know of and mxc (for img tags)
      allowedSchemes: [..._HtmlUtils.PERMITTED_URL_SCHEMES, 'mxc'],
      exclusiveFilter: frame => frame.tag === "mx-reply"
    });
  } // Part of Replies fallback support


  static getNestedReplyText(ev, permalinkCreator) {
    if (!ev) return null;
    let {
      body,
      formatted_body: html
    } = ev.getContent();

    if (this.getParentEventId(ev)) {
      if (body) body = this.stripPlainReply(body);
    }

    if (!body) body = ""; // Always ensure we have a body, for reasons.

    if (html) {
      // sanitize the HTML before we put it in an <mx-reply>
      html = this.stripHTMLReply(html);
    } else {
      // Escape the body to use as HTML below.
      // We also run a nl2br over the result to fix the fallback representation. We do this
      // after converting the text to safe HTML to avoid user-provided BR's from being converted.
      html = (0, _escapeHtml.default)(body).replace(/\n/g, '<br/>');
    } // dev note: do not rely on `body` being safe for HTML usage below.


    const evLink = permalinkCreator.forEvent(ev.getId());
    const userLink = (0, _Permalinks.makeUserPermalink)(ev.getSender());
    const mxid = ev.getSender(); // This fallback contains text that is explicitly EN.

    switch (ev.getContent().msgtype) {
      case 'm.text':
      case 'm.notice':
        {
          html = `<mx-reply><blockquote><a href="${evLink}">In reply to</a> <a href="${userLink}">${mxid}</a>` + `<br>${html}</blockquote></mx-reply>`;
          const lines = body.trim().split('\n');

          if (lines.length > 0) {
            lines[0] = `<${mxid}> ${lines[0]}`;
            body = lines.map(line => `> ${line}`).join('\n') + '\n\n';
          }

          break;
        }

      case 'm.image':
        html = `<mx-reply><blockquote><a href="${evLink}">In reply to</a> <a href="${userLink}">${mxid}</a>` + `<br>sent an image.</blockquote></mx-reply>`;
        body = `> <${mxid}> sent an image.\n\n`;
        break;

      case 'm.video':
        html = `<mx-reply><blockquote><a href="${evLink}">In reply to</a> <a href="${userLink}">${mxid}</a>` + `<br>sent a video.</blockquote></mx-reply>`;
        body = `> <${mxid}> sent a video.\n\n`;
        break;

      case 'm.audio':
        html = `<mx-reply><blockquote><a href="${evLink}">In reply to</a> <a href="${userLink}">${mxid}</a>` + `<br>sent an audio file.</blockquote></mx-reply>`;
        body = `> <${mxid}> sent an audio file.\n\n`;
        break;

      case 'm.file':
        html = `<mx-reply><blockquote><a href="${evLink}">In reply to</a> <a href="${userLink}">${mxid}</a>` + `<br>sent a file.</blockquote></mx-reply>`;
        body = `> <${mxid}> sent a file.\n\n`;
        break;

      case 'm.emote':
        {
          html = `<mx-reply><blockquote><a href="${evLink}">In reply to</a> * ` + `<a href="${userLink}">${mxid}</a><br>${html}</blockquote></mx-reply>`;
          const lines = body.trim().split('\n');

          if (lines.length > 0) {
            lines[0] = `* <${mxid}> ${lines[0]}`;
            body = lines.map(line => `> ${line}`).join('\n') + '\n\n';
          }

          break;
        }

      default:
        return null;
    }

    return {
      body,
      html
    };
  }

  static makeReplyMixIn(ev) {
    if (!ev) return {};
    const mixin = {
      'm.relates_to': {
        'm.in_reply_to': {
          'event_id': ev.getId()
        }
      }
    };
    /**
     * If the event replied is part of a thread
     * Add the `m.thread` relation so that clients
     * that know how to handle that relation will
     * be able to render them more accurately
     */

    if (ev.isThreadRelation) {
      mixin['m.relates_to'] = _objectSpread(_objectSpread({}, mixin['m.relates_to']), {}, {
        rel_type: _event.RelationType.Thread,
        event_id: ev.threadRootId
      });
    }

    return mixin;
  }

  static hasReply(event) {
    return Boolean(ReplyChain.getParentEventId(event));
  }

  componentDidMount() {
    this.initialize();
    this.trySetExpandableQuotes();
  }

  componentDidUpdate() {
    this.props.onHeightChanged();
    this.trySetExpandableQuotes();
  }

  componentWillUnmount() {
    this.unmounted = true;
  }

  trySetExpandableQuotes() {
    if (this.props.isQuoteExpanded === undefined && this.blockquoteRef.current) {
      const el = this.blockquoteRef.current.querySelector('.mx_EventTile_body');

      if (el) {
        const code = el.querySelector('code');
        const isCodeEllipsisShown = code ? code.offsetHeight >= SHOW_EXPAND_QUOTE_PIXELS : false;
        const isElipsisShown = el.offsetHeight >= SHOW_EXPAND_QUOTE_PIXELS || isCodeEllipsisShown;

        if (isElipsisShown) {
          this.props.setQuoteExpanded(false);
        }
      }
    }
  }

  async initialize() {
    const {
      parentEv
    } = this.props; // at time of making this component we checked that props.parentEv has a parentEventId

    const ev = await this.getEvent(ReplyChain.getParentEventId(parentEv));
    if (this.unmounted) return;

    if (ev) {
      const loadedEv = await this.getNextEvent(ev);
      this.setState({
        events: [ev],
        loadedEv,
        loading: false
      });
    } else {
      this.setState({
        err: true
      });
    }
  }

  async getNextEvent(ev) {
    try {
      const inReplyToEventId = ReplyChain.getParentEventId(ev);
      return await this.getEvent(inReplyToEventId);
    } catch (e) {
      return null;
    }
  }

  async getEvent(eventId) {
    if (!eventId) return null;
    const event = this.room.findEventById(eventId);
    if (event) return event;

    try {
      // ask the client to fetch the event we want using the context API, only interface to do so is to ask
      // for a timeline with that event, but once it is loaded we can use findEventById to look up the ev map
      await this.context.getEventTimeline(this.room.getUnfilteredTimelineSet(), eventId);
    } catch (e) {
      // if it fails catch the error and return early, there's no point trying to find the event in this case.
      // Return null as it is falsey and thus should be treated as an error (as the event cannot be resolved).
      return null;
    }

    return this.room.findEventById(eventId);
  }

  getReplyChainColorClass(ev) {
    return (0, _FormattingUtils.getUserNameColorClass)(ev.getSender()).replace("Username", "ReplyChain");
  }

  render() {
    let header = null;

    if (this.state.err) {
      header = /*#__PURE__*/_react.default.createElement("blockquote", {
        className: "mx_ReplyChain mx_ReplyChain_error"
      }, (0, _languageHandler._t)('Unable to load event that was replied to, ' + 'it either does not exist or you do not have permission to view it.'));
    } else if (this.state.loadedEv) {
      const ev = this.state.loadedEv;
      const room = this.context.getRoom(ev.getRoomId());
      header = /*#__PURE__*/_react.default.createElement("blockquote", {
        className: `mx_ReplyChain ${this.getReplyChainColorClass(ev)}`
      }, (0, _languageHandler._t)('<a>In reply to</a> <pill>', {}, {
        'a': sub => /*#__PURE__*/_react.default.createElement("a", {
          onClick: this.onQuoteClick,
          className: "mx_ReplyChain_show"
        }, sub),
        'pill': /*#__PURE__*/_react.default.createElement(_Pill.default, {
          type: _Pill.default.TYPE_USER_MENTION,
          room: room,
          url: (0, _Permalinks.makeUserPermalink)(ev.getSender()),
          shouldShowPillAvatar: _SettingsStore.default.getValue("Pill.shouldShowPillAvatar")
        })
      }));
    } else if (this.props.forExport) {
      const eventId = ReplyChain.getParentEventId(this.props.parentEv);
      header = /*#__PURE__*/_react.default.createElement("p", {
        className: "mx_ReplyChain_Export"
      }, (0, _languageHandler._t)("In reply to <a>this message</a>", {}, {
        a: sub => /*#__PURE__*/_react.default.createElement("a", {
          className: "mx_reply_anchor",
          href: `#${eventId}`,
          "scroll-to": eventId
        }, " ", sub, " ")
      }));
    } else if (this.state.loading) {
      header = /*#__PURE__*/_react.default.createElement(_Spinner.default, {
        w: 16,
        h: 16
      });
    }

    const {
      isQuoteExpanded
    } = this.props;
    const evTiles = this.state.events.map(ev => {
      const classname = (0, _classnames.default)({
        'mx_ReplyChain': true,
        [this.getReplyChainColorClass(ev)]: true,
        // We don't want to add the class if it's undefined, it should only be expanded/collapsed when it's true/false
        'mx_ReplyChain--expanded': isQuoteExpanded === true,
        // We don't want to add the class if it's undefined, it should only be expanded/collapsed when it's true/false
        'mx_ReplyChain--collapsed': isQuoteExpanded === false
      });
      return /*#__PURE__*/_react.default.createElement("blockquote", {
        ref: this.blockquoteRef,
        className: classname,
        key: ev.getId()
      }, /*#__PURE__*/_react.default.createElement(_ReplyTile.default, {
        mxEvent: ev,
        onHeightChanged: this.props.onHeightChanged,
        permalinkCreator: this.props.permalinkCreator,
        toggleExpandedQuote: () => this.props.setQuoteExpanded(!this.props.isQuoteExpanded)
      }));
    });
    return /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_ReplyChain_wrapper"
    }, /*#__PURE__*/_react.default.createElement("div", null, header), /*#__PURE__*/_react.default.createElement("div", null, evTiles));
  }

}, (0, _defineProperty2.default)(_class2, "contextType", _MatrixClientContext.default), _temp)) || _class);
exports.default = ReplyChain;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2VsZW1lbnRzL1JlcGx5Q2hhaW4udHN4Il0sIm5hbWVzIjpbIlNIT1dfRVhQQU5EX1FVT1RFX1BJWEVMUyIsIlJlcGx5Q2hhaW4iLCJSZWFjdCIsIkNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJjb250ZXh0IiwiY3JlYXRlUmVmIiwic3RhdGUiLCJldmVudHMiLCJsZW5ndGgiLCJpbml0aWFsaXplIiwiZXZlbnQiLCJsb2FkZWRFdiIsImdldE5leHRFdmVudCIsInNldFN0YXRlIiwiZGlzIiwiZmlyZSIsIkFjdGlvbiIsIkZvY3VzU2VuZE1lc3NhZ2VDb21wb3NlciIsImxvYWRpbmciLCJlcnIiLCJyb29tIiwiZ2V0Um9vbSIsInBhcmVudEV2IiwiZ2V0Um9vbUlkIiwiZ2V0UGFyZW50RXZlbnRJZCIsImV2IiwiaXNSZWRhY3RlZCIsIm1SZWxhdGVzVG8iLCJnZXRDb250ZW50IiwiZ2V0V2lyZUNvbnRlbnQiLCJtSW5SZXBseVRvIiwiU2V0dGluZ3NTdG9yZSIsImdldFZhbHVlIiwiaXNUaHJlYWRSZWxhdGlvbiIsInRocmVhZFJvb3RJZCIsInN0cmlwUGxhaW5SZXBseSIsImJvZHkiLCJsaW5lcyIsInNwbGl0Iiwic3RhcnRzV2l0aCIsInNoaWZ0Iiwiam9pbiIsInN0cmlwSFRNTFJlcGx5IiwiaHRtbCIsImFsbG93ZWRUYWdzIiwiYWxsb3dlZEF0dHJpYnV0ZXMiLCJhbGxvd2VkU2NoZW1lcyIsIlBFUk1JVFRFRF9VUkxfU0NIRU1FUyIsImV4Y2x1c2l2ZUZpbHRlciIsImZyYW1lIiwidGFnIiwiZ2V0TmVzdGVkUmVwbHlUZXh0IiwicGVybWFsaW5rQ3JlYXRvciIsImZvcm1hdHRlZF9ib2R5IiwicmVwbGFjZSIsImV2TGluayIsImZvckV2ZW50IiwiZ2V0SWQiLCJ1c2VyTGluayIsImdldFNlbmRlciIsIm14aWQiLCJtc2d0eXBlIiwidHJpbSIsIm1hcCIsImxpbmUiLCJtYWtlUmVwbHlNaXhJbiIsIm1peGluIiwicmVsX3R5cGUiLCJSZWxhdGlvblR5cGUiLCJUaHJlYWQiLCJldmVudF9pZCIsImhhc1JlcGx5IiwiQm9vbGVhbiIsImNvbXBvbmVudERpZE1vdW50IiwidHJ5U2V0RXhwYW5kYWJsZVF1b3RlcyIsImNvbXBvbmVudERpZFVwZGF0ZSIsIm9uSGVpZ2h0Q2hhbmdlZCIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwidW5tb3VudGVkIiwiaXNRdW90ZUV4cGFuZGVkIiwidW5kZWZpbmVkIiwiYmxvY2txdW90ZVJlZiIsImN1cnJlbnQiLCJlbCIsInF1ZXJ5U2VsZWN0b3IiLCJjb2RlIiwiaXNDb2RlRWxsaXBzaXNTaG93biIsIm9mZnNldEhlaWdodCIsImlzRWxpcHNpc1Nob3duIiwic2V0UXVvdGVFeHBhbmRlZCIsImdldEV2ZW50IiwiaW5SZXBseVRvRXZlbnRJZCIsImUiLCJldmVudElkIiwiZmluZEV2ZW50QnlJZCIsImdldEV2ZW50VGltZWxpbmUiLCJnZXRVbmZpbHRlcmVkVGltZWxpbmVTZXQiLCJnZXRSZXBseUNoYWluQ29sb3JDbGFzcyIsInJlbmRlciIsImhlYWRlciIsInN1YiIsIm9uUXVvdGVDbGljayIsIlBpbGwiLCJUWVBFX1VTRVJfTUVOVElPTiIsImZvckV4cG9ydCIsImEiLCJldlRpbGVzIiwiY2xhc3NuYW1lIiwiTWF0cml4Q2xpZW50Q29udGV4dCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFpQkE7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7Ozs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQSx3QkFBd0IsR0FBRyxFQUFqQztJQWdDcUJDLFUsS0FKckI7QUFDQTtBQUNBO09BQ0MsZ0RBQXFCLDJCQUFyQixDLG1DQUFELE1BQ3FCQSxVQURyQixTQUN3Q0MsZUFBTUMsU0FEOUMsQ0FDd0U7QUFNcEVD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IEMuSS5DLlxuQ29weXJpZ2h0IDIwMTkgTWljaGFlbCBUZWxhdHluc2tpIDw3dDNjaGd1eUBnbWFpbC5jb20+XG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuXG5pbXBvcnQgeyBfdCB9IGZyb20gJy4uLy4uLy4uL2xhbmd1YWdlSGFuZGxlcic7XG5pbXBvcnQgZGlzIGZyb20gJy4uLy4uLy4uL2Rpc3BhdGNoZXIvZGlzcGF0Y2hlcic7XG5pbXBvcnQgeyBNYXRyaXhFdmVudCB9IGZyb20gJ21hdHJpeC1qcy1zZGsvc3JjL21vZGVscy9ldmVudCc7XG5pbXBvcnQgeyBtYWtlVXNlclBlcm1hbGluaywgUm9vbVBlcm1hbGlua0NyZWF0b3IgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvcGVybWFsaW5rcy9QZXJtYWxpbmtzXCI7XG5pbXBvcnQgU2V0dGluZ3NTdG9yZSBmcm9tIFwiLi4vLi4vLi4vc2V0dGluZ3MvU2V0dGluZ3NTdG9yZVwiO1xuaW1wb3J0IHsgTGF5b3V0IH0gZnJvbSBcIi4uLy4uLy4uL3NldHRpbmdzL2VudW1zL0xheW91dFwiO1xuaW1wb3J0IGVzY2FwZUh0bWwgZnJvbSBcImVzY2FwZS1odG1sXCI7XG5pbXBvcnQgTWF0cml4Q2xpZW50Q29udGV4dCBmcm9tIFwiLi4vLi4vLi4vY29udGV4dHMvTWF0cml4Q2xpZW50Q29udGV4dFwiO1xuaW1wb3J0IHsgZ2V0VXNlck5hbWVDb2xvckNsYXNzIH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL0Zvcm1hdHRpbmdVdGlsc1wiO1xuaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSBcIi4uLy4uLy4uL2Rpc3BhdGNoZXIvYWN0aW9uc1wiO1xuaW1wb3J0IHNhbml0aXplSHRtbCBmcm9tIFwic2FuaXRpemUtaHRtbFwiO1xuaW1wb3J0IHsgUEVSTUlUVEVEX1VSTF9TQ0hFTUVTIH0gZnJvbSBcIi4uLy4uLy4uL0h0bWxVdGlsc1wiO1xuaW1wb3J0IHsgcmVwbGFjZWFibGVDb21wb25lbnQgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvcmVwbGFjZWFibGVDb21wb25lbnRcIjtcbmltcG9ydCBTcGlubmVyIGZyb20gJy4vU3Bpbm5lcic7XG5pbXBvcnQgUmVwbHlUaWxlIGZyb20gXCIuLi9yb29tcy9SZXBseVRpbGVcIjtcbmltcG9ydCBQaWxsIGZyb20gJy4vUGlsbCc7XG5pbXBvcnQgeyBSb29tIH0gZnJvbSAnbWF0cml4LWpzLXNkay9zcmMvbW9kZWxzL3Jvb20nO1xuaW1wb3J0IHsgUmVsYXRpb25UeXBlIH0gZnJvbSAnbWF0cml4LWpzLXNkay9zcmMvQHR5cGVzL2V2ZW50JztcblxuLyoqXG4gKiBUaGlzIG51bWJlciBpcyBiYXNlZCBvbiB0aGUgcHJldmlvdXMgYmVoYXZpb3IgLSBpZiB3ZSBoYXZlIG1lc3NhZ2Ugb2YgaGVpZ2h0XG4gKiBvdmVyIDYwcHggdGhlbiB3ZSB3YW50IHRvIHNob3cgYnV0dG9uIHRoYXQgd2lsbCBhbGxvdyB0byBleHBhbmQgaXQuXG4gKi9cbmNvbnN0IFNIT1dfRVhQQU5EX1FVT1RFX1BJWEVMUyA9IDYwO1xuXG5pbnRlcmZhY2UgSVByb3BzIHtcbiAgICAvLyB0aGUgbGF0ZXN0IGV2ZW50IGluIHRoaXMgY2hhaW4gb2YgcmVwbGllc1xuICAgIHBhcmVudEV2PzogTWF0cml4RXZlbnQ7XG4gICAgLy8gY2FsbGVkIHdoZW4gdGhlIFJlcGx5Q2hhaW4gY29udGVudHMgaGFzIGNoYW5nZWQsIGluY2x1ZGluZyBFdmVudFRpbGVzIHRoZXJlb2ZcbiAgICBvbkhlaWdodENoYW5nZWQ6ICgpID0+IHZvaWQ7XG4gICAgcGVybWFsaW5rQ3JlYXRvcjogUm9vbVBlcm1hbGlua0NyZWF0b3I7XG4gICAgLy8gU3BlY2lmaWVzIHdoaWNoIGxheW91dCB0byB1c2UuXG4gICAgbGF5b3V0PzogTGF5b3V0O1xuICAgIC8vIFdoZXRoZXIgdG8gYWx3YXlzIHNob3cgYSB0aW1lc3RhbXBcbiAgICBhbHdheXNTaG93VGltZXN0YW1wcz86IGJvb2xlYW47XG4gICAgZm9yRXhwb3J0PzogYm9vbGVhbjtcbiAgICBpc1F1b3RlRXhwYW5kZWQ/OiBib29sZWFuO1xuICAgIHNldFF1b3RlRXhwYW5kZWQ6IChpc0V4cGFuZGVkOiBib29sZWFuKSA9PiB2b2lkO1xufVxuXG5pbnRlcmZhY2UgSVN0YXRlIHtcbiAgICAvLyBUaGUgbG9hZGVkIGV2ZW50cyB0byBiZSByZW5kZXJlZCBhcyBsaW5lYXItcmVwbGllc1xuICAgIGV2ZW50czogTWF0cml4RXZlbnRbXTtcbiAgICAvLyBUaGUgbGF0ZXN0IGxvYWRlZCBldmVudCB3aGljaCBoYXMgbm90IHlldCBiZWVuIHNob3duXG4gICAgbG9hZGVkRXY6IE1hdHJpeEV2ZW50O1xuICAgIC8vIFdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyBzdGlsbCBsb2FkaW5nIG1vcmUgZXZlbnRzXG4gICAgbG9hZGluZzogYm9vbGVhbjtcbiAgICAvLyBXaGV0aGVyIGFzIGVycm9yIHdhcyBlbmNvdW50ZXJlZCBmZXRjaGluZyBhIHJlcGxpZWQgdG8gZXZlbnQuXG4gICAgZXJyOiBib29sZWFuO1xufVxuXG4vLyBUaGlzIGNvbXBvbmVudCBkb2VzIG5vIGN5Y2xlIGRldGVjdGlvbiwgc2ltcGx5IGJlY2F1c2UgdGhlIG9ubHkgd2F5IHRvIG1ha2Ugc3VjaCBhIGN5Y2xlIHdvdWxkIGJlIHRvXG4vLyBjcmFmdCBldmVudF9pZCdzLCB1c2luZyBhIGhvbWVzZXJ2ZXIgdGhhdCBnZW5lcmF0ZXMgcHJlZGljdGFibGUgZXZlbnQgSURzOyBldmVuIHRoZW4gdGhlIGltcGFjdCB3b3VsZFxuLy8gYmUgbG93IGFzIGVhY2ggZXZlbnQgYmVpbmcgbG9hZGVkIChhZnRlciB0aGUgZmlyc3QpIGlzIHRyaWdnZXJlZCBieSBhbiBleHBsaWNpdCB1c2VyIGFjdGlvbi5cbkByZXBsYWNlYWJsZUNvbXBvbmVudChcInZpZXdzLmVsZW1lbnRzLlJlcGx5Q2hhaW5cIilcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlcGx5Q2hhaW4gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8SVByb3BzLCBJU3RhdGU+IHtcbiAgICBzdGF0aWMgY29udGV4dFR5cGUgPSBNYXRyaXhDbGllbnRDb250ZXh0O1xuICAgIHByaXZhdGUgdW5tb3VudGVkID0gZmFsc2U7XG4gICAgcHJpdmF0ZSByb29tOiBSb29tO1xuICAgIHByaXZhdGUgYmxvY2txdW90ZVJlZiA9IFJlYWN0LmNyZWF0ZVJlZjxIVE1MRWxlbWVudD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZXZlbnRzOiBbXSxcbiAgICAgICAgICAgIGxvYWRlZEV2OiBudWxsLFxuICAgICAgICAgICAgbG9hZGluZzogdHJ1ZSxcbiAgICAgICAgICAgIGVycjogZmFsc2UsXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yb29tID0gdGhpcy5jb250ZXh0LmdldFJvb20odGhpcy5wcm9wcy5wYXJlbnRFdi5nZXRSb29tSWQoKSk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBnZXRQYXJlbnRFdmVudElkKGV2OiBNYXRyaXhFdmVudCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgICAgIGlmICghZXYgfHwgZXYuaXNSZWRhY3RlZCgpKSByZXR1cm47XG5cbiAgICAgICAgLy8gWFhYOiBGb3IgbmV3ZXIgcmVsYXRpb25zIChhbm5vdGF0aW9ucywgcmVwbGFjZW1lbnRzLCBldGMuKSwgd2Ugbm93XG4gICAgICAgIC8vIGhhdmUgYSBgZ2V0UmVsYXRpb25gIGhlbHBlciBvbiB0aGUgZXZlbnQsIGFuZCB5b3UgbWlnaHQgYXNzdW1lIGl0XG4gICAgICAgIC8vIGNvdWxkIGJlIHVzZWQgaGVyZSBmb3IgcmVwbGllcyBhcyB3ZWxsLi4uIEhvd2V2ZXIsIHRoZSBoZWxwZXJcbiAgICAgICAgLy8gY3VycmVudGx5IGFzc3VtZXMgdGhlIHJlbGF0aW9uIGhhcyBhIGByZWxfdHlwZWAsIHdoaWNoIG9sZGVyIHJlcGxpZXNcbiAgICAgICAgLy8gZG8gbm90LCBzbyB0aGlzIGJsb2NrIGlzIGxlZnQgYXMtaXMgZm9yIG5vdy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2UncmUgcHJlZmVyIGV2LmdldENvbnRlbnQoKSBvdmVyIGV2LmdldFdpcmVDb250ZW50KCkgdG8gbWFrZSBzdXJlXG4gICAgICAgIC8vIHdlIGdyYWIgdGhlIGxhdGVzdCBlZGl0IHdpdGggcG90ZW50aWFsbHkgbmV3IHJlbGF0aW9ucy4gQnV0IHdlIGFsc29cbiAgICAgICAgLy8gY2FuJ3QganVzdCByZWx5IG9uIGV2LmdldENvbnRlbnQoKSBieSBpdHNlbGYgYmVjYXVzZSBoaXN0b3JpY2FsbHkgd2VcbiAgICAgICAgLy8gc3RpbGwgc2hvdyB0aGUgcmVwbHkgZnJvbSB0aGUgb3JpZ2luYWwgbWVzc2FnZSBldmVuIHRob3VnaCB0aGUgZWRpdFxuICAgICAgICAvLyBldmVudCBkb2VzIG5vdCBpbmNsdWRlIHRoZSByZWxhdGlvbiByZXBseS5cbiAgICAgICAgY29uc3QgbVJlbGF0ZXNUbyA9IGV2LmdldENvbnRlbnQoKVsnbS5yZWxhdGVzX3RvJ10gfHwgZXYuZ2V0V2lyZUNvbnRlbnQoKVsnbS5yZWxhdGVzX3RvJ107XG4gICAgICAgIGlmIChtUmVsYXRlc1RvICYmIG1SZWxhdGVzVG9bJ20uaW5fcmVwbHlfdG8nXSkge1xuICAgICAgICAgICAgY29uc3QgbUluUmVwbHlUbyA9IG1SZWxhdGVzVG9bJ20uaW5fcmVwbHlfdG8nXTtcbiAgICAgICAgICAgIGlmIChtSW5SZXBseVRvICYmIG1JblJlcGx5VG9bJ2V2ZW50X2lkJ10pIHJldHVybiBtSW5SZXBseVRvWydldmVudF9pZCddO1xuICAgICAgICB9IGVsc2UgaWYgKCFTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFwiZmVhdHVyZV90aHJlYWRcIikgJiYgZXYuaXNUaHJlYWRSZWxhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGV2LnRocmVhZFJvb3RJZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFBhcnQgb2YgUmVwbGllcyBmYWxsYmFjayBzdXBwb3J0XG4gICAgcHVibGljIHN0YXRpYyBzdHJpcFBsYWluUmVwbHkoYm9keTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgLy8gUmVtb3ZlcyBsaW5lcyBiZWdpbm5pbmcgd2l0aCBgPiBgIHVudGlsIHlvdSByZWFjaCBvbmUgdGhhdCBkb2Vzbid0LlxuICAgICAgICBjb25zdCBsaW5lcyA9IGJvZHkuc3BsaXQoJ1xcbicpO1xuICAgICAgICB3aGlsZSAobGluZXMubGVuZ3RoICYmIGxpbmVzWzBdLnN0YXJ0c1dpdGgoJz4gJykpIGxpbmVzLnNoaWZ0KCk7XG4gICAgICAgIC8vIFJlcGx5IGZhbGxiYWNrIGhhcyBhIGJsYW5rIGxpbmUgYWZ0ZXIgaXQsIHNvIHJlbW92ZSBpdCB0byBwcmV2ZW50IGxlYWRpbmcgbmV3bGluZVxuICAgICAgICBpZiAobGluZXNbMF0gPT09ICcnKSBsaW5lcy5zaGlmdCgpO1xuICAgICAgICByZXR1cm4gbGluZXMuam9pbignXFxuJyk7XG4gICAgfVxuXG4gICAgLy8gUGFydCBvZiBSZXBsaWVzIGZhbGxiYWNrIHN1cHBvcnRcbiAgICBwdWJsaWMgc3RhdGljIHN0cmlwSFRNTFJlcGx5KGh0bWw6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIC8vIFNhbml0aXplIHRoZSBvcmlnaW5hbCBIVE1MIGZvciBpbmNsdXNpb24gaW4gPG14LXJlcGx5Pi4gIFdlIGFsbG93XG4gICAgICAgIC8vIGFueSBIVE1MLCBzaW5jZSB0aGUgb3JpZ2luYWwgc2VuZGVyIGNvdWxkIHVzZSBzcGVjaWFsIHRhZ3MgdGhhdCB3ZVxuICAgICAgICAvLyBkb24ndCByZWNvZ25pemUsIGJ1dCB3YW50IHRvIHBhc3MgYWxvbmcgdG8gYW55IHJlY2lwaWVudHMgd2hvIGRvXG4gICAgICAgIC8vIHJlY29nbml6ZSB0aGVtIC0tIHJlY2lwaWVudHMgc2hvdWxkIGJlIHNhbml0aXppbmcgYmVmb3JlIGRpc3BsYXlpbmdcbiAgICAgICAgLy8gYW55d2F5cy4gIEhvd2V2ZXIsIHdlIHNhbml0aXplIHRvIDEpIHJlbW92ZSBhbnkgbXgtcmVwbHksIHNvIHRoYXQgd2VcbiAgICAgICAgLy8gZG9uJ3QgZ2VuZXJhdGUgYSBuZXN0ZWQgbXgtcmVwbHksIGFuZCAyKSBtYWtlIHN1cmUgdGhhdCB0aGUgSFRNTCBpc1xuICAgICAgICAvLyBwcm9wZXJseSBmb3JtYXR0ZWQgKGUuZy4gdGFncyBhcmUgY2xvc2VkIHdoZXJlIG5lY2Vzc2FyeSlcbiAgICAgICAgcmV0dXJuIHNhbml0aXplSHRtbChcbiAgICAgICAgICAgIGh0bWwsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYWxsb3dlZFRhZ3M6IGZhbHNlLCAvLyBmYWxzZSBtZWFucyBhbGxvdyBldmVyeXRoaW5nXG4gICAgICAgICAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIC8vIHdlIHNvbWVob3cgY2FuJ3QgYWxsb3cgYWxsIHNjaGVtZXMsIHNvIHdlIGFsbG93IGFsbCB0aGF0IHdlXG4gICAgICAgICAgICAgICAgLy8ga25vdyBvZiBhbmQgbXhjIChmb3IgaW1nIHRhZ3MpXG4gICAgICAgICAgICAgICAgYWxsb3dlZFNjaGVtZXM6IFsuLi5QRVJNSVRURURfVVJMX1NDSEVNRVMsICdteGMnXSxcbiAgICAgICAgICAgICAgICBleGNsdXNpdmVGaWx0ZXI6IChmcmFtZSkgPT4gZnJhbWUudGFnID09PSBcIm14LXJlcGx5XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIFBhcnQgb2YgUmVwbGllcyBmYWxsYmFjayBzdXBwb3J0XG4gICAgcHVibGljIHN0YXRpYyBnZXROZXN0ZWRSZXBseVRleHQoXG4gICAgICAgIGV2OiBNYXRyaXhFdmVudCxcbiAgICAgICAgcGVybWFsaW5rQ3JlYXRvcjogUm9vbVBlcm1hbGlua0NyZWF0b3IsXG4gICAgKTogeyBib2R5OiBzdHJpbmcsIGh0bWw6IHN0cmluZyB9IHwgbnVsbCB7XG4gICAgICAgIGlmICghZXYpIHJldHVybiBudWxsO1xuXG4gICAgICAgIGxldCB7IGJvZHksIGZvcm1hdHRlZF9ib2R5OiBodG1sIH0gPSBldi5nZXRDb250ZW50KCk7XG4gICAgICAgIGlmICh0aGlzLmdldFBhcmVudEV2ZW50SWQoZXYpKSB7XG4gICAgICAgICAgICBpZiAoYm9keSkgYm9keSA9IHRoaXMuc3RyaXBQbGFpblJlcGx5KGJvZHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFib2R5KSBib2R5ID0gXCJcIjsgLy8gQWx3YXlzIGVuc3VyZSB3ZSBoYXZlIGEgYm9keSwgZm9yIHJlYXNvbnMuXG5cbiAgICAgICAgaWYgKGh0bWwpIHtcbiAgICAgICAgICAgIC8vIHNhbml0aXplIHRoZSBIVE1MIGJlZm9yZSB3ZSBwdXQgaXQgaW4gYW4gPG14LXJlcGx5PlxuICAgICAgICAgICAgaHRtbCA9IHRoaXMuc3RyaXBIVE1MUmVwbHkoaHRtbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBFc2NhcGUgdGhlIGJvZHkgdG8gdXNlIGFzIEhUTUwgYmVsb3cuXG4gICAgICAgICAgICAvLyBXZSBhbHNvIHJ1biBhIG5sMmJyIG92ZXIgdGhlIHJlc3VsdCB0byBmaXggdGhlIGZhbGxiYWNrIHJlcHJlc2VudGF0aW9uLiBXZSBkbyB0aGlzXG4gICAgICAgICAgICAvLyBhZnRlciBjb252ZXJ0aW5nIHRoZSB0ZXh0IHRvIHNhZmUgSFRNTCB0byBhdm9pZCB1c2VyLXByb3ZpZGVkIEJSJ3MgZnJvbSBiZWluZyBjb252ZXJ0ZWQuXG4gICAgICAgICAgICBodG1sID0gZXNjYXBlSHRtbChib2R5KS5yZXBsYWNlKC9cXG4vZywgJzxici8+Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZXYgbm90ZTogZG8gbm90IHJlbHkgb24gYGJvZHlgIGJlaW5nIHNhZmUgZm9yIEhUTUwgdXNhZ2UgYmVsb3cuXG5cbiAgICAgICAgY29uc3QgZXZMaW5rID0gcGVybWFsaW5rQ3JlYXRvci5mb3JFdmVudChldi5nZXRJZCgpKTtcbiAgICAgICAgY29uc3QgdXNlckxpbmsgPSBtYWtlVXNlclBlcm1hbGluayhldi5nZXRTZW5kZXIoKSk7XG4gICAgICAgIGNvbnN0IG14aWQgPSBldi5nZXRTZW5kZXIoKTtcblxuICAgICAgICAvLyBUaGlzIGZhbGxiYWNrIGNvbnRhaW5zIHRleHQgdGhhdCBpcyBleHBsaWNpdGx5IEVOLlxuICAgICAgICBzd2l0Y2ggKGV2LmdldENvbnRlbnQoKS5tc2d0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdtLnRleHQnOlxuICAgICAgICAgICAgY2FzZSAnbS5ub3RpY2UnOiB7XG4gICAgICAgICAgICAgICAgaHRtbCA9IGA8bXgtcmVwbHk+PGJsb2NrcXVvdGU+PGEgaHJlZj1cIiR7ZXZMaW5rfVwiPkluIHJlcGx5IHRvPC9hPiA8YSBocmVmPVwiJHt1c2VyTGlua31cIj4ke214aWR9PC9hPmBcbiAgICAgICAgICAgICAgICAgICAgKyBgPGJyPiR7aHRtbH08L2Jsb2NrcXVvdGU+PC9teC1yZXBseT5gO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gYm9keS50cmltKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzWzBdID0gYDwke214aWR9PiAke2xpbmVzWzBdfWA7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBsaW5lcy5tYXAoKGxpbmUpID0+IGA+ICR7bGluZX1gKS5qb2luKCdcXG4nKSArICdcXG5cXG4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ20uaW1hZ2UnOlxuICAgICAgICAgICAgICAgIGh0bWwgPSBgPG14LXJlcGx5PjxibG9ja3F1b3RlPjxhIGhyZWY9XCIke2V2TGlua31cIj5JbiByZXBseSB0bzwvYT4gPGEgaHJlZj1cIiR7dXNlckxpbmt9XCI+JHtteGlkfTwvYT5gXG4gICAgICAgICAgICAgICAgICAgICsgYDxicj5zZW50IGFuIGltYWdlLjwvYmxvY2txdW90ZT48L214LXJlcGx5PmA7XG4gICAgICAgICAgICAgICAgYm9keSA9IGA+IDwke214aWR9PiBzZW50IGFuIGltYWdlLlxcblxcbmA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtLnZpZGVvJzpcbiAgICAgICAgICAgICAgICBodG1sID0gYDxteC1yZXBseT48YmxvY2txdW90ZT48YSBocmVmPVwiJHtldkxpbmt9XCI+SW4gcmVwbHkgdG88L2E+IDxhIGhyZWY9XCIke3VzZXJMaW5rfVwiPiR7bXhpZH08L2E+YFxuICAgICAgICAgICAgICAgICAgICArIGA8YnI+c2VudCBhIHZpZGVvLjwvYmxvY2txdW90ZT48L214LXJlcGx5PmA7XG4gICAgICAgICAgICAgICAgYm9keSA9IGA+IDwke214aWR9PiBzZW50IGEgdmlkZW8uXFxuXFxuYDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ20uYXVkaW8nOlxuICAgICAgICAgICAgICAgIGh0bWwgPSBgPG14LXJlcGx5PjxibG9ja3F1b3RlPjxhIGhyZWY9XCIke2V2TGlua31cIj5JbiByZXBseSB0bzwvYT4gPGEgaHJlZj1cIiR7dXNlckxpbmt9XCI+JHtteGlkfTwvYT5gXG4gICAgICAgICAgICAgICAgICAgICsgYDxicj5zZW50IGFuIGF1ZGlvIGZpbGUuPC9ibG9ja3F1b3RlPjwvbXgtcmVwbHk+YDtcbiAgICAgICAgICAgICAgICBib2R5ID0gYD4gPCR7bXhpZH0+IHNlbnQgYW4gYXVkaW8gZmlsZS5cXG5cXG5gO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbS5maWxlJzpcbiAgICAgICAgICAgICAgICBodG1sID0gYDxteC1yZXBseT48YmxvY2txdW90ZT48YSBocmVmPVwiJHtldkxpbmt9XCI+SW4gcmVwbHkgdG88L2E+IDxhIGhyZWY9XCIke3VzZXJMaW5rfVwiPiR7bXhpZH08L2E+YFxuICAgICAgICAgICAgICAgICAgICArIGA8YnI+c2VudCBhIGZpbGUuPC9ibG9ja3F1b3RlPjwvbXgtcmVwbHk+YDtcbiAgICAgICAgICAgICAgICBib2R5ID0gYD4gPCR7bXhpZH0+IHNlbnQgYSBmaWxlLlxcblxcbmA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtLmVtb3RlJzoge1xuICAgICAgICAgICAgICAgIGh0bWwgPSBgPG14LXJlcGx5PjxibG9ja3F1b3RlPjxhIGhyZWY9XCIke2V2TGlua31cIj5JbiByZXBseSB0bzwvYT4gKiBgXG4gICAgICAgICAgICAgICAgICAgICsgYDxhIGhyZWY9XCIke3VzZXJMaW5rfVwiPiR7bXhpZH08L2E+PGJyPiR7aHRtbH08L2Jsb2NrcXVvdGU+PC9teC1yZXBseT5gO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gYm9keS50cmltKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzWzBdID0gYCogPCR7bXhpZH0+ICR7bGluZXNbMF19YDtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IGxpbmVzLm1hcCgobGluZSkgPT4gYD4gJHtsaW5lfWApLmpvaW4oJ1xcbicpICsgJ1xcblxcbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IGJvZHksIGh0bWwgfTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIG1ha2VSZXBseU1peEluKGV2OiBNYXRyaXhFdmVudCkge1xuICAgICAgICBpZiAoIWV2KSByZXR1cm4ge307XG5cbiAgICAgICAgY29uc3QgbWl4aW46IGFueSA9IHtcbiAgICAgICAgICAgICdtLnJlbGF0ZXNfdG8nOiB7XG4gICAgICAgICAgICAgICAgJ20uaW5fcmVwbHlfdG8nOiB7XG4gICAgICAgICAgICAgICAgICAgICdldmVudF9pZCc6IGV2LmdldElkKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBldmVudCByZXBsaWVkIGlzIHBhcnQgb2YgYSB0aHJlYWRcbiAgICAgICAgICogQWRkIHRoZSBgbS50aHJlYWRgIHJlbGF0aW9uIHNvIHRoYXQgY2xpZW50c1xuICAgICAgICAgKiB0aGF0IGtub3cgaG93IHRvIGhhbmRsZSB0aGF0IHJlbGF0aW9uIHdpbGxcbiAgICAgICAgICogYmUgYWJsZSB0byByZW5kZXIgdGhlbSBtb3JlIGFjY3VyYXRlbHlcbiAgICAgICAgICovXG4gICAgICAgIGlmIChldi5pc1RocmVhZFJlbGF0aW9uKSB7XG4gICAgICAgICAgICBtaXhpblsnbS5yZWxhdGVzX3RvJ10gPSB7XG4gICAgICAgICAgICAgICAgLi4ubWl4aW5bJ20ucmVsYXRlc190byddLFxuICAgICAgICAgICAgICAgIHJlbF90eXBlOiBSZWxhdGlvblR5cGUuVGhyZWFkLFxuICAgICAgICAgICAgICAgIGV2ZW50X2lkOiBldi50aHJlYWRSb290SWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1peGluO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgaGFzUmVwbHkoZXZlbnQ6IE1hdHJpeEV2ZW50KSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKFJlcGx5Q2hhaW4uZ2V0UGFyZW50RXZlbnRJZChldmVudCkpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgdGhpcy50cnlTZXRFeHBhbmRhYmxlUXVvdGVzKCk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICB0aGlzLnByb3BzLm9uSGVpZ2h0Q2hhbmdlZCgpO1xuICAgICAgICB0aGlzLnRyeVNldEV4cGFuZGFibGVRdW90ZXMoKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy51bm1vdW50ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgdHJ5U2V0RXhwYW5kYWJsZVF1b3RlcygpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuaXNRdW90ZUV4cGFuZGVkID09PSB1bmRlZmluZWQgJiYgdGhpcy5ibG9ja3F1b3RlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsOiBIVE1MRWxlbWVudCB8IG51bGwgPSB0aGlzLmJsb2NrcXVvdGVSZWYuY3VycmVudC5xdWVyeVNlbGVjdG9yKCcubXhfRXZlbnRUaWxlX2JvZHknKTtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGU6IEhUTUxFbGVtZW50IHwgbnVsbCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2NvZGUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0NvZGVFbGxpcHNpc1Nob3duID0gY29kZSA/IGNvZGUub2Zmc2V0SGVpZ2h0ID49IFNIT1dfRVhQQU5EX1FVT1RFX1BJWEVMUyA6IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzRWxpcHNpc1Nob3duID0gZWwub2Zmc2V0SGVpZ2h0ID49IFNIT1dfRVhQQU5EX1FVT1RFX1BJWEVMUyB8fCBpc0NvZGVFbGxpcHNpc1Nob3duO1xuICAgICAgICAgICAgICAgIGlmIChpc0VsaXBzaXNTaG93bikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnNldFF1b3RlRXhwYW5kZWQoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgaW5pdGlhbGl6ZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgeyBwYXJlbnRFdiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgLy8gYXQgdGltZSBvZiBtYWtpbmcgdGhpcyBjb21wb25lbnQgd2UgY2hlY2tlZCB0aGF0IHByb3BzLnBhcmVudEV2IGhhcyBhIHBhcmVudEV2ZW50SWRcbiAgICAgICAgY29uc3QgZXYgPSBhd2FpdCB0aGlzLmdldEV2ZW50KFJlcGx5Q2hhaW4uZ2V0UGFyZW50RXZlbnRJZChwYXJlbnRFdikpO1xuXG4gICAgICAgIGlmICh0aGlzLnVubW91bnRlZCkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChldikge1xuICAgICAgICAgICAgY29uc3QgbG9hZGVkRXYgPSBhd2FpdCB0aGlzLmdldE5leHRFdmVudChldik7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBldmVudHM6IFtldl0sXG4gICAgICAgICAgICAgICAgbG9hZGVkRXYsXG4gICAgICAgICAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBlcnI6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIGdldE5leHRFdmVudChldjogTWF0cml4RXZlbnQpOiBQcm9taXNlPE1hdHJpeEV2ZW50PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpblJlcGx5VG9FdmVudElkID0gUmVwbHlDaGFpbi5nZXRQYXJlbnRFdmVudElkKGV2KTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldEV2ZW50KGluUmVwbHlUb0V2ZW50SWQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgZ2V0RXZlbnQoZXZlbnRJZDogc3RyaW5nKTogUHJvbWlzZTxNYXRyaXhFdmVudD4ge1xuICAgICAgICBpZiAoIWV2ZW50SWQpIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBldmVudCA9IHRoaXMucm9vbS5maW5kRXZlbnRCeUlkKGV2ZW50SWQpO1xuICAgICAgICBpZiAoZXZlbnQpIHJldHVybiBldmVudDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gYXNrIHRoZSBjbGllbnQgdG8gZmV0Y2ggdGhlIGV2ZW50IHdlIHdhbnQgdXNpbmcgdGhlIGNvbnRleHQgQVBJLCBvbmx5IGludGVyZmFjZSB0byBkbyBzbyBpcyB0byBhc2tcbiAgICAgICAgICAgIC8vIGZvciBhIHRpbWVsaW5lIHdpdGggdGhhdCBldmVudCwgYnV0IG9uY2UgaXQgaXMgbG9hZGVkIHdlIGNhbiB1c2UgZmluZEV2ZW50QnlJZCB0byBsb29rIHVwIHRoZSBldiBtYXBcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY29udGV4dC5nZXRFdmVudFRpbWVsaW5lKHRoaXMucm9vbS5nZXRVbmZpbHRlcmVkVGltZWxpbmVTZXQoKSwgZXZlbnRJZCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0IGZhaWxzIGNhdGNoIHRoZSBlcnJvciBhbmQgcmV0dXJuIGVhcmx5LCB0aGVyZSdzIG5vIHBvaW50IHRyeWluZyB0byBmaW5kIHRoZSBldmVudCBpbiB0aGlzIGNhc2UuXG4gICAgICAgICAgICAvLyBSZXR1cm4gbnVsbCBhcyBpdCBpcyBmYWxzZXkgYW5kIHRodXMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYW4gZXJyb3IgKGFzIHRoZSBldmVudCBjYW5ub3QgYmUgcmVzb2x2ZWQpLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucm9vbS5maW5kRXZlbnRCeUlkKGV2ZW50SWQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBjYW5Db2xsYXBzZSA9ICgpOiBib29sZWFuID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuZXZlbnRzLmxlbmd0aCA+IDE7XG4gICAgfTtcblxuICAgIHB1YmxpYyBjb2xsYXBzZSA9ICgpOiB2b2lkID0+IHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25RdW90ZUNsaWNrID0gYXN5bmMgKGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50PEhUTUxBbmNob3JFbGVtZW50LCBNb3VzZUV2ZW50Pik6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgICBjb25zdCBldmVudHMgPSBbdGhpcy5zdGF0ZS5sb2FkZWRFdiwgLi4udGhpcy5zdGF0ZS5ldmVudHNdO1xuXG4gICAgICAgIGxldCBsb2FkZWRFdiA9IG51bGw7XG4gICAgICAgIGlmIChldmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbG9hZGVkRXYgPSBhd2FpdCB0aGlzLmdldE5leHRFdmVudChldmVudHNbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBsb2FkZWRFdixcbiAgICAgICAgICAgIGV2ZW50cyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGlzLmZpcmUoQWN0aW9uLkZvY3VzU2VuZE1lc3NhZ2VDb21wb3Nlcik7XG4gICAgfTtcblxuICAgIHByaXZhdGUgZ2V0UmVwbHlDaGFpbkNvbG9yQ2xhc3MoZXY6IE1hdHJpeEV2ZW50KTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGdldFVzZXJOYW1lQ29sb3JDbGFzcyhldi5nZXRTZW5kZXIoKSkucmVwbGFjZShcIlVzZXJuYW1lXCIsIFwiUmVwbHlDaGFpblwiKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCBoZWFkZXIgPSBudWxsO1xuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmVycikge1xuICAgICAgICAgICAgaGVhZGVyID0gPGJsb2NrcXVvdGUgY2xhc3NOYW1lPVwibXhfUmVwbHlDaGFpbiBteF9SZXBseUNoYWluX2Vycm9yXCI+XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBfdCgnVW5hYmxlIHRvIGxvYWQgZXZlbnQgdGhhdCB3YXMgcmVwbGllZCB0bywgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnaXQgZWl0aGVyIGRvZXMgbm90IGV4aXN0IG9yIHlvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIHZpZXcgaXQuJylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA8L2Jsb2NrcXVvdGU+O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUubG9hZGVkRXYpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ID0gdGhpcy5zdGF0ZS5sb2FkZWRFdjtcbiAgICAgICAgICAgIGNvbnN0IHJvb20gPSB0aGlzLmNvbnRleHQuZ2V0Um9vbShldi5nZXRSb29tSWQoKSk7XG4gICAgICAgICAgICBoZWFkZXIgPSA8YmxvY2txdW90ZSBjbGFzc05hbWU9e2BteF9SZXBseUNoYWluICR7dGhpcy5nZXRSZXBseUNoYWluQ29sb3JDbGFzcyhldil9YH0+XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBfdCgnPGE+SW4gcmVwbHkgdG88L2E+IDxwaWxsPicsIHt9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnYSc6IChzdWIpID0+IDxhIG9uQ2xpY2s9e3RoaXMub25RdW90ZUNsaWNrfSBjbGFzc05hbWU9XCJteF9SZXBseUNoYWluX3Nob3dcIj57IHN1YiB9PC9hPixcbiAgICAgICAgICAgICAgICAgICAgICAgICdwaWxsJzogKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxQaWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9e1BpbGwuVFlQRV9VU0VSX01FTlRJT059XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb209e3Jvb219XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybD17bWFrZVVzZXJQZXJtYWxpbmsoZXYuZ2V0U2VuZGVyKCkpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRTaG93UGlsbEF2YXRhcj17U2V0dGluZ3NTdG9yZS5nZXRWYWx1ZShcIlBpbGwuc2hvdWxkU2hvd1BpbGxBdmF0YXJcIil9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgPC9ibG9ja3F1b3RlPjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLmZvckV4cG9ydCkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRJZCA9IFJlcGx5Q2hhaW4uZ2V0UGFyZW50RXZlbnRJZCh0aGlzLnByb3BzLnBhcmVudEV2KTtcbiAgICAgICAgICAgIGhlYWRlciA9IDxwIGNsYXNzTmFtZT1cIm14X1JlcGx5Q2hhaW5fRXhwb3J0XCI+XG4gICAgICAgICAgICAgICAgeyBfdChcIkluIHJlcGx5IHRvIDxhPnRoaXMgbWVzc2FnZTwvYT5cIixcbiAgICAgICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgICAgIHsgYTogKHN1YikgPT4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3NOYW1lPVwibXhfcmVwbHlfYW5jaG9yXCIgaHJlZj17YCMke2V2ZW50SWR9YH0gc2Nyb2xsLXRvPXtldmVudElkfT4geyBzdWIgfSA8L2E+XG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgPC9wPjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmxvYWRpbmcpIHtcbiAgICAgICAgICAgIGhlYWRlciA9IDxTcGlubmVyIHc9ezE2fSBoPXsxNn0gLz47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGlzUXVvdGVFeHBhbmRlZCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgZXZUaWxlcyA9IHRoaXMuc3RhdGUuZXZlbnRzLm1hcCgoZXYpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzbmFtZSA9IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgICAgICdteF9SZXBseUNoYWluJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBbdGhpcy5nZXRSZXBseUNoYWluQ29sb3JDbGFzcyhldildOiB0cnVlLFxuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gYWRkIHRoZSBjbGFzcyBpZiBpdCdzIHVuZGVmaW5lZCwgaXQgc2hvdWxkIG9ubHkgYmUgZXhwYW5kZWQvY29sbGFwc2VkIHdoZW4gaXQncyB0cnVlL2ZhbHNlXG4gICAgICAgICAgICAgICAgJ214X1JlcGx5Q2hhaW4tLWV4cGFuZGVkJzogaXNRdW90ZUV4cGFuZGVkID09PSB0cnVlLFxuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gYWRkIHRoZSBjbGFzcyBpZiBpdCdzIHVuZGVmaW5lZCwgaXQgc2hvdWxkIG9ubHkgYmUgZXhwYW5kZWQvY29sbGFwc2VkIHdoZW4gaXQncyB0cnVlL2ZhbHNlXG4gICAgICAgICAgICAgICAgJ214X1JlcGx5Q2hhaW4tLWNvbGxhcHNlZCc6IGlzUXVvdGVFeHBhbmRlZCA9PT0gZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPGJsb2NrcXVvdGUgcmVmPXt0aGlzLmJsb2NrcXVvdGVSZWZ9IGNsYXNzTmFtZT17Y2xhc3NuYW1lfSBrZXk9e2V2LmdldElkKCl9PlxuICAgICAgICAgICAgICAgICAgICA8UmVwbHlUaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBteEV2ZW50PXtldn1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uSGVpZ2h0Q2hhbmdlZD17dGhpcy5wcm9wcy5vbkhlaWdodENoYW5nZWR9XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJtYWxpbmtDcmVhdG9yPXt0aGlzLnByb3BzLnBlcm1hbGlua0NyZWF0b3J9XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2dnbGVFeHBhbmRlZFF1b3RlPXsoKSA9PiB0aGlzLnByb3BzLnNldFF1b3RlRXhwYW5kZWQoIXRoaXMucHJvcHMuaXNRdW90ZUV4cGFuZGVkKX1cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8L2Jsb2NrcXVvdGU+XG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9XCJteF9SZXBseUNoYWluX3dyYXBwZXJcIj5cbiAgICAgICAgICAgIDxkaXY+eyBoZWFkZXIgfTwvZGl2PlxuICAgICAgICAgICAgPGRpdj57IGV2VGlsZXMgfTwvZGl2PlxuICAgICAgICA8L2Rpdj47XG4gICAgfVxufVxuIl19