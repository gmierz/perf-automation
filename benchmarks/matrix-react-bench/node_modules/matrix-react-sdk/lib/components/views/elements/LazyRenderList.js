"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _dec, _class, _class2, _temp;

class ItemRange {
  constructor(topCount, renderCount, bottomCount) {
    this.topCount = topCount;
    this.renderCount = renderCount;
    this.bottomCount = bottomCount;
  }

  contains(range) {
    // don't contain empty ranges
    // as it will prevent clearing the list
    // once it is scrolled far enough out of view
    if (!range.renderCount && this.renderCount) {
      return false;
    }

    return range.topCount >= this.topCount && range.topCount + range.renderCount <= this.topCount + this.renderCount;
  }

  expand(amount) {
    // don't expand ranges that won't render anything
    if (this.renderCount === 0) {
      return this;
    }

    const topGrow = Math.min(amount, this.topCount);
    const bottomGrow = Math.min(amount, this.bottomCount);
    return new ItemRange(this.topCount - topGrow, this.renderCount + topGrow + bottomGrow, this.bottomCount - bottomGrow);
  }

  totalSize() {
    return this.topCount + this.renderCount + this.bottomCount;
  }

}

let LazyRenderList = (_dec = (0, _replaceableComponent.replaceableComponent)("views.elements.LazyRenderList"), _dec(_class = (_temp = _class2 = class LazyRenderList extends _react.default.Component {
  constructor(props) {
    super(props);
    this.state = {
      renderRange: null
    };
  }

  static getDerivedStateFromProps(props, state) {
    const range = LazyRenderList.getVisibleRangeFromProps(props);
    const intersectRange = range.expand(props.overflowMargin);
    const renderRange = range.expand(props.overflowItems);
    const listHasChangedSize = !!state.renderRange && renderRange.totalSize() !== state.renderRange.totalSize(); // only update render Range if the list has shrunk/grown and we need to adjust padding OR
    // if the new range + overflowMargin isn't contained by the old anymore

    if (listHasChangedSize || !state.renderRange || !state.renderRange.contains(intersectRange)) {
      return {
        renderRange
      };
    }

    return null;
  }

  static getVisibleRangeFromProps(props) {
    const {
      items,
      itemHeight,
      scrollTop,
      height
    } = props;
    const length = items ? items.length : 0;
    const topCount = Math.min(Math.max(0, Math.floor(scrollTop / itemHeight)), length);
    const itemsAfterTop = length - topCount;
    const visibleItems = height !== 0 ? Math.ceil(height / itemHeight) : 0;
    const renderCount = Math.min(visibleItems, itemsAfterTop);
    const bottomCount = itemsAfterTop - renderCount;
    return new ItemRange(topCount, renderCount, bottomCount);
  }

  render() {
    const {
      itemHeight,
      items,
      renderItem
    } = this.props;
    const {
      renderRange
    } = this.state;
    const {
      topCount,
      renderCount,
      bottomCount
    } = renderRange;
    const paddingTop = topCount * itemHeight;
    const paddingBottom = bottomCount * itemHeight;
    const renderedItems = (items || []).slice(topCount, topCount + renderCount);
    const element = this.props.element || "div";
    const elementProps = {
      "style": {
        paddingTop: `${paddingTop}px`,
        paddingBottom: `${paddingBottom}px`
      },
      "className": this.props.className
    };
    return /*#__PURE__*/_react.default.createElement(element, elementProps, renderedItems.map(renderItem));
  }

}, (0, _defineProperty2.default)(_class2, "defaultProps", {
  overflowItems: 20,
  overflowMargin: 5
}), _temp)) || _class);
exports.default = LazyRenderList;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2VsZW1lbnRzL0xhenlSZW5kZXJMaXN0LnRzeCJdLCJuYW1lcyI6WyJJdGVtUmFuZ2UiLCJjb25zdHJ1Y3RvciIsInRvcENvdW50IiwicmVuZGVyQ291bnQiLCJib3R0b21Db3VudCIsImNvbnRhaW5zIiwicmFuZ2UiLCJleHBhbmQiLCJhbW91bnQiLCJ0b3BHcm93IiwiTWF0aCIsIm1pbiIsImJvdHRvbUdyb3ciLCJ0b3RhbFNpemUiLCJMYXp5UmVuZGVyTGlzdCIsIlJlYWN0IiwiQ29tcG9uZW50IiwicHJvcHMiLCJzdGF0ZSIsInJlbmRlclJhbmdlIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiZ2V0VmlzaWJsZVJhbmdlRnJvbVByb3BzIiwiaW50ZXJzZWN0UmFuZ2UiLCJvdmVyZmxvd01hcmdpbiIsIm92ZXJmbG93SXRlbXMiLCJsaXN0SGFzQ2hhbmdlZFNpemUiLCJpdGVtcyIsIml0ZW1IZWlnaHQiLCJzY3JvbGxUb3AiLCJoZWlnaHQiLCJsZW5ndGgiLCJtYXgiLCJmbG9vciIsIml0ZW1zQWZ0ZXJUb3AiLCJ2aXNpYmxlSXRlbXMiLCJjZWlsIiwicmVuZGVyIiwicmVuZGVySXRlbSIsInBhZGRpbmdUb3AiLCJwYWRkaW5nQm90dG9tIiwicmVuZGVyZWRJdGVtcyIsInNsaWNlIiwiZWxlbWVudCIsImVsZW1lbnRQcm9wcyIsImNsYXNzTmFtZSIsImNyZWF0ZUVsZW1lbnQiLCJtYXAiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBZ0JBOztBQUNBOzs7O0FBRUEsTUFBTUEsU0FBTixDQUFnQjtBQUNaQyxFQUFBQSxXQUFXLENBQ0FDLFFBREEsRUFFQUMsV0FGQSxFQUdBQyxXQUhBLEVBSVQ7QUFBQSxTQUhTRixRQUdULEdBSFNBLFFBR1Q7QUFBQSxTQUZTQyxXQUVULEdBRlNBLFdBRVQ7QUFBQSxTQURTQyxXQUNULEdBRFNBLFdBQ1Q7QUFBRzs7QUFFRUMsRUFBQUEsUUFBUSxDQUFD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QkFBYSxLQUFLdEIsS0FBTCxDQUFXMkI7QUFGUCxLQUFyQjtBQUlBLHdCQUFPN0IsZUFBTThCLGFBQU4sQ0FBb0JILE9BQXBCLEVBQTZCQyxZQUE3QixFQUEyQ0gsYUFBYSxDQUFDTSxHQUFkLENBQWtCVCxVQUFsQixDQUEzQyxDQUFQO0FBQ0g7O0FBeERtRixDLHlEQUM3QjtBQUNuRGIsRUFBQUEsYUFBYSxFQUFFLEVBRG9DO0FBRW5ERCxFQUFBQSxjQUFjLEVBQUU7QUFGbUMsQyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxOSBOZXcgVmVjdG9yIEx0ZFxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHJlcGxhY2VhYmxlQ29tcG9uZW50IH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL3JlcGxhY2VhYmxlQ29tcG9uZW50XCI7XG5cbmNsYXNzIEl0ZW1SYW5nZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHB1YmxpYyB0b3BDb3VudDogbnVtYmVyLFxuICAgICAgICBwdWJsaWMgcmVuZGVyQ291bnQ6IG51bWJlcixcbiAgICAgICAgcHVibGljIGJvdHRvbUNvdW50OiBudW1iZXIsXG4gICAgKSB7IH1cblxuICAgIHB1YmxpYyBjb250YWlucyhyYW5nZTogSXRlbVJhbmdlKTogYm9vbGVhbiB7XG4gICAgICAgIC8vIGRvbid0IGNvbnRhaW4gZW1wdHkgcmFuZ2VzXG4gICAgICAgIC8vIGFzIGl0IHdpbGwgcHJldmVudCBjbGVhcmluZyB0aGUgbGlzdFxuICAgICAgICAvLyBvbmNlIGl0IGlzIHNjcm9sbGVkIGZhciBlbm91Z2ggb3V0IG9mIHZpZXdcbiAgICAgICAgaWYgKCFyYW5nZS5yZW5kZXJDb3VudCAmJiB0aGlzLnJlbmRlckNvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlLnRvcENvdW50ID49IHRoaXMudG9wQ291bnQgJiZcbiAgICAgICAgICAgIChyYW5nZS50b3BDb3VudCArIHJhbmdlLnJlbmRlckNvdW50KSA8PSAodGhpcy50b3BDb3VudCArIHRoaXMucmVuZGVyQ291bnQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBleHBhbmQoYW1vdW50OiBudW1iZXIpOiBJdGVtUmFuZ2Uge1xuICAgICAgICAvLyBkb24ndCBleHBhbmQgcmFuZ2VzIHRoYXQgd29uJ3QgcmVuZGVyIGFueXRoaW5nXG4gICAgICAgIGlmICh0aGlzLnJlbmRlckNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRvcEdyb3cgPSBNYXRoLm1pbihhbW91bnQsIHRoaXMudG9wQ291bnQpO1xuICAgICAgICBjb25zdCBib3R0b21Hcm93ID0gTWF0aC5taW4oYW1vdW50LCB0aGlzLmJvdHRvbUNvdW50KTtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVtUmFuZ2UoXG4gICAgICAgICAgICB0aGlzLnRvcENvdW50IC0gdG9wR3JvdyxcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ291bnQgKyB0b3BHcm93ICsgYm90dG9tR3JvdyxcbiAgICAgICAgICAgIHRoaXMuYm90dG9tQ291bnQgLSBib3R0b21Hcm93LFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHB1YmxpYyB0b3RhbFNpemUoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9wQ291bnQgKyB0aGlzLnJlbmRlckNvdW50ICsgdGhpcy5ib3R0b21Db3VudDtcbiAgICB9XG59XG5cbmludGVyZmFjZSBJUHJvcHM8VD4ge1xuICAgIC8vIGhlaWdodCBpbiBwaXhlbHMgb2YgdGhlIGNvbXBvbmVudCByZXR1cm5lZCBieSBgcmVuZGVySXRlbWBcbiAgICBpdGVtSGVpZ2h0OiBudW1iZXI7XG4gICAgLy8gZnVuY3Rpb24gdG8gdHVybiBhbiBlbGVtZW50IG9mIGBpdGVtc2AgaW50byBhIHJlYWN0IGNvbXBvbmVudFxuICAgIHJlbmRlckl0ZW06IChpdGVtOiBUKSA9PiBKU1guRWxlbWVudDtcbiAgICAvLyBzY3JvbGxUb3Agb2YgdGhlIHZpZXdwb3J0IChtaW51cyB0aGUgaGVpZ2h0IG9mIGFueSBjb250ZW50IGFib3ZlIHRoaXMgbGlzdCBsaWtlIG90aGVyIGBMYXp5UmVuZGVyTGlzdGBzKVxuICAgIHNjcm9sbFRvcDogbnVtYmVyO1xuICAgIC8vIHRoZSBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0IHRoaXMgY29udGVudCBpcyBzY3JvbGxlZCBpblxuICAgIGhlaWdodDogbnVtYmVyO1xuICAgIC8vIGFsbCBpdGVtcyBmb3IgdGhlIGxpc3QuIFRoZXNlIHNob3VsZCBub3QgYmUgcmVhY3QgY29tcG9uZW50cywgc2VlIGByZW5kZXJJdGVtYC5cbiAgICBpdGVtcz86IFRbXTtcbiAgICAvLyB0aGUgYW1vdW50IG9mIGl0ZW1zIHRvIHNjcm9sbCBiZWZvcmUgY2F1c2luZyBhIHJlcmVuZGVyLFxuICAgIC8vIHNob3VsZCB0eXBpY2FsbHkgYmUgbGVzcyB0aGFuIGBvdmVyZmxvd0l0ZW1zYCB1bmxlc3MgYXBwbHlpbmdcbiAgICAvLyBtYXJnaW5zIGluIHRoZSBwYXJlbnQgY29tcG9uZW50IHdoZW4gdXNpbmcgbXVsdGlwbGUgTGF6eVJlbmRlckxpc3QgaW4gb25lIHZpZXdwb3J0LlxuICAgIC8vIHVzZSAwIHRvIG9ubHkgcmVyZW5kZXIgd2hlbiBpdGVtcyB3aWxsIGNvbWUgaW50byB2aWV3LlxuICAgIG92ZXJmbG93TWFyZ2luPzogbnVtYmVyO1xuICAgIC8vIHRoZSBhbW91bnQgb2YgaXRlbXMgdG8gYWRkIGF0IHRoZSB0b3AgYW5kIGJvdHRvbSB0byByZW5kZXIsXG4gICAgLy8gc28gbm90IGV2ZXJ5IHNjcm9sbCBvZiBjYXVzZXMgYSByZXJlbmRlci5cbiAgICBvdmVyZmxvd0l0ZW1zPzogbnVtYmVyO1xuXG4gICAgZWxlbWVudD86IHN0cmluZztcbiAgICBjbGFzc05hbWU/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBJU3RhdGUge1xuICAgIHJlbmRlclJhbmdlOiBJdGVtUmFuZ2U7XG59XG5cbkByZXBsYWNlYWJsZUNvbXBvbmVudChcInZpZXdzLmVsZW1lbnRzLkxhenlSZW5kZXJMaXN0XCIpXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYXp5UmVuZGVyTGlzdDxUID0gYW55PiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxJUHJvcHM8VD4sIElTdGF0ZT4ge1xuICAgIHB1YmxpYyBzdGF0aWMgZGVmYXVsdFByb3BzOiBQYXJ0aWFsPElQcm9wczx1bmtub3duPj4gPSB7XG4gICAgICAgIG92ZXJmbG93SXRlbXM6IDIwLFxuICAgICAgICBvdmVyZmxvd01hcmdpbjogNSxcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHM6IElQcm9wczxUPikge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHJlbmRlclJhbmdlOiBudWxsLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzOiBJUHJvcHM8dW5rbm93bj4sIHN0YXRlOiBJU3RhdGUpOiBQYXJ0aWFsPElTdGF0ZT4ge1xuICAgICAgICBjb25zdCByYW5nZSA9IExhenlSZW5kZXJMaXN0LmdldFZpc2libGVSYW5nZUZyb21Qcm9wcyhwcm9wcyk7XG4gICAgICAgIGNvbnN0IGludGVyc2VjdFJhbmdlID0gcmFuZ2UuZXhwYW5kKHByb3BzLm92ZXJmbG93TWFyZ2luKTtcbiAgICAgICAgY29uc3QgcmVuZGVyUmFuZ2UgPSByYW5nZS5leHBhbmQocHJvcHMub3ZlcmZsb3dJdGVtcyk7XG4gICAgICAgIGNvbnN0IGxpc3RIYXNDaGFuZ2VkU2l6ZSA9ICEhc3RhdGUucmVuZGVyUmFuZ2UgJiYgcmVuZGVyUmFuZ2UudG90YWxTaXplKCkgIT09IHN0YXRlLnJlbmRlclJhbmdlLnRvdGFsU2l6ZSgpO1xuICAgICAgICAvLyBvbmx5IHVwZGF0ZSByZW5kZXIgUmFuZ2UgaWYgdGhlIGxpc3QgaGFzIHNocnVuay9ncm93biBhbmQgd2UgbmVlZCB0byBhZGp1c3QgcGFkZGluZyBPUlxuICAgICAgICAvLyBpZiB0aGUgbmV3IHJhbmdlICsgb3ZlcmZsb3dNYXJnaW4gaXNuJ3QgY29udGFpbmVkIGJ5IHRoZSBvbGQgYW55bW9yZVxuICAgICAgICBpZiAobGlzdEhhc0NoYW5nZWRTaXplIHx8ICFzdGF0ZS5yZW5kZXJSYW5nZSB8fCAhc3RhdGUucmVuZGVyUmFuZ2UuY29udGFpbnMoaW50ZXJzZWN0UmFuZ2UpKSB7XG4gICAgICAgICAgICByZXR1cm4geyByZW5kZXJSYW5nZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdldFZpc2libGVSYW5nZUZyb21Qcm9wcyhwcm9wczogSVByb3BzPHVua25vd24+KTogSXRlbVJhbmdlIHtcbiAgICAgICAgY29uc3QgeyBpdGVtcywgaXRlbUhlaWdodCwgc2Nyb2xsVG9wLCBoZWlnaHQgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBpdGVtcyA/IGl0ZW1zLmxlbmd0aCA6IDA7XG4gICAgICAgIGNvbnN0IHRvcENvdW50ID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihzY3JvbGxUb3AgLyBpdGVtSGVpZ2h0KSksIGxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGl0ZW1zQWZ0ZXJUb3AgPSBsZW5ndGggLSB0b3BDb3VudDtcbiAgICAgICAgY29uc3QgdmlzaWJsZUl0ZW1zID0gaGVpZ2h0ICE9PSAwID8gTWF0aC5jZWlsKGhlaWdodCAvIGl0ZW1IZWlnaHQpIDogMDtcbiAgICAgICAgY29uc3QgcmVuZGVyQ291bnQgPSBNYXRoLm1pbih2aXNpYmxlSXRlbXMsIGl0ZW1zQWZ0ZXJUb3ApO1xuICAgICAgICBjb25zdCBib3R0b21Db3VudCA9IGl0ZW1zQWZ0ZXJUb3AgLSByZW5kZXJDb3VudDtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVtUmFuZ2UodG9wQ291bnQsIHJlbmRlckNvdW50LCBib3R0b21Db3VudCk7XG4gICAgfVxuXG4gICAgcHVibGljIHJlbmRlcigpOiBKU1guRWxlbWVudCB7XG4gICAgICAgIGNvbnN0IHsgaXRlbUhlaWdodCwgaXRlbXMsIHJlbmRlckl0ZW0gfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgcmVuZGVyUmFuZ2UgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgdG9wQ291bnQsIHJlbmRlckNvdW50LCBib3R0b21Db3VudCB9ID0gcmVuZGVyUmFuZ2U7XG5cbiAgICAgICAgY29uc3QgcGFkZGluZ1RvcCA9IHRvcENvdW50ICogaXRlbUhlaWdodDtcbiAgICAgICAgY29uc3QgcGFkZGluZ0JvdHRvbSA9IGJvdHRvbUNvdW50ICogaXRlbUhlaWdodDtcbiAgICAgICAgY29uc3QgcmVuZGVyZWRJdGVtcyA9IChpdGVtcyB8fCBbXSkuc2xpY2UoXG4gICAgICAgICAgICB0b3BDb3VudCxcbiAgICAgICAgICAgIHRvcENvdW50ICsgcmVuZGVyQ291bnQsXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMucHJvcHMuZWxlbWVudCB8fCBcImRpdlwiO1xuICAgICAgICBjb25zdCBlbGVtZW50UHJvcHMgPSB7XG4gICAgICAgICAgICBcInN0eWxlXCI6IHsgcGFkZGluZ1RvcDogYCR7cGFkZGluZ1RvcH1weGAsIHBhZGRpbmdCb3R0b206IGAke3BhZGRpbmdCb3R0b219cHhgIH0sXG4gICAgICAgICAgICBcImNsYXNzTmFtZVwiOiB0aGlzLnByb3BzLmNsYXNzTmFtZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoZWxlbWVudCwgZWxlbWVudFByb3BzLCByZW5kZXJlZEl0ZW1zLm1hcChyZW5kZXJJdGVtKSk7XG4gICAgfVxufVxuXG4iXX0=