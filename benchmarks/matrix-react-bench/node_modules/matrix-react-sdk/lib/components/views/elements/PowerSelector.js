"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var Roles = _interopRequireWildcard(require("../../../Roles"));

var _languageHandler = require("../../../languageHandler");

var _Field = _interopRequireDefault(require("./Field"));

var _Keyboard = require("../../../Keyboard");

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _dec, _class, _class2, _temp;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const CUSTOM_VALUE = "SELECT_VALUE_CUSTOM";
let PowerSelector = (_dec = (0, _replaceableComponent.replaceableComponent)("views.elements.PowerSelector"), _dec(_class = (_temp = _class2 = class PowerSelector extends _react.default.Component {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "onSelectChange", event => {
      const isCustom = event.target.value === CUSTOM_VALUE;

      if (isCustom) {
        this.setState({
          custom: true
        });
      } else {
        const powerLevel = parseInt(event.target.value);
        this.props.onChange(powerLevel, this.props.powerLevelKey);
        this.setState({
          selectValue: powerLevel
        });
      }
    });
    (0, _defineProperty2.default)(this, "onCustomChange", event => {
      this.setState({
        customValue: parseInt(event.target.value)
      });
    });
    (0, _defineProperty2.default)(this, "onCustomBlur", event => {
      event.preventDefault();
      event.stopPropagation();
      this.props.onChange(this.state.customValue, this.props.powerLevelKey);
    });
    (0, _defineProperty2.default)(this, "onCustomKeyDown", event => {
      if (event.key === _Keyboard.Key.ENTER) {
        event.preventDefault();
        event.stopPropagation(); // Do not call the onChange handler directly here - it can cause an infinite loop.
        // Long story short, a user hits Enter to submit the value which onChange handles as
        // raising a dialog which causes a blur which causes a dialog which causes a blur and
        // so on. By not causing the onChange to be called here, we avoid the loop because we
        // handle the onBlur safely.

        event.target.blur();
      }
    });
    this.state = {
      levelRoleMap: {},
      // List of power levels to show in the drop-down
      options: [],
      customValue: this.props.value,
      selectValue: 0
    };
  } // TODO: [REACT-WARNING] Replace with appropriate lifecycle event
  // eslint-disable-next-line camelcase, @typescript-eslint/naming-convention


  UNSAFE_componentWillMount() {
    this.initStateFromProps(this.props);
  } // eslint-disable-next-line camelcase, @typescript-eslint/naming-convention


  UNSAFE_componentWillReceiveProps(newProps) {
    this.initStateFromProps(newProps);
  }

  initStateFromProps(newProps) {
    // This needs to be done now because levelRoleMap has translated strings
    const levelRoleMap = Roles.levelRoleMap(newProps.usersDefault);
    const options = Object.keys(levelRoleMap).filter(level => {
      return level === undefined || parseInt(level) <= newProps.maxValue || parseInt(level) == newProps.value;
    }).map(level => parseInt(level));
    const isCustom = levelRoleMap[newProps.value] === undefined;
    this.setState({
      levelRoleMap,
      options,
      custom: isCustom,
      customLevel: newProps.value,
      selectValue: isCustom ? CUSTOM_VALUE : newProps.value
    });
  }

  render() {
    let picker;
    const label = typeof this.props.label === "undefined" ? (0, _languageHandler._t)("Power level") : this.props.label;

    if (this.state.custom) {
      picker = /*#__PURE__*/_react.default.createElement(_Field.default, {
        type: "number",
        label: label,
        max: this.props.maxValue,
        onBlur: this.onCustomBlur,
        onKeyDown: this.onCustomKeyDown,
        onChange: this.onCustomChange,
        value: String(this.state.customValue),
        disabled: this.props.disabled
      });
    } else {
      // Each level must have a definition in this.state.levelRoleMap
      const options = this.state.options.map(level => {
        return {
          value: String(level),
          text: Roles.textualPowerLevel(level, this.props.usersDefault)
        };
      });
      options.push({
        value: CUSTOM_VALUE,
        text: (0, _languageHandler._t)("Custom level")
      });
      const optionsElements = options.map(op => {
        return /*#__PURE__*/_react.default.createElement("option", {
          value: op.value,
          key: op.value
        }, op.text);
      });
      picker = /*#__PURE__*/_react.default.createElement(_Field.default, {
        element: "select",
        label: label,
        onChange: this.onSelectChange,
        value: String(this.state.selectValue),
        disabled: this.props.disabled
      }, optionsElements);
    }

    return /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_PowerSelector"
    }, picker);
  }

}, (0, _defineProperty2.default)(_class2, "defaultProps", {
  maxValue: Infinity,
  usersDefault: 0
}), _temp)) || _class);
exports.default = PowerSelector;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2VsZW1lbnRzL1Bvd2VyU2VsZWN0b3IudHN4Il0sIm5hbWVzIjpbIkNVU1RPTV9WQUxVRSIsIlBvd2VyU2VsZWN0b3IiLCJSZWFjdCIsIkNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJldmVudCIsImlzQ3VzdG9tIiwidGFyZ2V0IiwidmFsdWUiLCJzZXRTdGF0ZSIsImN1c3RvbSIsInBvd2VyTGV2ZWwiLCJwYXJzZUludCIsIm9uQ2hhbmdlIiwicG93ZXJMZXZlbEtleSIsInNlbGVjdFZhbHVlIiwiY3VzdG9tVmFsdWUiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsInN0YXRlIiwia2V5IiwiS2V5IiwiRU5URVIiLCJibHVyIiwibGV2ZWxSb2xlTWFwIiwib3B0aW9ucyIsIlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQiLCJpbml0U3RhdGVGcm9tUHJvcHMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIm5ld1Byb3BzIiwiUm9sZXMiLCJ1c2Vyc0RlZmF1bHQiLCJPYmplY3QiLCJrZXlzIiwiZmlsdGVyIiwibGV2ZWwiLCJ1bmRlZmluZWQiLCJtYXhWYWx1ZSIsIm1hcCIsImN1c3RvbUxldmVsIiwicmVuZGVyIiwicGlja2VyIiwibGFiZWwiLCJvbkN1c3RvbUJsdXIiLCJvbkN1c3RvbUtleURvd24iLCJvbkN1c3RvbUNoYW5nZSIsIlN0cmluZyIsImRpc2FibGVkIiwidGV4dCIsInRleHR1YWxQb3dlckxldmVsIiwicHVzaCIsIm9wdGlvbnNFbGVtZW50cyIsIm9wIiwib25TZWxlY3RDaGFuZ2UiLCJJbmZpbml0eSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFnQkE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7O0FBRUEsTUFBTUEsWUFBWSxHQUFHLHFCQUFyQjtJQWlDcUJDLGEsV0FEcEIsZ0RBQXFCLDhCQUFyQixD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Q0FEVjtBQUVIYSxVQUFBQSxJQUFJLEVBQUVsQixLQUFLLENBQUNtQixpQkFBTixDQUF3QmQsS0FBeEIsRUFBK0IsS0FBSy9CLEtBQUwsQ0FBVzJCLFlBQTFDO0FBRkgsU0FBUDtBQUlILE9BTGUsQ0FBaEI7QUFNQU4sTUFBQUEsT0FBTyxDQUFDeUIsSUFBUixDQUFhO0FBQUUxQyxRQUFBQSxLQUFLLEVBQUVULFlBQVQ7QUFBdUJpRCxRQUFBQSxJQUFJLEVBQUUseUJBQUcsY0FBSDtBQUE3QixPQUFiO0FBQ0EsWUFBTUcsZUFBZSxHQUFHMUIsT0FBTyxDQUFDYSxHQUFSLENBQWFjLEVBQUQsSUFBUTtBQUN4Qyw0QkFBTztBQUFRLFVBQUEsS0FBSyxFQUFFQSxFQUFFLENBQUM1QyxLQUFsQjtBQUF5QixVQUFBLEdBQUcsRUFBRTRDLEVBQUUsQ0FBQzVDO0FBQWpDLFdBQTBDNEMsRUFBRSxDQUFDSixJQUE3QyxDQUFQO0FBQ0gsT0FGdUIsQ0FBeEI7QUFJQVAsTUFBQUEsTUFBTSxnQkFDRiw2QkFBQyxjQUFEO0FBQ0ksUUFBQSxPQUFPLEVBQUMsUUFEWjtBQUVJLFFBQUEsS0FBSyxFQUFFQyxLQUZYO0FBR0ksUUFBQSxRQUFRLEVBQUUsS0FBS1csY0FIbkI7QUFJSSxRQUFBLEtBQUssRUFBRVAsTUFBTSxDQUFDLEtBQUszQixLQUFMLENBQVdKLFdBQVosQ0FKakI7QUFLSSxRQUFBLFFBQVEsRUFBRSxLQUFLWCxLQUFMLENBQVcyQztBQUx6QixTQU9NSSxlQVBOLENBREo7QUFXSDs7QUFFRCx3QkFDSTtBQUFLLE1BQUEsU0FBUyxFQUFDO0FBQWYsT0FDTVYsTUFETixDQURKO0FBS0g7O0FBdklzRSxDLHlEQUN6QjtBQUMxQ0osRUFBQUEsUUFBUSxFQUFFaUIsUUFEZ0M7QUFFMUN2QixFQUFBQSxZQUFZLEVBQUU7QUFGNEIsQyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxNSwgMjAxNiBPcGVuTWFya2V0IEx0ZFxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBSb2xlcyBmcm9tICcuLi8uLi8uLi9Sb2xlcyc7XG5pbXBvcnQgeyBfdCB9IGZyb20gJy4uLy4uLy4uL2xhbmd1YWdlSGFuZGxlcic7XG5pbXBvcnQgRmllbGQgZnJvbSBcIi4vRmllbGRcIjtcbmltcG9ydCB7IEtleSB9IGZyb20gXCIuLi8uLi8uLi9LZXlib2FyZFwiO1xuaW1wb3J0IHsgcmVwbGFjZWFibGVDb21wb25lbnQgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvcmVwbGFjZWFibGVDb21wb25lbnRcIjtcblxuY29uc3QgQ1VTVE9NX1ZBTFVFID0gXCJTRUxFQ1RfVkFMVUVfQ1VTVE9NXCI7XG5cbmludGVyZmFjZSBJUHJvcHMge1xuICAgIHZhbHVlOiBudW1iZXI7XG4gICAgLy8gVGhlIG1heGltdW0gdmFsdWUgdGhhdCBjYW4gYmUgc2V0IHdpdGggdGhlIHBvd2VyIHNlbGVjdG9yXG4gICAgbWF4VmFsdWU6IG51bWJlcjtcblxuICAgIC8vIERlZmF1bHQgdXNlciBwb3dlciBsZXZlbCBmb3IgdGhlIHJvb21cbiAgICB1c2Vyc0RlZmF1bHQ6IG51bWJlcjtcblxuICAgIC8vIHNob3VsZCB0aGUgdXNlciBiZSBhYmxlIHRvIGNoYW5nZSB0aGUgdmFsdWU/IGZhbHNlIGJ5IGRlZmF1bHQuXG4gICAgZGlzYWJsZWQ/OiBib29sZWFuO1xuICAgIG9uQ2hhbmdlPzogKHZhbHVlOiBudW1iZXIsIHBvd2VyTGV2ZWxLZXk6IHN0cmluZykgPT4gdm9pZDtcblxuICAgIC8vIE9wdGlvbmFsIGtleSB0byBwYXNzIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYG9uQ2hhbmdlYFxuICAgIHBvd2VyTGV2ZWxLZXk/OiBzdHJpbmc7XG5cbiAgICAvLyBUaGUgbmFtZSB0byBhbm5vdGF0ZSB0aGUgc2VsZWN0b3Igd2l0aFxuICAgIGxhYmVsPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgSVN0YXRlIHtcbiAgICBsZXZlbFJvbGVNYXA6IHt9O1xuICAgIC8vIExpc3Qgb2YgcG93ZXIgbGV2ZWxzIHRvIHNob3cgaW4gdGhlIGRyb3AtZG93blxuICAgIG9wdGlvbnM6IG51bWJlcltdO1xuXG4gICAgY3VzdG9tVmFsdWU6IG51bWJlcjtcbiAgICBzZWxlY3RWYWx1ZTogbnVtYmVyIHwgc3RyaW5nO1xuICAgIGN1c3RvbT86IGJvb2xlYW47XG4gICAgY3VzdG9tTGV2ZWw/OiBudW1iZXI7XG59XG5cbkByZXBsYWNlYWJsZUNvbXBvbmVudChcInZpZXdzLmVsZW1lbnRzLlBvd2VyU2VsZWN0b3JcIilcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvd2VyU2VsZWN0b3IgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8SVByb3BzLCBJU3RhdGU+IHtcbiAgICBwdWJsaWMgc3RhdGljIGRlZmF1bHRQcm9wczogUGFydGlhbDxJUHJvcHM+ID0ge1xuICAgICAgICBtYXhWYWx1ZTogSW5maW5pdHksXG4gICAgICAgIHVzZXJzRGVmYXVsdDogMCxcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHM6IElQcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGxldmVsUm9sZU1hcDoge30sXG4gICAgICAgICAgICAvLyBMaXN0IG9mIHBvd2VyIGxldmVscyB0byBzaG93IGluIHRoZSBkcm9wLWRvd25cbiAgICAgICAgICAgIG9wdGlvbnM6IFtdLFxuXG4gICAgICAgICAgICBjdXN0b21WYWx1ZTogdGhpcy5wcm9wcy52YWx1ZSxcbiAgICAgICAgICAgIHNlbGVjdFZhbHVlOiAwLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIFRPRE86IFtSRUFDVC1XQVJOSU5HXSBSZXBsYWNlIHdpdGggYXBwcm9wcmlhdGUgbGlmZWN5Y2xlIGV2ZW50XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZSwgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgcHVibGljIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaW5pdFN0YXRlRnJvbVByb3BzKHRoaXMucHJvcHMpO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2UsIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgIHB1YmxpYyBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wczogSVByb3BzKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaW5pdFN0YXRlRnJvbVByb3BzKG5ld1Byb3BzKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGluaXRTdGF0ZUZyb21Qcm9wcyhuZXdQcm9wczogSVByb3BzKTogdm9pZCB7XG4gICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgZG9uZSBub3cgYmVjYXVzZSBsZXZlbFJvbGVNYXAgaGFzIHRyYW5zbGF0ZWQgc3RyaW5nc1xuICAgICAgICBjb25zdCBsZXZlbFJvbGVNYXAgPSBSb2xlcy5sZXZlbFJvbGVNYXAobmV3UHJvcHMudXNlcnNEZWZhdWx0KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5rZXlzKGxldmVsUm9sZU1hcCkuZmlsdGVyKGxldmVsID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgbGV2ZWwgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgIHBhcnNlSW50KGxldmVsKSA8PSBuZXdQcm9wcy5tYXhWYWx1ZSB8fFxuICAgICAgICAgICAgICAgIHBhcnNlSW50KGxldmVsKSA9PSBuZXdQcm9wcy52YWx1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSkubWFwKGxldmVsID0+IHBhcnNlSW50KGxldmVsKSk7XG5cbiAgICAgICAgY29uc3QgaXNDdXN0b20gPSBsZXZlbFJvbGVNYXBbbmV3UHJvcHMudmFsdWVdID09PSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBsZXZlbFJvbGVNYXAsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgY3VzdG9tOiBpc0N1c3RvbSxcbiAgICAgICAgICAgIGN1c3RvbUxldmVsOiBuZXdQcm9wcy52YWx1ZSxcbiAgICAgICAgICAgIHNlbGVjdFZhbHVlOiBpc0N1c3RvbSA/IENVU1RPTV9WQUxVRSA6IG5ld1Byb3BzLnZhbHVlLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uU2VsZWN0Q2hhbmdlID0gKGV2ZW50OiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MU2VsZWN0RWxlbWVudD4pOiB2b2lkID0+IHtcbiAgICAgICAgY29uc3QgaXNDdXN0b20gPSBldmVudC50YXJnZXQudmFsdWUgPT09IENVU1RPTV9WQUxVRTtcbiAgICAgICAgaWYgKGlzQ3VzdG9tKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgY3VzdG9tOiB0cnVlIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcG93ZXJMZXZlbCA9IHBhcnNlSW50KGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHBvd2VyTGV2ZWwsIHRoaXMucHJvcHMucG93ZXJMZXZlbEtleSk7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgc2VsZWN0VmFsdWU6IHBvd2VyTGV2ZWwgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbkN1c3RvbUNoYW5nZSA9IChldmVudDogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pOiB2b2lkID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGN1c3RvbVZhbHVlOiBwYXJzZUludChldmVudC50YXJnZXQudmFsdWUpIH0pO1xuICAgIH07XG5cbiAgICBwcml2YXRlIG9uQ3VzdG9tQmx1ciA9IChldmVudDogUmVhY3QuRm9jdXNFdmVudCk6IHZvaWQgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHRoaXMuc3RhdGUuY3VzdG9tVmFsdWUsIHRoaXMucHJvcHMucG93ZXJMZXZlbEtleSk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25DdXN0b21LZXlEb3duID0gKGV2ZW50OiBSZWFjdC5LZXlib2FyZEV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KTogdm9pZCA9PiB7XG4gICAgICAgIGlmIChldmVudC5rZXkgPT09IEtleS5FTlRFUikge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICAvLyBEbyBub3QgY2FsbCB0aGUgb25DaGFuZ2UgaGFuZGxlciBkaXJlY3RseSBoZXJlIC0gaXQgY2FuIGNhdXNlIGFuIGluZmluaXRlIGxvb3AuXG4gICAgICAgICAgICAvLyBMb25nIHN0b3J5IHNob3J0LCBhIHVzZXIgaGl0cyBFbnRlciB0byBzdWJtaXQgdGhlIHZhbHVlIHdoaWNoIG9uQ2hhbmdlIGhhbmRsZXMgYXNcbiAgICAgICAgICAgIC8vIHJhaXNpbmcgYSBkaWFsb2cgd2hpY2ggY2F1c2VzIGEgYmx1ciB3aGljaCBjYXVzZXMgYSBkaWFsb2cgd2hpY2ggY2F1c2VzIGEgYmx1ciBhbmRcbiAgICAgICAgICAgIC8vIHNvIG9uLiBCeSBub3QgY2F1c2luZyB0aGUgb25DaGFuZ2UgdG8gYmUgY2FsbGVkIGhlcmUsIHdlIGF2b2lkIHRoZSBsb29wIGJlY2F1c2Ugd2VcbiAgICAgICAgICAgIC8vIGhhbmRsZSB0aGUgb25CbHVyIHNhZmVseS5cbiAgICAgICAgICAgIChldmVudC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkuYmx1cigpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHB1YmxpYyByZW5kZXIoKTogSlNYLkVsZW1lbnQge1xuICAgICAgICBsZXQgcGlja2VyO1xuICAgICAgICBjb25zdCBsYWJlbCA9IHR5cGVvZiB0aGlzLnByb3BzLmxhYmVsID09PSBcInVuZGVmaW5lZFwiID8gX3QoXCJQb3dlciBsZXZlbFwiKSA6IHRoaXMucHJvcHMubGFiZWw7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmN1c3RvbSkge1xuICAgICAgICAgICAgcGlja2VyID0gKFxuICAgICAgICAgICAgICAgIDxGaWVsZFxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw9e2xhYmVsfVxuICAgICAgICAgICAgICAgICAgICBtYXg9e3RoaXMucHJvcHMubWF4VmFsdWV9XG4gICAgICAgICAgICAgICAgICAgIG9uQmx1cj17dGhpcy5vbkN1c3RvbUJsdXJ9XG4gICAgICAgICAgICAgICAgICAgIG9uS2V5RG93bj17dGhpcy5vbkN1c3RvbUtleURvd259XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uQ3VzdG9tQ2hhbmdlfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17U3RyaW5nKHRoaXMuc3RhdGUuY3VzdG9tVmFsdWUpfVxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17dGhpcy5wcm9wcy5kaXNhYmxlZH1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEVhY2ggbGV2ZWwgbXVzdCBoYXZlIGEgZGVmaW5pdGlvbiBpbiB0aGlzLnN0YXRlLmxldmVsUm9sZU1hcFxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuc3RhdGUub3B0aW9ucy5tYXAoKGxldmVsKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFN0cmluZyhsZXZlbCksXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IFJvbGVzLnRleHR1YWxQb3dlckxldmVsKGxldmVsLCB0aGlzLnByb3BzLnVzZXJzRGVmYXVsdCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb3B0aW9ucy5wdXNoKHsgdmFsdWU6IENVU1RPTV9WQUxVRSwgdGV4dDogX3QoXCJDdXN0b20gbGV2ZWxcIikgfSk7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zRWxlbWVudHMgPSBvcHRpb25zLm1hcCgob3ApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gPG9wdGlvbiB2YWx1ZT17b3AudmFsdWV9IGtleT17b3AudmFsdWV9Pnsgb3AudGV4dCB9PC9vcHRpb24+O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHBpY2tlciA9IChcbiAgICAgICAgICAgICAgICA8RmllbGRcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudD1cInNlbGVjdFwiXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsPXtsYWJlbH1cbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25TZWxlY3RDaGFuZ2V9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXtTdHJpbmcodGhpcy5zdGF0ZS5zZWxlY3RWYWx1ZSl9XG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXt0aGlzLnByb3BzLmRpc2FibGVkfVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgeyBvcHRpb25zRWxlbWVudHMgfVxuICAgICAgICAgICAgICAgIDwvRmllbGQ+XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXhfUG93ZXJTZWxlY3RvclwiPlxuICAgICAgICAgICAgICAgIHsgcGlja2VyIH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cbn1cbiJdfQ==