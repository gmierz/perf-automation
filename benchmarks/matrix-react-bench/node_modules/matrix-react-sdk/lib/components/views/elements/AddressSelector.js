"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _AddressTile = _interopRequireDefault(require("./AddressTile"));

var _dec, _class;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

let AddressSelector = (_dec = (0, _replaceableComponent.replaceableComponent)("views.elements.AddressSelector"), _dec(_class = class AddressSelector extends _react.default.Component {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "scrollElement", /*#__PURE__*/(0, _react.createRef)());
    (0, _defineProperty2.default)(this, "addressListElement", /*#__PURE__*/(0, _react.createRef)());
    (0, _defineProperty2.default)(this, "moveSelectionTop", () => {
      if (this.state.selected > 0) {
        this.setState({
          selected: 0,
          hover: false
        });
      }
    });
    (0, _defineProperty2.default)(this, "moveSelectionUp", () => {
      if (this.state.selected > 0) {
        this.setState({
          selected: this.state.selected - 1,
          hover: false
        });
      }
    });
    (0, _defineProperty2.default)(this, "moveSelectionDown", () => {
      if (this.state.selected < this.maxSelected(this.props.addressList)) {
        this.setState({
          selected: this.state.selected + 1,
          hover: false
        });
      }
    });
    (0, _defineProperty2.default)(this, "chooseSelection", () => {
      this.selectAddress(this.state.selected);
    });
    (0, _defineProperty2.default)(this, "onClick", index => {
      this.selectAddress(index);
    });
    (0, _defineProperty2.default)(this, "onMouseEnter", index => {
      this.setState({
        selected: index,
        hover: true
      });
    });
    (0, _defineProperty2.default)(this, "onMouseLeave", () => {
      this.setState({
        hover: false
      });
    });
    (0, _defineProperty2.default)(this, "selectAddress", index => {
      // Only try to select an address if one exists
      if (this.props.addressList.length !== 0) {
        this.props.onSelected(index);
        this.setState({
          hover: false
        });
      }
    });
    this.state = {
      selected: this.props.selected === undefined ? 0 : this.props.selected,
      hover: false
    };
  } // TODO: [REACT-WARNING] Replace with appropriate lifecycle event


  UNSAFE_componentWillReceiveProps(props) {
    // eslint-disable-line
    // Make sure the selected item isn't outside the list bounds
    const selected = this.state.selected;
    const maxSelected = this.maxSelected(props.addressList);

    if (selected > maxSelected) {
      this.setState({
        selected: maxSelected
      });
    }
  }

  componentDidUpdate() {
    // As the user scrolls with the arrow keys keep the selected item
    // at the top of the window.
    if (this.scrollElement.current && this.props.addressList.length > 0 && !this.state.hover) {
      const elementHeight = this.addressListElement.current.getBoundingClientRect().height;
      this.scrollElement.current.scrollTop = this.state.selected * elementHeight - elementHeight;
    }
  }

  createAddressListTiles() {
    const maxSelected = this.maxSelected(this.props.addressList);
    const addressList = []; // Only create the address elements if there are address

    if (this.props.addressList.length > 0) {
      for (let i = 0; i <= maxSelected; i++) {
        const classes = (0, _classnames.default)({
          "mx_AddressSelector_addressListElement": true,
          "mx_AddressSelector_selected": this.state.selected === i
        }); // NOTE: Defaulting to "vector" as the network, until the network backend stuff is done.
        // Saving the addressListElement so we can use it to work out, in the componentDidUpdate
        // method, how far to scroll when using the arrow keys

        addressList.push( /*#__PURE__*/_react.default.createElement("div", {
          className: classes,
          onClick: this.onClick.bind(this, i),
          onMouseEnter: this.onMouseEnter.bind(this, i),
          onMouseLeave: this.onMouseLeave,
          key: this.props.addressList[i].addressType + "/" + this.props.addressList[i].address,
          ref: this.addressListElement
        }, /*#__PURE__*/_react.default.createElement(_AddressTile.default, {
          address: this.props.addressList[i],
          showAddress: this.props.showAddress,
          justified: true
        })));
      }
    }

    return addressList;
  }

  maxSelected(list) {
    const listSize = list.length === 0 ? 0 : list.length - 1;
    const maxSelected = listSize > this.props.truncateAt - 1 ? this.props.truncateAt - 1 : listSize;
    return maxSelected;
  }

  render() {
    const classes = (0, _classnames.default)({
      "mx_AddressSelector": true,
      "mx_AddressSelector_empty": this.props.addressList.length === 0
    });
    return /*#__PURE__*/_react.default.createElement("div", {
      className: classes,
      ref: this.scrollElement
    }, this.props.header, this.createAddressListTiles());
  }

}) || _class);
exports.default = AddressSelector;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2VsZW1lbnRzL0FkZHJlc3NTZWxlY3Rvci50c3giXSwibmFtZXMiOlsiQWRkcmVzc1NlbGVjdG9yIiwiUmVhY3QiLCJDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsInByb3BzIiwic3RhdGUiLCJzZWxlY3RlZCIsInNldFN0YXRlIiwiaG92ZXIiLCJtYXhTZWxlY3RlZCIsImFkZHJlc3NMaXN0Iiwic2VsZWN0QWRkcmVzcyIsImluZGV4IiwibGVuZ3RoIiwib25TZWxlY3RlZCIsInVuZGVmaW5lZCIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiY29tcG9uZW50RGlkVXBkYXRlIiwic2Nyb2xsRWxlbWVudCIsImN1cnJlbnQiLCJlbGVtZW50SGVpZ2h0IiwiYWRkcmVzc0xpc3RFbGVtZW50IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaGVpZ2h0Iiwic2Nyb2xsVG9wIiwiY3JlYXRlQWRkcmVzc0xpc3RUaWxlcyIsImkiLCJjbGFzc2VzIiwicHVzaCIsIm9uQ2xpY2siLCJiaW5kIiwib25Nb3VzZUVudGVyIiwib25Nb3VzZUxlYXZlIiwiYWRkcmVzc1R5cGUiLCJhZGRyZXNzIiwic2hvd0FkZHJlc3MiLCJsaXN0IiwibGlzdFNpemUiLCJ0cnVuY2F0ZUF0IiwicmVuZGVyIiwiaGVhZGVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWlCQTs7QUFDQTs7QUFDQTs7QUFFQTs7Ozs7Ozs7SUFzQnFCQSxlLFdBRHBCLGdEQUFxQixnQ0FBckIsQyxnQkFBRCxNQUNxQkEsZUFEckIsU0FDNkNDLGVBQU1DLFNBRG5ELENBQzZFO0FBSXpFQyxFQUFBQSxXQUFXLENBQUNDLEtBQUQsRUFBZ0I7QUFDdkIsVUFBTUEsS0FBTjtBQUR1QixzRUFISCx1QkFHRztBQUFBLDJFQUZFLHVCQUVGO0FBQUEsNERBNEJELE1BQVk7QUFDbEMsVUFBSSxLQUFLQyxLQUFMLENBQVdDLFFBQVgsR0FBc0Is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QSxPQUFPLEVBQUUsS0FBS2pCLEtBQUwsQ0FBV00sV0FBWCxDQUF1QmdCLENBQXZCLENBRGI7QUFFSSxVQUFBLFdBQVcsRUFBRSxLQUFLdEIsS0FBTCxDQUFXK0IsV0FGNUI7QUFHSSxVQUFBLFNBQVMsRUFBRTtBQUhmLFVBUkosQ0FESjtBQWdCSDtBQUNKOztBQUNELFdBQU96QixXQUFQO0FBQ0g7O0FBRU9ELEVBQUFBLFdBQVcsQ0FBQzJCLElBQUQsRUFBK0I7QUFDOUMsVUFBTUMsUUFBUSxHQUFHRCxJQUFJLENBQUN2QixNQUFMLEtBQWdCLENBQWhCLEdBQW9CLENBQXBCLEdBQXdCdUIsSUFBSSxDQUFDdkIsTUFBTCxHQUFjLENBQXZEO0FBQ0EsVUFBTUosV0FBVyxHQUFHNEIsUUFBUSxHQUFJLEtBQUtqQyxLQUFMLENBQVdrQyxVQUFYLEdBQXdCLENBQXBDLEdBQTBDLEtBQUtsQyxLQUFMLENBQVdrQyxVQUFYLEdBQXdCLENBQWxFLEdBQXVFRCxRQUEzRjtBQUNBLFdBQU81QixXQUFQO0FBQ0g7O0FBRUQ4QixFQUFBQSxNQUFNLEdBQUc7QUFDTCxVQUFNWixPQUFPLEdBQUcseUJBQVc7QUFDdkIsNEJBQXNCLElBREM7QUFFdkIsa0NBQTRCLEtBQUt2QixLQUFMLENBQVdNLFdBQVgsQ0FBdUJHLE1BQXZCLEtBQWtDO0FBRnZDLEtBQVgsQ0FBaEI7QUFLQSx3QkFDSTtBQUFLLE1BQUEsU0FBUyxFQUFFYyxPQUFoQjtBQUF5QixNQUFBLEdBQUcsRUFBRSxLQUFLVDtBQUFuQyxPQUNNLEtBQUtkLEtBQUwsQ0FBV29DLE1BRGpCLEVBRU0sS0FBS2Ysc0JBQUwsRUFGTixDQURKO0FBTUg7O0FBNUl3RSxDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE1LCAyMDE2IE9wZW5NYXJrZXQgTHRkXG5Db3B5cmlnaHQgMjAxNyBWZWN0b3IgQ3JlYXRpb25zIEx0ZFxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IHJlcGxhY2VhYmxlQ29tcG9uZW50IH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL3JlcGxhY2VhYmxlQ29tcG9uZW50XCI7XG5pbXBvcnQgeyBJVXNlckFkZHJlc3MgfSBmcm9tICcuLi8uLi8uLi9Vc2VyQWRkcmVzcyc7XG5pbXBvcnQgQWRkcmVzc1RpbGUgZnJvbSAnLi9BZGRyZXNzVGlsZSc7XG5cbmludGVyZmFjZSBJUHJvcHMge1xuICAgIG9uU2VsZWN0ZWQ6IChpbmRleDogbnVtYmVyKSA9PiB2b2lkO1xuXG4gICAgLy8gTGlzdCBvZiB0aGUgYWRkcmVzc2VzIHRvIGRpc3BsYXlcbiAgICBhZGRyZXNzTGlzdDogSVVzZXJBZGRyZXNzW107XG4gICAgLy8gV2hldGhlciB0byBzaG93IHRoZSBhZGRyZXNzIG9uIHRoZSBhZGRyZXNzIHRpbGVzXG4gICAgc2hvd0FkZHJlc3M/OiBib29sZWFuO1xuICAgIHRydW5jYXRlQXQ6IG51bWJlcjtcbiAgICBzZWxlY3RlZD86IG51bWJlcjtcblxuICAgIC8vIEVsZW1lbnQgdG8gcHV0IGFzIGEgaGVhZGVyIG9uIHRvcCBvZiB0aGUgbGlzdFxuICAgIGhlYWRlcj86IEpTWC5FbGVtZW50O1xufVxuXG5pbnRlcmZhY2UgSVN0YXRlIHtcbiAgICBzZWxlY3RlZDogbnVtYmVyO1xuICAgIGhvdmVyOiBib29sZWFuO1xufVxuXG5AcmVwbGFjZWFibGVDb21wb25lbnQoXCJ2aWV3cy5lbGVtZW50cy5BZGRyZXNzU2VsZWN0b3JcIilcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFkZHJlc3NTZWxlY3RvciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxJUHJvcHMsIElTdGF0ZT4ge1xuICAgIHByaXZhdGUgc2Nyb2xsRWxlbWVudCA9IGNyZWF0ZVJlZjxIVE1MRGl2RWxlbWVudD4oKTtcbiAgICBwcml2YXRlIGFkZHJlc3NMaXN0RWxlbWVudCA9IGNyZWF0ZVJlZjxIVE1MRGl2RWxlbWVudD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzOiBJUHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBzZWxlY3RlZDogdGhpcy5wcm9wcy5zZWxlY3RlZCA9PT0gdW5kZWZpbmVkID8gMCA6IHRoaXMucHJvcHMuc2VsZWN0ZWQsXG4gICAgICAgICAgICBob3ZlcjogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVE9ETzogW1JFQUNULVdBUk5JTkddIFJlcGxhY2Ugd2l0aCBhcHByb3ByaWF0ZSBsaWZlY3ljbGUgZXZlbnRcbiAgICBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhwcm9wczogSVByb3BzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBzZWxlY3RlZCBpdGVtIGlzbid0IG91dHNpZGUgdGhlIGxpc3QgYm91bmRzXG4gICAgICAgIGNvbnN0IHNlbGVjdGVkID0gdGhpcy5zdGF0ZS5zZWxlY3RlZDtcbiAgICAgICAgY29uc3QgbWF4U2VsZWN0ZWQgPSB0aGlzLm1heFNlbGVjdGVkKHByb3BzLmFkZHJlc3NMaXN0KTtcbiAgICAgICAgaWYgKHNlbGVjdGVkID4gbWF4U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBzZWxlY3RlZDogbWF4U2VsZWN0ZWQgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIC8vIEFzIHRoZSB1c2VyIHNjcm9sbHMgd2l0aCB0aGUgYXJyb3cga2V5cyBrZWVwIHRoZSBzZWxlY3RlZCBpdGVtXG4gICAgICAgIC8vIGF0IHRoZSB0b3Agb2YgdGhlIHdpbmRvdy5cbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsRWxlbWVudC5jdXJyZW50ICYmIHRoaXMucHJvcHMuYWRkcmVzc0xpc3QubGVuZ3RoID4gMCAmJiAhdGhpcy5zdGF0ZS5ob3Zlcikge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudEhlaWdodCA9IHRoaXMuYWRkcmVzc0xpc3RFbGVtZW50LmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50LmN1cnJlbnQuc2Nyb2xsVG9wID0gKHRoaXMuc3RhdGUuc2VsZWN0ZWQgKiBlbGVtZW50SGVpZ2h0KSAtIGVsZW1lbnRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgbW92ZVNlbGVjdGlvblRvcCA9ICgpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2VsZWN0ZWQgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZDogMCxcbiAgICAgICAgICAgICAgICBob3ZlcjogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwdWJsaWMgbW92ZVNlbGVjdGlvblVwID0gKCk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zZWxlY3RlZCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkOiB0aGlzLnN0YXRlLnNlbGVjdGVkIC0gMSxcbiAgICAgICAgICAgICAgICBob3ZlcjogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwdWJsaWMgbW92ZVNlbGVjdGlvbkRvd24gPSAoKTogdm9pZCA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnNlbGVjdGVkIDwgdGhpcy5tYXhTZWxlY3RlZCh0aGlzLnByb3BzLmFkZHJlc3NMaXN0KSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IHRoaXMuc3RhdGUuc2VsZWN0ZWQgKyAxLFxuICAgICAgICAgICAgICAgIGhvdmVyOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHB1YmxpYyBjaG9vc2VTZWxlY3Rpb24gPSAoKTogdm9pZCA9PiB7XG4gICAgICAgIHRoaXMuc2VsZWN0QWRkcmVzcyh0aGlzLnN0YXRlLnNlbGVjdGVkKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbkNsaWNrID0gKGluZGV4OiBudW1iZXIpOiB2b2lkID0+IHtcbiAgICAgICAgdGhpcy5zZWxlY3RBZGRyZXNzKGluZGV4KTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbk1vdXNlRW50ZXIgPSAoaW5kZXg6IG51bWJlcik6IHZvaWQgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHNlbGVjdGVkOiBpbmRleCxcbiAgICAgICAgICAgIGhvdmVyOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbk1vdXNlTGVhdmUgPSAoKTogdm9pZCA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBob3ZlcjogZmFsc2UgfSk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgc2VsZWN0QWRkcmVzcyA9IChpbmRleDogbnVtYmVyKTogdm9pZCA9PiB7XG4gICAgICAgIC8vIE9ubHkgdHJ5IHRvIHNlbGVjdCBhbiBhZGRyZXNzIGlmIG9uZSBleGlzdHNcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuYWRkcmVzc0xpc3QubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uU2VsZWN0ZWQoaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGhvdmVyOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcml2YXRlIGNyZWF0ZUFkZHJlc3NMaXN0VGlsZXMoKTogSlNYLkVsZW1lbnRbXSB7XG4gICAgICAgIGNvbnN0IG1heFNlbGVjdGVkID0gdGhpcy5tYXhTZWxlY3RlZCh0aGlzLnByb3BzLmFkZHJlc3NMaXN0KTtcbiAgICAgICAgY29uc3QgYWRkcmVzc0xpc3QgPSBbXTtcblxuICAgICAgICAvLyBPbmx5IGNyZWF0ZSB0aGUgYWRkcmVzcyBlbGVtZW50cyBpZiB0aGVyZSBhcmUgYWRkcmVzc1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5hZGRyZXNzTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBtYXhTZWxlY3RlZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xhc3NlcyA9IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgICAgICAgICBcIm14X0FkZHJlc3NTZWxlY3Rvcl9hZGRyZXNzTGlzdEVsZW1lbnRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJteF9BZGRyZXNzU2VsZWN0b3Jfc2VsZWN0ZWRcIjogdGhpcy5zdGF0ZS5zZWxlY3RlZCA9PT0gaSxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIE5PVEU6IERlZmF1bHRpbmcgdG8gXCJ2ZWN0b3JcIiBhcyB0aGUgbmV0d29yaywgdW50aWwgdGhlIG5ldHdvcmsgYmFja2VuZCBzdHVmZiBpcyBkb25lLlxuICAgICAgICAgICAgICAgIC8vIFNhdmluZyB0aGUgYWRkcmVzc0xpc3RFbGVtZW50IHNvIHdlIGNhbiB1c2UgaXQgdG8gd29yayBvdXQsIGluIHRoZSBjb21wb25lbnREaWRVcGRhdGVcbiAgICAgICAgICAgICAgICAvLyBtZXRob2QsIGhvdyBmYXIgdG8gc2Nyb2xsIHdoZW4gdXNpbmcgdGhlIGFycm93IGtleXNcbiAgICAgICAgICAgICAgICBhZGRyZXNzTGlzdC5wdXNoKFxuICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzZXN9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uQ2xpY2suYmluZCh0aGlzLCBpKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTW91c2VFbnRlcj17dGhpcy5vbk1vdXNlRW50ZXIuYmluZCh0aGlzLCBpKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17dGhpcy5vbk1vdXNlTGVhdmV9XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk9e3RoaXMucHJvcHMuYWRkcmVzc0xpc3RbaV0uYWRkcmVzc1R5cGUgKyBcIi9cIiArIHRoaXMucHJvcHMuYWRkcmVzc0xpc3RbaV0uYWRkcmVzc31cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZj17dGhpcy5hZGRyZXNzTGlzdEVsZW1lbnR9XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxBZGRyZXNzVGlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M9e3RoaXMucHJvcHMuYWRkcmVzc0xpc3RbaV19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0FkZHJlc3M9e3RoaXMucHJvcHMuc2hvd0FkZHJlc3N9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganVzdGlmaWVkPXt0cnVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+LFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFkZHJlc3NMaXN0O1xuICAgIH1cblxuICAgIHByaXZhdGUgbWF4U2VsZWN0ZWQobGlzdDogSVVzZXJBZGRyZXNzW10pOiBudW1iZXIge1xuICAgICAgICBjb25zdCBsaXN0U2l6ZSA9IGxpc3QubGVuZ3RoID09PSAwID8gMCA6IGxpc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgbWF4U2VsZWN0ZWQgPSBsaXN0U2l6ZSA+ICh0aGlzLnByb3BzLnRydW5jYXRlQXQgLSAxKSA/ICh0aGlzLnByb3BzLnRydW5jYXRlQXQgLSAxKSA6IGxpc3RTaXplO1xuICAgICAgICByZXR1cm4gbWF4U2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBjbGFzc2VzID0gY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICBcIm14X0FkZHJlc3NTZWxlY3RvclwiOiB0cnVlLFxuICAgICAgICAgICAgXCJteF9BZGRyZXNzU2VsZWN0b3JfZW1wdHlcIjogdGhpcy5wcm9wcy5hZGRyZXNzTGlzdC5sZW5ndGggPT09IDAsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3Nlc30gcmVmPXt0aGlzLnNjcm9sbEVsZW1lbnR9PlxuICAgICAgICAgICAgICAgIHsgdGhpcy5wcm9wcy5oZWFkZXIgfVxuICAgICAgICAgICAgICAgIHsgdGhpcy5jcmVhdGVBZGRyZXNzTGlzdFRpbGVzKCkgfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxufVxuIl19