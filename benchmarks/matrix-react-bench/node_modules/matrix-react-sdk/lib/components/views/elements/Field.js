"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var sdk = _interopRequireWildcard(require("../../../index"));

var _lodash = require("lodash");

const _excluded = ["element", "prefixComponent", "postfixComponent", "className", "onValidate", "children", "tooltipContent", "forceValidity", "tooltipClassName", "list", "validateOnBlur", "validateOnChange", "validateOnFocus", "usePlaceholderAsHint"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Invoke validation from user input (when typing, etc.) at most once every N ms.
const VALIDATION_THROTTLE_MS = 200;
const BASE_ID = "mx_Field";
let count = 1;

function getId() {
  return `${BASE_ID}_${count++}`;
}

class Field extends _react.default.PureComponent {
  /*
   * This was changed from throttle to debounce: this is more traditional for
   * form validation since it means that the validation doesn't happen at all
   * until the user stops typing for a bit (debounce defaults to not running on
   * the leading edge). If we're doing an HTTP hit on each validation, we have more
   * incentive to prevent validating input that's very unlikely to be valid.
   * We may find that we actually want different behaviour for registration
   * fields, in which case we can add some options to control it.
   */
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "input", void 0);
    (0, _defineProperty2.default)(this, "validateOnChange", (0, _lodash.debounce)(() => {
      this.validate({
        focused: true
      });
    }, VALIDATION_THROTTLE_MS));
    (0, _defineProperty2.default)(this, "onFocus", ev => {
      this.setState({
        focused: true
      });

      if (this.props.validateOnFocus) {
        this.validate({
          focused: true
        });
      } // Parent component may have supplied its own `onFocus` as well


      if (this.props.onFocus) {
        this.props.onFocus(ev);
      }
    });
    (0, _defineProperty2.default)(this, "onChange", ev => {
      if (this.props.validateOnChange) {
        this.validateOnChange();
      } // Parent component may have supplied its own `onChange` as well


      if (this.props.onChange) {
        this.props.onChange(ev);
      }
    });
    (0, _defineProperty2.default)(this, "onBlur", ev => {
      this.setState({
        focused: false
      });

      if (this.props.validateOnBlur) {
        this.validate({
          focused: false
        });
      } // Parent component may have supplied its own `onBlur` as well


      if (this.props.onBlur) {
        this.props.onBlur(ev);
      }
    });
    this.state = {
      valid: undefined,
      feedback: undefined,
      feedbackVisible: false,
      focused: false
    };
    this.id = this.props.id || getId();
  }

  focus() {
    this.input.focus(); // programmatic does not fire onFocus handler

    this.setState({
      focused: true
    });
  }

  async validate({
    focused,
    allowEmpty = true
  }) {
    if (!this.props.onValidate) {
      return;
    }

    const value = this.input ? this.input.value : null;
    const {
      valid,
      feedback
    } = await this.props.onValidate({
      value,
      focused,
      allowEmpty
    }); // this method is async and so we may have been blurred since the method was called
    // if we have then hide the feedback as withValidation does

    if (this.state.focused && feedback) {
      this.setState({
        valid,
        feedback,
        feedbackVisible: true
      });
    } else {
      // When we receive null `feedback`, we want to hide the tooltip.
      // We leave the previous `feedback` content in state without updating it,
      // so that we can hide the tooltip containing the most recent feedback
      // via CSS animation.
      this.setState({
        valid,
        feedbackVisible: false
      });
    }

    return valid;
  }

  render() {
    /* eslint @typescript-eslint/no-unused-vars: ["error", { "ignoreRestSiblings": true }] */
    const _this$props = this.props,
          {
      element,
      prefixComponent,
      postfixComponent,
      className,
      onValidate,
      children,
      tooltipContent,
      forceValidity,
      tooltipClassName,
      list,
      validateOnBlur,
      validateOnChange,
      validateOnFocus,
      usePlaceholderAsHint
    } = _this$props,
          inputProps = (0, _objectWithoutProperties2.default)(_this$props, _excluded); // Set some defaults for the <input> element

    const ref = input => this.input = input;

    inputProps.placeholder = inputProps.placeholder || inputProps.label;
    inputProps.id = this.id; // this overwrites the id from props

    inputProps.onFocus = this.onFocus;
    inputProps.onChange = this.onChange;
    inputProps.onBlur = this.onBlur; // Appease typescript's inference

    const inputProps_ = _objectSpread(_objectSpread({}, inputProps), {}, {
      ref,
      list
    });

    const fieldInput = /*#__PURE__*/_react.default.createElement(this.props.element, inputProps_, children);

    let prefixContainer = null;

    if (prefixComponent) {
      prefixContainer = /*#__PURE__*/_react.default.createElement("span", {
        className: "mx_Field_prefix"
      }, prefixComponent);
    }

    let postfixContainer = null;

    if (postfixComponent) {
      postfixContainer = /*#__PURE__*/_react.default.createElement("span", {
        className: "mx_Field_postfix"
      }, postfixComponent);
    }

    const hasValidationFlag = forceValidity !== null && forceValidity !== undefined;
    const fieldClasses = (0, _classnames.default)("mx_Field", `mx_Field_${this.props.element}`, className, {
      // If we have a prefix element, leave the label always at the top left and
      // don't animate it, as it looks a bit clunky and would add complexity to do
      // properly.
      mx_Field_labelAlwaysTopLeft: prefixComponent || usePlaceholderAsHint,
      mx_Field_placeholderIsHint: usePlaceholderAsHint,
      mx_Field_valid: hasValidationFlag ? forceValidity : onValidate && this.state.valid === true,
      mx_Field_invalid: hasValidationFlag ? !forceValidity : onValidate && this.state.valid === false
    }); // Handle displaying feedback on validity
    // FIXME: Using an import will result in test failures

    const Tooltip = sdk.getComponent("elements.Tooltip");
    let fieldTooltip;

    if (tooltipContent || this.state.feedback) {
      fieldTooltip = /*#__PURE__*/_react.default.createElement(Tooltip, {
        tooltipClassName: (0, _classnames.default)("mx_Field_tooltip", tooltipClassName),
        visible: this.state.focused && this.props.forceTooltipVisible || this.state.feedbackVisible,
        label: tooltipContent || this.state.feedback,
        alignment: Tooltip.Alignment.Right
      });
    }

    return /*#__PURE__*/_react.default.createElement("div", {
      className: fieldClasses
    }, prefixContainer, fieldInput, /*#__PURE__*/_react.default.createElement("label", {
      htmlFor: this.id
    }, this.props.label), postfixContainer, fieldTooltip);
  }

}

exports.default = Field;
(0, _defineProperty2.default)(Field, "defaultProps", {
  element: "input",
  type: "text",
  validateOnFocus: true,
  validateOnBlur: true,
  validateOnChange: true
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2VsZW1lbnRzL0ZpZWxkLnRzeCJdLCJuYW1lcyI6WyJWQUxJREFUSU9OX1RIUk9UVExFX01TIiwiQkFTRV9JRCIsImNvdW50IiwiZ2V0SWQiLCJGaWVsZCIsIlJlYWN0IiwiUHVyZUNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJ2YWxpZGF0ZSIsImZvY3VzZWQiLCJldiIsInNldFN0YXRlIiwidmFsaWRhdGVPbkZvY3VzIiwib25Gb2N1cyIsInZhbGlkYXRlT25DaGFuZ2UiLCJvbkNoYW5nZSIsInZhbGlkYXRlT25CbHVyIiwib25CbHVyIiwic3RhdGUiLCJ2YWxpZCIsInVuZGVmaW5lZCIsImZlZWRiYWNrIiwiZmVlZGJhY2tWaXNpYmxlIiwiaWQiLCJmb2N1cyIsImlucHV0IiwiYWxsb3dFbXB0eSIsIm9uVmFsaWRhdGUiLCJ2YWx1ZSIsInJlbmRlciIsImVsZW1lbnQiLCJwcmVmaXhDb21wb25lbnQiLCJwb3N0Zml4Q29tcG9uZW50IiwiY2xhc3NOYW1lIiwiY2hpbGRyZW4iLCJ0b29sdGlwQ29udGVudCIsImZvcmNlVmFsaWRpdHkiLCJ0b29sdGlwQ2xhc3NOYW1lIiwibGlzdCIsInVzZVBsYWNlaG9sZGVyQXNIaW50IiwiaW5wdXRQcm9wcyIsInJlZiIsInBsYWNlaG9sZGVyIiwibGFiZWwiLCJpbnB1dFByb3BzXyIsImZpZWxkSW5wdXQiLCJjcmVhdGVFbGVtZW50IiwicHJlZml4Q29udGFpbmVyIiwicG9zdGZpeENvbnRhaW5lciIsImhhc1ZhbGlkYXRpb25GbGFnIiwiZmllbGRDbGFzc2VzIiwibXhfRmllbGRfbGFiZWxBbHdheXNUb3BMZWZ0IiwibXhfRmllbGRfcGxhY2Vob2xkZXJJc0hpbnQiLCJteF9GaWVsZF92YWxpZCIsIm14X0ZpZWxkX2ludmFsaWQiLCJUb29sdGlwIiwic2RrIiwiZ2V0Q29tcG9uZW50IiwiZmllbGRUb29sdGlwIiwiZm9yY2VUb29sdGlwVmlz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QkFJcUI7QUFDbEMyQixFQUFBQSxPQUFPLEVBQUUsT0FEeUI7QUFFbENnQyxFQUFBQSxJQUFJLEVBQUUsTUFGNEI7QUFHbENsRCxFQUFBQSxlQUFlLEVBQUUsSUFIaUI7QUFJbENJLEVBQUFBLGNBQWMsRUFBRSxJQUprQjtBQUtsQ0YsRUFBQUEsZ0JBQWdCLEVBQUU7QUFMZ0IsQyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxOSBOZXcgVmVjdG9yIEx0ZFxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBSZWFjdCwgeyBJbnB1dEhUTUxBdHRyaWJ1dGVzLCBTZWxlY3RIVE1MQXR0cmlidXRlcywgVGV4dGFyZWFIVE1MQXR0cmlidXRlcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0ICogYXMgc2RrIGZyb20gJy4uLy4uLy4uL2luZGV4JztcbmltcG9ydCB7IGRlYm91bmNlIH0gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IHsgSUZpZWxkU3RhdGUsIElWYWxpZGF0aW9uUmVzdWx0IH0gZnJvbSBcIi4vVmFsaWRhdGlvblwiO1xuXG4vLyBJbnZva2UgdmFsaWRhdGlvbiBmcm9tIHVzZXIgaW5wdXQgKHdoZW4gdHlwaW5nLCBldGMuKSBhdCBtb3N0IG9uY2UgZXZlcnkgTiBtcy5cbmNvbnN0IFZBTElEQVRJT05fVEhST1RUTEVfTVMgPSAyMDA7XG5cbmNvbnN0IEJBU0VfSUQgPSBcIm14X0ZpZWxkXCI7XG5sZXQgY291bnQgPSAxO1xuZnVuY3Rpb24gZ2V0SWQoKSB7XG4gICAgcmV0dXJuIGAke0JBU0VfSUR9XyR7Y291bnQrK31gO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElWYWxpZGF0ZU9wdHMge1xuICAgIGZvY3VzZWQ/OiBib29sZWFuO1xuICAgIGFsbG93RW1wdHk/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgSVByb3BzIHtcbiAgICAvLyBUaGUgZmllbGQncyBJRCwgd2hpY2ggYmluZHMgdGhlIGlucHV0IGFuZCBsYWJlbCB0b2dldGhlci4gSW1tdXRhYmxlLlxuICAgIGlkPzogc3RyaW5nO1xuICAgIC8vIFRoZSBmaWVsZCdzIHR5cGUgKHdoZW4gdXNlZCBhcyBhbiA8aW5wdXQ+KS4gRGVmYXVsdHMgdG8gXCJ0ZXh0XCIuXG4gICAgdHlwZT86IHN0cmluZztcbiAgICAvLyBpZCBvZiBhIDxkYXRhbGlzdD4gZWxlbWVudCBmb3Igc3VnZ2VzdGlvbnNcbiAgICBsaXN0Pzogc3RyaW5nO1xuICAgIC8vIFRoZSBmaWVsZCdzIGxhYmVsIHN0cmluZy5cbiAgICBsYWJlbD86IHN0cmluZztcbiAgICAvLyBUaGUgZmllbGQncyBwbGFjZWhvbGRlciBzdHJpbmcuIERlZmF1bHRzIHRvIHRoZSBsYWJlbC5cbiAgICBwbGFjZWhvbGRlcj86IHN0cmluZztcbiAgICAvLyBXaGVuIHRydWUgKGRlZmF1bHQgZmFsc2UpLCB0aGUgcGxhY2Vob2xkZXIgd2lsbCBiZSBzaG93biBpbnN0ZWFkIG9mIHRoZSBsYWJlbCB3aGVuXG4gICAgLy8gdGhlIGNvbXBvbmVudCBpcyB1bmZvY3VzZWQgJiBlbXB0eS5cbiAgICB1c2VQbGFjZWhvbGRlckFzSGludD86IGJvb2xlYW47XG4gICAgLy8gT3B0aW9uYWwgY29tcG9uZW50IHRvIGluY2x1ZGUgaW5zaWRlIHRoZSBmaWVsZCBiZWZvcmUgdGhlIGlucHV0LlxuICAgIHByZWZpeENvbXBvbmVudD86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgICAvLyBPcHRpb25hbCBjb21wb25lbnQgdG8gaW5jbHVkZSBpbnNpZGUgdGhlIGZpZWxkIGFmdGVyIHRoZSBpbnB1dC5cbiAgICBwb3N0Zml4Q29tcG9uZW50PzogUmVhY3QuUmVhY3ROb2RlO1xuICAgIC8vIFRoZSBjYWxsYmFjayBjYWxsZWQgd2hlbmV2ZXIgdGhlIGNvbnRlbnRzIG9mIHRoZSBmaWVsZFxuICAgIC8vIGNoYW5nZXMuICBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGB2YWxpZGAgYm9vbGVhbiBmaWVsZFxuICAgIC8vIGFuZCBhIGBmZWVkYmFja2AgcmVhY3QgY29tcG9uZW50IGZpZWxkIHRvIHByb3ZpZGUgZmVlZGJhY2tcbiAgICAvLyB0byB0aGUgdXNlci5cbiAgICBvblZhbGlkYXRlPzogKGlucHV0OiBJRmllbGRTdGF0ZSkgPT4gUHJvbWlzZTxJVmFsaWRhdGlvblJlc3VsdD47XG4gICAgLy8gSWYgc3BlY2lmaWVkLCBvdmVycmlkZXMgdGhlIHZhbHVlIHJldHVybmVkIGJ5IG9uVmFsaWRhdGUuXG4gICAgZm9yY2VWYWxpZGl0eT86IGJvb2xlYW47XG4gICAgLy8gSWYgc3BlY2lmaWVkLCBjb250ZW50cyB3aWxsIGFwcGVhciBhcyBhIHRvb2x0aXAgb24gdGhlIGVsZW1lbnQgYW5kXG4gICAgLy8gdmFsaWRhdGlvbiBmZWVkYmFjayB0b29sdGlwcyB3aWxsIGJlIHN1cHByZXNzZWQuXG4gICAgdG9vbHRpcENvbnRlbnQ/OiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgLy8gSWYgc3BlY2lmaWVkIHRoZSB0b29sdGlwIHdpbGwgYmUgc2hvd24gcmVnYXJkbGVzcyBvZiBmZWVkYmFja1xuICAgIGZvcmNlVG9vbHRpcFZpc2libGU/OiBib29sZWFuO1xuICAgIC8vIElmIHNwZWNpZmllZCBhbG9uZ3NpZGUgdG9vbHRpcENvbnRlbnQsIHRoZSBjbGFzcyBuYW1lIHRvIGFwcGx5IHRvIHRoZVxuICAgIC8vIHRvb2x0aXAgaXRzZWxmLlxuICAgIHRvb2x0aXBDbGFzc05hbWU/OiBzdHJpbmc7XG4gICAgLy8gSWYgc3BlY2lmaWVkLCBhbiBhZGRpdGlvbmFsIGNsYXNzIG5hbWUgdG8gYXBwbHkgdG8gdGhlIGZpZWxkIGNvbnRhaW5lclxuICAgIGNsYXNzTmFtZT86IHN0cmluZztcbiAgICAvLyBPbiB3aGF0IGV2ZW50cyBzaG91bGQgdmFsaWRhdGlvbiBvY2N1cjsgYnkgZGVmYXVsdCBvbiBhbGxcbiAgICB2YWxpZGF0ZU9uRm9jdXM/OiBib29sZWFuO1xuICAgIHZhbGlkYXRlT25CbHVyPzogYm9vbGVhbjtcbiAgICB2YWxpZGF0ZU9uQ2hhbmdlPzogYm9vbGVhbjtcbiAgICAvLyBBbGwgb3RoZXIgcHJvcHMgcGFzcyB0aHJvdWdoIHRvIHRoZSA8aW5wdXQ+LlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElJbnB1dFByb3BzIGV4dGVuZHMgSVByb3BzLCBJbnB1dEhUTUxBdHRyaWJ1dGVzPEhUTUxJbnB1dEVsZW1lbnQ+IHtcbiAgICAvLyBUaGUgZWxlbWVudCB0byBjcmVhdGUuIERlZmF1bHRzIHRvIFwiaW5wdXRcIi5cbiAgICBlbGVtZW50PzogXCJpbnB1dFwiO1xuICAgIC8vIFRoZSBpbnB1dCdzIHZhbHVlLiBUaGlzIGlzIGEgY29udHJvbGxlZCBjb21wb25lbnQsIHNvIHRoZSB2YWx1ZSBpcyByZXF1aXJlZC5cbiAgICB2YWx1ZTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgSVNlbGVjdFByb3BzIGV4dGVuZHMgSVByb3BzLCBTZWxlY3RIVE1MQXR0cmlidXRlczxIVE1MU2VsZWN0RWxlbWVudD4ge1xuICAgIC8vIFRvIGRlZmluZSBvcHRpb25zIGZvciBhIHNlbGVjdCwgdXNlIDxGaWVsZD48b3B0aW9uIC4uLiAvPjwvRmllbGQ+XG4gICAgZWxlbWVudDogXCJzZWxlY3RcIjtcbiAgICAvLyBUaGUgc2VsZWN0J3MgdmFsdWUuIFRoaXMgaXMgYSBjb250cm9sbGVkIGNvbXBvbmVudCwgc28gdGhlIHZhbHVlIGlzIHJlcXVpcmVkLlxuICAgIHZhbHVlOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBJVGV4dGFyZWFQcm9wcyBleHRlbmRzIElQcm9wcywgVGV4dGFyZWFIVE1MQXR0cmlidXRlczxIVE1MVGV4dEFyZWFFbGVtZW50PiB7XG4gICAgZWxlbWVudDogXCJ0ZXh0YXJlYVwiO1xuICAgIC8vIFRoZSB0ZXh0YXJlYSdzIHZhbHVlLiBUaGlzIGlzIGEgY29udHJvbGxlZCBjb21wb25lbnQsIHNvIHRoZSB2YWx1ZSBpcyByZXF1aXJlZC5cbiAgICB2YWx1ZTogc3RyaW5nO1xufVxuXG50eXBlIFByb3BTaGFwZXMgPSBJSW5wdXRQcm9wcyB8IElTZWxlY3RQcm9wcyB8IElUZXh0YXJlYVByb3BzO1xuXG5pbnRlcmZhY2UgSVN0YXRlIHtcbiAgICB2YWxpZDogYm9vbGVhbjtcbiAgICBmZWVkYmFjazogUmVhY3QuUmVhY3ROb2RlO1xuICAgIGZlZWRiYWNrVmlzaWJsZTogYm9vbGVhbjtcbiAgICBmb2N1c2VkOiBib29sZWFuO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaWVsZCBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8UHJvcFNoYXBlcywgSVN0YXRlPiB7XG4gICAgcHJpdmF0ZSBpZDogc3RyaW5nO1xuICAgIHByaXZhdGUgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQ7XG5cbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgZWxlbWVudDogXCJpbnB1dFwiLFxuICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgdmFsaWRhdGVPbkZvY3VzOiB0cnVlLFxuICAgICAgICB2YWxpZGF0ZU9uQmx1cjogdHJ1ZSxcbiAgICAgICAgdmFsaWRhdGVPbkNoYW5nZTogdHJ1ZSxcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBUaGlzIHdhcyBjaGFuZ2VkIGZyb20gdGhyb3R0bGUgdG8gZGVib3VuY2U6IHRoaXMgaXMgbW9yZSB0cmFkaXRpb25hbCBmb3JcbiAgICAgKiBmb3JtIHZhbGlkYXRpb24gc2luY2UgaXQgbWVhbnMgdGhhdCB0aGUgdmFsaWRhdGlvbiBkb2Vzbid0IGhhcHBlbiBhdCBhbGxcbiAgICAgKiB1bnRpbCB0aGUgdXNlciBzdG9wcyB0eXBpbmcgZm9yIGEgYml0IChkZWJvdW5jZSBkZWZhdWx0cyB0byBub3QgcnVubmluZyBvblxuICAgICAqIHRoZSBsZWFkaW5nIGVkZ2UpLiBJZiB3ZSdyZSBkb2luZyBhbiBIVFRQIGhpdCBvbiBlYWNoIHZhbGlkYXRpb24sIHdlIGhhdmUgbW9yZVxuICAgICAqIGluY2VudGl2ZSB0byBwcmV2ZW50IHZhbGlkYXRpbmcgaW5wdXQgdGhhdCdzIHZlcnkgdW5saWtlbHkgdG8gYmUgdmFsaWQuXG4gICAgICogV2UgbWF5IGZpbmQgdGhhdCB3ZSBhY3R1YWxseSB3YW50IGRpZmZlcmVudCBiZWhhdmlvdXIgZm9yIHJlZ2lzdHJhdGlvblxuICAgICAqIGZpZWxkcywgaW4gd2hpY2ggY2FzZSB3ZSBjYW4gYWRkIHNvbWUgb3B0aW9ucyB0byBjb250cm9sIGl0LlxuICAgICAqL1xuICAgIHByaXZhdGUgdmFsaWRhdGVPbkNoYW5nZSA9IGRlYm91bmNlKCgpID0+IHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSh7XG4gICAgICAgICAgICBmb2N1c2VkOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9LCBWQUxJREFUSU9OX1RIUk9UVExFX01TKTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHZhbGlkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBmZWVkYmFjazogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZmVlZGJhY2tWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGZvY3VzZWQ6IGZhbHNlLFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuaWQgPSB0aGlzLnByb3BzLmlkIHx8IGdldElkKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGZvY3VzKCkge1xuICAgICAgICB0aGlzLmlucHV0LmZvY3VzKCk7XG4gICAgICAgIC8vIHByb2dyYW1tYXRpYyBkb2VzIG5vdCBmaXJlIG9uRm9jdXMgaGFuZGxlclxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZvY3VzZWQ6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgb25Gb2N1cyA9IChldikgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZvY3VzZWQ6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy52YWxpZGF0ZU9uRm9jdXMpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGUoe1xuICAgICAgICAgICAgICAgIGZvY3VzZWQ6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYXJlbnQgY29tcG9uZW50IG1heSBoYXZlIHN1cHBsaWVkIGl0cyBvd24gYG9uRm9jdXNgIGFzIHdlbGxcbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25Gb2N1cykge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkZvY3VzKGV2KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcml2YXRlIG9uQ2hhbmdlID0gKGV2KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnZhbGlkYXRlT25DaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVPbkNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhcmVudCBjb21wb25lbnQgbWF5IGhhdmUgc3VwcGxpZWQgaXRzIG93biBgb25DaGFuZ2VgIGFzIHdlbGxcbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25DaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UoZXYpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25CbHVyID0gKGV2KSA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZm9jdXNlZDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy52YWxpZGF0ZU9uQmx1cikge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZSh7XG4gICAgICAgICAgICAgICAgZm9jdXNlZDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYXJlbnQgY29tcG9uZW50IG1heSBoYXZlIHN1cHBsaWVkIGl0cyBvd24gYG9uQmx1cmAgYXMgd2VsbFxuICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkJsdXIpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25CbHVyKGV2KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwdWJsaWMgYXN5bmMgdmFsaWRhdGUoeyBmb2N1c2VkLCBhbGxvd0VtcHR5ID0gdHJ1ZSB9OiBJVmFsaWRhdGVPcHRzKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm9wcy5vblZhbGlkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmlucHV0ID8gdGhpcy5pbnB1dC52YWx1ZSA6IG51bGw7XG4gICAgICAgIGNvbnN0IHsgdmFsaWQsIGZlZWRiYWNrIH0gPSBhd2FpdCB0aGlzLnByb3BzLm9uVmFsaWRhdGUoe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBmb2N1c2VkLFxuICAgICAgICAgICAgYWxsb3dFbXB0eSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdGhpcyBtZXRob2QgaXMgYXN5bmMgYW5kIHNvIHdlIG1heSBoYXZlIGJlZW4gYmx1cnJlZCBzaW5jZSB0aGUgbWV0aG9kIHdhcyBjYWxsZWRcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSB0aGVuIGhpZGUgdGhlIGZlZWRiYWNrIGFzIHdpdGhWYWxpZGF0aW9uIGRvZXNcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZm9jdXNlZCAmJiBmZWVkYmFjaykge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgdmFsaWQsXG4gICAgICAgICAgICAgICAgZmVlZGJhY2ssXG4gICAgICAgICAgICAgICAgZmVlZGJhY2tWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIHJlY2VpdmUgbnVsbCBgZmVlZGJhY2tgLCB3ZSB3YW50IHRvIGhpZGUgdGhlIHRvb2x0aXAuXG4gICAgICAgICAgICAvLyBXZSBsZWF2ZSB0aGUgcHJldmlvdXMgYGZlZWRiYWNrYCBjb250ZW50IGluIHN0YXRlIHdpdGhvdXQgdXBkYXRpbmcgaXQsXG4gICAgICAgICAgICAvLyBzbyB0aGF0IHdlIGNhbiBoaWRlIHRoZSB0b29sdGlwIGNvbnRhaW5pbmcgdGhlIG1vc3QgcmVjZW50IGZlZWRiYWNrXG4gICAgICAgICAgICAvLyB2aWEgQ1NTIGFuaW1hdGlvbi5cbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHZhbGlkLFxuICAgICAgICAgICAgICAgIGZlZWRiYWNrVmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVuZGVyKCkge1xuICAgICAgICAvKiBlc2xpbnQgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwiaWdub3JlUmVzdFNpYmxpbmdzXCI6IHRydWUgfV0gKi9cbiAgICAgICAgY29uc3QgeyBlbGVtZW50LCBwcmVmaXhDb21wb25lbnQsIHBvc3RmaXhDb21wb25lbnQsIGNsYXNzTmFtZSwgb25WYWxpZGF0ZSwgY2hpbGRyZW4sXG4gICAgICAgICAgICB0b29sdGlwQ29udGVudCwgZm9yY2VWYWxpZGl0eSwgdG9vbHRpcENsYXNzTmFtZSwgbGlzdCwgdmFsaWRhdGVPbkJsdXIsIHZhbGlkYXRlT25DaGFuZ2UsIHZhbGlkYXRlT25Gb2N1cyxcbiAgICAgICAgICAgIHVzZVBsYWNlaG9sZGVyQXNIaW50LFxuICAgICAgICAgICAgLi4uaW5wdXRQcm9wcyB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICAvLyBTZXQgc29tZSBkZWZhdWx0cyBmb3IgdGhlIDxpbnB1dD4gZWxlbWVudFxuICAgICAgICBjb25zdCByZWYgPSBpbnB1dCA9PiB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIGlucHV0UHJvcHMucGxhY2Vob2xkZXIgPSBpbnB1dFByb3BzLnBsYWNlaG9sZGVyIHx8IGlucHV0UHJvcHMubGFiZWw7XG4gICAgICAgIGlucHV0UHJvcHMuaWQgPSB0aGlzLmlkOyAvLyB0aGlzIG92ZXJ3cml0ZXMgdGhlIGlkIGZyb20gcHJvcHNcblxuICAgICAgICBpbnB1dFByb3BzLm9uRm9jdXMgPSB0aGlzLm9uRm9jdXM7XG4gICAgICAgIGlucHV0UHJvcHMub25DaGFuZ2UgPSB0aGlzLm9uQ2hhbmdlO1xuICAgICAgICBpbnB1dFByb3BzLm9uQmx1ciA9IHRoaXMub25CbHVyO1xuXG4gICAgICAgIC8vIEFwcGVhc2UgdHlwZXNjcmlwdCdzIGluZmVyZW5jZVxuICAgICAgICBjb25zdCBpbnB1dFByb3BzXyA9IHsgLi4uaW5wdXRQcm9wcywgcmVmLCBsaXN0IH07XG5cbiAgICAgICAgY29uc3QgZmllbGRJbnB1dCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQodGhpcy5wcm9wcy5lbGVtZW50LCBpbnB1dFByb3BzXywgY2hpbGRyZW4pO1xuXG4gICAgICAgIGxldCBwcmVmaXhDb250YWluZXIgPSBudWxsO1xuICAgICAgICBpZiAocHJlZml4Q29tcG9uZW50KSB7XG4gICAgICAgICAgICBwcmVmaXhDb250YWluZXIgPSA8c3BhbiBjbGFzc05hbWU9XCJteF9GaWVsZF9wcmVmaXhcIj57IHByZWZpeENvbXBvbmVudCB9PC9zcGFuPjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcG9zdGZpeENvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIGlmIChwb3N0Zml4Q29tcG9uZW50KSB7XG4gICAgICAgICAgICBwb3N0Zml4Q29udGFpbmVyID0gPHNwYW4gY2xhc3NOYW1lPVwibXhfRmllbGRfcG9zdGZpeFwiPnsgcG9zdGZpeENvbXBvbmVudCB9PC9zcGFuPjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGhhc1ZhbGlkYXRpb25GbGFnID0gZm9yY2VWYWxpZGl0eSAhPT0gbnVsbCAmJiBmb3JjZVZhbGlkaXR5ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGZpZWxkQ2xhc3NlcyA9IGNsYXNzTmFtZXMoXCJteF9GaWVsZFwiLCBgbXhfRmllbGRfJHt0aGlzLnByb3BzLmVsZW1lbnR9YCwgY2xhc3NOYW1lLCB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcHJlZml4IGVsZW1lbnQsIGxlYXZlIHRoZSBsYWJlbCBhbHdheXMgYXQgdGhlIHRvcCBsZWZ0IGFuZFxuICAgICAgICAgICAgLy8gZG9uJ3QgYW5pbWF0ZSBpdCwgYXMgaXQgbG9va3MgYSBiaXQgY2x1bmt5IGFuZCB3b3VsZCBhZGQgY29tcGxleGl0eSB0byBkb1xuICAgICAgICAgICAgLy8gcHJvcGVybHkuXG4gICAgICAgICAgICBteF9GaWVsZF9sYWJlbEFsd2F5c1RvcExlZnQ6IHByZWZpeENvbXBvbmVudCB8fCB1c2VQbGFjZWhvbGRlckFzSGludCxcbiAgICAgICAgICAgIG14X0ZpZWxkX3BsYWNlaG9sZGVySXNIaW50OiB1c2VQbGFjZWhvbGRlckFzSGludCxcbiAgICAgICAgICAgIG14X0ZpZWxkX3ZhbGlkOiBoYXNWYWxpZGF0aW9uRmxhZyA/IGZvcmNlVmFsaWRpdHkgOiBvblZhbGlkYXRlICYmIHRoaXMuc3RhdGUudmFsaWQgPT09IHRydWUsXG4gICAgICAgICAgICBteF9GaWVsZF9pbnZhbGlkOiBoYXNWYWxpZGF0aW9uRmxhZ1xuICAgICAgICAgICAgICAgID8gIWZvcmNlVmFsaWRpdHlcbiAgICAgICAgICAgICAgICA6IG9uVmFsaWRhdGUgJiYgdGhpcy5zdGF0ZS52YWxpZCA9PT0gZmFsc2UsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEhhbmRsZSBkaXNwbGF5aW5nIGZlZWRiYWNrIG9uIHZhbGlkaXR5XG4gICAgICAgIC8vIEZJWE1FOiBVc2luZyBhbiBpbXBvcnQgd2lsbCByZXN1bHQgaW4gdGVzdCBmYWlsdXJlc1xuICAgICAgICBjb25zdCBUb29sdGlwID0gc2RrLmdldENvbXBvbmVudChcImVsZW1lbnRzLlRvb2x0aXBcIik7XG4gICAgICAgIGxldCBmaWVsZFRvb2x0aXA7XG4gICAgICAgIGlmICh0b29sdGlwQ29udGVudCB8fCB0aGlzLnN0YXRlLmZlZWRiYWNrKSB7XG4gICAgICAgICAgICBmaWVsZFRvb2x0aXAgPSA8VG9vbHRpcFxuICAgICAgICAgICAgICAgIHRvb2x0aXBDbGFzc05hbWU9e2NsYXNzTmFtZXMoXCJteF9GaWVsZF90b29sdGlwXCIsIHRvb2x0aXBDbGFzc05hbWUpfVxuICAgICAgICAgICAgICAgIHZpc2libGU9eyh0aGlzLnN0YXRlLmZvY3VzZWQgJiYgdGhpcy5wcm9wcy5mb3JjZVRvb2x0aXBWaXNpYmxlKSB8fCB0aGlzLnN0YXRlLmZlZWRiYWNrVmlzaWJsZX1cbiAgICAgICAgICAgICAgICBsYWJlbD17dG9vbHRpcENvbnRlbnQgfHwgdGhpcy5zdGF0ZS5mZWVkYmFja31cbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQ9e1Rvb2x0aXAuQWxpZ25tZW50LlJpZ2h0fVxuICAgICAgICAgICAgLz47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9e2ZpZWxkQ2xhc3Nlc30+XG4gICAgICAgICAgICB7IHByZWZpeENvbnRhaW5lciB9XG4gICAgICAgICAgICB7IGZpZWxkSW5wdXQgfVxuICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9e3RoaXMuaWR9PnsgdGhpcy5wcm9wcy5sYWJlbCB9PC9sYWJlbD5cbiAgICAgICAgICAgIHsgcG9zdGZpeENvbnRhaW5lciB9XG4gICAgICAgICAgICB7IGZpZWxkVG9vbHRpcCB9XG4gICAgICAgIDwvZGl2PjtcbiAgICB9XG59XG4iXX0=