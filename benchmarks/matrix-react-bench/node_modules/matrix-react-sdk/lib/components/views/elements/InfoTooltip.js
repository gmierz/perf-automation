"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.InfoTooltipKind = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _Tooltip = _interopRequireWildcard(require("./Tooltip"));

var _languageHandler = require("../../../languageHandler");

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _dec, _class;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

let InfoTooltipKind;
exports.InfoTooltipKind = InfoTooltipKind;

(function (InfoTooltipKind) {
  InfoTooltipKind["Info"] = "info";
  InfoTooltipKind["Warning"] = "warning";
})(InfoTooltipKind || (exports.InfoTooltipKind = InfoTooltipKind = {}));

let InfoTooltip = (_dec = (0, _replaceableComponent.replaceableComponent)("views.elements.InfoTooltip"), _dec(_class = class InfoTooltip extends _react.default.PureComponent {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "onMouseOver", () => {
      this.setState({
        hover: true
      });
    });
    (0, _defineProperty2.default)(this, "onMouseLeave", () => {
      this.setState({
        hover: false
      });
    });
    this.state = {
      hover: false
    };
  }

  render() {
    const {
      tooltip,
      children,
      tooltipClassName,
      className,
      kind
    } = this.props;
    const title = (0, _languageHandler._t)("Information");
    const iconClassName = kind !== InfoTooltipKind.Warning ? "mx_InfoTooltip_icon_info" : "mx_InfoTooltip_icon_warning"; // Tooltip are forced on the right for a more natural feel to them on info icons

    const tip = this.state.hover ? /*#__PURE__*/_react.default.createElement(_Tooltip.default, {
      className: "mx_InfoTooltip_container",
      tooltipClassName: (0, _classnames.default)("mx_InfoTooltip_tooltip", tooltipClassName),
      label: tooltip || title,
      alignment: _Tooltip.Alignment.Right
    }) : /*#__PURE__*/_react.default.createElement("div", null);
    return /*#__PURE__*/_react.default.createElement("div", {
      onMouseOver: this.onMouseOver,
      onMouseLeave: this.onMouseLeave,
      className: (0, _classnames.default)("mx_InfoTooltip", className)
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: (0, _classnames.default)("mx_InfoTooltip_icon", iconClassName),
      "aria-label": title
    }), children, tip);
  }

}) || _class);
exports.default = InfoTooltip;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2VsZW1lbnRzL0luZm9Ub29sdGlwLnRzeCJdLCJuYW1lcyI6WyJJbmZvVG9vbHRpcEtpbmQiLCJJbmZvVG9vbHRpcCIsIlJlYWN0IiwiUHVyZUNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJzZXRTdGF0ZSIsImhvdmVyIiwic3RhdGUiLCJyZW5kZXIiLCJ0b29sdGlwIiwiY2hpbGRyZW4iLCJ0b29sdGlwQ2xhc3NOYW1lIiwiY2xhc3NOYW1lIiwia2luZCIsInRpdGxlIiwiaWNvbkNsYXNzTmFtZSIsIldhcm5pbmciLCJ0aXAiLCJBbGlnbm1lbnQiLCJSaWdodCIsIm9uTW91c2VPdmVyIiwib25Nb3VzZUxlYXZlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWlCQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7SUFFWUEsZTs7O1dBQUFBLGU7QUFBQUEsRUFBQUEsZTtBQUFBQSxFQUFBQSxlO0dBQUFBLGUsK0JBQUFBLGU7O0lBaUJTQyxXLFdBRHBCLGdEQUFxQiw0QkFBckIsQyxnQkFBRCxNQUNxQkEsV0FEckIsU0FDeUNDLGVBQU1DLGFBRC9DLENBQ29GO0FBQ2hGQyxFQUFBQSxXQUFXLENBQUNDLEtBQUQsRUFBdUI7QUFDOUIsVUFBTUEsS0FBTjtBQUQ4Qix1REFPcEIsTUFBTTtBQUNoQixXQUFLQyxRQUFMLENBQWM7QUFDVkMsUUFBQUEsS0FBSyxFQUFFO0FBREcsT0FBZDtBQUdILEtBWGlDO0FBQUEsd0RBYW5CLE1BQU07QUFDakIsV0FBS0QsUUFBTCxDQUFjO0FBQ1ZDLFFBQUFBLEtBQUssRUFBRTtBQURHLE9BQWQ7QUFHSCxLQWpCaUM7QUFFOUIsU0FBS0MsS0FBTCxHQUFhO0FBQ1RELE1BQUFBLEtBQUssRUFBRTtBQURFLEtBQWI7QUFHSDs7QUFjREUsRUFBQUEsTUFBTSxHQUFHO0FBQ0wsVUFBTTtBQUFFQyxNQUFBQSxPQUFGO0FBQVdDLE1BQUFBLFFBQVg7QUFBcUJDLE1BQUFBLGdCQUFyQjtBQUF1Q0MsTUFBQUEsU0FBdkM7QUFBa0RDLE1BQUFBO0FBQWxELFFBQTJELEtBQUtULEtBQXRFO0FBQ0EsVUFBTVUsS0FBSyxHQUFHLHlCQUFHLGFBQUgsQ0FBZDtBQUNBLFVBQU1DLGFBQWEsR0FDZEYsSUFBSSxLQUFLZCxlQUFlLENBQUNpQixPQUExQixHQUNJLDBCQURKLEdBQ2lDLDZCQUZyQyxDQUhLLENBUUw7O0FBQ0EsVUFBTUMsR0FBRyxHQUFHLEtBQUtWLEtBQUwsQ0FBV0QsS0FBWCxnQkFBbUIsNkJBQUMsZ0JBQUQ7QUFDM0IsTUFBQSxTQUFTLEVBQUMsMEJBRGlCO0FBRTNCLE1BQUEsZ0JBQWdCLEVBQUUseUJBQVcsd0JBQVgsRUFBcUNLLGdCQUFyQyxDQUZTO0FBRzNCLE1BQUEsS0FBSyxFQUFFRixPQUFPLElBQUlLLEtBSFM7QUFJM0IsTUFBQSxTQUFTLEVBQUVJLG1CQUFVQztBQUpNLE1BQW5CLGdCQUtQLHlDQUxMO0FBTUEsd0JBQ0k7QUFDSSxNQUFBLFdBQVcsRUFBRSxLQUFLQyxXQUR0QjtBQUVJLE1BQUEsWUFBWSxFQUFFLEtBQUtDLFlBRnZCO0FBR0ksTUFBQSxTQUFTLEVBQUUseUJBQVcsZ0JBQVgsRUFBNkJULFNBQTdCO0FBSGYsb0JBS0k7QUFBTSxNQUFBLFNBQVMsRUFBRSx5QkFBVyxxQkFBWCxFQUFrQ0csYUFBbEMsQ0FBakI7QUFBbUUsb0JBQVlEO0FBQS9FLE1BTEosRUFNTUosUUFOTixFQU9NTyxHQVBOLENBREo7QUFXSDs7QUE5QytFLEMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMTkgTWljaGFlbCBUZWxhdHluc2tpIDw3dDNjaGd1eUBnbWFpbC5jb20+XG5Db3B5cmlnaHQgMjAxOSBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcblxuaW1wb3J0IFRvb2x0aXAsIHsgQWxpZ25tZW50IH0gZnJvbSAnLi9Ub29sdGlwJztcbmltcG9ydCB7IF90IH0gZnJvbSBcIi4uLy4uLy4uL2xhbmd1YWdlSGFuZGxlclwiO1xuaW1wb3J0IHsgcmVwbGFjZWFibGVDb21wb25lbnQgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvcmVwbGFjZWFibGVDb21wb25lbnRcIjtcblxuZXhwb3J0IGVudW0gSW5mb1Rvb2x0aXBLaW5kIHtcbiAgICBJbmZvID0gXCJpbmZvXCIsXG4gICAgV2FybmluZyA9IFwid2FybmluZ1wiLFxufVxuXG5pbnRlcmZhY2UgSVRvb2x0aXBQcm9wcyB7XG4gICAgdG9vbHRpcD86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgICBjbGFzc05hbWU/OiBzdHJpbmc7XG4gICAgdG9vbHRpcENsYXNzTmFtZT86IHN0cmluZztcbiAgICBraW5kPzogSW5mb1Rvb2x0aXBLaW5kO1xufVxuXG5pbnRlcmZhY2UgSVN0YXRlIHtcbiAgICBob3ZlcjogYm9vbGVhbjtcbn1cblxuQHJlcGxhY2VhYmxlQ29tcG9uZW50KFwidmlld3MuZWxlbWVudHMuSW5mb1Rvb2x0aXBcIilcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEluZm9Ub29sdGlwIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxJVG9vbHRpcFByb3BzLCBJU3RhdGU+IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wczogSVRvb2x0aXBQcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBob3ZlcjogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgb25Nb3VzZU92ZXIgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgaG92ZXI6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBvbk1vdXNlTGVhdmUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgaG92ZXI6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHRvb2x0aXAsIGNoaWxkcmVuLCB0b29sdGlwQ2xhc3NOYW1lLCBjbGFzc05hbWUsIGtpbmQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHRpdGxlID0gX3QoXCJJbmZvcm1hdGlvblwiKTtcbiAgICAgICAgY29uc3QgaWNvbkNsYXNzTmFtZSA9IChcbiAgICAgICAgICAgIChraW5kICE9PSBJbmZvVG9vbHRpcEtpbmQuV2FybmluZykgP1xuICAgICAgICAgICAgICAgIFwibXhfSW5mb1Rvb2x0aXBfaWNvbl9pbmZvXCIgOiBcIm14X0luZm9Ub29sdGlwX2ljb25fd2FybmluZ1wiXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gVG9vbHRpcCBhcmUgZm9yY2VkIG9uIHRoZSByaWdodCBmb3IgYSBtb3JlIG5hdHVyYWwgZmVlbCB0byB0aGVtIG9uIGluZm8gaWNvbnNcbiAgICAgICAgY29uc3QgdGlwID0gdGhpcy5zdGF0ZS5ob3ZlciA/IDxUb29sdGlwXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJteF9JbmZvVG9vbHRpcF9jb250YWluZXJcIlxuICAgICAgICAgICAgdG9vbHRpcENsYXNzTmFtZT17Y2xhc3NOYW1lcyhcIm14X0luZm9Ub29sdGlwX3Rvb2x0aXBcIiwgdG9vbHRpcENsYXNzTmFtZSl9XG4gICAgICAgICAgICBsYWJlbD17dG9vbHRpcCB8fCB0aXRsZX1cbiAgICAgICAgICAgIGFsaWdubWVudD17QWxpZ25tZW50LlJpZ2h0fVxuICAgICAgICAvPiA6IDxkaXYgLz47XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgb25Nb3VzZU92ZXI9e3RoaXMub25Nb3VzZU92ZXJ9XG4gICAgICAgICAgICAgICAgb25Nb3VzZUxlYXZlPXt0aGlzLm9uTW91c2VMZWF2ZX1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXCJteF9JbmZvVG9vbHRpcFwiLCBjbGFzc05hbWUpfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcIm14X0luZm9Ub29sdGlwX2ljb25cIiwgaWNvbkNsYXNzTmFtZSl9IGFyaWEtbGFiZWw9e3RpdGxlfSAvPlxuICAgICAgICAgICAgICAgIHsgY2hpbGRyZW4gfVxuICAgICAgICAgICAgICAgIHsgdGlwIH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cbn1cbiJdfQ==