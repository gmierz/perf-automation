"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var React = _interopRequireWildcard(require("react"));

var _qrcode = require("qrcode");

var _classnames = _interopRequireDefault(require("classnames"));

var _languageHandler = require("../../../languageHandler");

var _Spinner = _interopRequireDefault(require("./Spinner"));

const _excluded = ["data", "className"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const defaultOptions = {
  errorCorrectionLevel: 'L' // we want it as trivial-looking as possible

};

const QRCode = _ref => {
  let {
    data,
    className
  } = _ref,
      options = (0, _objectWithoutProperties2.default)(_ref, _excluded);
  const [dataUri, setUri] = React.useState(null);
  React.useEffect(() => {
    let cancelled = false;
    (0, _qrcode.toDataURL)(data, _objectSpread(_objectSpread({}, defaultOptions), options)).then(uri => {
      if (cancelled) return;
      setUri(uri);
    });
    return () => {
      cancelled = true;
    };
  }, [JSON.stringify(data), options]); // eslint-disable-line react-hooks/exhaustive-deps

  return /*#__PURE__*/React.createElement("div", {
    className: (0, _classnames.default)("mx_QRCode", className)
  }, dataUri ? /*#__PURE__*/React.createElement("img", {
    src: dataUri,
    className: "mx_VerificationQRCode",
    alt: (0, _languageHandler._t)("QR Code")
  }) : /*#__PURE__*/React.createElement(_Spinner.default, null));
};

var _default = QRCode;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2VsZW1lbnRzL1FSQ29kZS50c3giXSwibmFtZXMiOlsiZGVmYXVsdE9wdGlvbnMiLCJlcnJvckNvcnJlY3Rpb25MZXZlbCIsIlFSQ29kZSIsImRhdGEiLCJjbGFzc05hbWUiLCJvcHRpb25zIiwiZGF0YVVyaSIsInNldFVyaSIsIlJlYWN0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJjYW5jZWxsZWQiLCJ0aGVuIiwidXJpIiwiSlNPTiIsInN0cmluZ2lmeSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQWdCQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7Ozs7Ozs7Ozs7O0FBT0EsTUFBTUEsY0FBc0MsR0FBRztBQUMzQ0MsRUFBQUEsb0JBQW9CLEVBQUUsR0FEcUIsQ0FDaEI7O0FBRGdCLENBQS9DOztBQUlBLE1BQU1DLE1BQXdCLEdBQUcsUUFBcUM7QUFBQSxNQUFwQztBQUFFQyxJQUFBQSxJQUFGO0FBQVFDLElBQUFBO0FBQVIsR0FBb0M7QUFBQSxNQUFkQyxPQUFjO0FBQ2xFLFFBQU0sQ0FBQ0MsT0FBRCxFQUFVQyxNQUFWLElBQW9CQyxLQUFLLENBQUNDLFFBQU4sQ0FBdUIsSUFBdkIsQ0FBMUI7QUFDQUQsRUFBQUEsS0FBSyxDQUFDRSxTQUFOLENBQWdCLE1BQU07QUFDbEIsUUFBSUMsU0FBUyxHQUFHLEtBQWhCO0FBQ0EsMkJBQVVSLElBQVYsa0NBQXFCSCxjQUFyQixHQUF3Q0ssT0FBeEMsR0FBbURPLElBQW5ELENBQXdEQyxHQUFHLElBQUk7QUFDM0QsVUFBSUYsU0FBSixFQUFlO0FBQ2ZKLE1BQUFBLE1BQU0sQ0FBQ00sR0FBRCxDQUFOO0FBQ0gsS0FIRDtBQUlBLFdBQU8sTUFBTTtBQUNURixNQUFBQSxTQUFTLEdBQUcsSUFBWjtBQUNILEtBRkQ7QUFHSCxHQVRELEVBU0csQ0FBQ0csSUFBSSxDQUFDQyxTQUFMLENBQWVaLElBQWYsQ0FBRCxFQUF1QkUsT0FBdkIsQ0FUSCxFQUZrRSxDQVc3Qjs7QUFFckMsc0JBQU87QUFBSyxJQUFBLFNBQVMsRUFBRSx5QkFBVyxXQUFYLEVBQXdCRCxTQUF4QjtBQUFoQixLQUNERSxPQUFPLGdCQUFHO0FBQUssSUFBQSxHQUFHLEVBQUVBLE9BQVY7QUFBbUIsSUFBQSxTQUFTLEVBQUMsdUJBQTdCO0FBQXFELElBQUEsR0FBRyxFQUFFLHlCQUFHLFNBQUg7QUFBMUQsSUFBSCxnQkFBaUYsb0JBQUMsZ0JBQUQsT0FEdkYsQ0FBUDtBQUdILENBaEJEOztlQWtCZUosTSIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAyMCBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdG9EYXRhVVJMLCBRUkNvZGVTZWdtZW50LCBRUkNvZGVUb0RhdGFVUkxPcHRpb25zIH0gZnJvbSBcInFyY29kZVwiO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSBcImNsYXNzbmFtZXNcIjtcblxuaW1wb3J0IHsgX3QgfSBmcm9tIFwiLi4vLi4vLi4vbGFuZ3VhZ2VIYW5kbGVyXCI7XG5pbXBvcnQgU3Bpbm5lciBmcm9tIFwiLi9TcGlubmVyXCI7XG5cbmludGVyZmFjZSBJUHJvcHMgZXh0ZW5kcyBRUkNvZGVUb0RhdGFVUkxPcHRpb25zIHtcbiAgICBkYXRhOiBzdHJpbmcgfCBRUkNvZGVTZWdtZW50W107XG4gICAgY2xhc3NOYW1lPzogc3RyaW5nO1xufVxuXG5jb25zdCBkZWZhdWx0T3B0aW9uczogUVJDb2RlVG9EYXRhVVJMT3B0aW9ucyA9IHtcbiAgICBlcnJvckNvcnJlY3Rpb25MZXZlbDogJ0wnLCAvLyB3ZSB3YW50IGl0IGFzIHRyaXZpYWwtbG9va2luZyBhcyBwb3NzaWJsZVxufTtcblxuY29uc3QgUVJDb2RlOiBSZWFjdC5GQzxJUHJvcHM+ID0gKHsgZGF0YSwgY2xhc3NOYW1lLCAuLi5vcHRpb25zIH0pID0+IHtcbiAgICBjb25zdCBbZGF0YVVyaSwgc2V0VXJpXSA9IFJlYWN0LnVzZVN0YXRlPHN0cmluZz4obnVsbCk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICB0b0RhdGFVUkwoZGF0YSwgeyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9KS50aGVuKHVyaSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgICAgICBzZXRVcmkodXJpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgIH0sIFtKU09OLnN0cmluZ2lmeShkYXRhKSwgb3B0aW9uc10pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuXG4gICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFwibXhfUVJDb2RlXCIsIGNsYXNzTmFtZSl9PlxuICAgICAgICB7IGRhdGFVcmkgPyA8aW1nIHNyYz17ZGF0YVVyaX0gY2xhc3NOYW1lPVwibXhfVmVyaWZpY2F0aW9uUVJDb2RlXCIgYWx0PXtfdChcIlFSIENvZGVcIil9IC8+IDogPFNwaW5uZXIgLz4gfVxuICAgIDwvZGl2Pjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFFSQ29kZTtcbiJdfQ==