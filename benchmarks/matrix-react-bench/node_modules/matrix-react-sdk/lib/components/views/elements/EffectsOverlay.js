"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _dispatcher = _interopRequireDefault(require("../../../dispatcher/dispatcher"));

var _effects = require("../../../effects");

var _UIStore = _interopRequireWildcard(require("../../../stores/UIStore"));

var _logger = require("matrix-js-sdk/src/logger");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const EffectsOverlay = ({
  roomWidth
}) => {
  const canvasRef = (0, _react.useRef)(null);
  const effectsRef = (0, _react.useRef)(new Map());

  const lazyLoadEffectModule = async name => {
    if (!name) return null;
    let effect = effectsRef.current[name] || null;

    if (effect === null) {
      var _CHAT_EFFECTS$find;

      const options = (_CHAT_EFFECTS$find = _effects.CHAT_EFFECTS.find(e => e.command === name)) === null || _CHAT_EFFECTS$find === void 0 ? void 0 : _CHAT_EFFECTS$find.options;

      try {
        const {
          default: Effect
        } = await Promise.resolve(`../../../effects/${name}`).then(s => _interopRequireWildcard(require(s)));
        effect = new Effect(options);
        effectsRef.current[name] = effect;
      } catch (err) {
        _logger.logger.warn(`Unable to load effect module at '../../../effects/${name}.`, err);
      }
    }

    return effect;
  };

  (0, _react.useEffect)(() => {
    const resize = () => {
      var _canvasRef$current;

      if (canvasRef.current && ((_canvasRef$current = canvasRef.current) === null || _canvasRef$current === void 0 ? void 0 : _canvasRef$current.height) !== _UIStore.default.instance.windowHeight) {
        canvasRef.current.height = _UIStore.default.instance.windowHeight;
      }
    };

    const onAction = payload => {
      const actionPrefix = 'effects.';

      if (payload.action.indexOf(actionPrefix) === 0) {
        const effect = payload.action.substr(actionPrefix.length);
        lazyLoadEffectModule(effect).then(module => module === null || module === void 0 ? void 0 : module.start(canvasRef.current));
      }
    };

    const dispatcherRef = _dispatcher.default.register(onAction);

    const canvas = canvasRef.current;
    canvas.height = _UIStore.default.instance.windowHeight;

    _UIStore.default.instance.on(_UIStore.UI_EVENTS.Resize, resize);

    return () => {
      _dispatcher.default.unregister(dispatcherRef);

      _UIStore.default.instance.off(_UIStore.UI_EVENTS.Resize, resize); // eslint-disable-next-line react-hooks/exhaustive-deps


      const currentEffects = effectsRef.current; // this is not a react node ref, warning can be safely ignored

      for (const effect in currentEffects) {
        const effectModule = currentEffects[effect];

        if (effectModule && effectModule.isRunning) {
          effectModule.stop();
        }
      }
    };
  }, []);
  return /*#__PURE__*/_react.default.createElement("canvas", {
    ref: canvasRef,
    width: roomWidth,
    style: {
      display: 'block',
      zIndex: 999999,
      pointerEvents: 'none',
      position: 'fixed',
      top: 0,
      right: 0
    }
  });
};

var _default = EffectsOverlay;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2VsZW1lbnRzL0VmZmVjdHNPdmVybGF5LnRzeCJdLCJuYW1lcyI6WyJFZmZlY3RzT3ZlcmxheSIsInJvb21XaWR0aCIsImNhbnZhc1JlZiIsImVmZmVjdHNSZWYiLCJNYXAiLCJsYXp5TG9hZEVmZmVjdE1vZHVsZSIsIm5hbWUiLCJlZmZlY3QiLCJjdXJyZW50Iiwib3B0aW9ucyIsIkNIQVRfRUZGRUNUUyIsImZpbmQiLCJlIiwiY29tbWFuZCIsImRlZmF1bHQiLCJFZmZlY3QiLCJlcnIiLCJsb2dnZXIiLCJ3YXJuIiwicmVzaXplIiwiaGVpZ2h0IiwiVUlTdG9yZSIsImluc3RhbmNlIiwid2luZG93SGVpZ2h0Iiwib25BY3Rpb24iLCJwYXlsb2FkIiwiYWN0aW9uUHJlZml4IiwiYWN0aW9uIiwiaW5kZXhPZiIsInN1YnN0ciIsImxlbmd0aCIsInRoZW4iLCJtb2R1bGUiLCJzdGFydCIsImRpc3BhdGNoZXJSZWYiLCJkaXMiLCJyZWdpc3RlciIsImNhbnZhcyIsIm9uIiwiVUlfRVZFTlRTIiwiUmVzaXplIiwidW5yZWdpc3RlciIsIm9mZiIsImN1cnJlbnRFZmZlY3RzIiwiZWZmZWN0TW9kdWxlIiwiaXNSdW5uaW5nIiwic3RvcCIsImRpc3BsYXkiLCJ6SW5kZXgiLCJwb2ludGVyRXZlbnRzIiwicG9zaXRpb24iLCJ0b3AiLCJyaWdodCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBZ0JBOztBQUNBOztBQUVBOztBQUNBOztBQUVBOzs7Ozs7QUFNQSxNQUFNQSxjQUF5QyxHQUFHLENBQUM7QUFBRUMsRUFBQUE7QUFBRixDQUFELEtBQW1CO0FBQ2pFLFFBQU1DLFNBQVMsR0FBRyxtQkFBMEIsSUFBMUIsQ0FBbEI7QUFDQSxRQUFNQyxVQUFVLEdBQUcsbUJBQW1DLElBQUlDLEdBQUosRUFBbkMsQ0FBbkI7O0FBRUEsUUFBTUMsb0JBQW9CLEdBQUcsTUFBT0MsSUFBUCxJQUFnRDtBQUN6RSxRQUFJLENB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QUFFNUMsU0FEVDtBQUVJLElBQUEsS0FBSyxFQUFFRCxTQUZYO0FBR0ksSUFBQSxLQUFLLEVBQUU7QUFDSDhDLE1BQUFBLE9BQU8sRUFBRSxPQUROO0FBRUhDLE1BQUFBLE1BQU0sRUFBRSxNQUZMO0FBR0hDLE1BQUFBLGFBQWEsRUFBRSxNQUhaO0FBSUhDLE1BQUFBLFFBQVEsRUFBRSxPQUpQO0FBS0hDLE1BQUFBLEdBQUcsRUFBRSxDQUxGO0FBTUhDLE1BQUFBLEtBQUssRUFBRTtBQU5KO0FBSFgsSUFESjtBQWNILENBbEVEOztlQW9FZXBELGMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuIENvcHlyaWdodCAyMDIwIE51cmppbiBKYWZhclxuIENvcHlyaWdodCAyMDIwIE5vcmRlY2sgSVQgKyBDb25zdWx0aW5nIEdtYkguXG5cbiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCBSZWFjdCwgeyBGdW5jdGlvbkNvbXBvbmVudCwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgZGlzIGZyb20gJy4uLy4uLy4uL2Rpc3BhdGNoZXIvZGlzcGF0Y2hlcic7XG5pbXBvcnQgSUNhbnZhc0VmZmVjdCBmcm9tICcuLi8uLi8uLi9lZmZlY3RzL0lDYW52YXNFZmZlY3QnO1xuaW1wb3J0IHsgQ0hBVF9FRkZFQ1RTIH0gZnJvbSAnLi4vLi4vLi4vZWZmZWN0cyc7XG5pbXBvcnQgVUlTdG9yZSwgeyBVSV9FVkVOVFMgfSBmcm9tIFwiLi4vLi4vLi4vc3RvcmVzL1VJU3RvcmVcIjtcblxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL2xvZ2dlclwiO1xuXG5pbnRlcmZhY2UgSVByb3BzIHtcbiAgICByb29tV2lkdGg6IG51bWJlcjtcbn1cblxuY29uc3QgRWZmZWN0c092ZXJsYXk6IEZ1bmN0aW9uQ29tcG9uZW50PElQcm9wcz4gPSAoeyByb29tV2lkdGggfSkgPT4ge1xuICAgIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudD4obnVsbCk7XG4gICAgY29uc3QgZWZmZWN0c1JlZiA9IHVzZVJlZjxNYXA8c3RyaW5nLCBJQ2FudmFzRWZmZWN0Pj4obmV3IE1hcDxzdHJpbmcsIElDYW52YXNFZmZlY3Q+KCkpO1xuXG4gICAgY29uc3QgbGF6eUxvYWRFZmZlY3RNb2R1bGUgPSBhc3luYyAobmFtZTogc3RyaW5nKTogUHJvbWlzZTxJQ2FudmFzRWZmZWN0PiA9PiB7XG4gICAgICAgIGlmICghbmFtZSkgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBlZmZlY3Q6IElDYW52YXNFZmZlY3QgfCBudWxsID0gZWZmZWN0c1JlZi5jdXJyZW50W25hbWVdIHx8IG51bGw7XG4gICAgICAgIGlmIChlZmZlY3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBDSEFUX0VGRkVDVFMuZmluZCgoZSkgPT4gZS5jb21tYW5kID09PSBuYW1lKT8ub3B0aW9ucztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkZWZhdWx0OiBFZmZlY3QgfSA9IGF3YWl0IGltcG9ydChgLi4vLi4vLi4vZWZmZWN0cy8ke25hbWV9YCk7XG4gICAgICAgICAgICAgICAgZWZmZWN0ID0gbmV3IEVmZmVjdChvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBlZmZlY3RzUmVmLmN1cnJlbnRbbmFtZV0gPSBlZmZlY3Q7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgVW5hYmxlIHRvIGxvYWQgZWZmZWN0IG1vZHVsZSBhdCAnLi4vLi4vLi4vZWZmZWN0cy8ke25hbWV9LmAsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVmZmVjdDtcbiAgICB9O1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzaXplID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbnZhc1JlZi5jdXJyZW50ICYmIGNhbnZhc1JlZi5jdXJyZW50Py5oZWlnaHQgIT09IFVJU3RvcmUuaW5zdGFuY2Uud2luZG93SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgY2FudmFzUmVmLmN1cnJlbnQuaGVpZ2h0ID0gVUlTdG9yZS5pbnN0YW5jZS53aW5kb3dIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uQWN0aW9uID0gKHBheWxvYWQ6IHsgYWN0aW9uOiBzdHJpbmcgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uUHJlZml4ID0gJ2VmZmVjdHMuJztcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmFjdGlvbi5pbmRleE9mKGFjdGlvblByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlZmZlY3QgPSBwYXlsb2FkLmFjdGlvbi5zdWJzdHIoYWN0aW9uUHJlZml4Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGF6eUxvYWRFZmZlY3RNb2R1bGUoZWZmZWN0KS50aGVuKChtb2R1bGUpID0+IG1vZHVsZT8uc3RhcnQoY2FudmFzUmVmLmN1cnJlbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZGlzcGF0Y2hlclJlZiA9IGRpcy5yZWdpc3RlcihvbkFjdGlvbik7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gVUlTdG9yZS5pbnN0YW5jZS53aW5kb3dIZWlnaHQ7XG4gICAgICAgIFVJU3RvcmUuaW5zdGFuY2Uub24oVUlfRVZFTlRTLlJlc2l6ZSwgcmVzaXplKTtcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgZGlzLnVucmVnaXN0ZXIoZGlzcGF0Y2hlclJlZik7XG4gICAgICAgICAgICBVSVN0b3JlLmluc3RhbmNlLm9mZihVSV9FVkVOVFMuUmVzaXplLCByZXNpemUpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEVmZmVjdHMgPSBlZmZlY3RzUmVmLmN1cnJlbnQ7IC8vIHRoaXMgaXMgbm90IGEgcmVhY3Qgbm9kZSByZWYsIHdhcm5pbmcgY2FuIGJlIHNhZmVseSBpZ25vcmVkXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVmZmVjdCBpbiBjdXJyZW50RWZmZWN0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVmZmVjdE1vZHVsZTogSUNhbnZhc0VmZmVjdCA9IGN1cnJlbnRFZmZlY3RzW2VmZmVjdF07XG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdE1vZHVsZSAmJiBlZmZlY3RNb2R1bGUuaXNSdW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdE1vZHVsZS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxjYW52YXNcbiAgICAgICAgICAgIHJlZj17Y2FudmFzUmVmfVxuICAgICAgICAgICAgd2lkdGg9e3Jvb21XaWR0aH1cbiAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICB6SW5kZXg6IDk5OTk5OSxcbiAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgfX1cbiAgICAgICAgLz5cbiAgICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRWZmZWN0c092ZXJsYXk7XG4iXX0=