"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPersistKey = exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _lodash = require("lodash");

var _dispatcher = _interopRequireDefault(require("../../../dispatcher/dispatcher"));

var _MatrixClientContext = _interopRequireDefault(require("../../../contexts/MatrixClientContext"));

var _MatrixClientPeg = require("../../../MatrixClientPeg");

var _utils = require("matrix-js-sdk/src/utils");

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _dec, _class;

const getPersistKey = appId => 'widget_' + appId; // Shamelessly ripped off Modal.js.  There's probably a better way
// of doing reusable widgets like dialog boxes & menus where we go and
// pass in a custom control as the actual body.


exports.getPersistKey = getPersistKey;

function getContainer(containerId) {
  return document.getElementById(containerId);
}

function getOrCreateContainer(containerId) {
  let container = getContainer(containerId);

  if (!container) {
    container = document.createElement("div");
    container.id = containerId;
    document.body.appendChild(container);
  }

  return container;
}

let PersistedElement = (
/**
 * Class of component that renders its children in a separate ReactDOM virtual tree
 * in a container element appended to document.body.
 *
 * This prevents the children from being unmounted when the parent of PersistedElement
 * unmounts, allowing them to persist.
 *
 * When PE is unmounted, it hides the children using CSS. When mounted or updated, the
 * children are made visible and are positioned into a div that is given the same
 * bounding rect as the parent of PE.
 */
_dec = (0, _replaceableComponent.replaceableComponent)("views.elements.PersistedElement"), _dec(_class = class PersistedElement extends _react.default.Component {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "resizeObserver", void 0);
    (0, _defineProperty2.default)(this, "dispatcherRef", void 0);
    (0, _defineProperty2.default)(this, "childContainer", void 0);
    (0, _defineProperty2.default)(this, "child", void 0);
    (0, _defineProperty2.default)(this, "collectChildContainer", ref => {
      if (this.childContainer) {
        this.resizeObserver.unobserve(this.childContainer);
      }

      this.childContainer = ref;

      if (ref) {
        this.resizeObserver.observe(ref);
      }
    });
    (0, _defineProperty2.default)(this, "collectChild", ref => {
      this.child = ref;
      this.updateChild();
    });
    (0, _defineProperty2.default)(this, "onAction", payload => {
      if (payload.action === 'timeline_resize') {
        this.repositionChild();
      } else if (payload.action === 'logout') {
        PersistedElement.destroyElement(this.props.persistKey);
      }
    });
    (0, _defineProperty2.default)(this, "repositionChild", () => {
      this.updateChildPosition(this.child, this.childContainer);
    });
    (0, _defineProperty2.default)(this, "updateChildPosition", (0, _lodash.throttle)((child, parent) => {
      if (!child || !parent) return;
      const parentRect = parent.getBoundingClientRect();
      Object.assign(child.style, {
        zIndex: (0, _utils.isNullOrUndefined)(this.props.zIndex) ? 9 : this.props.zIndex,
        position: 'absolute',
        top: parentRect.top + 'px',
        left: parentRect.left + 'px',
        width: parentRect.width + 'px',
        height: parentRect.height + 'px'
      });
    }, 100, {
      trailing: true,
      leading: true
    }));
    this.resizeObserver = new ResizeObserver(this.repositionChild); // Annoyingly, a resize observer is insufficient, since we also care
    // about when the element moves on the screen without changing its
    // dimensions. Doesn't look like there's a ResizeObserver equivalent
    // for this, so we bodge it by listening for document resize and
    // the timeline_resize action.

    window.addEventListener('resize', this.repositionChild);
    this.dispatcherRef = _dispatcher.default.register(this.onAction);
  }
  /**
   * Removes the DOM elements created when a PersistedElement with the given
   * persistKey was mounted. The DOM elements will be re-added if another
   * PersistedElement is mounted in the future.
   *
   * @param {string} persistKey Key used to uniquely identify this PersistedElement
   */


  static destroyElement(persistKey) {
    const container = getContainer('mx_persistedElement_' + persistKey);

    if (container) {
      container.remove();
    }
  }

  static isMounted(persistKey) {
    return Boolean(getContainer('mx_persistedElement_' + persistKey));
  }

  componentDidMount() {
    this.updateChild();
    this.renderApp();
  }

  componentDidUpdate() {
    this.updateChild();
    this.renderApp();
  }

  componentWillUnmount() {
    this.updateChildVisibility(this.child, false);
    this.resizeObserver.disconnect();
    window.removeEventListener('resize', this.repositionChild);

    _dispatcher.default.unregister(this.dispatcherRef);
  }

  updateChild() {
    this.updateChildPosition(this.child, this.childContainer);
    this.updateChildVisibility(this.child, true);
  }

  renderApp() {
    const content = /*#__PURE__*/_react.default.createElement(_MatrixClientContext.default.Provider, {
      value: _MatrixClientPeg.MatrixClientPeg.get()
    }, /*#__PURE__*/_react.default.createElement("div", {
      ref: this.collectChild,
      style: this.props.style
    }, this.props.children));

    _reactDom.default.render(content, getOrCreateContainer('mx_persistedElement_' + this.props.persistKey));
  }

  updateChildVisibility(child, visible) {
    if (!child) return;
    child.style.display = visible ? 'block' : 'none';
  }

  render() {
    return /*#__PURE__*/_react.default.createElement("div", {
      ref: this.collectChildContainer
    });
  }

}) || _class);
exports.default = PersistedElement;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2VsZW1lbnRzL1BlcnNpc3RlZEVsZW1lbnQudHN4Il0sIm5hbWVzIjpbImdldFBlcnNpc3RLZXkiLCJhcHBJZCIsImdldENvbnRhaW5lciIsImNvbnRhaW5lcklkIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsImdldE9yQ3JlYXRlQ29udGFpbmVyIiwiY29udGFpbmVyIiwiY3JlYXRlRWxlbWVudCIsImlkIiwiYm9keSIsImFwcGVuZENoaWxkIiwiUGVyc2lzdGVkRWxlbWVudCIsIlJlYWN0IiwiQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJwcm9wcyIsInJlZiIsImNoaWxkQ29udGFpbmVyIiwicmVzaXplT2JzZXJ2ZXIiLCJ1bm9ic2VydmUiLCJvYnNlcnZlIiwiY2hpbGQiLCJ1cGRhdGVDaGlsZCIsInBheWxvYWQiLCJhY3Rpb24iLCJyZXBvc2l0aW9uQ2hpbGQiLCJkZXN0cm95RWxlbWVudCIsInBlcnNpc3RLZXkiLCJ1cGRhdGVDaGlsZFBvc2l0aW9uIiwicGFyZW50IiwicGFyZW50UmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIk9iamVjdCIsImFzc2lnbiIsInN0eWxlIiwiekluZGV4IiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0Iiwid2lkdGgiLCJoZWlnaHQiLCJ0cmFpbGluZyIsImxlYWRpbmciLCJSZXNpemVPYnNlcnZlciIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJkaXNwYXRjaGVyUmVmIiwiZGlzIiwicmVnaXN0ZXIiLCJvbkFjdGlvbiIsInJlbW92ZSIsImlzTW91bnRlZCIsIkJvb2xlYW4iLCJjb21wb25lbnREaWRNb3VudCIsInJlbmRlckFwcCIsImNvbXBvbmVudERpZFVwZGF0ZSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwidXBkYXRlQ2hpbGRWaXNpYmlsaXR5IiwiZGlzY29ubmVjdCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1bnJlZ2lzdGVyIiwiY29udGVudCIsIk1hdHJpeENsaWVudFBlZyIsImdldCIsImNvbGxlY3RDaGlsZCIsImNoaWxkcmVuIiwiUmVhY3RET00iLCJyZW5kZXIiLCJ2aXNpYmxlIiwiZGlzcGxheSIsImNvbGxlY3RDaGlsZENvbnRhaW5lciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFnQkE7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFHTyxNQUFNQSxhQUFhLEdBQUlDLEtBQUQsSUFBbUIsWUFBWUEsS0FBckQsQyxDQUVQO0FBQ0E7QUFDQTs7Ozs7QUFFQSxTQUFTQyxZQUFULENBQXNCQyxXQUF0QixFQUEyRDtBQUN2RCxTQUFPQyxRQUFRLENBQUNDLGNBQVQsQ0FBd0JGLFdBQXhCLENBQVA7QUFDSDs7QUFFRCxTQUFTRyxvQkFBVCxDQUE4QkgsV0FBOUIsRUFBbUU7QUFDL0QsTUFBSUksU0FBUyxHQUFHTCxZQUFZLENBQUNDLFdBQUQsQ0FBNUI7O0FBRUEsTUFBSSxDQUFDSSxTQUFMLEVBQWdCO0FBQ1pBLElBQUFBLFNBQVMsR0FBR0gsUUFBUSxDQUFDSSxhQUFULENBQXVCLEtBQXZCLENBQVo7QUFDQUQsSUFBQUEsU0FBUyxDQUFDRSxFQUFWLEdBQWVOLFdBQWY7QUFDQUMsSUFBQUEsUUFBUSxDQUFDTSxJQUFULENBQWNDLFdBQWQsQ0FBMEJKLFNBQTFCO0FBQ0g7O0FBRUQsU0FBT0EsU0FBUDtBQUNIOztJQTBCb0JLLGdCO0FBWnJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7T0FDQyxnREFBcUIsaUNBQXJCLEMsZ0JBQUQsTUFDcUJBLGdCQURyQixTQUM4Q0MsZUFBTUMsU0FEcEQsQ0FDc0U7QUFNbEVDLEVBQUFBLFdBQVcsQ0FBQ0MsS0FBRCxFQUFnQjtBQUN2QixVQUFNQSxLQUFOO0FBRHVCO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUVBK0JNQyxHQUFELElBQStCO0FBQzNELFVBQUksS0FBS0MsY0FBVCxFQUF5QjtBQUNy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O0FBQWYsTUFBUDtBQUNIOztBQXJIaUUsQyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxOCBOZXcgVmVjdG9yIEx0ZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyB0aHJvdHRsZSB9IGZyb20gXCJsb2Rhc2hcIjtcblxuaW1wb3J0IGRpcyBmcm9tICcuLi8uLi8uLi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXInO1xuaW1wb3J0IE1hdHJpeENsaWVudENvbnRleHQgZnJvbSBcIi4uLy4uLy4uL2NvbnRleHRzL01hdHJpeENsaWVudENvbnRleHRcIjtcbmltcG9ydCB7IE1hdHJpeENsaWVudFBlZyB9IGZyb20gXCIuLi8uLi8uLi9NYXRyaXhDbGllbnRQZWdcIjtcbmltcG9ydCB7IGlzTnVsbE9yVW5kZWZpbmVkIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL3V0aWxzXCI7XG5pbXBvcnQgeyByZXBsYWNlYWJsZUNvbXBvbmVudCB9IGZyb20gXCIuLi8uLi8uLi91dGlscy9yZXBsYWNlYWJsZUNvbXBvbmVudFwiO1xuaW1wb3J0IHsgQWN0aW9uUGF5bG9hZCB9IGZyb20gXCIuLi8uLi8uLi9kaXNwYXRjaGVyL3BheWxvYWRzXCI7XG5cbmV4cG9ydCBjb25zdCBnZXRQZXJzaXN0S2V5ID0gKGFwcElkOiBzdHJpbmcpID0+ICd3aWRnZXRfJyArIGFwcElkO1xuXG4vLyBTaGFtZWxlc3NseSByaXBwZWQgb2ZmIE1vZGFsLmpzLiAgVGhlcmUncyBwcm9iYWJseSBhIGJldHRlciB3YXlcbi8vIG9mIGRvaW5nIHJldXNhYmxlIHdpZGdldHMgbGlrZSBkaWFsb2cgYm94ZXMgJiBtZW51cyB3aGVyZSB3ZSBnbyBhbmRcbi8vIHBhc3MgaW4gYSBjdXN0b20gY29udHJvbCBhcyB0aGUgYWN0dWFsIGJvZHkuXG5cbmZ1bmN0aW9uIGdldENvbnRhaW5lcihjb250YWluZXJJZDogc3RyaW5nKTogSFRNTERpdkVsZW1lbnQge1xuICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb250YWluZXJJZCkgYXMgSFRNTERpdkVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGdldE9yQ3JlYXRlQ29udGFpbmVyKGNvbnRhaW5lcklkOiBzdHJpbmcpOiBIVE1MRGl2RWxlbWVudCB7XG4gICAgbGV0IGNvbnRhaW5lciA9IGdldENvbnRhaW5lcihjb250YWluZXJJZCk7XG5cbiAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBjb250YWluZXIuaWQgPSBjb250YWluZXJJZDtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBjb250YWluZXI7XG59XG5cbmludGVyZmFjZSBJUHJvcHMge1xuICAgIC8vIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIFBlcnNpc3RlZEVsZW1lbnQgaW5zdGFuY2VcbiAgICAvLyBBbnkgUGVyc2lzdGVkRWxlbWVudHMgd2l0aCB0aGUgc2FtZSBwZXJzaXN0S2V5IHdpbGwgdXNlXG4gICAgLy8gdGhlIHNhbWUgRE9NIGNvbnRhaW5lci5cbiAgICBwZXJzaXN0S2V5OiBzdHJpbmc7XG5cbiAgICAvLyB6LWluZGV4IGZvciB0aGUgZWxlbWVudC4gRGVmYXVsdHMgdG8gOS5cbiAgICB6SW5kZXg/OiBudW1iZXI7XG5cbiAgICBzdHlsZT86IFJlYWN0LlN0eWxlSFRNTEF0dHJpYnV0ZXM8SFRNTERpdkVsZW1lbnQ+O1xufVxuXG4vKipcbiAqIENsYXNzIG9mIGNvbXBvbmVudCB0aGF0IHJlbmRlcnMgaXRzIGNoaWxkcmVuIGluIGEgc2VwYXJhdGUgUmVhY3RET00gdmlydHVhbCB0cmVlXG4gKiBpbiBhIGNvbnRhaW5lciBlbGVtZW50IGFwcGVuZGVkIHRvIGRvY3VtZW50LmJvZHkuXG4gKlxuICogVGhpcyBwcmV2ZW50cyB0aGUgY2hpbGRyZW4gZnJvbSBiZWluZyB1bm1vdW50ZWQgd2hlbiB0aGUgcGFyZW50IG9mIFBlcnNpc3RlZEVsZW1lbnRcbiAqIHVubW91bnRzLCBhbGxvd2luZyB0aGVtIHRvIHBlcnNpc3QuXG4gKlxuICogV2hlbiBQRSBpcyB1bm1vdW50ZWQsIGl0IGhpZGVzIHRoZSBjaGlsZHJlbiB1c2luZyBDU1MuIFdoZW4gbW91bnRlZCBvciB1cGRhdGVkLCB0aGVcbiAqIGNoaWxkcmVuIGFyZSBtYWRlIHZpc2libGUgYW5kIGFyZSBwb3NpdGlvbmVkIGludG8gYSBkaXYgdGhhdCBpcyBnaXZlbiB0aGUgc2FtZVxuICogYm91bmRpbmcgcmVjdCBhcyB0aGUgcGFyZW50IG9mIFBFLlxuICovXG5AcmVwbGFjZWFibGVDb21wb25lbnQoXCJ2aWV3cy5lbGVtZW50cy5QZXJzaXN0ZWRFbGVtZW50XCIpXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQZXJzaXN0ZWRFbGVtZW50IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PElQcm9wcz4ge1xuICAgIHByaXZhdGUgcmVzaXplT2JzZXJ2ZXI6IFJlc2l6ZU9ic2VydmVyO1xuICAgIHByaXZhdGUgZGlzcGF0Y2hlclJlZjogc3RyaW5nO1xuICAgIHByaXZhdGUgY2hpbGRDb250YWluZXI6IEhUTUxEaXZFbGVtZW50O1xuICAgIHByaXZhdGUgY2hpbGQ6IEhUTUxEaXZFbGVtZW50O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHM6IElQcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcih0aGlzLnJlcG9zaXRpb25DaGlsZCk7XG4gICAgICAgIC8vIEFubm95aW5nbHksIGEgcmVzaXplIG9ic2VydmVyIGlzIGluc3VmZmljaWVudCwgc2luY2Ugd2UgYWxzbyBjYXJlXG4gICAgICAgIC8vIGFib3V0IHdoZW4gdGhlIGVsZW1lbnQgbW92ZXMgb24gdGhlIHNjcmVlbiB3aXRob3V0IGNoYW5naW5nIGl0c1xuICAgICAgICAvLyBkaW1lbnNpb25zLiBEb2Vzbid0IGxvb2sgbGlrZSB0aGVyZSdzIGEgUmVzaXplT2JzZXJ2ZXIgZXF1aXZhbGVudFxuICAgICAgICAvLyBmb3IgdGhpcywgc28gd2UgYm9kZ2UgaXQgYnkgbGlzdGVuaW5nIGZvciBkb2N1bWVudCByZXNpemUgYW5kXG4gICAgICAgIC8vIHRoZSB0aW1lbGluZV9yZXNpemUgYWN0aW9uLlxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZXBvc2l0aW9uQ2hpbGQpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoZXJSZWYgPSBkaXMucmVnaXN0ZXIodGhpcy5vbkFjdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgRE9NIGVsZW1lbnRzIGNyZWF0ZWQgd2hlbiBhIFBlcnNpc3RlZEVsZW1lbnQgd2l0aCB0aGUgZ2l2ZW5cbiAgICAgKiBwZXJzaXN0S2V5IHdhcyBtb3VudGVkLiBUaGUgRE9NIGVsZW1lbnRzIHdpbGwgYmUgcmUtYWRkZWQgaWYgYW5vdGhlclxuICAgICAqIFBlcnNpc3RlZEVsZW1lbnQgaXMgbW91bnRlZCBpbiB0aGUgZnV0dXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBlcnNpc3RLZXkgS2V5IHVzZWQgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBQZXJzaXN0ZWRFbGVtZW50XG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBkZXN0cm95RWxlbWVudChwZXJzaXN0S2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gZ2V0Q29udGFpbmVyKCdteF9wZXJzaXN0ZWRFbGVtZW50XycgKyBwZXJzaXN0S2V5KTtcbiAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGlzTW91bnRlZChwZXJzaXN0S2V5KSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKGdldENvbnRhaW5lcignbXhfcGVyc2lzdGVkRWxlbWVudF8nICsgcGVyc2lzdEtleSkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgY29sbGVjdENoaWxkQ29udGFpbmVyID0gKHJlZjogSFRNTERpdkVsZW1lbnQpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKHRoaXMuY2hpbGRDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRDb250YWluZXIgPSByZWY7XG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShyZWYpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByaXZhdGUgY29sbGVjdENoaWxkID0gKHJlZjogSFRNTERpdkVsZW1lbnQpOiB2b2lkID0+IHtcbiAgICAgICAgdGhpcy5jaGlsZCA9IHJlZjtcbiAgICAgICAgdGhpcy51cGRhdGVDaGlsZCgpO1xuICAgIH07XG5cbiAgICBwdWJsaWMgY29tcG9uZW50RGlkTW91bnQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMudXBkYXRlQ2hpbGQoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJBcHAoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY29tcG9uZW50RGlkVXBkYXRlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnVwZGF0ZUNoaWxkKCk7XG4gICAgICAgIHRoaXMucmVuZGVyQXBwKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGNvbXBvbmVudFdpbGxVbm1vdW50KCk6IHZvaWQge1xuICAgICAgICB0aGlzLnVwZGF0ZUNoaWxkVmlzaWJpbGl0eSh0aGlzLmNoaWxkLCBmYWxzZSk7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZXBvc2l0aW9uQ2hpbGQpO1xuICAgICAgICBkaXMudW5yZWdpc3Rlcih0aGlzLmRpc3BhdGNoZXJSZWYpO1xuICAgIH1cblxuICAgIHByaXZhdGUgb25BY3Rpb24gPSAocGF5bG9hZDogQWN0aW9uUGF5bG9hZCk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAocGF5bG9hZC5hY3Rpb24gPT09ICd0aW1lbGluZV9yZXNpemUnKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9zaXRpb25DaGlsZCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHBheWxvYWQuYWN0aW9uID09PSAnbG9nb3V0Jykge1xuICAgICAgICAgICAgUGVyc2lzdGVkRWxlbWVudC5kZXN0cm95RWxlbWVudCh0aGlzLnByb3BzLnBlcnNpc3RLZXkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByaXZhdGUgcmVwb3NpdGlvbkNoaWxkID0gKCk6IHZvaWQgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZUNoaWxkUG9zaXRpb24odGhpcy5jaGlsZCwgdGhpcy5jaGlsZENvbnRhaW5lcik7XG4gICAgfTtcblxuICAgIHByaXZhdGUgdXBkYXRlQ2hpbGQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMudXBkYXRlQ2hpbGRQb3NpdGlvbih0aGlzLmNoaWxkLCB0aGlzLmNoaWxkQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy51cGRhdGVDaGlsZFZpc2liaWxpdHkodGhpcy5jaGlsZCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZW5kZXJBcHAoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSA8TWF0cml4Q2xpZW50Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17TWF0cml4Q2xpZW50UGVnLmdldCgpfT5cbiAgICAgICAgICAgIDxkaXYgcmVmPXt0aGlzLmNvbGxlY3RDaGlsZH0gc3R5bGU9e3RoaXMucHJvcHMuc3R5bGV9PlxuICAgICAgICAgICAgICAgIHsgdGhpcy5wcm9wcy5jaGlsZHJlbiB9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9NYXRyaXhDbGllbnRDb250ZXh0LlByb3ZpZGVyPjtcblxuICAgICAgICBSZWFjdERPTS5yZW5kZXIoY29udGVudCwgZ2V0T3JDcmVhdGVDb250YWluZXIoJ214X3BlcnNpc3RlZEVsZW1lbnRfJyt0aGlzLnByb3BzLnBlcnNpc3RLZXkpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZUNoaWxkVmlzaWJpbGl0eShjaGlsZDogSFRNTERpdkVsZW1lbnQsIHZpc2libGU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgaWYgKCFjaGlsZCkgcmV0dXJuO1xuICAgICAgICBjaGlsZC5zdHlsZS5kaXNwbGF5ID0gdmlzaWJsZSA/ICdibG9jaycgOiAnbm9uZSc7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVDaGlsZFBvc2l0aW9uID0gdGhyb3R0bGUoKGNoaWxkOiBIVE1MRGl2RWxlbWVudCwgcGFyZW50OiBIVE1MRGl2RWxlbWVudCk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAoIWNoaWxkIHx8ICFwYXJlbnQpIHJldHVybjtcblxuICAgICAgICBjb25zdCBwYXJlbnRSZWN0ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGNoaWxkLnN0eWxlLCB7XG4gICAgICAgICAgICB6SW5kZXg6IGlzTnVsbE9yVW5kZWZpbmVkKHRoaXMucHJvcHMuekluZGV4KSA/IDkgOiB0aGlzLnByb3BzLnpJbmRleCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgdG9wOiBwYXJlbnRSZWN0LnRvcCArICdweCcsXG4gICAgICAgICAgICBsZWZ0OiBwYXJlbnRSZWN0LmxlZnQgKyAncHgnLFxuICAgICAgICAgICAgd2lkdGg6IHBhcmVudFJlY3Qud2lkdGggKyAncHgnLFxuICAgICAgICAgICAgaGVpZ2h0OiBwYXJlbnRSZWN0LmhlaWdodCArICdweCcsXG4gICAgICAgIH0pO1xuICAgIH0sIDEwMCwgeyB0cmFpbGluZzogdHJ1ZSwgbGVhZGluZzogdHJ1ZSB9KTtcblxuICAgIHB1YmxpYyByZW5kZXIoKTogSlNYLkVsZW1lbnQge1xuICAgICAgICByZXR1cm4gPGRpdiByZWY9e3RoaXMuY29sbGVjdENoaWxkQ29udGFpbmVyfSAvPjtcbiAgICB9XG59XG5cbiJdfQ==