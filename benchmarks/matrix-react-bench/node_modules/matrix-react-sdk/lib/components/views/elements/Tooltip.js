"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Alignment = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _classnames = _interopRequireDefault(require("classnames"));

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _UIStore = _interopRequireDefault(require("../../../stores/UIStore"));

var _dec, _class, _class2, _temp;

const MIN_TOOLTIP_HEIGHT = 25;
let Alignment;
exports.Alignment = Alignment;

(function (Alignment) {
  Alignment[Alignment["Natural"] = 0] = "Natural";
  Alignment[Alignment["Left"] = 1] = "Left";
  Alignment[Alignment["Right"] = 2] = "Right";
  Alignment[Alignment["Top"] = 3] = "Top";
  Alignment[Alignment["Bottom"] = 4] = "Bottom";
})(Alignment || (exports.Alignment = Alignment = {}));

let Tooltip = (_dec = (0, _replaceableComponent.replaceableComponent)("views.elements.Tooltip"), _dec(_class = (_temp = _class2 = class Tooltip extends _react.default.Component {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "tooltipContainer", void 0);
    (0, _defineProperty2.default)(this, "tooltip", void 0);
    (0, _defineProperty2.default)(this, "parent", void 0);
    (0, _defineProperty2.default)(this, "renderTooltip", () => {
      // Add the parent's position to the tooltips, so it's correctly
      // positioned, also taking into account any window zoom
      // NOTE: The additional 6 pixels for the left position, is to take account of the
      // tooltips chevron
      const style = this.updatePosition({}); // Hide the entire container when not visible. This prevents flashing of the tooltip
      // if it is not meant to be visible on first mount.

      style.display = this.props.visible ? "block" : "none";
      const tooltipClasses = (0, _classnames.default)("mx_Tooltip", this.props.tooltipClassName, {
        "mx_Tooltip_visible": this.props.visible,
        "mx_Tooltip_invisible": !this.props.visible
      });

      const tooltip = /*#__PURE__*/_react.default.createElement("div", {
        className: tooltipClasses,
        style: style
      }, /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_Tooltip_chevron"
      }), this.props.label); // Render the tooltip manually, as we wish it not to be rendered within the parent


      this.tooltip = _reactDom.default.render(tooltip, this.tooltipContainer);
    });
  }

  // Create a wrapper for the tooltip outside the parent and attach it to the body element
  componentDidMount() {
    this.tooltipContainer = document.createElement("div");
    this.tooltipContainer.className = "mx_Tooltip_wrapper";
    document.body.appendChild(this.tooltipContainer);
    window.addEventListener('scroll', this.renderTooltip, {
      passive: true,
      capture: true
    });
    this.parent = _reactDom.default.findDOMNode(this).parentNode;
    this.renderTooltip();
  }

  componentDidUpdate() {
    this.renderTooltip();
  } // Remove the wrapper element, as the tooltip has finished using it


  componentWillUnmount() {
    _reactDom.default.unmountComponentAtNode(this.tooltipContainer);

    document.body.removeChild(this.tooltipContainer);
    window.removeEventListener('scroll', this.renderTooltip, {
      capture: true
    });
  }

  updatePosition(style) {
    const parentBox = this.parent.getBoundingClientRect();
    let offset = 0;

    if (parentBox.height > MIN_TOOLTIP_HEIGHT) {
      offset = Math.floor((parentBox.height - MIN_TOOLTIP_HEIGHT) / 2);
    } else {
      // The tooltip is larger than the parent height: figure out what offset
      // we need so that we're still centered.
      offset = Math.floor(parentBox.height - MIN_TOOLTIP_HEIGHT);
    }

    const width = _UIStore.default.instance.windowWidth;
    const baseTop = parentBox.top - 2 + this.props.yOffset + window.pageYOffset;
    const top = baseTop + offset;
    const right = width - parentBox.right - window.pageXOffset - 16;
    const left = parentBox.right + window.pageXOffset + 6;
    const horizontalCenter = parentBox.right - window.pageXOffset - parentBox.width / 2;

    switch (this.props.alignment) {
      case Alignment.Natural:
        if (parentBox.right > width / 2) {
          style.right = right;
          style.top = top;
          break;
        }

      // fall through to Right

      case Alignment.Right:
        style.left = left;
        style.top = top;
        break;

      case Alignment.Left:
        style.right = right;
        style.top = top;
        break;

      case Alignment.Top:
        style.top = baseTop - 16;
        style.left = horizontalCenter;
        break;

      case Alignment.Bottom:
        style.top = baseTop + parentBox.height;
        style.left = horizontalCenter;
        break;
    }

    return style;
  }

  render() {
    // Render a placeholder
    return /*#__PURE__*/_react.default.createElement("div", {
      className: this.props.className
    });
  }

}, (0, _defineProperty2.default)(_class2, "Alignment", Alignment), (0, _defineProperty2.default)(_class2, "defaultProps", {
  visible: true,
  yOffset: 0,
  alignment: Alignment.Natural
}), _temp)) || _class);
exports.default = Tooltip;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2VsZW1lbnRzL1Rvb2x0aXAudHN4Il0sIm5hbWVzIjpbIk1JTl9UT09MVElQX0hFSUdIVCIsIkFsaWdubWVudCIsIlRvb2x0aXAiLCJSZWFjdCIsIkNvbXBvbmVudCIsInN0eWxlIiwidXBkYXRlUG9zaXRpb24iLCJkaXNwbGF5IiwicHJvcHMiLCJ2aXNpYmxlIiwidG9vbHRpcENsYXNzZXMiLCJ0b29sdGlwQ2xhc3NOYW1lIiwidG9vbHRpcCIsImxhYmVsIiwiUmVhY3RET00iLCJyZW5kZXIiLCJ0b29sdGlwQ29udGFpbmVyIiwiY29tcG9uZW50RGlkTW91bnQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVuZGVyVG9vbHRpcCIsInBhc3NpdmUiLCJjYXB0dXJlIiwicGFyZW50IiwiZmluZERPTU5vZGUiLCJwYXJlbnROb2RlIiwiY29tcG9uZW50RGlkVXBkYXRlIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJ1bm1vdW50Q29tcG9uZW50QXROb2RlIiwicmVtb3ZlQ2hpbGQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicGFyZW50Qm94IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwib2Zmc2V0IiwiaGVpZ2h0IiwiTWF0aCIsImZsb29yIiwid2lkdGgiLCJVSVN0b3JlIiwiaW5zdGFuY2UiLCJ3aW5kb3dXaWR0aCIsImJhc2VUb3AiLCJ0b3AiLCJ5T2Zmc2V0IiwicGFnZVlPZmZzZXQiLCJyaWdodCIsInBhZ2VYT2Zmc2V0IiwibGVmdCIsImhvcml6b250YWxDZW50ZXIiLCJhbGlnbm1lbnQiLCJOYXR1cmFsIiwiUmlnaHQiLCJMZWZ0IiwiVG9wIiwiQm90dG9tIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQW1CQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUVBLE1B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SyxDQUFDMEMsR0FBTixHQUFZQSxHQUFaO0FBQ0E7O0FBQ0osV0FBSzlDLFNBQVMsQ0FBQ3dELElBQWY7QUFDSXBELFFBQUFBLEtBQUssQ0FBQzZDLEtBQU4sR0FBY0EsS0FBZDtBQUNBN0MsUUFBQUEsS0FBSyxDQUFDMEMsR0FBTixHQUFZQSxHQUFaO0FBQ0E7O0FBQ0osV0FBSzlDLFNBQVMsQ0FBQ3lELEdBQWY7QUFDSXJELFFBQUFBLEtBQUssQ0FBQzBDLEdBQU4sR0FBWUQsT0FBTyxHQUFHLEVBQXRCO0FBQ0F6QyxRQUFBQSxLQUFLLENBQUMrQyxJQUFOLEdBQWFDLGdCQUFiO0FBQ0E7O0FBQ0osV0FBS3BELFNBQVMsQ0FBQzBELE1BQWY7QUFDSXRELFFBQUFBLEtBQUssQ0FBQzBDLEdBQU4sR0FBWUQsT0FBTyxHQUFHVixTQUFTLENBQUNHLE1BQWhDO0FBQ0FsQyxRQUFBQSxLQUFLLENBQUMrQyxJQUFOLEdBQWFDLGdCQUFiO0FBQ0E7QUF2QlI7O0FBMEJBLFdBQU9oRCxLQUFQO0FBQ0g7O0FBNEJNVSxFQUFBQSxNQUFNLEdBQUc7QUFDWjtBQUNBLHdCQUNJO0FBQUssTUFBQSxTQUFTLEVBQUUsS0FBS1AsS0FBTCxDQUFXWTtBQUEzQixNQURKO0FBR0g7O0FBdkh3RCxDLHNEQU90Qm5CLFMsMERBRUc7QUFDbENRLEVBQUFBLE9BQU8sRUFBRSxJQUR5QjtBQUVsQ3VDLEVBQUFBLE9BQU8sRUFBRSxDQUZ5QjtBQUdsQ00sRUFBQUEsU0FBUyxFQUFFckQsU0FBUyxDQUFDc0Q7QUFIYSxDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE1LCAyMDE2IE9wZW5NYXJrZXQgTHRkXG5Db3B5cmlnaHQgMjAxOSBOZXcgVmVjdG9yIEx0ZFxuQ29weXJpZ2h0IDIwMTkgTWljaGFlbCBUZWxhdHluc2tpIDw3dDNjaGd1eUBnbWFpbC5jb20+XG5Db3B5cmlnaHQgMjAxOSwgMjAyMCBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIENTU1Byb3BlcnRpZXMgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHsgcmVwbGFjZWFibGVDb21wb25lbnQgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvcmVwbGFjZWFibGVDb21wb25lbnRcIjtcbmltcG9ydCBVSVN0b3JlIGZyb20gXCIuLi8uLi8uLi9zdG9yZXMvVUlTdG9yZVwiO1xuXG5jb25zdCBNSU5fVE9PTFRJUF9IRUlHSFQgPSAyNTtcblxuZXhwb3J0IGVudW0gQWxpZ25tZW50IHtcbiAgICBOYXR1cmFsLCAvLyBQaWNrIGxlZnQgb3IgcmlnaHRcbiAgICBMZWZ0LFxuICAgIFJpZ2h0LFxuICAgIFRvcCwgLy8gQ2VudGVyZWRcbiAgICBCb3R0b20sIC8vIENlbnRlcmVkXG59XG5cbmludGVyZmFjZSBJUHJvcHMge1xuICAgICAgICAvLyBDbGFzcyBhcHBsaWVkIHRvIHRoZSBlbGVtZW50IHVzZWQgdG8gcG9zaXRpb24gdGhlIHRvb2x0aXBcbiAgICAgICAgY2xhc3NOYW1lPzogc3RyaW5nO1xuICAgICAgICAvLyBDbGFzcyBhcHBsaWVkIHRvIHRoZSB0b29sdGlwIGl0c2VsZlxuICAgICAgICB0b29sdGlwQ2xhc3NOYW1lPzogc3RyaW5nO1xuICAgICAgICAvLyBXaGV0aGVyIHRoZSB0b29sdGlwIGlzIHZpc2libGUgb3IgaGlkZGVuLlxuICAgICAgICAvLyBUaGUgaGlkZGVuIHN0YXRlIGFsbG93cyBhbmltYXRpbmcgdGhlIHRvb2x0aXAgYXdheSB2aWEgQ1NTLlxuICAgICAgICAvLyBEZWZhdWx0cyB0byB2aXNpYmxlIGlmIHVuc2V0LlxuICAgICAgICB2aXNpYmxlPzogYm9vbGVhbjtcbiAgICAgICAgLy8gdGhlIHJlYWN0IGVsZW1lbnQgdG8gcHV0IGludG8gdGhlIHRvb2x0aXBcbiAgICAgICAgbGFiZWw6IFJlYWN0LlJlYWN0Tm9kZTtcbiAgICAgICAgYWxpZ25tZW50PzogQWxpZ25tZW50OyAvLyBkZWZhdWx0cyB0byBOYXR1cmFsXG4gICAgICAgIHlPZmZzZXQ/OiBudW1iZXI7XG59XG5cbkByZXBsYWNlYWJsZUNvbXBvbmVudChcInZpZXdzLmVsZW1lbnRzLlRvb2x0aXBcIilcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvb2x0aXAgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8SVByb3BzPiB7XG4gICAgcHJpdmF0ZSB0b29sdGlwQ29udGFpbmVyOiBIVE1MRWxlbWVudDtcbiAgICBwcml2YXRlIHRvb2x0aXA6IHZvaWQgfCBFbGVtZW50IHwgQ29tcG9uZW50PEVsZW1lbnQsIGFueSwgYW55PjtcbiAgICBwcml2YXRlIHBhcmVudDogRWxlbWVudDtcblxuICAgIC8vIFhYWDogVGhpcyBpcyBiZWNhdXNlIHNvbWUgY29tcG9uZW50cyAoRmllbGQpIGFyZSB1bmFibGUgdG8gYGltcG9ydGAgdGhlIFRvb2x0aXAgY2xhc3MsXG4gICAgLy8gc28gd2UgZXhwb3NlIHRoZSBBbGlnbm1lbnQgb3B0aW9ucyBvZmYgb2YgdXMgc3RhdGljYWxseS5cbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEFsaWdubWVudCA9IEFsaWdubWVudDtcblxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgICB5T2Zmc2V0OiAwLFxuICAgICAgICBhbGlnbm1lbnQ6IEFsaWdubWVudC5OYXR1cmFsLFxuICAgIH07XG5cbiAgICAvLyBDcmVhdGUgYSB3cmFwcGVyIGZvciB0aGUgdG9vbHRpcCBvdXRzaWRlIHRoZSBwYXJlbnQgYW5kIGF0dGFjaCBpdCB0byB0aGUgYm9keSBlbGVtZW50XG4gICAgcHVibGljIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLnRvb2x0aXBDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLnRvb2x0aXBDb250YWluZXIuY2xhc3NOYW1lID0gXCJteF9Ub29sdGlwX3dyYXBwZXJcIjtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnRvb2x0aXBDb250YWluZXIpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5yZW5kZXJUb29sdGlwLCB7XG4gICAgICAgICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5wYXJlbnQgPSBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKS5wYXJlbnROb2RlIGFzIEVsZW1lbnQ7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJUb29sdGlwKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJUb29sdGlwKCk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIHRoZSB3cmFwcGVyIGVsZW1lbnQsIGFzIHRoZSB0b29sdGlwIGhhcyBmaW5pc2hlZCB1c2luZyBpdFxuICAgIHB1YmxpYyBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSh0aGlzLnRvb2x0aXBDb250YWluZXIpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMudG9vbHRpcENvbnRhaW5lcik7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLnJlbmRlclRvb2x0aXAsIHtcbiAgICAgICAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlUG9zaXRpb24oc3R5bGU6IENTU1Byb3BlcnRpZXMpIHtcbiAgICAgICAgY29uc3QgcGFyZW50Qm94ID0gdGhpcy5wYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBpZiAocGFyZW50Qm94LmhlaWdodCA+IE1JTl9UT09MVElQX0hFSUdIVCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gTWF0aC5mbG9vcigocGFyZW50Qm94LmhlaWdodCAtIE1JTl9UT09MVElQX0hFSUdIVCkgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZSB0b29sdGlwIGlzIGxhcmdlciB0aGFuIHRoZSBwYXJlbnQgaGVpZ2h0OiBmaWd1cmUgb3V0IHdoYXQgb2Zmc2V0XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHNvIHRoYXQgd2UncmUgc3RpbGwgY2VudGVyZWQuXG4gICAgICAgICAgICBvZmZzZXQgPSBNYXRoLmZsb29yKHBhcmVudEJveC5oZWlnaHQgLSBNSU5fVE9PTFRJUF9IRUlHSFQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdpZHRoID0gVUlTdG9yZS5pbnN0YW5jZS53aW5kb3dXaWR0aDtcbiAgICAgICAgY29uc3QgYmFzZVRvcCA9IChwYXJlbnRCb3gudG9wIC0gMiArIHRoaXMucHJvcHMueU9mZnNldCkgKyB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgIGNvbnN0IHRvcCA9IGJhc2VUb3AgKyBvZmZzZXQ7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gd2lkdGggLSBwYXJlbnRCb3gucmlnaHQgLSB3aW5kb3cucGFnZVhPZmZzZXQgLSAxNjtcbiAgICAgICAgY29uc3QgbGVmdCA9IHBhcmVudEJveC5yaWdodCArIHdpbmRvdy5wYWdlWE9mZnNldCArIDY7XG4gICAgICAgIGNvbnN0IGhvcml6b250YWxDZW50ZXIgPSBwYXJlbnRCb3gucmlnaHQgLSB3aW5kb3cucGFnZVhPZmZzZXQgLSAocGFyZW50Qm94LndpZHRoIC8gMik7XG4gICAgICAgIHN3aXRjaCAodGhpcy5wcm9wcy5hbGlnbm1lbnQpIHtcbiAgICAgICAgICAgIGNhc2UgQWxpZ25tZW50Lk5hdHVyYWw6XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudEJveC5yaWdodCA+IHdpZHRoIC8gMikge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5yaWdodCA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS50b3AgPSB0b3A7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBmYWxsIHRocm91Z2ggdG8gUmlnaHRcbiAgICAgICAgICAgIGNhc2UgQWxpZ25tZW50LlJpZ2h0OlxuICAgICAgICAgICAgICAgIHN0eWxlLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgICAgIHN0eWxlLnRvcCA9IHRvcDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQWxpZ25tZW50LkxlZnQ6XG4gICAgICAgICAgICAgICAgc3R5bGUucmlnaHQgPSByaWdodDtcbiAgICAgICAgICAgICAgICBzdHlsZS50b3AgPSB0b3A7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEFsaWdubWVudC5Ub3A6XG4gICAgICAgICAgICAgICAgc3R5bGUudG9wID0gYmFzZVRvcCAtIDE2O1xuICAgICAgICAgICAgICAgIHN0eWxlLmxlZnQgPSBob3Jpem9udGFsQ2VudGVyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBBbGlnbm1lbnQuQm90dG9tOlxuICAgICAgICAgICAgICAgIHN0eWxlLnRvcCA9IGJhc2VUb3AgKyBwYXJlbnRCb3guaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHN0eWxlLmxlZnQgPSBob3Jpem9udGFsQ2VudGVyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH1cblxuICAgIHByaXZhdGUgcmVuZGVyVG9vbHRpcCA9ICgpID0+IHtcbiAgICAgICAgLy8gQWRkIHRoZSBwYXJlbnQncyBwb3NpdGlvbiB0byB0aGUgdG9vbHRpcHMsIHNvIGl0J3MgY29ycmVjdGx5XG4gICAgICAgIC8vIHBvc2l0aW9uZWQsIGFsc28gdGFraW5nIGludG8gYWNjb3VudCBhbnkgd2luZG93IHpvb21cbiAgICAgICAgLy8gTk9URTogVGhlIGFkZGl0aW9uYWwgNiBwaXhlbHMgZm9yIHRoZSBsZWZ0IHBvc2l0aW9uLCBpcyB0byB0YWtlIGFjY291bnQgb2YgdGhlXG4gICAgICAgIC8vIHRvb2x0aXBzIGNoZXZyb25cbiAgICAgICAgY29uc3Qgc3R5bGUgPSB0aGlzLnVwZGF0ZVBvc2l0aW9uKHt9KTtcbiAgICAgICAgLy8gSGlkZSB0aGUgZW50aXJlIGNvbnRhaW5lciB3aGVuIG5vdCB2aXNpYmxlLiBUaGlzIHByZXZlbnRzIGZsYXNoaW5nIG9mIHRoZSB0b29sdGlwXG4gICAgICAgIC8vIGlmIGl0IGlzIG5vdCBtZWFudCB0byBiZSB2aXNpYmxlIG9uIGZpcnN0IG1vdW50LlxuICAgICAgICBzdHlsZS5kaXNwbGF5ID0gdGhpcy5wcm9wcy52aXNpYmxlID8gXCJibG9ja1wiIDogXCJub25lXCI7XG5cbiAgICAgICAgY29uc3QgdG9vbHRpcENsYXNzZXMgPSBjbGFzc05hbWVzKFwibXhfVG9vbHRpcFwiLCB0aGlzLnByb3BzLnRvb2x0aXBDbGFzc05hbWUsIHtcbiAgICAgICAgICAgIFwibXhfVG9vbHRpcF92aXNpYmxlXCI6IHRoaXMucHJvcHMudmlzaWJsZSxcbiAgICAgICAgICAgIFwibXhfVG9vbHRpcF9pbnZpc2libGVcIjogIXRoaXMucHJvcHMudmlzaWJsZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgdG9vbHRpcCA9IChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXt0b29sdGlwQ2xhc3Nlc30gc3R5bGU9e3N0eWxlfT5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm14X1Rvb2x0aXBfY2hldnJvblwiIC8+XG4gICAgICAgICAgICAgICAgeyB0aGlzLnByb3BzLmxhYmVsIH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFJlbmRlciB0aGUgdG9vbHRpcCBtYW51YWxseSwgYXMgd2Ugd2lzaCBpdCBub3QgdG8gYmUgcmVuZGVyZWQgd2l0aGluIHRoZSBwYXJlbnRcbiAgICAgICAgdGhpcy50b29sdGlwID0gUmVhY3RET00ucmVuZGVyPEVsZW1lbnQ+KHRvb2x0aXAsIHRoaXMudG9vbHRpcENvbnRhaW5lcik7XG4gICAgfTtcblxuICAgIHB1YmxpYyByZW5kZXIoKSB7XG4gICAgICAgIC8vIFJlbmRlciBhIHBsYWNlaG9sZGVyXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17dGhpcy5wcm9wcy5jbGFzc05hbWV9IC8+XG4gICAgICAgICk7XG4gICAgfVxufVxuIl19