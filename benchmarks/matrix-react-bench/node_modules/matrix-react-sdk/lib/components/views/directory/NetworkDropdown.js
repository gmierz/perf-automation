"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ALL_ROOMS = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _react = _interopRequireWildcard(require("react"));

var _MatrixClientPeg = require("../../../MatrixClientPeg");

var _DirectoryUtils = require("../../../utils/DirectoryUtils");

var _ContextMenu = _interopRequireWildcard(require("../../structures/ContextMenu"));

var _languageHandler = require("../../../languageHandler");

var _SdkConfig = _interopRequireDefault(require("../../../SdkConfig"));

var _useSettings = require("../../../hooks/useSettings");

var _Modal = _interopRequireDefault(require("../../../Modal"));

var _SettingsStore = _interopRequireDefault(require("../../../settings/SettingsStore"));

var _Validation = _interopRequireDefault(require("../elements/Validation"));

var _SettingLevel = require("../../../settings/SettingLevel");

var _TextInputDialog = _interopRequireDefault(require("../dialogs/TextInputDialog"));

var _QuestionDialog = _interopRequireDefault(require("../dialogs/QuestionDialog"));

var _UIStore = _interopRequireDefault(require("../../../stores/UIStore"));

var _strings = require("../../../utils/strings");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
Copyright 2019 Michael Telatynski <7t3chguy@gmail.com>
Copyright 2016, 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// XXX: We would ideally use a symbol here but we can't since we save this value to localStorage
const ALL_ROOMS = "ALL_ROOMS";
exports.ALL_ROOMS = ALL_ROOMS;
const SETTING_NAME = "room_directory_servers";

const inPlaceOf = elementRect => ({
  right: _UIStore.default.instance.windowWidth - elementRect.right,
  top: elementRect.top,
  chevronOffset: 0,
  chevronFace: _ContextMenu.ChevronFace.None
});

const validServer = (0, _Validation.default)({
  deriveData: async ({
    value
  }) => {
    try {
      // check if we can successfully load this server's room directory
      await _MatrixClientPeg.MatrixClientPeg.get().publicRooms({
        limit: 1,
        server: value
      });
      return {};
    } catch (error) {
      return {
        error
      };
    }
  },
  rules: [{
    key: "required",
    test: async ({
      value
    }) => !!value,
    invalid: () => (0, _languageHandler._t)("Enter a server name")
  }, {
    key: "available",
    final: true,
    test: async (_, {
      error
    }) => !error,
    valid: () => (0, _languageHandler._t)("Looks good"),
    invalid: ({
      error
    }) => error.errcode === "M_FORBIDDEN" ? (0, _languageHandler._t)("You are not allowed to view this server's rooms list") : (0, _languageHandler._t)("Can't find this server or its room list")
  }]
});

// This dropdown sources homeservers from three places:
// + your currently connected homeserver
// + homeservers in config.json["roomDirectory"]
// + homeservers in SettingsStore["room_directory_servers"]
// if a server exists in multiple, only keep the top-most entry.
const NetworkDropdown = ({
  onOptionChange,
  protocols = {},
  selectedServerName,
  selectedInstanceId
}) => {
  const [menuDisplayed, handle, openMenu, closeMenu] = (0, _ContextMenu.useContextMenu)();

  const _userDefinedServers = (0, _useSettings.useSettingValue)(SETTING_NAME);

  const [userDefinedServers, _setUserDefinedServers] = (0, _react.useState)(_userDefinedServers);

  const handlerFactory = (server, instanceId) => {
    return () => {
      onOptionChange(server, instanceId);
      closeMenu();
    };
  };

  const setUserDefinedServers = servers => {
    _setUserDefinedServers(servers);

    _SettingsStore.default.setValue(SETTING_NAME, null, _SettingLevel.SettingLevel.ACCOUNT, servers);
  }; // keep local echo up to date with external changes


  (0, _react.useEffect)(() => {
    _setUserDefinedServers(_userDefinedServers);
  }, [_userDefinedServers]); // we either show the button or the dropdown in its place.

  let content;

  if (menuDisplayed) {
    const config = _SdkConfig.default.get();

    const roomDirectory = config.roomDirectory || {};

    const hsName = _MatrixClientPeg.MatrixClientPeg.getHomeserverName();

    const configServers = new Set(roomDirectory.servers); // configured servers take preference over user-defined ones, if one occurs in both ignore the latter one.

    const removableServers = new Set(userDefinedServers.filter(s => !configServers.has(s) && s !== hsName));
    const servers = [// we always show our connected HS, this takes precedence over it being configured or user-defined
    hsName, ...Array.from(configServers).filter(s => s !== hsName).sort(), ...Array.from(removableServers).sort()]; // For our own HS, we can use the instance_ids given in the third party protocols
    // response to get the server to filter the room list by network for us.
    // We can't get thirdparty protocols for remote server yet though, so for those
    // we can only show the default room list.

    const options = servers.map(server => {
      const serverSelected = server === selectedServerName;
      const entries = [];
      const protocolsList = server === hsName ? Object.values(protocols) : [];

      if (protocolsList.length > 0) {
        // add a fake protocol with ALL_ROOMS
        protocolsList.push({
          instances: [{
            fields: [],
            network_id: "",
            instance_id: ALL_ROOMS,
            desc: (0, _languageHandler._t)("All rooms")
          }],
          location_fields: [],
          user_fields: [],
          field_types: {},
          icon: ""
        });
      }

      protocolsList.forEach(({
        instances = []
      }) => {
        [...instances].sort((b, a) => {
          return (0, _strings.compare)(a.desc, b.desc);
        }).forEach(({
          desc,
          instance_id: instanceId
        }) => {
          entries.push( /*#__PURE__*/_react.default.createElement(_ContextMenu.MenuItemRadio, {
            key: String(instanceId),
            active: serverSelected && instanceId === selectedInstanceId,
            onClick: handlerFactory(server, instanceId),
            label: desc,
            className: "mx_NetworkDropdown_server_network"
          }, desc));
        });
      });
      let subtitle;

      if (server === hsName) {
        subtitle = /*#__PURE__*/_react.default.createElement("div", {
          className: "mx_NetworkDropdown_server_subtitle"
        }, (0, _languageHandler._t)("Your server"));
      }

      let removeButton;

      if (removableServers.has(server)) {
        const onClick = async () => {
          closeMenu();

          const {
            finished
          } = _Modal.default.createTrackedDialog("Network Dropdown", "Remove server", _QuestionDialog.default, {
            title: (0, _languageHandler._t)("Are you sure?"),
            description: (0, _languageHandler._t)("Are you sure you want to remove <b>%(serverName)s</b>", {
              serverName: server
            }, {
              b: serverName => /*#__PURE__*/_react.default.createElement("b", null, serverName)
            }),
            button: (0, _languageHandler._t)("Remove"),
            fixedWidth: false
          }, "mx_NetworkDropdown_dialog");

          const [ok] = await finished;
          if (!ok) return; // delete from setting

          setUserDefinedServers(servers.filter(s => s !== server)); // the selected server is being removed, reset to our HS

          if (serverSelected) {
            onOptionChange(hsName, undefined);
          }
        };

        removeButton = /*#__PURE__*/_react.default.createElement(_ContextMenu.MenuItem, {
          onClick: onClick,
          label: (0, _languageHandler._t)("Remove server")
        });
      } // ARIA: in actual fact the entire menu is one large radio group but for better screen reader support
      // we use group to notate server wrongly.


      return /*#__PURE__*/_react.default.createElement(_ContextMenu.MenuGroup, {
        label: server,
        className: "mx_NetworkDropdown_server",
        key: server
      }, /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_NetworkDropdown_server_title"
      }, server, removeButton), subtitle, /*#__PURE__*/_react.default.createElement(_ContextMenu.MenuItemRadio, {
        active: serverSelected && !selectedInstanceId,
        onClick: handlerFactory(server, undefined),
        label: (0, _languageHandler._t)("Matrix"),
        className: "mx_NetworkDropdown_server_network"
      }, (0, _languageHandler._t)("Matrix")), entries);
    });

    const onClick = async () => {
      closeMenu();

      const {
        finished
      } = _Modal.default.createTrackedDialog("Network Dropdown", "Add a new server", _TextInputDialog.default, {
        title: (0, _languageHandler._t)("Add a new server"),
        description: (0, _languageHandler._t)("Enter the name of a new server you want to explore."),
        button: (0, _languageHandler._t)("Add"),
        hasCancel: false,
        placeholder: (0, _languageHandler._t)("Server name"),
        validator: validServer,
        fixedWidth: false
      }, "mx_NetworkDropdown_dialog");

      const [ok, newServer] = await finished;
      if (!ok) return;

      if (!userDefinedServers.includes(newServer)) {
        setUserDefinedServers([...userDefinedServers, newServer]);
      }

      onOptionChange(newServer); // change filter to the new server
    };

    const buttonRect = handle.current.getBoundingClientRect();
    content = /*#__PURE__*/_react.default.createElement(_ContextMenu.default, (0, _extends2.default)({}, inPlaceOf(buttonRect), {
      onFinished: closeMenu,
      focusLock: true
    }), /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_NetworkDropdown_menu"
    }, options, /*#__PURE__*/_react.default.createElement(_ContextMenu.MenuItem, {
      className: "mx_NetworkDropdown_server_add",
      label: undefined,
      onClick: onClick
    }, (0, _languageHandler._t)("Add a new server..."))));
  } else {
    let currentValue;

    if (selectedInstanceId === ALL_ROOMS) {
      currentValue = (0, _languageHandler._t)("All rooms");
    } else if (selectedInstanceId) {
      const instance = (0, _DirectoryUtils.instanceForInstanceId)(protocols, selectedInstanceId);
      currentValue = (0, _languageHandler._t)("%(networkName)s rooms", {
        networkName: instance.desc
      });
    } else {
      currentValue = (0, _languageHandler._t)("Matrix rooms");
    }

    content = /*#__PURE__*/_react.default.createElement(_ContextMenu.ContextMenuButton, {
      className: "mx_NetworkDropdown_handle",
      onClick: openMenu,
      isExpanded: menuDisplayed
    }, /*#__PURE__*/_react.default.createElement("span", null, currentValue), " ", /*#__PURE__*/_react.default.createElement("span", {
      className: "mx_NetworkDropdown_handle_server"
    }, "(", selectedServerName, ")"));
  }

  return /*#__PURE__*/_react.default.createElement("div", {
    className: "mx_NetworkDropdown",
    ref: handle
  }, content);
};

var _default = NetworkDropdown;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2RpcmVjdG9yeS9OZXR3b3JrRHJvcGRvd24udHN4Il0sIm5hbWVzIjpbIkFMTF9ST09NUyIsIlNFVFRJTkdfTkFNRSIsImluUGxhY2VPZiIsImVsZW1lbnRSZWN0IiwicmlnaHQiLCJVSVN0b3JlIiwiaW5zdGFuY2UiLCJ3aW5kb3dXaWR0aCIsInRvcCIsImNoZXZyb25PZmZzZXQiLCJjaGV2cm9uRmFjZSIsIkNoZXZyb25GYWNlIiwiTm9uZSIsInZhbGlkU2VydmVyIiwiZGVyaXZlRGF0YSIsInZhbHVlIiwiTWF0cml4Q2xpZW50UGVnIiwiZ2V0IiwicHVibGljUm9vbXMiLCJsaW1pdCIsInNlcnZlciIsImVycm9yIiwicnVsZXMiLCJrZXkiLCJ0ZXN0IiwiaW52YWxpZCIsImZpbmFsIiwiXyIsInZhbGlkIiwiZXJyY29kZSIsIk5ldHdvcmtEcm9wZG93biIsIm9uT3B0aW9uQ2hhbmdlIiwicHJvdG9jb2xzIiwic2VsZWN0ZWRTZXJ2ZXJOYW1lIiwic2VsZWN0ZWRJbnN0YW5jZUlkIiwibWVudURpc3BsYXllZCIsImhhbmRsZSIsIm9wZW5NZW51IiwiY2xvc2VNZW51IiwiX3VzZXJEZWZpbmVkU2VydmVycyIsInVzZXJEZWZpbmVkU2VydmVycyIsIl9zZXRVc2VyRGVmaW5lZFNlcnZlcnMiLCJoYW5kbGVyRmFjdG9yeSIsImluc3RhbmNlSWQiLCJzZXRVc2VyRGVmaW5lZFNlcnZlcnMiLCJzZXJ2ZXJzIiwiU2V0dGluZ3NTdG9yZSIsInNldFZhbHVlIiwiU2V0dGluZ0xldmVsIiwiQUNDT1VOVCIsImNvbnRlbnQiLCJjb25maWciLCJTZGtDb25maWciLCJyb29tRGlyZWN0b3J5IiwiaHNOYW1lIiwiZ2V0SG9tZXNlcnZlck5hbWUiLCJjb25maWdTZXJ2ZXJzIiwiU2V0IiwicmVtb3ZhYmxlU2VydmVycyIsImZpbHRlciIsInMiLCJoYXMiLCJBcnJheSIsImZyb20iLCJzb3J0Iiwib3B0aW9ucyIsIm1hcCIsInNlcnZlclNlbGVjdGVkIiwiZW50cmllcyIsInByb3RvY29sc0xpc3QiLCJPYmplY3QiLCJ2YWx1ZXMiLCJsZW5ndGgiLCJwdXNoIiwiaW5zdGFuY2VzIiwiZmllbGRzIiwibmV0d29ya19pZCIsImluc3RhbmNlX2lkIiwiZGVzYyIsImxvY2F0aW9uX2ZpZWxkcyIsInVzZXJfZmllbGRzIiwiZmllbGRfdHlwZXMiLCJpY29uIiwiZm9yRWFjaCIsImIiLCJhIiwiU3RyaW5nIiwic3VidGl0bGUiLCJyZW1vdmVCdXR0b24iLCJvbkNsaWNrIiwiZmluaXNoZWQiLCJNb2RhbCIsImNyZWF0ZVRyYWNrZWREaWFsb2ciLCJRdWVzdGlvbkRpYWxvZyIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJzZXJ2ZXJOYW1lIiwiYnV0dG9uIiwiZml4ZWRXaWR0aCIsIm9rIiwidW5kZWZpbmVkIiwiVGV4dElucHV0RGlhbG9nIiwiaGFzQ2FuY2VsIiwicGxhY2Vob2xkZXIiLCJ2YWxpZGF0b3IiLCJuZXdTZXJ2ZXIiLCJpbmNsdWRlcyIsImJ1dHRvblJlY3QiLCJjdXJyZW50IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY3VycmVudFZhbHVlIiwibmV0d29ya05hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBaUJBOztBQUlBOztBQUNBOztBQUNBOztBQVFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7QUF6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE0QkE7QUFDTyxNQUFNQSxTQUFTLEdBQUcsV0FBbEI7O0FBRVAsTUFBTUMsWUFBWSxHQUFHLHdCQUFyQjs7QUFFQSxNQUFNQyxTQUFTLEdBQUlDLFdBQUQsS0FBa0Q7QUFDaEVDLEVBQUFBLEtBQUssRUFBRUMsaUJBQVFDLFFBQVIsQ0FBaUJDLFdBQWpCLEdBQStCSixXQUFXLENBQUNDLEtBRGM7QUFFaEVJLEVBQUFBLEdBQUcsRUFBRUwsV0FBVyxDQUFDSyxHQUYrQztBQUdoRUMsRUFBQUEsYUFBYSxFQUFFLENBSGlEO0FBSWhFQyxFQUFBQSxXQUFXLEVBQUVDLHlCQUFZQztBQUp1QyxDQUFsRCxDQUFsQjs7QUFPQSxNQUFNQyxXQUFXLEdBQUcseUJBQW1EO0FBQ25FQyxFQUFBQSxVQUFVLEVBQUUsT0FBTztBQUFFQyxJQUFBQTtBQUFGLEdBQVAsS0FBcUI7QUFDN0IsUUFBSTtBQUNBO0FBQ0EsWUFBTUMsaUNBQWdCQyxHQUFoQixHQUFzQkMsV0FBdEIsQ0FBa0M7QUFDcENDLFFBQUFBLEtBQUssRUFBRSxDQUQ2QjtBQUVwQ0MsUUFBQUEsTUFBTSxFQUFFTDtBQUY0QixPQUFsQyxDQUFOO0FBSUEsYUFBTyxFQUFQO0FBQ0gsS0FQRCxDQU9FLE9BQU9NLEtBQVAsRUFBYztBQUNaLGFBQU87QUFBRUEsUUFBQUE7QUFBRixPQUFQO0FBQ0g7QUFDSixHQVprRTtBQWFuRUMsRUFBQUEsS0FBSyxFQUFFLENBQ0g7QUFDSUMsSUFBQUEsR0FBRyxFQUFFLFVBRFQ7QUFFSUMsSUFBQUEsSUFBSSxFQUFFLE9BQU87QUFBRVQsTUFBQUE7QUFBRixLQUFQLEtBQXFCLENBQUMsQ0FBQ0EsS0FGakM7QUFHSVUsSUFBQUEsT0FBTyxFQUFFLE1BQU0seUJBQUcscUJBQUg7QUFIbkIsR0FERyxFQUtBO0FBQ0NGLElBQUFBLEdBQUcsRUFBRSxXQUROO0FBRUNHLElBQUFBLEtBQUssRUFBRSxJQUZSO0FBR0NGLElBQUFBLElBQUksRUFBRSxPQUFPRyxDQUFQLEVBQVU7QUFBRU4sTUFBQUE7QUFBRixLQUFWLEtBQXdCLENBQUNBLEtBSGhDO0FBSUNPLElBQUFBLEtBQUssRUFBRSxNQUFNLHlCQUFHLFlBQUgsQ0FKZDtBQUtDSCxJQUFBQSxPQUFPLEVBQUUsQ0FBQztBQUFFSixNQUFBQTtBQUFGLEtBQUQsS0FBZUEsS0FBSyxDQUFDUSxPQUFOLEtBQWtCLGFBQWxCLEdBQ2xCLHlCQUFHLHNEQUFILENBRGtCLEdBRWxCLHlCQUFHLHlDQUFIO0FBUFAsR0FMQTtBQWI0RCxDQUFuRCxDQUFwQjs7QUF1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBLE1BQU1DLGVBQWUsR0FBRyxDQUFDO0FBQUVDLEVBQUFBLGNBQUY7QUFBa0JDLEVBQUFBLFNBQVMsR0FBRyxFQUE5QjtBQUFrQ0MsRUFBQUEsa0JBQWxDO0FBQXNEQyxFQUFBQTtBQUF0RCxDQUFELEtBQXdGO0FBQzVHLFFBQU0sQ0FBQ0MsYUFBRCxFQUFnQkMsTUFBaEIsRUFBd0JDLFFBQXhCLEVBQWtDQyxTQUFsQyxJQUErQyxrQ0FBckQ7O0FBQ0EsUUFBTUMsbUJBQTZCLEdBQUcsa0NBQWdCdEMsWUFBaEIsQ0FBdEM7O0FBQ0EsUUFBTSxDQUFDdUMsa0JBQUQsRUFBcUJDLHNCQUFyQixJQUErQyxxQkFBU0YsbUJBQVQsQ0FBckQ7O0FBRUEsUUFBTUcsY0FBYyxHQUFHLENBQUN0QixNQUFELEVBQVN1QixVQUFULEtBQXdCO0FBQzNDLFdBQU8sTUFBTTtBQUNUWixNQUFBQSxjQUFjLENBQUNYLE1BQUQsRUFBU3VCLFVBQVQsQ0FBZDtBQUNBTCxNQUFBQSxTQUFTO0FBQ1osS0FIRDtBQUlILEdBTEQ7O0FBT0EsUUFBTU0scUJBQXFCLEdBQUdDLE9BQU8sSUFBSTtBQUNyQ0osSUFBQUEsc0JBQXNCLENBQUNJLE9BQUQsQ0FBdEI7O0FBQ0FDLDJCQUFjQyxRQUFkLENBQXVCOUMsWUFBdkIsRUFBcUMsSUFBckMsRUFBMkMrQywyQkFBYUMsT0FBeEQsRUFBaUVKLE9BQWpFO0FBQ0gsR0FIRCxDQVo0RyxDQWdCNUc7OztBQUNBLHdCQUFVLE1BQU07QUFDWkosSUFBQUEsc0JBQXNCLENBQUNGLG1CQUFELENBQXRCO0FBQ0gsR0FGRCxFQUVHLENBQUNBLG1CQUFELENBRkgsRUFqQjRHLENBcUI1Rzs7QUFDQSxNQUFJVyxPQUFKOztBQUNBLE1BQUlmLGFBQUosRUFBbUI7QUFDZixVQUFNZ0IsTUFBTSxHQUFHQyxtQkFBVW5DLEdBQVYsRUFBZjs7QUFDQSxVQUFNb0MsYUFBYSxHQUFHRixNQUFNLENBQUNFLGFBQVAsSUFBd0IsRUFBOUM7O0FBRUEsVUFBTUMsTUFBTSxHQUFHdEMsaUNBQWdCdUMsaUJBQWhCLEVBQWY7O0FBQ0EsVUFBTUMsYUFBYSxHQUFHLElBQUlDLEdBQUosQ0FBZ0JKLGFBQWEsQ0FBQ1IsT0FBOUIsQ0FBdEIsQ0FMZSxDQU9mOztBQUNBLFVBQU1hLGdCQUFnQixHQUFHLElBQUlELEdBQUosQ0FBUWpCLGtCQUFrQixDQUFDbUIsTUFBbkIsQ0FBMEJDLENBQUMsSUFBSSxDQUFDSixhQUFhLENBQUNLLEdBQWQsQ0FBa0JELENBQWxCLENBQUQsSUFBeUJBLENBQUMsS0FBS04sTUFBOUQsQ0FBUixDQUF6QjtBQUNBLFVBQU1ULE9BQU8sR0FBRyxDQUNaO0FBQ0FTLElBQUFBLE1BRlksRUFHWixHQUFHUSxLQUFLLENBQUNDLElBQU4sQ0FBV1AsYUFBWCxFQUEwQkcsTUFBMUIsQ0FBaUNDLENBQUMsSUFBSUEsQ0FBQyxLQUFLTixNQUE1QyxFQUFvRFUsSUFBcEQsRUFIUyxFQUlaLEdBQUdGLEtBQUssQ0FBQ0MsSUFBTixDQUFXTCxnQkFBWCxFQUE2Qk0sSUFBN0IsRUFKUyxDQUFoQixDQVRlLENBZ0JmO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFVBQU1DLE9BQU8sR0FBR3BCLE9BQU8sQ0FBQ3FCLEdBQVIsQ0FBWTlDLE1BQU0sSUFBSTtBQUNsQyxZQUFNK0MsY0FBYyxHQUFHL0MsTUFBTSxLQUFLYSxrQkFBbEM7QUFDQSxZQUFNbUMsT0FBTyxHQUFHLEVBQWhCO0FBRUEsWUFBTUMsYUFBYSxHQUFHakQsTUFBTSxLQUFLa0MsTUFBWCxHQUFvQmdCLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjdkMsU0FBZCxDQUFwQixHQUErQyxFQUFyRTs7QUFDQSxVQUFJcUMsYUFBYSxDQUFDRyxNQUFkLEdBQXVCLENBQTNCLEVBQThCO0FBQzFCO0FBQ0FILFFBQUFBLGFBQWEsQ0FBQ0ksSUFBZCxDQUFtQjtBQUNmQyxVQUFBQSxTQUFTLEVBQUUsQ0FBQztBQUNSQyxZQUFBQSxNQUFNLEVBQUUsRUFEQTtBQUVSQyxZQUFBQSxVQUFVLEVBQUUsRUFGSjtBQUdSQyxZQUFBQSxXQUFXLEVBQUU3RSxTQUhMO0FBSVI4RSxZQUFBQSxJQUFJLEVBQUUseUJBQUcsV0FBSDtBQUpFLFdBQUQsQ0FESTtBQU9mQyxVQUFBQSxlQUFlLEVBQUUsRUFQRjtBQVFmQyxVQUFBQSxXQUFXLEVBQUUsRUFSRTtBQVNmQyxVQUFBQSxXQUFXLEVBQUUsRUFURTtBQVVmQyxVQUFBQSxJQUFJLEVBQUU7QUFWUyxTQUFuQjtBQVlIOztBQUVEYixNQUFBQSxhQUFhLENBQUNjLE9BQWQsQ0FBc0IsQ0FBQztBQUFFVCxRQUFBQSxTQUFTLEdBQUM7QUFBWixPQUFELEtBQXNCO0FBQ3hDLFNBQUMsR0FBR0EsU0FBSixFQUFlVixJQUFmLENBQW9CLENBQUNvQixDQUFELEVBQUlDLENBQUosS0FBVTtBQUMxQixpQkFBTyxzQkFBUUEsQ0FBQyxDQUFDUCxJQUFWLEVBQWdCTSxDQUFDLENBQUNOLElBQWxCLENBQVA7QUFDSCxTQUZELEVBRUdLLE9BRkgsQ0FFVyxDQUFDO0FBQUVMLFVBQUFBLElBQUY7QUFBUUQsVUFBQUEsV0FBVyxFQUFFbEM7QUFBckIsU0FBRCxLQUF1QztBQUM5Q3lCLFVBQUFBLE9BQU8sQ0FBQ0ssSUFBUixlQUNJLDZCQUFDLDBCQUFEO0FBQ0ksWUFBQSxHQUFHLEVBQUVhLE1BQU0sQ0FBQzNDLFVBQUQsQ0FEZjtBQUVJLFlBQUEsTUFBTSxFQUFFd0IsY0FBYyxJQUFJeEIsVUFBVSxLQUFLVCxrQkFGN0M7QUFHSSxZQUFBLE9BQU8sRUFBRVEsY0FBYyxDQUFDdEIsTUFBRCxFQUFTdUIsVUFBVCxDQUgzQjtBQUlJLFlBQUEsS0FBSyxFQUFFbUMsSUFKWDtBQUtJLFlBQUEsU0FBUyxFQUFDO0FBTGQsYUFPTUEsSUFQTixDQURKO0FBVUgsU0FiRDtBQWNILE9BZkQ7QUFpQkEsVUFBSVMsUUFBSjs7QUFDQSxVQUFJbkUsTUFBTSxLQUFLa0MsTUFBZixFQUF1QjtBQUNuQmlDLFFBQUFBLFFBQVEsZ0JBQ0o7QUFBSyxVQUFBLFNBQVMsRUFBQztBQUFmLFdBQ00seUJBQUcsYUFBSCxDQUROLENBREo7QUFLSDs7QUFFRCxVQUFJQyxZQUFKOztBQUNBLFVBQUk5QixnQkFBZ0IsQ0FBQ0csR0FBakIsQ0FBcUJ6QyxNQUFyQixDQUFKLEVBQWtDO0FBQzlCLGNBQU1xRSxPQUFPLEdBQUcsWUFBWTtBQUN4Qm5ELFVBQUFBLFNBQVM7O0FBQ1QsZ0JBQU07QUFBRW9ELFlBQUFBO0FBQUYsY0FBZUMsZUFBTUMsbUJBQU4sQ0FDakIsa0JBRGlCLEVBQ0csZUFESCxFQUNvQkMsdUJBRHBCLEVBRWpCO0FBQ0lDLFlBQUFBLEtBQUssRUFBRSx5QkFBRyxlQUFILENBRFg7QUFFSUMsWUFBQUEsV0FBVyxFQUFFLHlCQUFHLHVEQUFILEVBQTREO0FBQ3JFQyxjQUFBQSxVQUFVLEVBQUU1RTtBQUR5RCxhQUE1RCxFQUVWO0FBQ0NnRSxjQUFBQSxDQUFDLEVBQUVZLFVBQVUsaUJBQUksd0NBQUtBLFVBQUw7QUFEbEIsYUFGVSxDQUZqQjtBQU9JQyxZQUFBQSxNQUFNLEVBQUUseUJBQUcsUUFBSCxDQVBaO0FBUUlDLFlBQUFBLFVBQVUsRUFBRTtBQVJoQixXQUZpQixFQVlqQiwyQkFaaUIsQ0FBckI7O0FBZUEsZ0JBQU0sQ0FBQ0MsRUFBRCxJQUFPLE1BQU1ULFFBQW5CO0FBQ0EsY0FBSSxDQUFDUyxFQUFMLEVBQVMsT0FsQmUsQ0FvQnhCOztBQUNBdkQsVUFBQUEscUJBQXFCLENBQUNDLE9BQU8sQ0FBQ2MsTUFBUixDQUFlQyxDQUFDLElBQUlBLENBQUMsS0FBS3hDLE1BQTFCLENBQUQsQ0FBckIsQ0FyQndCLENBdUJ4Qjs7QUFDQSxjQUFJK0MsY0FBSixFQUFvQjtBQUNoQnBDLFlBQUFBLGNBQWMsQ0FBQ3VCLE1BQUQsRUFBUzhDLFNBQVQsQ0FBZDtBQUNIO0FBQ0osU0EzQkQ7O0FBNEJBWixRQUFBQSxZQUFZLGdCQUFHLDZCQUFDLHFCQUFEO0FBQVUsVUFBQSxPQUFPLEVBQUVDLE9BQW5CO0FBQTRCLFVBQUEsS0FBSyxFQUFFLHlCQUFHLGVBQUg7QUFBbkMsVUFBZjtBQUNILE9BOUVpQyxDQWdGbEM7QUFDQTs7O0FBQ0EsMEJBQ0ksNkJBQUMsc0JBQUQ7QUFBVyxRQUFBLEtBQUssRUFBRXJFLE1BQWxCO0FBQTBCLFFBQUEsU0FBUyxFQUFDLDJCQUFwQztBQUFnRSxRQUFBLEdBQUcsRUFBRUE7QUFBckUsc0JBQ0k7QUFBSyxRQUFBLFNBQVMsRUFBQztBQUFmLFNBQ01BLE1BRE4sRUFFTW9FLFlBRk4sQ0FESixFQUtNRCxRQUxOLGVBT0ksNkJBQUMsMEJBQUQ7QUFDSSxRQUFBLE1BQU0sRUFBRXBCLGNBQWMsSUFBSSxDQUFDakMsa0JBRC9CO0FBRUksUUFBQSxPQUFPLEVBQUVRLGNBQWMsQ0FBQ3RCLE1BQUQsRUFBU2dGLFNBQVQsQ0FGM0I7QUFHSSxRQUFBLEtBQUssRUFBRSx5QkFBRyxRQUFILENBSFg7QUFJSSxRQUFBLFNBQVMsRUFBQztBQUpkLFNBTU0seUJBQUcsUUFBSCxDQU5OLENBUEosRUFlTWhDLE9BZk4sQ0FESjtBQW1CSCxLQXJHZSxDQUFoQjs7QUF1R0EsVUFBTXFCLE9BQU8sR0FBRyxZQUFZO0FBQ3hCbkQsTUFBQUEsU0FBUzs7QUFDVCxZQUFNO0FBQUVvRCxRQUFBQTtBQUFGLFVBQWVDLGVBQU1DLG1CQUFOLENBQTBCLGtCQUExQixFQUE4QyxrQkFBOUMsRUFBa0VTLHdCQUFsRSxFQUFtRjtBQUNwR1AsUUFBQUEsS0FBSyxFQUFFLHlCQUFHLGtCQUFILENBRDZGO0FBRXBHQyxRQUFBQSxXQUFXLEVBQUUseUJBQUcscURBQUgsQ0FGdUY7QUFHcEdFLFFBQUFBLE1BQU0sRUFBRSx5QkFBRyxLQUFILENBSDRGO0FBSXBHSyxRQUFBQSxTQUFTLEVBQUUsS0FKeUY7QUFLcEdDLFFBQUFBLFdBQVcsRUFBRSx5QkFBRyxhQUFILENBTHVGO0FBTXBHQyxRQUFBQSxTQUFTLEVBQUUzRixXQU55RjtBQU9wR3FGLFFBQUFBLFVBQVUsRUFBRTtBQVB3RixPQUFuRixFQVFsQiwyQkFSa0IsQ0FBckI7O0FBVUEsWUFBTSxDQUFDQyxFQUFELEVBQUtNLFNBQUwsSUFBa0IsTUFBTWYsUUFBOUI7QUFDQSxVQUFJLENBQUNTLEVBQUwsRUFBUzs7QUFFVCxVQUFJLENBQUMzRCxrQkFBa0IsQ0FBQ2tFLFFBQW5CLENBQTRCRCxTQUE1QixDQUFMLEVBQTZDO0FBQ3pDN0QsUUFBQUEscUJBQXFCLENBQUMsQ0FBQyxHQUFHSixrQkFBSixFQUF3QmlFLFNBQXhCLENBQUQsQ0FBckI7QUFDSDs7QUFFRDFFLE1BQUFBLGNBQWMsQ0FBQzBFLFNBQUQsQ0FBZCxDQW5Cd0IsQ0FtQkc7QUFDOUIsS0FwQkQ7O0FBc0JBLFVBQU1FLFVBQVUsR0FBR3ZFLE1BQU0sQ0FBQ3dFLE9BQVAsQ0FBZUMscUJBQWYsRUFBbkI7QUFDQTNELElBQUFBLE9BQU8sZ0JBQUcsNkJBQUMsb0JBQUQsNkJBQWlCaEQsU0FBUyxDQUFDeUcsVUFBRCxDQUExQjtBQUF3QyxNQUFBLFVBQVUsRUFBRXJFLFNBQXBEO0FBQStELE1BQUEsU0FBUztBQUF4RSxxQkFDTjtBQUFLLE1BQUEsU0FBUyxFQUFDO0FBQWYsT0FDTTJCLE9BRE4sZUFFSSw2QkFBQyxxQkFBRDtBQUFVLE1BQUEsU0FBUyxFQUFDLCtCQUFwQjtBQUFvRCxNQUFBLEtBQUssRUFBRW1DLFNBQTNEO0FBQXNFLE1BQUEsT0FBTyxFQUFFWDtBQUEvRSxPQUNNLHlCQUFHLHFCQUFILENBRE4sQ0FGSixDQURNLENBQVY7QUFRSCxHQTFKRCxNQTBKTztBQUNILFFBQUlxQixZQUFKOztBQUNBLFFBQUk1RSxrQkFBa0IsS0FBS2xDLFNBQTNCLEVBQXNDO0FBQ2xDOEcsTUFBQUEsWUFBWSxHQUFHLHlCQUFHLFdBQUgsQ0FBZjtBQUNILEtBRkQsTUFFTyxJQUFJNUUsa0JBQUosRUFBd0I7QUFDM0IsWUFBTTVCLFFBQVEsR0FBRywyQ0FBc0IwQixTQUF0QixFQUFpQ0Usa0JBQWpDLENBQWpCO0FBQ0E0RSxNQUFBQSxZQUFZLEdBQUcseUJBQUcsdUJBQUgsRUFBNEI7QUFDdkNDLFFBQUFBLFdBQVcsRUFBRXpHLFFBQVEsQ0FBQ3dFO0FBRGlCLE9BQTVCLENBQWY7QUFHSCxLQUxNLE1BS0E7QUFDSGdDLE1BQUFBLFlBQVksR0FBRyx5QkFBRyxjQUFILENBQWY7QUFDSDs7QUFFRDVELElBQUFBLE9BQU8sZ0JBQUcsNkJBQUMsOEJBQUQ7QUFDTixNQUFBLFNBQVMsRUFBQywyQkFESjtBQUVOLE1BQUEsT0FBTyxFQUFFYixRQUZIO0FBR04sTUFBQSxVQUFVLEVBQUVGO0FBSE4sb0JBS04sMkNBQ00yRSxZQUROLENBTE0sb0JBT0U7QUFBTSxNQUFBLFNBQVMsRUFBQztBQUFoQixZQUNEN0Usa0JBREMsTUFQRixDQUFWO0FBV0g7O0FBRUQsc0JBQU87QUFBSyxJQUFBLFNBQVMsRUFBQyxvQkFBZjtBQUFvQyxJQUFBLEdBQUcsRUFBRUc7QUFBekMsS0FDRGMsT0FEQyxDQUFQO0FBR0gsQ0E5TUQ7O2VBZ05lcEIsZSIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxOSBNaWNoYWVsIFRlbGF0eW5za2kgPDd0M2NoZ3V5QGdtYWlsLmNvbT5cbkNvcHlyaWdodCAyMDE2LCAyMDIwIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IE1hdHJpeEVycm9yIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL2h0dHAtYXBpXCI7XG5pbXBvcnQgeyBJUHJvdG9jb2wgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvY2xpZW50XCI7XG5cbmltcG9ydCB7IE1hdHJpeENsaWVudFBlZyB9IGZyb20gJy4uLy4uLy4uL01hdHJpeENsaWVudFBlZyc7XG5pbXBvcnQgeyBpbnN0YW5jZUZvckluc3RhbmNlSWQgfSBmcm9tICcuLi8uLi8uLi91dGlscy9EaXJlY3RvcnlVdGlscyc7XG5pbXBvcnQgQ29udGV4dE1lbnUsIHtcbiAgICBDaGV2cm9uRmFjZSxcbiAgICBDb250ZXh0TWVudUJ1dHRvbixcbiAgICBNZW51R3JvdXAsXG4gICAgTWVudUl0ZW0sXG4gICAgTWVudUl0ZW1SYWRpbyxcbiAgICB1c2VDb250ZXh0TWVudSxcbn0gZnJvbSBcIi4uLy4uL3N0cnVjdHVyZXMvQ29udGV4dE1lbnVcIjtcbmltcG9ydCB7IF90IH0gZnJvbSBcIi4uLy4uLy4uL2xhbmd1YWdlSGFuZGxlclwiO1xuaW1wb3J0IFNka0NvbmZpZyBmcm9tIFwiLi4vLi4vLi4vU2RrQ29uZmlnXCI7XG5pbXBvcnQgeyB1c2VTZXR0aW5nVmFsdWUgfSBmcm9tIFwiLi4vLi4vLi4vaG9va3MvdXNlU2V0dGluZ3NcIjtcbmltcG9ydCBNb2RhbCBmcm9tIFwiLi4vLi4vLi4vTW9kYWxcIjtcbmltcG9ydCBTZXR0aW5nc1N0b3JlIGZyb20gXCIuLi8uLi8uLi9zZXR0aW5ncy9TZXR0aW5nc1N0b3JlXCI7XG5pbXBvcnQgd2l0aFZhbGlkYXRpb24gZnJvbSBcIi4uL2VsZW1lbnRzL1ZhbGlkYXRpb25cIjtcbmltcG9ydCB7IFNldHRpbmdMZXZlbCB9IGZyb20gXCIuLi8uLi8uLi9zZXR0aW5ncy9TZXR0aW5nTGV2ZWxcIjtcbmltcG9ydCBUZXh0SW5wdXREaWFsb2cgZnJvbSBcIi4uL2RpYWxvZ3MvVGV4dElucHV0RGlhbG9nXCI7XG5pbXBvcnQgUXVlc3Rpb25EaWFsb2cgZnJvbSBcIi4uL2RpYWxvZ3MvUXVlc3Rpb25EaWFsb2dcIjtcbmltcG9ydCBVSVN0b3JlIGZyb20gXCIuLi8uLi8uLi9zdG9yZXMvVUlTdG9yZVwiO1xuaW1wb3J0IHsgY29tcGFyZSB9IGZyb20gXCIuLi8uLi8uLi91dGlscy9zdHJpbmdzXCI7XG5cbi8vIFhYWDogV2Ugd291bGQgaWRlYWxseSB1c2UgYSBzeW1ib2wgaGVyZSBidXQgd2UgY2FuJ3Qgc2luY2Ugd2Ugc2F2ZSB0aGlzIHZhbHVlIHRvIGxvY2FsU3RvcmFnZVxuZXhwb3J0IGNvbnN0IEFMTF9ST09NUyA9IFwiQUxMX1JPT01TXCI7XG5cbmNvbnN0IFNFVFRJTkdfTkFNRSA9IFwicm9vbV9kaXJlY3Rvcnlfc2VydmVyc1wiO1xuXG5jb25zdCBpblBsYWNlT2YgPSAoZWxlbWVudFJlY3Q6IFBpY2s8RE9NUmVjdCwgXCJyaWdodFwiIHwgXCJ0b3BcIj4pID0+ICh7XG4gICAgcmlnaHQ6IFVJU3RvcmUuaW5zdGFuY2Uud2luZG93V2lkdGggLSBlbGVtZW50UmVjdC5yaWdodCxcbiAgICB0b3A6IGVsZW1lbnRSZWN0LnRvcCxcbiAgICBjaGV2cm9uT2Zmc2V0OiAwLFxuICAgIGNoZXZyb25GYWNlOiBDaGV2cm9uRmFjZS5Ob25lLFxufSk7XG5cbmNvbnN0IHZhbGlkU2VydmVyID0gd2l0aFZhbGlkYXRpb248dW5kZWZpbmVkLCB7IGVycm9yPzogTWF0cml4RXJyb3IgfT4oe1xuICAgIGRlcml2ZURhdGE6IGFzeW5jICh7IHZhbHVlIH0pID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGNhbiBzdWNjZXNzZnVsbHkgbG9hZCB0aGlzIHNlcnZlcidzIHJvb20gZGlyZWN0b3J5XG4gICAgICAgICAgICBhd2FpdCBNYXRyaXhDbGllbnRQZWcuZ2V0KCkucHVibGljUm9vbXMoe1xuICAgICAgICAgICAgICAgIGxpbWl0OiAxLFxuICAgICAgICAgICAgICAgIHNlcnZlcjogdmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yIH07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJ1bGVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJyZXF1aXJlZFwiLFxuICAgICAgICAgICAgdGVzdDogYXN5bmMgKHsgdmFsdWUgfSkgPT4gISF2YWx1ZSxcbiAgICAgICAgICAgIGludmFsaWQ6ICgpID0+IF90KFwiRW50ZXIgYSBzZXJ2ZXIgbmFtZVwiKSxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAga2V5OiBcImF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgZmluYWw6IHRydWUsXG4gICAgICAgICAgICB0ZXN0OiBhc3luYyAoXywgeyBlcnJvciB9KSA9PiAhZXJyb3IsXG4gICAgICAgICAgICB2YWxpZDogKCkgPT4gX3QoXCJMb29rcyBnb29kXCIpLFxuICAgICAgICAgICAgaW52YWxpZDogKHsgZXJyb3IgfSkgPT4gZXJyb3IuZXJyY29kZSA9PT0gXCJNX0ZPUkJJRERFTlwiXG4gICAgICAgICAgICAgICAgPyBfdChcIllvdSBhcmUgbm90IGFsbG93ZWQgdG8gdmlldyB0aGlzIHNlcnZlcidzIHJvb21zIGxpc3RcIilcbiAgICAgICAgICAgICAgICA6IF90KFwiQ2FuJ3QgZmluZCB0aGlzIHNlcnZlciBvciBpdHMgcm9vbSBsaXN0XCIpLFxuICAgICAgICB9LFxuICAgIF0sXG59KTtcblxuZXhwb3J0IHR5cGUgUHJvdG9jb2xzID0gUmVjb3JkPHN0cmluZywgSVByb3RvY29sPjtcblxuaW50ZXJmYWNlIElQcm9wcyB7XG4gICAgcHJvdG9jb2xzOiBQcm90b2NvbHM7XG4gICAgc2VsZWN0ZWRTZXJ2ZXJOYW1lOiBzdHJpbmc7XG4gICAgc2VsZWN0ZWRJbnN0YW5jZUlkOiBzdHJpbmc7XG4gICAgb25PcHRpb25DaGFuZ2Uoc2VydmVyOiBzdHJpbmcsIGluc3RhbmNlSWQ/OiBzdHJpbmcpOiB2b2lkO1xufVxuXG4vLyBUaGlzIGRyb3Bkb3duIHNvdXJjZXMgaG9tZXNlcnZlcnMgZnJvbSB0aHJlZSBwbGFjZXM6XG4vLyArIHlvdXIgY3VycmVudGx5IGNvbm5lY3RlZCBob21lc2VydmVyXG4vLyArIGhvbWVzZXJ2ZXJzIGluIGNvbmZpZy5qc29uW1wicm9vbURpcmVjdG9yeVwiXVxuLy8gKyBob21lc2VydmVycyBpbiBTZXR0aW5nc1N0b3JlW1wicm9vbV9kaXJlY3Rvcnlfc2VydmVyc1wiXVxuLy8gaWYgYSBzZXJ2ZXIgZXhpc3RzIGluIG11bHRpcGxlLCBvbmx5IGtlZXAgdGhlIHRvcC1tb3N0IGVudHJ5LlxuXG5jb25zdCBOZXR3b3JrRHJvcGRvd24gPSAoeyBvbk9wdGlvbkNoYW5nZSwgcHJvdG9jb2xzID0ge30sIHNlbGVjdGVkU2VydmVyTmFtZSwgc2VsZWN0ZWRJbnN0YW5jZUlkIH06IElQcm9wcykgPT4ge1xuICAgIGNvbnN0IFttZW51RGlzcGxheWVkLCBoYW5kbGUsIG9wZW5NZW51LCBjbG9zZU1lbnVdID0gdXNlQ29udGV4dE1lbnU8SFRNTERpdkVsZW1lbnQ+KCk7XG4gICAgY29uc3QgX3VzZXJEZWZpbmVkU2VydmVyczogc3RyaW5nW10gPSB1c2VTZXR0aW5nVmFsdWUoU0VUVElOR19OQU1FKTtcbiAgICBjb25zdCBbdXNlckRlZmluZWRTZXJ2ZXJzLCBfc2V0VXNlckRlZmluZWRTZXJ2ZXJzXSA9IHVzZVN0YXRlKF91c2VyRGVmaW5lZFNlcnZlcnMpO1xuXG4gICAgY29uc3QgaGFuZGxlckZhY3RvcnkgPSAoc2VydmVyLCBpbnN0YW5jZUlkKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBvbk9wdGlvbkNoYW5nZShzZXJ2ZXIsIGluc3RhbmNlSWQpO1xuICAgICAgICAgICAgY2xvc2VNZW51KCk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IHNldFVzZXJEZWZpbmVkU2VydmVycyA9IHNlcnZlcnMgPT4ge1xuICAgICAgICBfc2V0VXNlckRlZmluZWRTZXJ2ZXJzKHNlcnZlcnMpO1xuICAgICAgICBTZXR0aW5nc1N0b3JlLnNldFZhbHVlKFNFVFRJTkdfTkFNRSwgbnVsbCwgU2V0dGluZ0xldmVsLkFDQ09VTlQsIHNlcnZlcnMpO1xuICAgIH07XG4gICAgLy8ga2VlcCBsb2NhbCBlY2hvIHVwIHRvIGRhdGUgd2l0aCBleHRlcm5hbCBjaGFuZ2VzXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgX3NldFVzZXJEZWZpbmVkU2VydmVycyhfdXNlckRlZmluZWRTZXJ2ZXJzKTtcbiAgICB9LCBbX3VzZXJEZWZpbmVkU2VydmVyc10pO1xuXG4gICAgLy8gd2UgZWl0aGVyIHNob3cgdGhlIGJ1dHRvbiBvciB0aGUgZHJvcGRvd24gaW4gaXRzIHBsYWNlLlxuICAgIGxldCBjb250ZW50O1xuICAgIGlmIChtZW51RGlzcGxheWVkKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IFNka0NvbmZpZy5nZXQoKTtcbiAgICAgICAgY29uc3Qgcm9vbURpcmVjdG9yeSA9IGNvbmZpZy5yb29tRGlyZWN0b3J5IHx8IHt9O1xuXG4gICAgICAgIGNvbnN0IGhzTmFtZSA9IE1hdHJpeENsaWVudFBlZy5nZXRIb21lc2VydmVyTmFtZSgpO1xuICAgICAgICBjb25zdCBjb25maWdTZXJ2ZXJzID0gbmV3IFNldDxzdHJpbmc+KHJvb21EaXJlY3Rvcnkuc2VydmVycyk7XG5cbiAgICAgICAgLy8gY29uZmlndXJlZCBzZXJ2ZXJzIHRha2UgcHJlZmVyZW5jZSBvdmVyIHVzZXItZGVmaW5lZCBvbmVzLCBpZiBvbmUgb2NjdXJzIGluIGJvdGggaWdub3JlIHRoZSBsYXR0ZXIgb25lLlxuICAgICAgICBjb25zdCByZW1vdmFibGVTZXJ2ZXJzID0gbmV3IFNldCh1c2VyRGVmaW5lZFNlcnZlcnMuZmlsdGVyKHMgPT4gIWNvbmZpZ1NlcnZlcnMuaGFzKHMpICYmIHMgIT09IGhzTmFtZSkpO1xuICAgICAgICBjb25zdCBzZXJ2ZXJzID0gW1xuICAgICAgICAgICAgLy8gd2UgYWx3YXlzIHNob3cgb3VyIGNvbm5lY3RlZCBIUywgdGhpcyB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgaXQgYmVpbmcgY29uZmlndXJlZCBvciB1c2VyLWRlZmluZWRcbiAgICAgICAgICAgIGhzTmFtZSxcbiAgICAgICAgICAgIC4uLkFycmF5LmZyb20oY29uZmlnU2VydmVycykuZmlsdGVyKHMgPT4gcyAhPT0gaHNOYW1lKS5zb3J0KCksXG4gICAgICAgICAgICAuLi5BcnJheS5mcm9tKHJlbW92YWJsZVNlcnZlcnMpLnNvcnQoKSxcbiAgICAgICAgXTtcblxuICAgICAgICAvLyBGb3Igb3VyIG93biBIUywgd2UgY2FuIHVzZSB0aGUgaW5zdGFuY2VfaWRzIGdpdmVuIGluIHRoZSB0aGlyZCBwYXJ0eSBwcm90b2NvbHNcbiAgICAgICAgLy8gcmVzcG9uc2UgdG8gZ2V0IHRoZSBzZXJ2ZXIgdG8gZmlsdGVyIHRoZSByb29tIGxpc3QgYnkgbmV0d29yayBmb3IgdXMuXG4gICAgICAgIC8vIFdlIGNhbid0IGdldCB0aGlyZHBhcnR5IHByb3RvY29scyBmb3IgcmVtb3RlIHNlcnZlciB5ZXQgdGhvdWdoLCBzbyBmb3IgdGhvc2VcbiAgICAgICAgLy8gd2UgY2FuIG9ubHkgc2hvdyB0aGUgZGVmYXVsdCByb29tIGxpc3QuXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBzZXJ2ZXJzLm1hcChzZXJ2ZXIgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VydmVyU2VsZWN0ZWQgPSBzZXJ2ZXIgPT09IHNlbGVjdGVkU2VydmVyTmFtZTtcbiAgICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSBbXTtcblxuICAgICAgICAgICAgY29uc3QgcHJvdG9jb2xzTGlzdCA9IHNlcnZlciA9PT0gaHNOYW1lID8gT2JqZWN0LnZhbHVlcyhwcm90b2NvbHMpIDogW107XG4gICAgICAgICAgICBpZiAocHJvdG9jb2xzTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIGEgZmFrZSBwcm90b2NvbCB3aXRoIEFMTF9ST09NU1xuICAgICAgICAgICAgICAgIHByb3RvY29sc0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrX2lkOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VfaWQ6IEFMTF9ST09NUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2M6IF90KFwiQWxsIHJvb21zXCIpLFxuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb25fZmllbGRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgdXNlcl9maWVsZHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZF90eXBlczoge30sXG4gICAgICAgICAgICAgICAgICAgIGljb246IFwiXCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByb3RvY29sc0xpc3QuZm9yRWFjaCgoeyBpbnN0YW5jZXM9W10gfSkgPT4ge1xuICAgICAgICAgICAgICAgIFsuLi5pbnN0YW5jZXNdLnNvcnQoKGIsIGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmUoYS5kZXNjLCBiLmRlc2MpO1xuICAgICAgICAgICAgICAgIH0pLmZvckVhY2goKHsgZGVzYywgaW5zdGFuY2VfaWQ6IGluc3RhbmNlSWQgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICA8TWVudUl0ZW1SYWRpb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17U3RyaW5nKGluc3RhbmNlSWQpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZT17c2VydmVyU2VsZWN0ZWQgJiYgaW5zdGFuY2VJZCA9PT0gc2VsZWN0ZWRJbnN0YW5jZUlkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZXJGYWN0b3J5KHNlcnZlciwgaW5zdGFuY2VJZCl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9e2Rlc2N9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibXhfTmV0d29ya0Ryb3Bkb3duX3NlcnZlcl9uZXR3b3JrXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGRlc2MgfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9NZW51SXRlbVJhZGlvPik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbGV0IHN1YnRpdGxlO1xuICAgICAgICAgICAgaWYgKHNlcnZlciA9PT0gaHNOYW1lKSB7XG4gICAgICAgICAgICAgICAgc3VidGl0bGUgPSAoXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXhfTmV0d29ya0Ryb3Bkb3duX3NlcnZlcl9zdWJ0aXRsZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgeyBfdChcIllvdXIgc2VydmVyXCIpIH1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHJlbW92ZUJ1dHRvbjtcbiAgICAgICAgICAgIGlmIChyZW1vdmFibGVTZXJ2ZXJzLmhhcyhzZXJ2ZXIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb25DbGljayA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VNZW51KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZmluaXNoZWQgfSA9IE1vZGFsLmNyZWF0ZVRyYWNrZWREaWFsb2coXG4gICAgICAgICAgICAgICAgICAgICAgICBcIk5ldHdvcmsgRHJvcGRvd25cIiwgXCJSZW1vdmUgc2VydmVyXCIsIFF1ZXN0aW9uRGlhbG9nLFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBfdChcIkFyZSB5b3Ugc3VyZT9cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IF90KFwiQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIHJlbW92ZSA8Yj4lKHNlcnZlck5hbWUpczwvYj5cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJOYW1lOiBzZXJ2ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiOiBzZXJ2ZXJOYW1lID0+IDxiPnsgc2VydmVyTmFtZSB9PC9iPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b246IF90KFwiUmVtb3ZlXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpeGVkV2lkdGg6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibXhfTmV0d29ya0Ryb3Bkb3duX2RpYWxvZ1wiLFxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtva10gPSBhd2FpdCBmaW5pc2hlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBmcm9tIHNldHRpbmdcbiAgICAgICAgICAgICAgICAgICAgc2V0VXNlckRlZmluZWRTZXJ2ZXJzKHNlcnZlcnMuZmlsdGVyKHMgPT4gcyAhPT0gc2VydmVyKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHNlbGVjdGVkIHNlcnZlciBpcyBiZWluZyByZW1vdmVkLCByZXNldCB0byBvdXIgSFNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcnZlclNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbk9wdGlvbkNoYW5nZShoc05hbWUsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlbW92ZUJ1dHRvbiA9IDxNZW51SXRlbSBvbkNsaWNrPXtvbkNsaWNrfSBsYWJlbD17X3QoXCJSZW1vdmUgc2VydmVyXCIpfSAvPjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQVJJQTogaW4gYWN0dWFsIGZhY3QgdGhlIGVudGlyZSBtZW51IGlzIG9uZSBsYXJnZSByYWRpbyBncm91cCBidXQgZm9yIGJldHRlciBzY3JlZW4gcmVhZGVyIHN1cHBvcnRcbiAgICAgICAgICAgIC8vIHdlIHVzZSBncm91cCB0byBub3RhdGUgc2VydmVyIHdyb25nbHkuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxNZW51R3JvdXAgbGFiZWw9e3NlcnZlcn0gY2xhc3NOYW1lPVwibXhfTmV0d29ya0Ryb3Bkb3duX3NlcnZlclwiIGtleT17c2VydmVyfT5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJteF9OZXR3b3JrRHJvcGRvd25fc2VydmVyX3RpdGxlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICB7IHNlcnZlciB9XG4gICAgICAgICAgICAgICAgICAgICAgICB7IHJlbW92ZUJ1dHRvbiB9XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICB7IHN1YnRpdGxlIH1cblxuICAgICAgICAgICAgICAgICAgICA8TWVudUl0ZW1SYWRpb1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlPXtzZXJ2ZXJTZWxlY3RlZCAmJiAhc2VsZWN0ZWRJbnN0YW5jZUlkfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlckZhY3Rvcnkoc2VydmVyLCB1bmRlZmluZWQpfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9e190KFwiTWF0cml4XCIpfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibXhfTmV0d29ya0Ryb3Bkb3duX3NlcnZlcl9uZXR3b3JrXCJcbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgeyBfdChcIk1hdHJpeFwiKSB9XG4gICAgICAgICAgICAgICAgICAgIDwvTWVudUl0ZW1SYWRpbz5cbiAgICAgICAgICAgICAgICAgICAgeyBlbnRyaWVzIH1cbiAgICAgICAgICAgICAgICA8L01lbnVHcm91cD5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IG9uQ2xpY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjbG9zZU1lbnUoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZmluaXNoZWQgfSA9IE1vZGFsLmNyZWF0ZVRyYWNrZWREaWFsb2coXCJOZXR3b3JrIERyb3Bkb3duXCIsIFwiQWRkIGEgbmV3IHNlcnZlclwiLCBUZXh0SW5wdXREaWFsb2csIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogX3QoXCJBZGQgYSBuZXcgc2VydmVyXCIpLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBfdChcIkVudGVyIHRoZSBuYW1lIG9mIGEgbmV3IHNlcnZlciB5b3Ugd2FudCB0byBleHBsb3JlLlwiKSxcbiAgICAgICAgICAgICAgICBidXR0b246IF90KFwiQWRkXCIpLFxuICAgICAgICAgICAgICAgIGhhc0NhbmNlbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IF90KFwiU2VydmVyIG5hbWVcIiksXG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yOiB2YWxpZFNlcnZlcixcbiAgICAgICAgICAgICAgICBmaXhlZFdpZHRoOiBmYWxzZSxcbiAgICAgICAgICAgIH0sIFwibXhfTmV0d29ya0Ryb3Bkb3duX2RpYWxvZ1wiKTtcblxuICAgICAgICAgICAgY29uc3QgW29rLCBuZXdTZXJ2ZXJdID0gYXdhaXQgZmluaXNoZWQ7XG4gICAgICAgICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgICAgICAgIGlmICghdXNlckRlZmluZWRTZXJ2ZXJzLmluY2x1ZGVzKG5ld1NlcnZlcikpIHtcbiAgICAgICAgICAgICAgICBzZXRVc2VyRGVmaW5lZFNlcnZlcnMoWy4uLnVzZXJEZWZpbmVkU2VydmVycywgbmV3U2VydmVyXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9uT3B0aW9uQ2hhbmdlKG5ld1NlcnZlcik7IC8vIGNoYW5nZSBmaWx0ZXIgdG8gdGhlIG5ldyBzZXJ2ZXJcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBidXR0b25SZWN0ID0gaGFuZGxlLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnRlbnQgPSA8Q29udGV4dE1lbnUgey4uLmluUGxhY2VPZihidXR0b25SZWN0KX0gb25GaW5pc2hlZD17Y2xvc2VNZW51fSBmb2N1c0xvY2s+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm14X05ldHdvcmtEcm9wZG93bl9tZW51XCI+XG4gICAgICAgICAgICAgICAgeyBvcHRpb25zIH1cbiAgICAgICAgICAgICAgICA8TWVudUl0ZW0gY2xhc3NOYW1lPVwibXhfTmV0d29ya0Ryb3Bkb3duX3NlcnZlcl9hZGRcIiBsYWJlbD17dW5kZWZpbmVkfSBvbkNsaWNrPXtvbkNsaWNrfT5cbiAgICAgICAgICAgICAgICAgICAgeyBfdChcIkFkZCBhIG5ldyBzZXJ2ZXIuLi5cIikgfVxuICAgICAgICAgICAgICAgIDwvTWVudUl0ZW0+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9Db250ZXh0TWVudT47XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgaWYgKHNlbGVjdGVkSW5zdGFuY2VJZCA9PT0gQUxMX1JPT01TKSB7XG4gICAgICAgICAgICBjdXJyZW50VmFsdWUgPSBfdChcIkFsbCByb29tc1wiKTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxlY3RlZEluc3RhbmNlSWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VGb3JJbnN0YW5jZUlkKHByb3RvY29scywgc2VsZWN0ZWRJbnN0YW5jZUlkKTtcbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IF90KFwiJShuZXR3b3JrTmFtZSlzIHJvb21zXCIsIHtcbiAgICAgICAgICAgICAgICBuZXR3b3JrTmFtZTogaW5zdGFuY2UuZGVzYyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudFZhbHVlID0gX3QoXCJNYXRyaXggcm9vbXNcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZW50ID0gPENvbnRleHRNZW51QnV0dG9uXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJteF9OZXR3b3JrRHJvcGRvd25faGFuZGxlXCJcbiAgICAgICAgICAgIG9uQ2xpY2s9e29wZW5NZW51fVxuICAgICAgICAgICAgaXNFeHBhbmRlZD17bWVudURpc3BsYXllZH1cbiAgICAgICAgPlxuICAgICAgICAgICAgPHNwYW4+XG4gICAgICAgICAgICAgICAgeyBjdXJyZW50VmFsdWUgfVxuICAgICAgICAgICAgPC9zcGFuPiA8c3BhbiBjbGFzc05hbWU9XCJteF9OZXR3b3JrRHJvcGRvd25faGFuZGxlX3NlcnZlclwiPlxuICAgICAgICAgICAgICAgICh7IHNlbGVjdGVkU2VydmVyTmFtZSB9KVxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L0NvbnRleHRNZW51QnV0dG9uPjtcbiAgICB9XG5cbiAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9XCJteF9OZXR3b3JrRHJvcGRvd25cIiByZWY9e2hhbmRsZX0+XG4gICAgICAgIHsgY29udGVudCB9XG4gICAgPC9kaXY+O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTmV0d29ya0Ryb3Bkb3duO1xuIl19