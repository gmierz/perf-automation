"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SendMessageComposer = void 0;
exports.attachRelation = attachRelation;
exports.createMessageContent = createMessageContent;
exports.default = void 0;
exports.isQuickReaction = isQuickReaction;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _emojibaseRegex = _interopRequireDefault(require("emojibase-regex"));

var _lodash = require("lodash");

var _event = require("matrix-js-sdk/src/@types/event");

var _logger = require("matrix-js-sdk/src/logger");

var _dispatcher = _interopRequireDefault(require("../../../dispatcher/dispatcher"));

var _model = _interopRequireDefault(require("../../../editor/model"));

var _serialize = require("../../../editor/serialize");

var _BasicMessageComposer = _interopRequireWildcard(require("./BasicMessageComposer"));

var _parts = require("../../../editor/parts");

var _ReplyChain = _interopRequireDefault(require("../elements/ReplyChain"));

var _EventUtils = require("../../../utils/EventUtils");

var _SendHistoryManager = _interopRequireDefault(require("../../../SendHistoryManager"));

var _SlashCommands = require("../../../SlashCommands");

var _Modal = _interopRequireDefault(require("../../../Modal"));

var _languageHandler = require("../../../languageHandler");

var _ContentMessages = _interopRequireDefault(require("../../../ContentMessages"));

var _MatrixClientContext = require("../../../contexts/MatrixClientContext");

var _actions = require("../../../dispatcher/actions");

var _utils = require("../../../effects/utils");

var _effects = require("../../../effects");

var _CountlyAnalytics = _interopRequireDefault(require("../../../CountlyAnalytics"));

var _MatrixClientPeg = require("../../../MatrixClientPeg");

var _KeyBindingsManager = require("../../../KeyBindingsManager");

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _SettingsStore = _interopRequireDefault(require("../../../settings/SettingsStore"));

var _ErrorDialog = _interopRequireDefault(require("../dialogs/ErrorDialog"));

var _QuestionDialog = _interopRequireDefault(require("../dialogs/QuestionDialog"));

var _sendTimePerformanceMetrics = require("../../../sendTimePerformanceMetrics");

var _RoomContext = _interopRequireWildcard(require("../../../contexts/RoomContext"));

var _position = _interopRequireDefault(require("../../../editor/position"));

var _ComposerInsertPayload = require("../../../dispatcher/payloads/ComposerInsertPayload");

var _dec, _class, _class2, _temp;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function addReplyToMessageContent(content, replyToEvent, permalinkCreator) {
  const replyContent = _ReplyChain.default.makeReplyMixIn(replyToEvent);

  Object.assign(content, replyContent); // Part of Replies fallback support - prepend the text we're sending
  // with the text we're replying to

  const nestedReply = _ReplyChain.default.getNestedReplyText(replyToEvent, permalinkCreator);

  if (nestedReply) {
    if (content.formatted_body) {
      content.formatted_body = nestedReply.html + content.formatted_body;
    }

    content.body = nestedReply.body + content.body;
  }
}

function attachRelation(content, relation) {
  if (relation) {
    content['m.relates_to'] = _objectSpread(_objectSpread({}, relation), content['m.relates_to']);
  }
} // exported for tests


function createMessageContent(model, replyToEvent, relation, permalinkCreator) {
  const isEmote = (0, _serialize.containsEmote)(model);

  if (isEmote) {
    model = (0, _serialize.stripEmoteCommand)(model);
  }

  if ((0, _serialize.startsWith)(model, "//")) {
    model = (0, _serialize.stripPrefix)(model, "/");
  }

  model = (0, _serialize.unescapeMessage)(model);
  const body = (0, _serialize.textSerialize)(model);
  const content = {
    msgtype: isEmote ? "m.emote" : "m.text",
    body: body
  };
  const formattedBody = (0, _serialize.htmlSerializeIfNeeded)(model, {
    forceHTML: !!replyToEvent
  });

  if (formattedBody) {
    content.format = "org.matrix.custom.html";
    content.formatted_body = formattedBody;
  }

  if (replyToEvent) {
    addReplyToMessageContent(content, replyToEvent, permalinkCreator);
  }

  if (relation) {
    content['m.relates_to'] = _objectSpread(_objectSpread({}, relation), content['m.relates_to']);
  }

  return content;
} // exported for tests


function isQuickReaction(model) {
  const parts = model.parts;
  if (parts.length == 0) return false;
  const text = (0, _serialize.textSerialize)(model); // shortcut takes the form "+:emoji:" or "+ :emoji:""
  // can be in 1 or 2 parts

  if (parts.length <= 2) {
    const hasShortcut = text.startsWith("+") || text.startsWith("+ ");
    const emojiMatch = text.match(_emojibaseRegex.default);

    if (hasShortcut && emojiMatch && emojiMatch.length == 1) {
      return emojiMatch[0] === text.substring(1) || emojiMatch[0] === text.substring(2);
    }
  }

  return false;
}

let SendMessageComposer = (_dec = (0, _replaceableComponent.replaceableComponent)("views.rooms.SendMessageComposer"), _dec(_class = (_temp = _class2 = class SendMessageComposer extends _react.default.Component {
  constructor(props, context) {
    super(props);
    (0, _defineProperty2.default)(this, "context", void 0);
    (0, _defineProperty2.default)(this, "prepareToEncrypt", void 0);
    (0, _defineProperty2.default)(this, "editorRef", /*#__PURE__*/(0, _react.createRef)());
    (0, _defineProperty2.default)(this, "model", null);
    (0, _defineProperty2.default)(this, "currentlyComposedEditorState", null);
    (0, _defineProperty2.default)(this, "dispatcherRef", void 0);
    (0, _defineProperty2.default)(this, "sendHistoryManager", void 0);
    (0, _defineProperty2.default)(this, "onKeyDown", event => {
      var _this$editorRef$curre, _this$props$relation, _this$editorRef$curre2, _this$editorRef$curre3;

      // ignore any keypress while doing IME compositions
      if ((_this$editorRef$curre = this.editorRef.current) !== null && _this$editorRef$curre !== void 0 && _this$editorRef$curre.isComposing(event)) {
        return;
      }

      const replyingToThread = ((_this$props$relation = this.props.relation) === null || _this$props$relation === void 0 ? void 0 : _this$props$relation.key) === _event.RelationType.Thread;
      const action = (0, _KeyBindingsManager.getKeyBindingsManager)().getMessageComposerAction(event);

      switch (action) {
        case _KeyBindingsManager.MessageComposerAction.Send:
          this.sendMessage();
          event.preventDefault();
          break;

        case _KeyBindingsManager.MessageComposerAction.SelectPrevSendHistory:
        case _KeyBindingsManager.MessageComposerAction.SelectNextSendHistory:
          {
            // Try select composer history
            const selected = this.selectSendHistory(action === _KeyBindingsManager.MessageComposerAction.SelectPrevSendHistory);

            if (selected) {
              // We're selecting history, so prevent the key event from doing anything else
              event.preventDefault();
            }

            break;
          }

        case _KeyBindingsManager.MessageComposerAction.EditPrevMessage:
          // selection must be collapsed and caret at start
          if ((_this$editorRef$curre2 = this.editorRef.current) !== null && _this$editorRef$curre2 !== void 0 && _this$editorRef$curre2.isSelectionCollapsed() && (_this$editorRef$curre3 = this.editorRef.current) !== null && _this$editorRef$curre3 !== void 0 && _this$editorRef$curre3.isCaretAtStart()) {
            const events = this.context.liveTimeline.getEvents().concat(replyingToThread ? [] : this.props.room.getPendingEvents());
            const editEvent = (0, _EventUtils.findEditableEvent)({
              events,
              isForward: false
            });

            if (editEvent) {
              // We're selecting history, so prevent the key event from doing anything else
              event.preventDefault();

              _dispatcher.default.dispatch({
                action: _actions.Action.EditEvent,
                event: editEvent,
                timelineRenderingType: this.context.timelineRenderingType
              });
            }
          }

          break;

        case _KeyBindingsManager.MessageComposerAction.CancelEditing:
          _dispatcher.default.dispatch({
            action: 'reply_to_event',
            event: null,
            context: this.context.timelineRenderingType
          });

          break;

        default:
          if (this.prepareToEncrypt) {
            // This needs to be last!
            this.prepareToEncrypt();
          }

      }
    });
    (0, _defineProperty2.default)(this, "shouldSaveStoredEditorState", () => {
      return !this.model.isEmpty || !!this.props.replyToEvent;
    });
    (0, _defineProperty2.default)(this, "saveStoredEditorState", () => {
      if (this.shouldSaveStoredEditorState()) {
        const item = _SendHistoryManager.default.createItem(this.model, this.props.replyToEvent);

        localStorage.setItem(this.editorStateKey, JSON.stringify(item));
      } else {
        this.clearStoredEditorState();
      }
    });
    (0, _defineProperty2.default)(this, "onAction", payload => {
      // don't let the user into the composer if it is disabled - all of these branches lead
      // to the cursor being in the composer
      if (this.props.disabled) return;

      switch (payload.action) {
        case 'reply_to_event':
        case _actions.Action.FocusSendMessageComposer:
          if ((payload.context ?? _RoomContext.TimelineRenderingType.Room) === this.context.timelineRenderingType) {
            var _this$editorRef$curre4;

            (_this$editorRef$curre4 = this.editorRef.current) === null || _this$editorRef$curre4 === void 0 ? void 0 : _this$editorRef$curre4.focus();
          }

          break;

        case _actions.Action.ComposerInsert:
          if (payload.timelineRenderingType !== this.context.timelineRenderingType) break;
          if (payload.composerType !== _ComposerInsertPayload.ComposerType.Send) break;

          if (payload.userId) {
            var _this$editorRef$curre5;

            (_this$editorRef$curre5 = this.editorRef.current) === null || _this$editorRef$curre5 === void 0 ? void 0 : _this$editorRef$curre5.insertMention(payload.userId);
          } else if (payload.event) {
            var _this$editorRef$curre6;

            (_this$editorRef$curre6 = this.editorRef.current) === null || _this$editorRef$curre6 === void 0 ? void 0 : _this$editorRef$curre6.insertQuotedMessage(payload.event);
          } else if (payload.text) {
            var _this$editorRef$curre7;

            (_this$editorRef$curre7 = this.editorRef.current) === null || _this$editorRef$curre7 === void 0 ? void 0 : _this$editorRef$curre7.insertPlaintext(payload.text);
          }

          break;
      }
    });
    (0, _defineProperty2.default)(this, "onPaste", event => {
      const {
        clipboardData
      } = event; // Prioritize text on the clipboard over files if RTF is present as Office on macOS puts a bitmap
      // in the clipboard as well as the content being copied. Modern versions of Office seem to not do this anymore.
      // We check text/rtf instead of text/plain as when copy+pasting a file from Finder or Gnome Image Viewer
      // it puts the filename in as text/plain which we want to ignore.

      if (clipboardData.files.length && !clipboardData.types.includes("text/rtf")) {
        _ContentMessages.default.sharedInstance().sendContentListToRoom(Array.from(clipboardData.files), this.props.room.roomId, this.props.relation, this.props.mxClient);

        return true; // to skip internal onPaste handler
      }
    });
    (0, _defineProperty2.default)(this, "onChange", () => {
      if (this.props.onChange) this.props.onChange(this.model);
    });
    (0, _defineProperty2.default)(this, "focusComposer", () => {
      var _this$editorRef$curre8;

      (_this$editorRef$curre8 = this.editorRef.current) === null || _this$editorRef$curre8 === void 0 ? void 0 : _this$editorRef$curre8.focus();
    });

    if (this.props.mxClient.isCryptoEnabled() && this.props.mxClient.isRoomEncrypted(this.props.room.roomId)) {
      this.prepareToEncrypt = (0, _lodash.throttle)(() => {
        this.props.mxClient.prepareToEncrypt(this.props.room);
      }, 60000, {
        leading: true,
        trailing: false
      });
    }

    window.addEventListener("beforeunload", this.saveStoredEditorState);
  }

  componentDidUpdate(prevProps) {
    var _this$props$relation2, _this$props$relation3, _prevProps$relation;

    const replyingToThread = ((_this$props$relation2 = this.props.relation) === null || _this$props$relation2 === void 0 ? void 0 : _this$props$relation2.key) === _event.RelationType.Thread;
    const differentEventTarget = ((_this$props$relation3 = this.props.relation) === null || _this$props$relation3 === void 0 ? void 0 : _this$props$relation3.event_id) !== ((_prevProps$relation = prevProps.relation) === null || _prevProps$relation === void 0 ? void 0 : _prevProps$relation.event_id);
    const threadChanged = replyingToThread && differentEventTarget;

    if (threadChanged) {
      var _this$editorRef$curre9;

      const partCreator = new _parts.CommandPartCreator(this.props.room, this.props.mxClient);
      const parts = this.restoreStoredEditorState(partCreator) || [];
      this.model.reset(parts);
      (_this$editorRef$curre9 = this.editorRef.current) === null || _this$editorRef$curre9 === void 0 ? void 0 : _this$editorRef$curre9.focus();
    }
  }

  // we keep sent messages/commands in a separate history (separate from undo history)
  // so you can alt+up/down in them
  selectSendHistory(up) {
    const delta = up ? -1 : 1; // True if we are not currently selecting history, but composing a message

    if (this.sendHistoryManager.currentIndex === this.sendHistoryManager.history.length) {
      // We can't go any further - there isn't any more history, so nop.
      if (!up) {
        return false;
      }

      this.currentlyComposedEditorState = this.model.serializeParts();
    } else if (this.sendHistoryManager.currentIndex + delta === this.sendHistoryManager.history.length) {
      // True when we return to the message being composed currently
      this.model.reset(this.currentlyComposedEditorState);
      this.sendHistoryManager.currentIndex = this.sendHistoryManager.history.length;
      return true;
    }

    const {
      parts,
      replyEventId
    } = this.sendHistoryManager.getItem(delta);

    _dispatcher.default.dispatch({
      action: 'reply_to_event',
      event: replyEventId ? this.props.room.findEventById(replyEventId) : null,
      context: this.context.timelineRenderingType
    });

    if (parts) {
      var _this$editorRef$curre10;

      this.model.reset(parts);
      (_this$editorRef$curre10 = this.editorRef.current) === null || _this$editorRef$curre10 === void 0 ? void 0 : _this$editorRef$curre10.focus();
    }

    return true;
  }

  isSlashCommand() {
    const parts = this.model.parts;
    const firstPart = parts[0];

    if (firstPart) {
      if (firstPart.type === _parts.Type.Command && firstPart.text.startsWith("/") && !firstPart.text.startsWith("//")) {
        return true;
      } // be extra resilient when somehow the AutocompleteWrapperModel or
      // CommandPartCreator fails to insert a command part, so we don't send
      // a command as a message


      if (firstPart.text.startsWith("/") && !firstPart.text.startsWith("//") && (firstPart.type === _parts.Type.Plain || firstPart.type === _parts.Type.PillCandidate)) {
        return true;
      }
    }

    return false;
  }

  sendQuickReaction() {
    const timeline = this.context.liveTimeline;
    const events = timeline.getEvents();
    const reaction = this.model.parts[1].text;

    for (let i = events.length - 1; i >= 0; i--) {
      if (events[i].getType() === _event.EventType.RoomMessage) {
        let shouldReact = true;
        const lastMessage = events[i];

        const userId = _MatrixClientPeg.MatrixClientPeg.get().getUserId();

        const messageReactions = this.props.room.getUnfilteredTimelineSet().getRelationsForEvent(lastMessage.getId(), _event.RelationType.Annotation, _event.EventType.Reaction); // if we have already sent this reaction, don't redact but don't re-send

        if (messageReactions) {
          const myReactionEvents = messageReactions.getAnnotationsBySender()[userId] || [];
          const myReactionKeys = [...myReactionEvents].filter(event => !event.isRedacted()).map(event => event.getRelation().key);
          shouldReact = !myReactionKeys.includes(reaction);
        }

        if (shouldReact) {
          _MatrixClientPeg.MatrixClientPeg.get().sendEvent(lastMessage.getRoomId(), _event.EventType.Reaction, {
            "m.relates_to": {
              "rel_type": _event.RelationType.Annotation,
              "event_id": lastMessage.getId(),
              "key": reaction
            }
          });

          _dispatcher.default.dispatch({
            action: "message_sent"
          });
        }

        break;
      }
    }
  }

  getSlashCommand() {
    const commandText = this.model.parts.reduce((text, part) => {
      // use mxid to textify user pills in a command
      if (part.type === "user-pill") {
        return text + part.resourceId;
      }

      return text + part.text;
    }, "");
    const {
      cmd,
      args
    } = (0, _SlashCommands.getCommand)(commandText);
    return [cmd, args, commandText];
  }

  async runSlashCommand(cmd, args) {
    var _this$props$relation4, _this$props$relation5;

    const threadId = ((_this$props$relation4 = this.props.relation) === null || _this$props$relation4 === void 0 ? void 0 : _this$props$relation4.rel_type) === _event.RelationType.Thread ? (_this$props$relation5 = this.props.relation) === null || _this$props$relation5 === void 0 ? void 0 : _this$props$relation5.event_id : null;
    const result = cmd.run(this.props.room.roomId, threadId, args);
    let messageContent;
    let error = result.error;

    if (result.promise) {
      try {
        if (cmd.category === _SlashCommands.CommandCategories.messages) {
          // The command returns a modified message that we need to pass on
          messageContent = await result.promise;
        } else {
          await result.promise;
        }
      } catch (err) {
        error = err;
      }
    }

    if (error) {
      _logger.logger.error("Command failure: %s", error); // assume the error is a server error when the command is async


      const isServerError = !!result.promise;
      const title = isServerError ? (0, _languageHandler._td)("Server error") : (0, _languageHandler._td)("Command error");
      let errText;

      if (typeof error === 'string') {
        errText = error;
      } else if (error.message) {
        errText = error.message;
      } else {
        errText = (0, _languageHandler._t)("Server unavailable, overloaded, or something else went wrong.");
      }

      _Modal.default.createTrackedDialog(title, '', _ErrorDialog.default, {
        title: (0, _languageHandler._t)(title),
        description: errText
      });
    } else {
      _logger.logger.log("Command success.");

      if (messageContent) return messageContent;
    }
  }

  async sendMessage() {
    var _this$editorRef$curre12, _this$editorRef$curre13;

    const model = this.model;

    if (model.isEmpty) {
      return;
    } // Replace emoticon at the end of the message


    if (_SettingsStore.default.getValue('MessageComposerInput.autoReplaceEmoji')) {
      var _this$editorRef$curre11;

      const indexOfLastPart = model.parts.length - 1;
      const positionInLastPart = model.parts[indexOfLastPart].text.length;
      (_this$editorRef$curre11 = this.editorRef.current) === null || _this$editorRef$curre11 === void 0 ? void 0 : _this$editorRef$curre11.replaceEmoticon(new _position.default(indexOfLastPart, positionInLastPart), _BasicMessageComposer.REGEX_EMOTICON);
    }

    const replyToEvent = this.props.replyToEvent;
    let shouldSend = true;
    let content;

    if (!(0, _serialize.containsEmote)(model) && this.isSlashCommand()) {
      const [cmd, args, commandText] = this.getSlashCommand();

      if (cmd) {
        if (cmd.category === _SlashCommands.CommandCategories.messages) {
          content = await this.runSlashCommand(cmd, args);

          if (replyToEvent) {
            addReplyToMessageContent(content, replyToEvent, this.props.permalinkCreator);
          }

          attachRelation(content, this.props.relation);
        } else {
          this.runSlashCommand(cmd, args);
          shouldSend = false;
        }
      } else {
        // ask the user if their unknown command should be sent as a message
        const {
          finished
        } = _Modal.default.createTrackedDialog("Unknown command", "", _QuestionDialog.default, {
          title: (0, _languageHandler._t)("Unknown Command"),
          description: /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("p", null, (0, _languageHandler._t)("Unrecognised command: %(commandText)s", {
            commandText
          })), /*#__PURE__*/_react.default.createElement("p", null, (0, _languageHandler._t)("You can use <code>/help</code> to list available commands. " + "Did you mean to send this as a message?", {}, {
            code: t => /*#__PURE__*/_react.default.createElement("code", null, t)
          })), /*#__PURE__*/_react.default.createElement("p", null, (0, _languageHandler._t)("Hint: Begin your message with <code>//</code> to start it with a slash.", {}, {
            code: t => /*#__PURE__*/_react.default.createElement("code", null, t)
          }))),
          button: (0, _languageHandler._t)('Send as message')
        });

        const [sendAnyway] = await finished; // if !sendAnyway bail to let the user edit the composer and try again

        if (!sendAnyway) return;
      }
    }

    if (isQuickReaction(model)) {
      shouldSend = false;
      this.sendQuickReaction();
    }

    if (shouldSend) {
      var _this$props$relation6;

      const startTime = _CountlyAnalytics.default.getTimestamp();

      const {
        roomId
      } = this.props.room;

      if (!content) {
        content = createMessageContent(model, replyToEvent, this.props.relation, this.props.permalinkCreator);
      } // don't bother sending an empty message


      if (!content.body.trim()) return;

      if (_SettingsStore.default.getValue("Performance.addSendMessageTimingMetadata")) {
        (0, _sendTimePerformanceMetrics.decorateStartSendingTime)(content);
      }

      const threadId = ((_this$props$relation6 = this.props.relation) === null || _this$props$relation6 === void 0 ? void 0 : _this$props$relation6.rel_type) === _event.RelationType.Thread ? this.props.relation.event_id : null;
      const prom = this.props.mxClient.sendMessage(roomId, threadId, content);

      if (replyToEvent) {
        // Clear reply_to_event as we put the message into the queue
        // if the send fails, retry will handle resending.
        _dispatcher.default.dispatch({
          action: 'reply_to_event',
          event: null,
          context: this.context.timelineRenderingType
        });
      }

      _dispatcher.default.dispatch({
        action: "message_sent"
      });

      _effects.CHAT_EFFECTS.forEach(effect => {
        if ((0, _utils.containsEmoji)(content, effect.emojis)) {
          var _this$props$relation7;

          // For initial threads launch, chat effects are disabled
          // see #19731
          const isNotThread = ((_this$props$relation7 = this.props.relation) === null || _this$props$relation7 === void 0 ? void 0 : _this$props$relation7.rel_type) !== _event.RelationType.Thread;

          if (!_SettingsStore.default.getValue("feature_thread") || isNotThread) {
            _dispatcher.default.dispatch({
              action: `effects.${effect.command}`
            });
          }
        }
      });

      if (_SettingsStore.default.getValue("Performance.addSendMessageTimingMetadata")) {
        prom.then(resp => {
          (0, _sendTimePerformanceMetrics.sendRoundTripMetric)(this.props.mxClient, roomId, resp.event_id);
        });
      }

      _CountlyAnalytics.default.instance.trackSendMessage(startTime, prom, roomId, false, !!replyToEvent, content);
    }

    this.sendHistoryManager.save(model, replyToEvent); // clear composer

    model.reset([]);
    (_this$editorRef$curre12 = this.editorRef.current) === null || _this$editorRef$curre12 === void 0 ? void 0 : _this$editorRef$curre12.clearUndoHistory();
    (_this$editorRef$curre13 = this.editorRef.current) === null || _this$editorRef$curre13 === void 0 ? void 0 : _this$editorRef$curre13.focus();
    this.clearStoredEditorState();

    if (_SettingsStore.default.getValue("scrollToBottomOnMessageSent")) {
      _dispatcher.default.dispatch({
        action: "scroll_to_bottom",
        timelineRenderingType: this.context.timelineRenderingType
      });
    }
  }

  componentWillUnmount() {
    _dispatcher.default.unregister(this.dispatcherRef);

    window.removeEventListener("beforeunload", this.saveStoredEditorState);
    this.saveStoredEditorState();
  } // TODO: [REACT-WARNING] Move this to constructor


  UNSAFE_componentWillMount() {
    // eslint-disable-line
    const partCreator = new _parts.CommandPartCreator(this.props.room, this.props.mxClient);
    const parts = this.restoreStoredEditorState(partCreator) || [];
    this.model = new _model.default(parts, partCreator);
    this.dispatcherRef = _dispatcher.default.register(this.onAction);
    this.sendHistoryManager = new _SendHistoryManager.default(this.props.room.roomId, 'mx_cider_history_');
  }

  get editorStateKey() {
    var _this$props$replyToEv;

    let key = `mx_cider_state_${this.props.room.roomId}`;
    const thread = (_this$props$replyToEv = this.props.replyToEvent) === null || _this$props$replyToEv === void 0 ? void 0 : _this$props$replyToEv.getThread();

    if (thread) {
      key += `_${thread.id}`;
    }

    return key;
  }

  clearStoredEditorState() {
    localStorage.removeItem(this.editorStateKey);
  }

  restoreStoredEditorState(partCreator) {
    var _this$props$relation8;

    const replyingToThread = ((_this$props$relation8 = this.props.relation) === null || _this$props$relation8 === void 0 ? void 0 : _this$props$relation8.key) === _event.RelationType.Thread;

    if (replyingToThread) {
      return null;
    }

    const json = localStorage.getItem(this.editorStateKey);

    if (json) {
      try {
        const {
          parts: serializedParts,
          replyEventId
        } = JSON.parse(json);
        const parts = serializedParts.map(p => partCreator.deserializePart(p));

        if (replyEventId) {
          _dispatcher.default.dispatch({
            action: 'reply_to_event',
            event: this.props.room.findEventById(replyEventId),
            context: this.context.timelineRenderingType
          });
        }

        return parts;
      } catch (e) {
        _logger.logger.error(e);
      }
    }
  } // should save state when editor has contents or reply is open


  render() {
    var _this$props$relation9;

    const threadId = ((_this$props$relation9 = this.props.relation) === null || _this$props$relation9 === void 0 ? void 0 : _this$props$relation9.rel_type) === _event.RelationType.Thread ? this.props.relation.event_id : null;
    return /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_SendMessageComposer",
      onClick: this.focusComposer,
      onKeyDown: this.onKeyDown
    }, /*#__PURE__*/_react.default.createElement(_BasicMessageComposer.default, {
      onChange: this.onChange,
      ref: this.editorRef,
      model: this.model,
      room: this.props.room,
      threadId: threadId,
      label: this.props.placeholder,
      placeholder: this.props.placeholder,
      onPaste: this.onPaste,
      disabled: this.props.disabled
    }));
  }

}, (0, _defineProperty2.default)(_class2, "contextType", _RoomContext.default), _temp)) || _class);
exports.SendMessageComposer = SendMessageComposer;
const SendMessageComposerWithMatrixClient = (0, _MatrixClientContext.withMatrixClientHOC)(SendMessageComposer);
var _default = SendMessageComposerWithMatrixClient;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL3Jvb21zL1NlbmRNZXNzYWdlQ29tcG9zZXIudHN4Il0sIm5hbWVzIjpbImFkZFJlcGx5VG9NZXNzYWdlQ29udGVudCIsImNvbnRlbnQiLCJyZXBseVRvRXZlbnQiLCJwZXJtYWxpbmtDcmVhdG9yIiwicmVwbHlDb250ZW50IiwiUmVwbHlDaGFpbiIsIm1ha2VSZXBseU1peEluIiwiT2JqZWN0IiwiYXNzaWduIiwibmVzdGVkUmVwbHkiLCJnZXROZXN0ZWRSZXBseVRleHQiLCJmb3JtYXR0ZWRfYm9keSIsImh0bWwiLCJib2R5IiwiYXR0YWNoUmVsYXRpb24iLCJyZWxhdGlvbiIsImNyZWF0ZU1lc3NhZ2VDb250ZW50IiwibW9kZWwiLCJpc0Vtb3RlIiwibXNndHlwZSIsImZvcm1hdHRlZEJvZHkiLCJmb3JjZUhUTUwiLCJmb3JtYXQiLCJpc1F1aWNrUmVhY3Rpb24iLCJwYXJ0cyIsImxlbmd0aCIsInRleHQiLCJoYXNTaG9ydGN1dCIsInN0YXJ0c1dpdGgiLCJlbW9qaU1hdGNoIiwibWF0Y2giLCJFTU9KSV9SRUdFWCIsInN1YnN0cmluZyIsIlNlbmRNZXNzYWdlQ29tcG9zZXIiLCJSZWFjdCIsIkNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJjb250ZXh0IiwiZXZlbnQiLCJlZGl0b3JSZWYiLCJjdXJyZW50IiwiaXNDb21wb3NpbmciLCJyZXBseWluZ1RvVGhyZWFkIiwia2V5IiwiUmVsYXRpb25UeXBlIiwiVGhyZWFkIiwiYWN0aW9uIiwiZ2V0TWVzc2FnZUNvbXBvc2VyQWN0aW9uIiwiTWVzc2FnZUNvbXBvc2VyQWN0aW9uIiwiU2VuZCIsInNlbmRNZXNzYWdlIiwicHJldmVudERlZmF1bHQiLCJTZWxlY3RQcmV2U2VuZEhpc3RvcnkiLCJTZWxlY3ROZXh0U2VuZEhpc3RvcnkiLCJzZWxlY3RlZCIsInNlbGVjdFNlbmRIaXN0b3J5IiwiRWRpdFByZXZNZXNzYWdlIiwiaXNTZWxlY3Rpb25Db2xsYXBzZWQiLCJpc0NhcmV0QXRTdGFydCIsImV2ZW50cyIsImxpdmVUaW1lbGluZSIsImdldEV2ZW50cyIsImNvbmNhdCIsInJvb20iLCJnZXRQZW5kaW5nRXZlbnRzIiwiZWRpdEV2ZW50IiwiaXNGb3J3YXJkIiwiZGlzIiwiZGlzcGF0Y2giLCJBY3Rpb24iLCJFZGl0RXZlbnQiLCJ0aW1lbGluZVJlbmRlcmluZ1R5cGUiLCJDYW5jZWxFZGl0aW5nIiwicHJlcGFyZVRvRW5jcnlwdCIsImlzRW1wdHkiLCJzaG91bGRTYXZlU3RvcmVkRWRpdG9yU3RhdGUiLCJpdGVtIiwiU2VuZEhpc3RvcnlNYW5hZ2VyIiwiY3JlYXRlSXRlbSIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJlZGl0b3JTdGF0ZUtleSIsIkpTT04iLCJzdHJpbmdpZnkiLCJjbGVhclN0b3JlZEVkaXRvclN0YXRlIiwicGF5bG9hZCIsImRpc2FibGVkIiwiRm9jdXNTZW5kTWVzc2FnZUNvbXBvc2VyIiwiVGltZWxpbmVSZW5kZXJpbmdUeXBlIiwiUm9vbSIsImZvY3VzIiwiQ29tcG9zZXJJbnNlcnQiLCJjb21wb3NlclR5cGUiLCJDb21wb3NlclR5cGUiLCJ1c2VySWQiLCJpbnNlcnRNZW50aW9uIiwiaW5zZXJ0UXVvdGVkTWVzc2FnZSIsImluc2VydFBsYWludGV4dCIsImNsaXBib2FyZERhdGEiLCJmaWxlcyIsInR5cGVzIiwiaW5jbHVkZXMiLCJDb250ZW50TWVzc2FnZXMiLCJzaGFyZWRJbnN0YW5jZSIsInNlbmRDb250ZW50TGlzdFRvUm9vbSIsIkFycmF5IiwiZnJvbSIsInJvb21JZCIsIm14Q2xpZW50Iiwib25DaGFuZ2UiLCJpc0NyeXB0b0VuYWJsZWQiLCJpc1Jvb21FbmNyeXB0ZWQiLCJsZWFkaW5nIiwidHJhaWxpbmciLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwic2F2ZVN0b3JlZEVkaXRvclN0YXRlIiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJldlByb3BzIiwiZGlmZmVyZW50RXZlbnRUYXJnZXQiLCJldmVudF9pZCIsInRocmVhZENoYW5nZWQiLCJwYXJ0Q3JlYXRvciIsIkNvbW1hbmRQYXJ0Q3JlYXRvciIsInJlc3RvcmVTdG9yZWRFZGl0b3JTdGF0ZSIsInJlc2V0IiwidXAiLCJkZWx0YSIsInNlbmRIaXN0b3J5TWFuYWdlciIsImN1cnJlbnRJbmRleCIsImhpc3RvcnkiLCJjdXJyZW50bHlDb21wb3NlZEVkaXRvclN0YXRlIiwic2VyaWFsaXplUGFydHMiLCJyZXBseUV2ZW50SWQiLCJnZXRJdGVtIiwiZmluZEV2ZW50QnlJZCIsImlzU2xhc2hDb21tYW5kIiwiZmlyc3RQYXJ0IiwidHlwZSIsIlR5cGUiLCJDb21tYW5kIiwiUGxhaW4iLCJQaWxsQ2FuZGlkYXRlIiwic2VuZFF1aWNrUmVhY3Rpb24iLCJ0aW1lbGluZSIsInJlYWN0aW9uIiwiaSIsImdldFR5cGUiLCJFdmVudFR5cGUiLCJSb29tTWVzc2FnZSIsInNob3VsZFJlYWN0IiwibGFzdE1lc3NhZ2UiLCJNYXRyaXhDbGllbnRQZWciLCJnZXQiLCJnZXRVc2VySWQiLCJtZXNzYWdlUmVhY3Rpb25zIiwiZ2V0VW5maWx0ZXJlZFRpbWVsaW5lU2V0IiwiZ2V0UmVsYXRpb25zRm9yRXZlbnQiLCJnZXRJZCIsIkFubm90YXRpb24iLCJSZWFjdGlvbiIsIm15UmVhY3Rpb25FdmVudHMiLCJnZXRBbm5vdGF0aW9uc0J5U2VuZGVyIiwibXlSZWFjdGlvbktleXMiLCJmaWx0ZXIiLCJpc1JlZGFjdGVkIiwibWFwIiwiZ2V0UmVsYXRpb24iLCJzZW5kRXZlbnQiLCJnZXRSb29tSWQiLCJnZXRTbGFzaENvbW1hbmQiLCJjb21tYW5kVGV4dCIsInJlZHVjZSIsInBhcnQiLCJyZXNvdXJjZUlkIiwiY21kIiwiYXJncyIsInJ1blNsYXNoQ29tbWFuZCIsInRocmVhZElkIiwicmVsX3R5cGUiLCJyZXN1bHQiLCJydW4iLCJtZXNzYWdlQ29udGVudCIsImVycm9yIiwicHJvbWlzZSIsImNhdGVnb3J5IiwiQ29tbWFuZENhdGVnb3JpZXMiLCJtZXNzYWdlcyIsImVyciIsImxvZ2dlciIsImlzU2VydmVyRXJyb3IiLCJ0aXRsZSIsImVyclRleHQiLCJtZXNzYWdlIiwiTW9kYWwiLCJjcmVhdGVUcmFja2VkRGlhbG9nIiwiRXJyb3JEaWFsb2ciLCJkZXNjcmlwdGlvbiIsImxvZyIsIlNldHRpbmdzU3RvcmUiLCJnZXRWYWx1ZSIsImluZGV4T2ZMYXN0UGFydCIsInBvc2l0aW9uSW5MYXN0UGFydCIsInJlcGxhY2VFbW90aWNvbiIsIkRvY3VtZW50UG9zaXRpb24iLCJSRUdFWF9FTU9USUNPTiIsInNob3VsZFNlbmQiLCJmaW5pc2hlZCIsIlF1ZXN0aW9uRGlhbG9nIiwiY29kZSIsInQiLCJidXR0b24iLCJzZW5kQW55d2F5Iiwic3RhcnRUaW1lIiwiQ291bnRseUFuYWx5dGljcyIsImdldFRpbWVzdGFtcCIsInRyaW0iLCJwcm9tIiwiQ0hBVF9FRkZFQ1RTIiwiZm9yRWFjaCIsImVmZmVjdCIsImVtb2ppcyIsImlzTm90VGhyZWFkIiwiY29tbWFuZCIsInRoZW4iLCJyZXNwIiwiaW5zdGFuY2UiLCJ0cmFja1NlbmRNZXNzYWdlIiwic2F2ZSIsImNsZWFyVW5kb0hpc3RvcnkiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInVucmVnaXN0ZXIiLCJkaXNwYXRjaGVyUmVmIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQiLCJFZGl0b3JNb2RlbCIsInJlZ2lzdGVyIiwib25BY3Rpb24iLCJ0aHJlYWQiLCJnZXRUaHJlYWQiLCJpZCIsInJlbW92ZUl0ZW0iLCJqc29uIiwic2VyaWFsaXplZFBhcnRzIiwicGFyc2UiLCJwIiwiZGVzZXJpYWxpemVQYXJ0IiwiZSIsInJlbmRlciIsImZvY3VzQ29tcG9zZXIiLCJvbktleURvd24iLCJwbGFjZWhvbGRlciIsIm9uUGFzdGUiLCJSb29tQ29udGV4dCIsIlNlbmRNZXNzYWdlQ29tcG9zZXJXaXRoTWF0cml4Q2xpZW50Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBU0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBR0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBLFNBQVNBLHdCQUFULENBQ0lDLE9BREosRUFFSUMsWUFGSixFQUdJQyxnQkFISixFQUlRO0FBQ0osUUFBTUMsWUFBWSxHQUFHQyxvQkFBV0MsY0FBWCxDQUEwQkosWUFBMUIsQ0FBckI7O0FBQ0FLLEVBQUFBLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjUCxPQUFkLEVBQXVCRyxZQUF2QixFQUZJLENBSUo7QUFDQTs7QUFDQSxRQUFNSyxXQUFXLEdBQUdKLG9CQUFXSyxrQkFBWCxDQUE4QlIsWUFBOUIsRUFBNENDLGdCQUE1QyxDQUFwQjs7QUFDQSxNQUFJTSxXQUFKLEVBQWlCO0FBQ2IsUUFBSVIsT0FBTyxDQUFDVSxjQUFaLEVBQTRCO0FBQ3hCVixNQUFBQSxPQUFPLENBQUNVLGNBQVIsR0FBeUJGLFdBQVcsQ0FBQ0csSUFBWixHQUFtQlgsT0FBTyxDQUFDVSxjQUFwRDtBQUNIOztBQUNEVixJQUFBQSxPQUFPLENBQUNZLElBQVIsR0FBZUosV0FBVyxDQUFDSSxJQUFaLEdBQW1CWixPQUFPLENBQUNZLElBQTFDO0FBQ0g7QUFDSjs7QUFFTSxTQUFTQyxjQUFULENBQ0hiLE9BREcsRUFFSGMsUUFGRyxFQUdDO0FBQ0osTUFBSUEsUUFBSixFQUFjO0FBQ1ZkLElBQUFBLE9BQU8sQ0FBQyxjQUFELENBQVAsbUNBQ09jLFFBRFAsR0FFT2QsT0FBTyxDQUFDLGNBQUQsQ0FGZDtBQUlIO0FBQ0osQyxDQUVEOzs7QUFDTyxTQUFTZSxvQkFBVCxDQUNIQyxLQURHLEVBRUhmLFlBRkcsRUFHSGEsUUFIRyxFQUlIWixnQkFKRyxFQUtLO0FBQ1IsUUFBTWUsT0FBTyxHQUFHLDhCQUFjRCxLQUFkLENBQWhCOztBQUNBLE1BQUlDLE9BQUosRUFBYTtBQUNURCxJQUFBQSxLQUFLLEdBQUcsa0NBQWtCQSxLQUFsQixDQUFSO0FBQ0g7O0FBQ0QsTUFBSSwyQkFBV0EsS0FBWCxFQUFrQixJQUFsQixDQUFKLEVBQTZCO0FBQ3pCQSxJQUFBQSxLQUFLLEdBQUcsNEJBQVlBLEtBQVosRUFBbUIsR0FBbkIsQ0FBUjtBQUNIOztBQUNEQSxFQUFBQSxLQUFLLEdBQUcsZ0NBQWdCQSxLQUFoQixDQUFSO0FBRUEsUUFBTUosSUFBSSxHQUFHLDhCQUFjSSxLQUFkLENBQWI7QUFDQSxRQUFNaEIsT0FBaUIsR0FBRztBQUN0QmtCLElBQUFBLE9BQU8sRUFBRUQsT0FBTyxHQUFHLFNBQUgsR0FBZSxRQURUO0FBRXRCTCxJQUFBQSxJQUFJLEVBQUVBO0FBRmdCLEdBQTFCO0FBSUEsUUFBTU8sYUFBYSxHQUFHLHNDQUFzQkgsS0FBdEIsRUFBNkI7QUFBRUksSUFBQUEsU0FBUyxFQUFFLENBQUMsQ0FBQ25CO0FBQWYsR0FBN0IsQ0FBdEI7O0FBQ0EsTUFBSWtCLGFBQUosRUFBbUI7QUFDZm5CLElBQUFBLE9BQU8sQ0FBQ3FCLE1BQVIsR0FBaUIsd0JBQWpCO0FBQ0FyQixJQUFBQSxPQUFPLENBQUNVLGNBQVIsR0FBeUJTLGFBQXpCO0FBQ0g7O0FBRUQsTUFBSWxCLFlBQUosRUFBa0I7QUFDZEYsSUFBQUEsd0JBQXdCLENBQUNDLE9BQUQsRUFBVUMsWUFBVixFQUF3QkMsZ0JBQXhCLENBQXhCO0FBQ0g7O0FBRUQsTUFBSVksUUFBSixFQUFjO0FBQ1ZkLElBQUFBLE9BQU8sQ0FBQyxjQUFELENBQVAsbUNBQ09jLFFBRFAsR0FFT2QsT0FBTyxDQUFDLGNBQUQsQ0FGZDtBQUlIOztBQUVELFNBQU9BLE9BQVA7QUFDSCxDLENBRUQ7OztBQUNPLFNBQVNzQixlQUFULENBQXlCTixLQUF6QixFQUFzRDtBQUN6RCxRQUFNTyxLQUFLLEdBQUdQLEtBQUssQ0FBQ08sS0FBcEI7QUFDQSxNQUFJQSxLQUFLLENBQUNDLE1BQU4sSUFBZ0IsQ0FBcEIsRUFBdUIsT0FBTyxLQUFQO0FBQ3ZCLFFBQU1DLElBQUksR0FBRyw4QkFBY1QsS0FBZCxDQUFiLENBSHlELENBSXpEO0FBQ0E7O0FBQ0EsTUFBSU8sS0FBSyxDQUFDQyxNQUFOLElBQWdCLENBQXBCLEVBQXVCO0FBQ25CLFVBQU1FLFdBQVcsR0FBR0QsSUFBSSxDQUFDRSxVQUFMLENBQWdCLEdBQWhCLEtBQXdCRixJQUFJLENBQUNFLFVBQUwsQ0FBZ0IsSUFBaEIsQ0FBNUM7QUFDQSxVQUFNQyxVQUFVLEdBQUdILElBQUksQ0FBQ0ksS0FBTCxDQUFXQyx1QkFBWCxDQUFuQjs7QUFDQSxRQUFJSixXQUFXLElBQUlFLFVBQWYsSUFBNkJBLFVBQVUsQ0FBQ0osTUFBWCxJQUFxQixDQUF0RCxFQUF5RDtBQUNyRCxhQUFPSSxVQUFVLENBQUMsQ0FBRCxDQUFWLEtBQWtCSCxJQUFJLENBQUNNLFNBQUwsQ0FBZSxDQUFmLENBQWxCLElBQ0hILFVBQVUsQ0FBQyxDQUFELENBQVYsS0FBa0JILElBQUksQ0FBQ00sU0FBTCxDQUFlLENBQWYsQ0FEdEI7QUFFSDtBQUNKOztBQUNELFNBQU8sS0FBUDtBQUNIOztJQWFZQyxtQixXQURaLGdEQUFxQixpQ0FBckIsQyxtQ0FBRCxNQUNhQSxtQkFEYixTQUN5Q0MsZUFBTUMsU0FEL0MsQ0FDb0Y7QUFXaEZDLEVBQUFBLFdBQVcsQ0FBQ0MsS0FBRCxFQUFtQ0MsT0FBbkMsRUFBbUY7QUFDMUYsVUFBTUQsS0FBTjtBQUQwRjtBQUFBO0FBQUEsa0VBTmpFLHVCQU1pRTtBQUFBLGlEQUxqRSxJQUtpRTtBQUFBLHdFQUpyQyxJQUlxQztBQUFBO0FBQUE7QUFBQSxxREF3QnpFRSxLQUFELElBQWdDO0FBQUE7O0FBQ2hEO0FBQ0EsbUNBQUksS0FBS0MsU0FBTCxDQUFlQyxPQUFuQixrREFBSSxzQkFBd0JDLFdBQXhCLENBQW9DSCxLQUFwQyxDQUFKLEVBQWdEO0FBQzVDO0FBQ0g7O0FBQ0QsWUFBTUksZ0JBQWdCLEdBQUcsOEJBQUtOLEtBQUwsQ0FBV3RCLFFBQVgsOEVBQXFCNkIsR0FBckIsTUFBNkJDLG9CQUFhQyxNQUFuRTtBQUNBLFlBQU1DLE1BQU0sR0FBRyxpREFBd0JDLHdCQUF4QixDQUFpRFQsS0FBakQsQ0FBZjs7QUFDQSxjQUFRUSxNQUFSO0FBQ0ksYUFBS0UsMENBQXNCQyxJQUEzQjtBQUNJLGVBQUtDLFdBQUw7QUFDQVosVUFBQUEsS0FBSyxDQUFDYSxjQUFOO0FBQ0E7O0FBQ0osYUFBS0gsMENBQXNCSSxxQkFBM0I7QUFDQSxhQUFLSiwwQ0FBc0JLLHFCQUEzQjtBQUFrRDtBQUM5QztBQUNBLGtCQUFNQyxRQUFRLEdBQUcsS0FBS0MsaUJBQUwsQ0FBdUJULE1BQU0sS0FBS0UsMENBQXNCSSxxQkFBeEQsQ0FBakI7O0FBQ0EsZ0JBQUlFLFFBQUosRUFBYztBQUNWO0FBQ0FoQixjQUFBQSxLQUFLLENBQUNhLGNBQU47QUFDSDs7QUFDRDtBQUNIOztBQUNELGFBQUtILDBDQUFzQlEsZUFBM0I7QUFDSTtBQUNBLGNBQUksK0JBQUtqQixTQUFMLENBQWVDLE9BQWYsMEVBQXdCaUIsb0JBQXhCLGdDQUFrRCxLQUFLbEIsU0FBTCxDQUFlQyxPQUFqRSxtREFBa0QsdUJBQXdCa0IsY0FBeEIsRUFBdEQsRUFBZ0c7QUFDNUYsa0JBQU1DLE1BQU0sR0FDUixLQUFLdEIsT0FBTCxDQUFhdUIsWUFBYixDQUEwQkMsU0FBMUIsR0FDS0MsTUFETCxDQUNZcEIsZ0JBQWdCLEdBQUcsRUFBSCxHQUFRLEtBQUtOLEtBQUwsQ0FBVzJCLElBQVgsQ0FBZ0JDLGdCQUFoQixFQURwQyxDQURKO0FBR0Esa0JBQU1DLFNBQVMsR0FBRyxtQ0FBa0I7QUFDaENOLGNBQUFBLE1BRGdDO0FBRWhDTyxjQUFBQSxTQUFTLEVBQUU7QUFGcUIsYUFBbEIsQ0FBbEI7O0FBSUEsZ0JBQUlELFNBQUosRUFBZTtBQUNYO0FBQ0EzQixjQUFBQSxLQUFLLENBQUNhLGNBQU47O0FBQ0FnQixrQ0FBSUMsUUFBSixDQUFhO0FBQ1R0QixnQkFBQUEsTUFBTSxFQUFFdUIsZ0JBQU9DLFNBRE47QUFFVGhDLGdCQUFBQSxLQUFLLEVBQUUyQixTQUZFO0FBR1RNLGdCQUFBQSxxQkFBcUIsRUFBRSxLQUFLbEMsT0FBTCxDQUFha0M7QUFIM0IsZUFBYjtBQUtIO0FBQ0o7O0FBQ0Q7O0FBQ0osYUFBS3ZCLDBDQUFzQndCLGFBQTNCO0FBQ0lMLDhCQUFJQyxRQUFKLENBQWE7QUFDVHRCLFlBQUFBLE1BQU0sRUFBRSxnQkFEQztBQUVUUixZQUFBQSxLQUFLLEVBQUUsSUFGRTtBQUdURCxZQUFBQSxPQUFPLEVBQUUsS0FBS0EsT0FBTCxDQUFha0M7QUFIYixXQUFiOztBQUtBOztBQUNKO0FBQ0ksY0FBSSxLQUFLRSxnQkFBVCxFQUEyQjtBQUN2QjtBQUNBLGlCQUFLQSxnQkFBTDtBQUNIOztBQS9DVDtBQWlESCxLQWhGNkY7QUFBQSx1RUE0WnhELE1BQWU7QUFDakQsYUFBTyxDQUFDLEtBQUt6RCxLQUFMLENBQVcwRCxPQUFaLElBQXVCLENBQUMsQ0FBQyxLQUFLdEMsS0FBTCxDQUFXbkMsWUFBM0M7QUFDSCxLQTlaNkY7QUFBQSxpRUFnYTlELE1BQVk7QUFDeEMsVUFBSSxLQUFLMEUsMkJBQUwsRUFBSixFQUF3QztBQUNwQyxjQUFNQyxJQUFJLEdBQUdDLDRCQUFtQkMsVUFBbkIsQ0FBOEIsS0FBSzlELEtBQW5DLEVBQTBDLEtBQUtvQixLQUFMLENBQVduQyxZQUFyRCxDQUFiOztBQUNBOEUsUUFBQUEsWUFBWSxDQUFDQyxPQUFiLENBQXFCLEtBQUtDLGNBQTFCLEVBQTBDQyxJQUFJLENBQUNDLFNBQUwsQ0FBZVAsSUFBZixDQUExQztBQUNILE9BSEQsTUFHTztBQUNILGFBQUtRLHNCQUFMO0FBQ0g7QUFDSixLQXZhNkY7QUFBQSxvREF5YTFFQyxPQUFELElBQWtDO0FBQ2pEO0FBQ0E7QUFDQSxVQUFJLEtBQUtqRCxLQUFMLENBQVdrRCxRQUFmLEVBQXlCOztBQUV6QixjQUFRRCxPQUFPLENBQUN2QyxNQUFoQjtBQUNJLGFBQUssZ0JBQUw7QUFDQSxhQUFLdUIsZ0JBQU9rQix3QkFBWjtBQUNJLGNBQUksQ0FBQ0YsT0FBTyxDQUFDaEQsT0FBUixJQUFtQm1ELG1DQUFzQkMsSUFBMUMsTUFBb0QsS0FBS3BELE9BQUwsQ0FBYWtDLHFCQUFyRSxFQUE0RjtBQUFBOztBQUN4RiwyQ0FBS2hDLFNBQUwsQ0FBZUMsT0FBZixrRkFBd0JrRCxLQUF4QjtBQUNIOztBQUNEOztBQUNKLGFBQUtyQixnQkFBT3NCLGNBQVo7QUFDSSxjQUFJTixPQUFPLENBQUNkLHFCQUFSLEtBQWtDLEtBQUtsQyxPQUFMLENBQWFrQyxxQkFBbkQsRUFBMEU7QUFDMUUsY0FBSWMsT0FBTyxDQUFDTyxZQUFSLEtBQXlCQyxvQ0FBYTVDLElBQTFDLEVBQWdEOztBQUVoRCxjQUFJb0MsT0FBTyxDQUFDUyxNQUFaLEVBQW9CO0FBQUE7O0FBQ2hCLDJDQUFLdkQsU0FBTCxDQUFlQyxPQUFmLGtGQUF3QnVELGFBQXhCLENBQXNDVixPQUFPLENBQUNTLE1BQTlDO0FBQ0gsV0FGRCxNQUVPLElBQUlULE9BQU8sQ0FBQy9DLEtBQVosRUFBbUI7QUFBQTs7QUFDdEIsMkNBQUtDLFNBQUwsQ0FBZUMsT0FBZixrRkFBd0J3RCxtQkFBeEIsQ0FBNENYLE9BQU8sQ0FBQy9DLEtBQXBEO0FBQ0gsV0FGTSxNQUVBLElBQUkrQyxPQUFPLENBQUM1RCxJQUFaLEVBQWtCO0FBQUE7O0FBQ3JCLDJDQUFLYyxTQUFMLENBQWVDLE9BQWYsa0ZBQXdCeUQsZUFBeEIsQ0FBd0NaLE9BQU8sQ0FBQzVELElBQWhEO0FBQ0g7O0FBQ0Q7QUFsQlI7QUFvQkgsS0FsYzZGO0FBQUEsbURBb2MzRWEsS0FBRCxJQUFvRDtBQUNsRSxZQUFNO0FBQUU0RCxRQUFBQTtBQUFGLFVBQW9CNUQsS0FBMUIsQ0FEa0UsQ0FFbEU7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsVUFBSTRELGFBQWEsQ0FBQ0MsS0FBZCxDQUFvQjNFLE1BQXBCLElBQThCLENBQUMwRSxhQUFhLENBQUNFLEtBQWQsQ0FBb0JDLFFBQXBCLENBQTZCLFVBQTdCLENBQW5DLEVBQTZFO0FBQ3pFQyxpQ0FBZ0JDLGNBQWhCLEdBQWlDQyxxQkFBakMsQ0FDSUMsS0FBSyxDQUFDQyxJQUFOLENBQVdSLGFBQWEsQ0FBQ0MsS0FBekIsQ0FESixFQUNxQyxLQUFLL0QsS0FBTCxDQUFXMkIsSUFBWCxDQUFnQjRDLE1BRHJELEVBQzZELEtBQUt2RSxLQUFMLENBQVd0QixRQUR4RSxFQUNrRixLQUFLc0IsS0FBTCxDQUFXd0UsUUFEN0Y7O0FBR0EsZUFBTyxJQUFQLENBSnlFLENBSTVEO0FBQ2hCO0FBQ0osS0FoZDZGO0FBQUEsb0RBa2QzRSxNQUFZO0FBQzNCLFVBQUksS0FBS3hFLEtBQUwsQ0FBV3lFLFFBQWYsRUFBeUIsS0FBS3pFLEtBQUwsQ0FBV3lFLFFBQVgsQ0FBb0IsS0FBSzdGLEtBQXpCO0FBQzVCLEtBcGQ2RjtBQUFBLHlEQXNkdEUsTUFBWTtBQUFBOztBQUNoQyxxQ0FBS3VCLFNBQUwsQ0FBZUMsT0FBZixrRkFBd0JrRCxLQUF4QjtBQUNILEtBeGQ2Rjs7QUFFMUYsUUFBSSxLQUFLdEQsS0FBTCxDQUFXd0UsUUFBWCxDQUFvQkUsZUFBcEIsTUFBeUMsS0FBSzFFLEtBQUwsQ0FBV3dFLFFBQVgsQ0FBb0JHLGVBQXBCLENBQW9DLEtBQUszRSxLQUFMLENBQVcyQixJQUFYLENBQWdCNEMsTUFBcEQsQ0FBN0MsRUFBMEc7QUFDdEcsV0FBS2xDLGdCQUFMLEdBQXdCLHNCQUFTLE1BQU07QUFDbkMsYUFBS3JDLEtBQUwsQ0FBV3dFLFFBQVgsQ0FBb0JuQyxnQkFBcEIsQ0FBcUMsS0FBS3JDLEtBQUwsQ0FBVzJCLElBQWhEO0FBQ0gsT0FGdUIsRUFFckIsS0FGcUIsRUFFZDtBQUFFaUQsUUFBQUEsT0FBTyxFQUFFLElBQVg7QUFBaUJDLFFBQUFBLFFBQVEsRUFBRTtBQUEzQixPQUZjLENBQXhCO0FBR0g7O0FBRURDLElBQUFBLE1BQU0sQ0FBQ0MsZ0JBQVAsQ0FBd0IsY0FBeEIsRUFBd0MsS0FBS0MscUJBQTdDO0FBQ0g7O0FBRU1DLEVBQUFBLGtCQUFrQixDQUFDQyxTQUFELEVBQTZDO0FBQUE7O0FBQ2xFLFVBQU01RSxnQkFBZ0IsR0FBRywrQkFBS04sS0FBTCxDQUFXdEIsUUFBWCxnRkFBcUI2QixHQUFyQixNQUE2QkMsb0JBQWFDLE1BQW5FO0FBQ0EsVUFBTTBFLG9CQUFvQixHQUFHLCtCQUFLbkYsS0FBTCxDQUFXdEIsUUFBWCxnRkFBcUIwRyxRQUFyQiw4QkFBa0NGLFNBQVMsQ0FBQ3hHLFFBQTVDLHdEQUFrQyxvQkFBb0IwRyxRQUF0RCxDQUE3QjtBQUVBLFVBQU1DLGFBQWEsR0FBRy9FLGdCQUFnQixJQUFLNkUsb0JBQTNDOztBQUNBLFFBQUlFLGFBQUosRUFBbUI7QUFBQTs7QUFDZixZQUFNQyxXQUFXLEdBQUcsSUFBSUMseUJBQUosQ0FBdUIsS0FBS3ZGLEtBQUwsQ0FBVzJCLElBQWxDLEVBQXdDLEtBQUszQixLQUFMLENBQVd3RSxRQUFuRCxDQUFwQjtBQUNBLFlBQU1yRixLQUFLLEdBQUcsS0FBS3FHLHdCQUFMLENBQThCRixXQUE5QixLQUE4QyxFQUE1RDtBQUNBLFdBQUsxRyxLQUFMLENBQVc2RyxLQUFYLENBQWlCdEcsS0FBakI7QUFDQSxxQ0FBS2dCLFNBQUwsQ0FBZUMsT0FBZixrRkFBd0JrRCxLQUF4QjtBQUNIO0FBQ0o7O0FBNEREO0FBQ0E7QUFDUW5DLEVBQUFBLGlCQUFpQixDQUFDdUUsRUFBRCxFQUF1QjtBQUM1QyxVQUFNQyxLQUFLLEdBQUdELEVBQUUsR0FBRyxDQUFDLENBQUosR0FBUSxDQUF4QixDQUQ0QyxDQUU1Qzs7QUFDQSxRQUFJLEtBQUtFLGtCQUFMLENBQXdCQyxZQUF4QixLQUF5QyxLQUFLRCxrQkFBTCxDQUF3QkUsT0FBeEIsQ0FBZ0MxRyxNQUE3RSxFQUFxRjtBQUNqRjtBQUNBLFVBQUksQ0FBQ3NHLEVBQUwsRUFBUztBQUNMLGVBQU8sS0FBUDtBQUNIOztBQUNELFdBQUtLLDRCQUFMLEdBQW9DLEtBQUtuSCxLQUFMLENBQVdvSCxjQUFYLEVBQXBDO0FBQ0gsS0FORCxNQU1PLElBQUksS0FBS0osa0JBQUwsQ0FBd0JDLFlBQXhCLEdBQXVDRixLQUF2QyxLQUFpRCxLQUFLQyxrQkFBTCxDQUF3QkUsT0FBeEIsQ0FBZ0MxRyxNQUFyRixFQUE2RjtBQUNoRztBQUNBLFdBQUtSLEtBQUwsQ0FBVzZHLEtBQVgsQ0FBaUIsS0FBS00sNEJBQXRCO0FBQ0EsV0FBS0gsa0JBQUwsQ0FBd0JDLFlBQXhCLEdBQXVDLEtBQUtELGtCQUFMLENBQXdCRSxPQUF4QixDQUFnQzFHLE1BQXZFO0FBQ0EsYUFBTyxJQUFQO0FBQ0g7O0FBQ0QsVUFBTTtBQUFFRCxNQUFBQSxLQUFGO0FBQVM4RyxNQUFBQTtBQUFULFFBQTBCLEtBQUtMLGtCQUFMLENBQXdCTSxPQUF4QixDQUFnQ1AsS0FBaEMsQ0FBaEM7O0FBQ0E1RCx3QkFBSUMsUUFBSixDQUFhO0FBQ1R0QixNQUFBQSxNQUFNLEVBQUUsZ0JBREM7QUFFVFIsTUFBQUEsS0FBSyxFQUFFK0YsWUFBWSxHQUFHLEtBQUtqRyxLQUFMLENBQVcyQixJQUFYLENBQWdCd0UsYUFBaEIsQ0FBOEJGLFlBQTlCLENBQUgsR0FBaUQsSUFGM0Q7QUFHVGhHLE1BQUFBLE9BQU8sRUFBRSxLQUFLQSxPQUFMLENBQWFrQztBQUhiLEtBQWI7O0FBS0EsUUFBSWhELEtBQUosRUFBVztBQUFBOztBQUNQLFdBQUtQLEtBQUwsQ0FBVzZHLEtBQVgsQ0FBaUJ0RyxLQUFqQjtBQUNBLHNDQUFLZ0IsU0FBTCxDQUFlQyxPQUFmLG9GQUF3QmtELEtBQXhCO0FBQ0g7O0FBQ0QsV0FBTyxJQUFQO0FBQ0g7O0FBRU84QyxFQUFBQSxjQUFjLEdBQVk7QUFDOUIsVUFBTWpILEtBQUssR0FBRyxLQUFLUCxLQUFMLENBQVdPLEtBQXpCO0FBQ0EsVUFBTWtILFNBQVMsR0FBR2xILEtBQUssQ0FBQyxDQUFELENBQXZCOztBQUNBLFFBQUlrSCxTQUFKLEVBQWU7QUFDWCxVQUFJQSxTQUFTLENBQUNDLElBQVYsS0FBbUJDLFlBQUtDLE9BQXhCLElBQW1DSCxTQUFTLENBQUNoSCxJQUFWLENBQWVFLFVBQWYsQ0FBMEIsR0FBMUIsQ0FBbkMsSUFBcUUsQ0FBQzhHLFNBQVMsQ0FBQ2hILElBQVYsQ0FBZUUsVUFBZixDQUEwQixJQUExQixDQUExRSxFQUEyRztBQUN2RyxlQUFPLElBQVA7QUFDSCxPQUhVLENBSVg7QUFDQTtBQUNBOzs7QUFDQSxVQUFJOEcsU0FBUyxDQUFDaEgsSUFBVixDQUFlRSxVQUFmLENBQTBCLEdBQTFCLEtBQWtDLENBQUM4RyxTQUFTLENBQUNoSCxJQUFWLENBQWVFLFVBQWYsQ0FBMEIsSUFBMUIsQ0FBbkMsS0FDSThHLFNBQVMsQ0FBQ0MsSUFBVixLQUFtQkMsWUFBS0UsS0FBeEIsSUFBaUNKLFNBQVMsQ0FBQ0MsSUFBVixLQUFtQkMsWUFBS0csYUFEN0QsQ0FBSixFQUNpRjtBQUM3RSxlQUFPLElBQVA7QUFDSDtBQUNKOztBQUNELFdBQU8sS0FBUDtBQUNIOztBQUVPQyxFQUFBQSxpQkFBaUIsR0FBUztBQUM5QixVQUFNQyxRQUFRLEdBQUcsS0FBSzNHLE9BQUwsQ0FBYXVCLFlBQTlCO0FBQ0EsVUFBTUQsTUFBTSxHQUFHcUYsUUFBUSxDQUFDbkYsU0FBVCxFQUFmO0FBQ0EsVUFBTW9GLFFBQVEsR0FBRyxLQUFLakksS0FBTCxDQUFXTyxLQUFYLENBQWlCLENBQWpCLEVBQW9CRSxJQUFyQzs7QUFDQSxTQUFLLElBQUl5SCxDQUFDLEdBQUd2RixNQUFNLENBQUNuQyxNQUFQLEdBQWdCLENBQTdCLEVBQWdDMEgsQ0FBQyxJQUFJLENBQXJDLEVBQXdDQSxDQUFDLEVBQXpDLEVBQTZDO0FBQ3pDLFVBQUl2RixNQUFNLENBQUN1RixDQUFELENBQU4sQ0FBVUMsT0FBVixPQUF3QkMsaUJBQVVDLFdBQXRDLEVBQW1EO0FBQy9DLFlBQUlDLFdBQVcsR0FBRyxJQUFsQjtBQUNBLGNBQU1DLFdBQVcsR0FBRzVGLE1BQU0sQ0FBQ3VGLENBQUQsQ0FBMUI7O0FBQ0EsY0FBTXBELE1BQU0sR0FBRzBELGlDQUFnQkMsR0FBaEIsR0FBc0JDLFNBQXRCLEVBQWY7O0FBQ0EsY0FBTUMsZ0JBQWdCLEdBQUcsS0FBS3ZILEtBQUwsQ0FBVzJCLElBQVgsQ0FBZ0I2Rix3QkFBaEIsR0FDcEJDLG9CQURvQixDQUNDTixXQUFXLENBQUNPLEtBQVosRUFERCxFQUNzQmxILG9CQUFhbUgsVUFEbkMsRUFDK0NYLGlCQUFVWSxRQUR6RCxDQUF6QixDQUorQyxDQU8vQzs7QUFDQSxZQUFJTCxnQkFBSixFQUFzQjtBQUNsQixnQkFBTU0sZ0JBQWdCLEdBQUdOLGdCQUFnQixDQUFDTyxzQkFBakIsR0FBMENwRSxNQUExQyxLQUFxRCxFQUE5RTtBQUNBLGdCQUFNcUUsY0FBYyxHQUFHLENBQUMsR0FBR0YsZ0JBQUosRUFDbEJHLE1BRGtCLENBQ1g5SCxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDK0gsVUFBTixFQURDLEVBRWxCQyxHQUZrQixDQUVkaEksS0FBSyxJQUFJQSxLQUFLLENBQUNpSSxXQUFOLEdBQW9CNUgsR0FGZixDQUF2QjtBQUdBMkcsVUFBQUEsV0FBVyxHQUFHLENBQUNhLGNBQWMsQ0FBQzlELFFBQWYsQ0FBd0I0QyxRQUF4QixDQUFmO0FBQ0g7O0FBQ0QsWUFBSUssV0FBSixFQUFpQjtBQUNiRSwyQ0FBZ0JDLEdBQWhCLEdBQXNCZSxTQUF0QixDQUFnQ2pCLFdBQVcsQ0FBQ2tCLFNBQVosRUFBaEMsRUFBeURyQixpQkFBVVksUUFBbkUsRUFBNkU7QUFDekUsNEJBQWdCO0FBQ1osMEJBQVlwSCxvQkFBYW1ILFVBRGI7QUFFWiwwQkFBWVIsV0FBVyxDQUFDTyxLQUFaLEVBRkE7QUFHWixxQkFBT2I7QUFISztBQUR5RCxXQUE3RTs7QUFPQTlFLDhCQUFJQyxRQUFKLENBQWE7QUFBRXRCLFlBQUFBLE1BQU0sRUFBRTtBQUFWLFdBQWI7QUFDSDs7QUFDRDtBQUNIO0FBQ0o7QUFDSjs7QUFFTzRILEVBQUFBLGVBQWUsR0FBOEI7QUFDakQsVUFBTUMsV0FBVyxHQUFHLEtBQUszSixLQUFMLENBQVdPLEtBQVgsQ0FBaUJxSixNQUFqQixDQUF3QixDQUFDbkosSUFBRCxFQUFPb0osSUFBUCxLQUFnQjtBQUN4RDtBQUNBLFVBQUlBLElBQUksQ0FBQ25DLElBQUwsS0FBYyxXQUFsQixFQUErQjtBQUMzQixlQUFPakgsSUFBSSxHQUFHb0osSUFBSSxDQUFDQyxVQUFuQjtBQUNIOztBQUNELGFBQU9ySixJQUFJLEdBQUdvSixJQUFJLENBQUNwSixJQUFuQjtBQUNILEtBTm1CLEVBTWpCLEVBTmlCLENBQXBCO0FBT0EsVUFBTTtBQUFFc0osTUFBQUEsR0FBRjtBQUFPQyxNQUFBQTtBQUFQLFFBQWdCLCtCQUFXTCxXQUFYLENBQXRCO0FBQ0EsV0FBTyxDQUFDSSxHQUFELEVBQU1DLElBQU4sRUFBWUwsV0FBWixDQUFQO0FBQ0g7O0FBRTRCLFFBQWZNLGVBQWUsQ0FBQ0YsR0FBRCxFQUFlQyxJQUFmLEVBQTRDO0FBQUE7O0FBQ3JFLFVBQU1FLFFBQVEsR0FBRywrQkFBSzlJLEtBQUwsQ0FBV3RCLFFBQVgsZ0ZBQXFCcUssUUFBckIsTUFBa0N2SSxvQkFBYUMsTUFBL0MsNEJBQ1gsS0FBS1QsS0FBTCxDQUFXdEIsUUFEQSwwREFDWCxzQkFBcUIwRyxRQURWLEdBRVgsSUFGTjtBQUlBLFVBQU00RCxNQUFNLEdBQUdMLEdBQUcsQ0FBQ00sR0FBSixDQUFRLEtBQUtqSixLQUFMLENBQVcyQixJQUFYLENBQWdCNEMsTUFBeEIsRUFBZ0N1RSxRQUFoQyxFQUEwQ0YsSUFBMUMsQ0FBZjtBQUNBLFFBQUlNLGNBQUo7QUFDQSxRQUFJQyxLQUFLLEdBQUdILE1BQU0sQ0FBQ0csS0FBbkI7O0FBQ0EsUUFBSUgsTUFBTSxDQUFDSSxPQUFYLEVBQW9CO0FBQ2hCLFVBQUk7QUFDQSxZQUFJVCxHQUFHLENBQUNVLFFBQUosS0FBaUJDLGlDQUFrQkMsUUFBdkMsRUFBaUQ7QUFDN0M7QUFDQUwsVUFBQUEsY0FBYyxHQUFHLE1BQU1GLE1BQU0sQ0FBQ0ksT0FBOUI7QUFDSCxTQUhELE1BR087QUFDSCxnQkFBTUosTUFBTSxDQUFDSSxPQUFiO0FBQ0g7QUFDSixPQVBELENBT0UsT0FBT0ksR0FBUCxFQUFZO0FBQ1ZMLFFBQUFBLEtBQUssR0FBR0ssR0FBUjtBQUNIO0FBQ0o7O0FBQ0QsUUFBSUwsS0FBSixFQUFXO0FBQ1BNLHFCQUFPTixLQUFQLENBQWEscUJBQWIsRUFBb0NBLEtBQXBDLEVBRE8sQ0FFUDs7O0FBQ0EsWUFBTU8sYUFBYSxHQUFHLENBQUMsQ0FBQ1YsTUFBTSxDQUFDSSxPQUEvQjtBQUNBLFlBQU1PLEtBQUssR0FBR0QsYUFBYSxHQUFHLDBCQUFJLGNBQUosQ0FBSCxHQUF5QiwwQkFBSSxlQUFKLENBQXBEO0FBRUEsVUFBSUUsT0FBSjs7QUFDQSxVQUFJLE9BQU9ULEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDM0JTLFFBQUFBLE9BQU8sR0FBR1QsS0FBVjtBQUNILE9BRkQsTUFFTyxJQUFJQSxLQUFLLENBQUNVLE9BQVYsRUFBbUI7QUFDdEJELFFBQUFBLE9BQU8sR0FBR1QsS0FBSyxDQUFDVSxPQUFoQjtBQUNILE9BRk0sTUFFQTtBQUNIRCxRQUFBQSxPQUFPLEdBQUcseUJBQUcsK0RBQUgsQ0FBVjtBQUNIOztBQUVERSxxQkFBTUMsbUJBQU4sQ0FBMEJKLEtBQTFCLEVBQWlDLEVBQWpDLEVBQXFDSyxvQkFBckMsRUFBa0Q7QUFDOUNMLFFBQUFBLEtBQUssRUFBRSx5QkFBR0EsS0FBSCxDQUR1QztBQUU5Q00sUUFBQUEsV0FBVyxFQUFFTDtBQUZpQyxPQUFsRDtBQUlILEtBbkJELE1BbUJPO0FBQ0hILHFCQUFPUyxHQUFQLENBQVcsa0JBQVg7O0FBQ0EsVUFBSWhCLGNBQUosRUFBb0IsT0FBT0EsY0FBUDtBQUN2QjtBQUNKOztBQUV1QixRQUFYcEksV0FBVyxHQUFrQjtBQUFBOztBQUN0QyxVQUFNbEMsS0FBSyxHQUFHLEtBQUtBLEtBQW5COztBQUVBLFFBQUlBLEtBQUssQ0FBQzBELE9BQVYsRUFBbUI7QUFDZjtBQUNILEtBTHFDLENBT3RDOzs7QUFDQSxRQUFJNkgsdUJBQWNDLFFBQWQsQ0FBdUIsdUNBQXZCLENBQUosRUFBcUU7QUFBQTs7QUFDakUsWUFBTUMsZUFBZSxHQUFHekwsS0FBSyxDQUFDTyxLQUFOLENBQVlDLE1BQVosR0FBcUIsQ0FBN0M7QUFDQSxZQUFNa0wsa0JBQWtCLEdBQUcxTCxLQUFLLENBQUNPLEtBQU4sQ0FBWWtMLGVBQVosRUFBNkJoTCxJQUE3QixDQUFrQ0QsTUFBN0Q7QUFDQSxzQ0FBS2UsU0FBTCxDQUFlQyxPQUFmLG9GQUF3Qm1LLGVBQXhCLENBQ0ksSUFBSUMsaUJBQUosQ0FBcUJILGVBQXJCLEVBQXNDQyxrQkFBdEMsQ0FESixFQUVJRyxvQ0FGSjtBQUlIOztBQUVELFVBQU01TSxZQUFZLEdBQUcsS0FBS21DLEtBQUwsQ0FBV25DLFlBQWhDO0FBQ0EsUUFBSTZNLFVBQVUsR0FBRyxJQUFqQjtBQUNBLFFBQUk5TSxPQUFKOztBQUVBLFFBQUksQ0FBQyw4QkFBY2dCLEtBQWQsQ0FBRCxJQUF5QixLQUFLd0gsY0FBTCxFQUE3QixFQUFvRDtBQUNoRCxZQUFNLENBQUN1QyxHQUFELEVBQU1DLElBQU4sRUFBWUwsV0FBWixJQUEyQixLQUFLRCxlQUFMLEVBQWpDOztBQUNBLFVBQUlLLEdBQUosRUFBUztBQUNMLFlBQUlBLEdBQUcsQ0FBQ1UsUUFBSixLQUFpQkMsaUNBQWtCQyxRQUF2QyxFQUFpRDtBQUM3QzNMLFVBQUFBLE9BQU8sR0FBRyxNQUFNLEtBQUtpTCxlQUFMLENBQXFCRixHQUFyQixFQUEwQkMsSUFBMUIsQ0FBaEI7O0FBQ0EsY0FBSS9LLFlBQUosRUFBa0I7QUFDZEYsWUFBQUEsd0JBQXdCLENBQ3BCQyxPQURvQixFQUVwQkMsWUFGb0IsRUFHcEIsS0FBS21DLEtBQUwsQ0FBV2xDLGdCQUhTLENBQXhCO0FBS0g7O0FBQ0RXLFVBQUFBLGNBQWMsQ0FBQ2IsT0FBRCxFQUFVLEtBQUtvQyxLQUFMLENBQVd0QixRQUFyQixDQUFkO0FBQ0gsU0FWRCxNQVVPO0FBQ0gsZUFBS21LLGVBQUwsQ0FBcUJGLEdBQXJCLEVBQTBCQyxJQUExQjtBQUNBOEIsVUFBQUEsVUFBVSxHQUFHLEtBQWI7QUFDSDtBQUNKLE9BZkQsTUFlTztBQUNIO0FBQ0EsY0FBTTtBQUFFQyxVQUFBQTtBQUFGLFlBQWViLGVBQU1DLG1CQUFOLENBQTBCLGlCQUExQixFQUE2QyxFQUE3QyxFQUFpRGEsdUJBQWpELEVBQWlFO0FBQ2xGakIsVUFBQUEsS0FBSyxFQUFFLHlCQUFHLGlCQUFILENBRDJFO0FBRWxGTSxVQUFBQSxXQUFXLGVBQUUsdURBQ1Qsd0NBQ00seUJBQUcsdUNBQUgsRUFBNEM7QUFBRTFCLFlBQUFBO0FBQUYsV0FBNUMsQ0FETixDQURTLGVBSVQsd0NBQ00seUJBQUcsZ0VBQ0QseUNBREYsRUFDNkMsRUFEN0MsRUFDaUQ7QUFDL0NzQyxZQUFBQSxJQUFJLEVBQUVDLENBQUMsaUJBQUksMkNBQVFBLENBQVI7QUFEb0MsV0FEakQsQ0FETixDQUpTLGVBVVQsd0NBQ00seUJBQUcseUVBQUgsRUFBOEUsRUFBOUUsRUFBa0Y7QUFDaEZELFlBQUFBLElBQUksRUFBRUMsQ0FBQyxpQkFBSSwyQ0FBUUEsQ0FBUjtBQURxRSxXQUFsRixDQUROLENBVlMsQ0FGcUU7QUFrQmxGQyxVQUFBQSxNQUFNLEVBQUUseUJBQUcsaUJBQUg7QUFsQjBFLFNBQWpFLENBQXJCOztBQW9CQSxjQUFNLENBQUNDLFVBQUQsSUFBZSxNQUFNTCxRQUEzQixDQXRCRyxDQXVCSDs7QUFDQSxZQUFJLENBQUNLLFVBQUwsRUFBaUI7QUFDcEI7QUFDSjs7QUFFRCxRQUFJOUwsZUFBZSxDQUFDTixLQUFELENBQW5CLEVBQTRCO0FBQ3hCOEwsTUFBQUEsVUFBVSxHQUFHLEtBQWI7QUFDQSxXQUFLL0QsaUJBQUw7QUFDSDs7QUFFRCxRQUFJK0QsVUFBSixFQUFnQjtBQUFBOztBQUNaLFlBQU1PLFNBQVMsR0FBR0MsMEJBQWlCQyxZQUFqQixFQUFsQjs7QUFDQSxZQUFNO0FBQUU1RyxRQUFBQTtBQUFGLFVBQWEsS0FBS3ZFLEtBQUwsQ0FBVzJCLElBQTlCOztBQUNBLFVBQUksQ0FBQy9ELE9BQUwsRUFBYztBQUNWQSxRQUFBQSxPQUFPLEdBQUdlLG9CQUFvQixDQUMxQkMsS0FEMEIsRUFFMUJmLFlBRjBCLEVBRzFCLEtBQUttQyxLQUFMLENBQVd0QixRQUhlLEVBSTFCLEtBQUtzQixLQUFMLENBQVdsQyxnQkFKZSxDQUE5QjtBQU1ILE9BVlcsQ0FXWjs7O0FBQ0EsVUFBSSxDQUFDRixPQUFPLENBQUNZLElBQVIsQ0FBYTRNLElBQWIsRUFBTCxFQUEwQjs7QUFFMUIsVUFBSWpCLHVCQUFjQyxRQUFkLENBQXVCLDBDQUF2QixDQUFKLEVBQXdFO0FBQ3BFLGtFQUF5QnhNLE9BQXpCO0FBQ0g7O0FBRUQsWUFBTWtMLFFBQVEsR0FBRywrQkFBSzlJLEtBQUwsQ0FBV3RCLFFBQVgsZ0ZBQXFCcUssUUFBckIsTUFBa0N2SSxvQkFBYUMsTUFBL0MsR0FDWCxLQUFLVCxLQUFMLENBQVd0QixRQUFYLENBQW9CMEcsUUFEVCxHQUVYLElBRk47QUFJQSxZQUFNaUcsSUFBSSxHQUFHLEtBQUtyTCxLQUFMLENBQVd3RSxRQUFYLENBQW9CMUQsV0FBcEIsQ0FBZ0N5RCxNQUFoQyxFQUF3Q3VFLFFBQXhDLEVBQWtEbEwsT0FBbEQsQ0FBYjs7QUFDQSxVQUFJQyxZQUFKLEVBQWtCO0FBQ2Q7QUFDQTtBQUNBa0UsNEJBQUlDLFFBQUosQ0FBYTtBQUNUdEIsVUFBQUEsTUFBTSxFQUFFLGdCQURDO0FBRVRSLFVBQUFBLEtBQUssRUFBRSxJQUZFO0FBR1RELFVBQUFBLE9BQU8sRUFBRSxLQUFLQSxPQUFMLENBQWFrQztBQUhiLFNBQWI7QUFLSDs7QUFDREosMEJBQUlDLFFBQUosQ0FBYTtBQUFFdEIsUUFBQUEsTUFBTSxFQUFFO0FBQVYsT0FBYjs7QUFDQTRLLDRCQUFhQyxPQUFiLENBQXNCQyxNQUFELElBQVk7QUFDN0IsWUFBSSwwQkFBYzVOLE9BQWQsRUFBdUI0TixNQUFNLENBQUNDLE1BQTlCLENBQUosRUFBMkM7QUFBQTs7QUFDdkM7QUFDQTtBQUNBLGdCQUFNQyxXQUFXLEdBQUcsK0JBQUsxTCxLQUFMLENBQVd0QixRQUFYLGdGQUFxQnFLLFFBQXJCLE1BQWtDdkksb0JBQWFDLE1BQW5FOztBQUNBLGNBQUksQ0FBQzBKLHVCQUFjQyxRQUFkLENBQXVCLGdCQUF2QixDQUFELElBQTZDc0IsV0FBakQsRUFBOEQ7QUFDMUQzSixnQ0FBSUMsUUFBSixDQUFhO0FBQUV0QixjQUFBQSxNQUFNLEVBQUcsV0FBVThLLE1BQU0sQ0FBQ0csT0FBUTtBQUFwQyxhQUFiO0FBQ0g7QUFDSjtBQUNKLE9BVEQ7O0FBVUEsVUFBSXhCLHVCQUFjQyxRQUFkLENBQXVCLDBDQUF2QixDQUFKLEVBQXdFO0FBQ3BFaUIsUUFBQUEsSUFBSSxDQUFDTyxJQUFMLENBQVVDLElBQUksSUFBSTtBQUNkLCtEQUFvQixLQUFLN0wsS0FBTCxDQUFXd0UsUUFBL0IsRUFBeUNELE1BQXpDLEVBQWlEc0gsSUFBSSxDQUFDekcsUUFBdEQ7QUFDSCxTQUZEO0FBR0g7O0FBQ0Q4RixnQ0FBaUJZLFFBQWpCLENBQTBCQyxnQkFBMUIsQ0FBMkNkLFNBQTNDLEVBQXNESSxJQUF0RCxFQUE0RDlHLE1BQTVELEVBQW9FLEtBQXBFLEVBQTJFLENBQUMsQ0FBQzFHLFlBQTdFLEVBQTJGRCxPQUEzRjtBQUNIOztBQUVELFNBQUtnSSxrQkFBTCxDQUF3Qm9HLElBQXhCLENBQTZCcE4sS0FBN0IsRUFBb0NmLFlBQXBDLEVBMUhzQyxDQTJIdEM7O0FBQ0FlLElBQUFBLEtBQUssQ0FBQzZHLEtBQU4sQ0FBWSxFQUFaO0FBQ0Esb0NBQUt0RixTQUFMLENBQWVDLE9BQWYsb0ZBQXdCNkwsZ0JBQXhCO0FBQ0Esb0NBQUs5TCxTQUFMLENBQWVDLE9BQWYsb0ZBQXdCa0QsS0FBeEI7QUFDQSxTQUFLTixzQkFBTDs7QUFDQSxRQUFJbUgsdUJBQWNDLFFBQWQsQ0FBdUIsNkJBQXZCLENBQUosRUFBMkQ7QUFDdkRySSwwQkFBSUMsUUFBSixDQUFhO0FBQ1R0QixRQUFBQSxNQUFNLEVBQUUsa0JBREM7QUFFVHlCLFFBQUFBLHFCQUFxQixFQUFFLEtBQUtsQyxPQUFMLENBQWFrQztBQUYzQixPQUFiO0FBSUg7QUFDSjs7QUFFRCtKLEVBQUFBLG9CQUFvQixHQUFHO0FBQ25Cbkssd0JBQUlvSyxVQUFKLENBQWUsS0FBS0MsYUFBcEI7O0FBQ0F0SCxJQUFBQSxNQUFNLENBQUN1SCxtQkFBUCxDQUEyQixjQUEzQixFQUEyQyxLQUFLckgscUJBQWhEO0FBQ0EsU0FBS0EscUJBQUw7QUFDSCxHQXJYK0UsQ0F1WGhGOzs7QUFDQXNILEVBQUFBLHlCQUF5QixHQUFHO0FBQUU7QUFDMUIsVUFBTWhILFdBQVcsR0FBRyxJQUFJQyx5QkFBSixDQUF1QixLQUFLdkYsS0FBTCxDQUFXMkIsSUFBbEMsRUFBd0MsS0FBSzNCLEtBQUwsQ0FBV3dFLFFBQW5ELENBQXBCO0FBQ0EsVUFBTXJGLEtBQUssR0FBRyxLQUFLcUcsd0JBQUwsQ0FBOEJGLFdBQTlCLEtBQThDLEVBQTVEO0FBQ0EsU0FBSzFHLEtBQUwsR0FBYSxJQUFJMk4sY0FBSixDQUFnQnBOLEtBQWhCLEVBQXVCbUcsV0FBdkIsQ0FBYjtBQUNBLFNBQUs4RyxhQUFMLEdBQXFCckssb0JBQUl5SyxRQUFKLENBQWEsS0FBS0MsUUFBbEIsQ0FBckI7QUFDQSxTQUFLN0csa0JBQUwsR0FBMEIsSUFBSW5ELDJCQUFKLENBQXVCLEtBQUt6QyxLQUFMLENBQVcyQixJQUFYLENBQWdCNEMsTUFBdkMsRUFBK0MsbUJBQS9DLENBQTFCO0FBQ0g7O0FBRXlCLE1BQWQxQixjQUFjLEdBQUc7QUFBQTs7QUFDekIsUUFBSXRDLEdBQUcsR0FBSSxrQkFBaUIsS0FBS1AsS0FBTCxDQUFXMkIsSUFBWCxDQUFnQjRDLE1BQU8sRUFBbkQ7QUFDQSxVQUFNbUksTUFBTSw0QkFBRyxLQUFLMU0sS0FBTCxDQUFXbkMsWUFBZCwwREFBRyxzQkFBeUI4TyxTQUF6QixFQUFmOztBQUNBLFFBQUlELE1BQUosRUFBWTtBQUNSbk0sTUFBQUEsR0FBRyxJQUFLLElBQUdtTSxNQUFNLENBQUNFLEVBQUcsRUFBckI7QUFDSDs7QUFDRCxXQUFPck0sR0FBUDtBQUNIOztBQUVPeUMsRUFBQUEsc0JBQXNCLEdBQVM7QUFDbkNMLElBQUFBLFlBQVksQ0FBQ2tLLFVBQWIsQ0FBd0IsS0FBS2hLLGNBQTdCO0FBQ0g7O0FBRU8yQyxFQUFBQSx3QkFBd0IsQ0FBQ0YsV0FBRCxFQUFtQztBQUFBOztBQUMvRCxVQUFNaEYsZ0JBQWdCLEdBQUcsK0JBQUtOLEtBQUwsQ0FBV3RCLFFBQVgsZ0ZBQXFCNkIsR0FBckIsTUFBNkJDLG9CQUFhQyxNQUFuRTs7QUFDQSxRQUFJSCxnQkFBSixFQUFzQjtBQUNsQixhQUFPLElBQVA7QUFDSDs7QUFFRCxVQUFNd00sSUFBSSxHQUFHbkssWUFBWSxDQUFDdUQsT0FBYixDQUFxQixLQUFLckQsY0FBMUIsQ0FBYjs7QUFDQSxRQUFJaUssSUFBSixFQUFVO0FBQ04sVUFBSTtBQUNBLGNBQU07QUFBRTNOLFVBQUFBLEtBQUssRUFBRTROLGVBQVQ7QUFBMEI5RyxVQUFBQTtBQUExQixZQUEyQ25ELElBQUksQ0FBQ2tLLEtBQUwsQ0FBV0YsSUFBWCxDQUFqRDtBQUNBLGNBQU0zTixLQUFhLEdBQUc0TixlQUFlLENBQUM3RSxHQUFoQixDQUFvQitFLENBQUMsSUFBSTNILFdBQVcsQ0FBQzRILGVBQVosQ0FBNEJELENBQTVCLENBQXpCLENBQXRCOztBQUNBLFlBQUloSCxZQUFKLEVBQWtCO0FBQ2RsRSw4QkFBSUMsUUFBSixDQUFhO0FBQ1R0QixZQUFBQSxNQUFNLEVBQUUsZ0JBREM7QUFFVFIsWUFBQUEsS0FBSyxFQUFFLEtBQUtGLEtBQUwsQ0FBVzJCLElBQVgsQ0FBZ0J3RSxhQUFoQixDQUE4QkYsWUFBOUIsQ0FGRTtBQUdUaEcsWUFBQUEsT0FBTyxFQUFFLEtBQUtBLE9BQUwsQ0FBYWtDO0FBSGIsV0FBYjtBQUtIOztBQUNELGVBQU9oRCxLQUFQO0FBQ0gsT0FYRCxDQVdFLE9BQU9nTyxDQUFQLEVBQVU7QUFDUjFELHVCQUFPTixLQUFQLENBQWFnRSxDQUFiO0FBQ0g7QUFDSjtBQUNKLEdBcGErRSxDQXNhaEY7OztBQStEQUMsRUFBQUEsTUFBTSxHQUFHO0FBQUE7O0FBQ0wsVUFBTXRFLFFBQVEsR0FBRywrQkFBSzlJLEtBQUwsQ0FBV3RCLFFBQVgsZ0ZBQXFCcUssUUFBckIsTUFBa0N2SSxvQkFBYUMsTUFBL0MsR0FDWCxLQUFLVCxLQUFMLENBQVd0QixRQUFYLENBQW9CMEcsUUFEVCxHQUVYLElBRk47QUFHQSx3QkFDSTtBQUFLLE1BQUEsU0FBUyxFQUFDLHdCQUFmO0FBQXdDLE1BQUEsT0FBTyxFQUFFLEtBQUtpSSxhQUF0RDtBQUFxRSxNQUFBLFNBQVMsRUFBRSxLQUFLQztBQUFyRixvQkFDSSw2QkFBQyw2QkFBRDtBQUNJLE1BQUEsUUFBUSxFQUFFLEtBQUs3SSxRQURuQjtBQUVJLE1BQUEsR0FBRyxFQUFFLEtBQUt0RSxTQUZkO0FBR0ksTUFBQSxLQUFLLEVBQUUsS0FBS3ZCLEtBSGhCO0FBSUksTUFBQSxJQUFJLEVBQUUsS0FBS29CLEtBQUwsQ0FBVzJCLElBSnJCO0FBS0ksTUFBQSxRQUFRLEVBQUVtSCxRQUxkO0FBTUksTUFBQSxLQUFLLEVBQUUsS0FBSzlJLEtBQUwsQ0FBV3VOLFdBTnRCO0FBT0ksTUFBQSxXQUFXLEVBQUUsS0FBS3ZOLEtBQUwsQ0FBV3VOLFdBUDVCO0FBUUksTUFBQSxPQUFPLEVBQUUsS0FBS0MsT0FSbEI7QUFTSSxNQUFBLFFBQVEsRUFBRSxLQUFLeE4sS0FBTCxDQUFXa0Q7QUFUekIsTUFESixDQURKO0FBZUg7O0FBeGYrRSxDLHdEQUMzRHVLLG9COztBQTBmekIsTUFBTUMsbUNBQW1DLEdBQUcsOENBQW9COU4sbUJBQXBCLENBQTVDO2VBQ2U4TixtQyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxOSAtIDIwMjEgVGhlIE1hdHJpeC5vcmcgRm91bmRhdGlvbiBDLkkuQy5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgUmVhY3QsIHsgQ2xpcGJvYXJkRXZlbnQsIGNyZWF0ZVJlZiwgS2V5Ym9hcmRFdmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBFTU9KSV9SRUdFWCBmcm9tICdlbW9qaWJhc2UtcmVnZXgnO1xuaW1wb3J0IHsgSUNvbnRlbnQsIE1hdHJpeEV2ZW50LCBJRXZlbnRSZWxhdGlvbiB9IGZyb20gJ21hdHJpeC1qcy1zZGsvc3JjL21vZGVscy9ldmVudCc7XG5pbXBvcnQgeyBEZWJvdW5jZWRGdW5jLCB0aHJvdHRsZSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBFdmVudFR5cGUsIFJlbGF0aW9uVHlwZSB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9AdHlwZXMvZXZlbnRcIjtcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9sb2dnZXJcIjtcblxuaW1wb3J0IGRpcyBmcm9tICcuLi8uLi8uLi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXInO1xuaW1wb3J0IEVkaXRvck1vZGVsIGZyb20gJy4uLy4uLy4uL2VkaXRvci9tb2RlbCc7XG5pbXBvcnQge1xuICAgIGNvbnRhaW5zRW1vdGUsXG4gICAgaHRtbFNlcmlhbGl6ZUlmTmVlZGVkLFxuICAgIHN0YXJ0c1dpdGgsXG4gICAgc3RyaXBFbW90ZUNvbW1hbmQsXG4gICAgc3RyaXBQcmVmaXgsXG4gICAgdGV4dFNlcmlhbGl6ZSxcbiAgICB1bmVzY2FwZU1lc3NhZ2UsXG59IGZyb20gJy4uLy4uLy4uL2VkaXRvci9zZXJpYWxpemUnO1xuaW1wb3J0IEJhc2ljTWVzc2FnZUNvbXBvc2VyLCB7IFJFR0VYX0VNT1RJQ09OIH0gZnJvbSBcIi4vQmFzaWNNZXNzYWdlQ29tcG9zZXJcIjtcbmltcG9ydCB7IENvbW1hbmRQYXJ0Q3JlYXRvciwgUGFydCwgUGFydENyZWF0b3IsIFNlcmlhbGl6ZWRQYXJ0LCBUeXBlIH0gZnJvbSAnLi4vLi4vLi4vZWRpdG9yL3BhcnRzJztcbmltcG9ydCBSZXBseUNoYWluIGZyb20gXCIuLi9lbGVtZW50cy9SZXBseUNoYWluXCI7XG5pbXBvcnQgeyBmaW5kRWRpdGFibGVFdmVudCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL0V2ZW50VXRpbHMnO1xuaW1wb3J0IFNlbmRIaXN0b3J5TWFuYWdlciBmcm9tIFwiLi4vLi4vLi4vU2VuZEhpc3RvcnlNYW5hZ2VyXCI7XG5pbXBvcnQgeyBDb21tYW5kLCBDb21tYW5kQ2F0ZWdvcmllcywgZ2V0Q29tbWFuZCB9IGZyb20gJy4uLy4uLy4uL1NsYXNoQ29tbWFuZHMnO1xuaW1wb3J0IE1vZGFsIGZyb20gJy4uLy4uLy4uL01vZGFsJztcbmltcG9ydCB7IF90LCBfdGQgfSBmcm9tICcuLi8uLi8uLi9sYW5ndWFnZUhhbmRsZXInO1xuaW1wb3J0IENvbnRlbnRNZXNzYWdlcyBmcm9tICcuLi8uLi8uLi9Db250ZW50TWVzc2FnZXMnO1xuaW1wb3J0IHsgd2l0aE1hdHJpeENsaWVudEhPQywgTWF0cml4Q2xpZW50UHJvcHMgfSBmcm9tIFwiLi4vLi4vLi4vY29udGV4dHMvTWF0cml4Q2xpZW50Q29udGV4dFwiO1xuaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSBcIi4uLy4uLy4uL2Rpc3BhdGNoZXIvYWN0aW9uc1wiO1xuaW1wb3J0IHsgY29udGFpbnNFbW9qaSB9IGZyb20gXCIuLi8uLi8uLi9lZmZlY3RzL3V0aWxzXCI7XG5pbXBvcnQgeyBDSEFUX0VGRkVDVFMgfSBmcm9tICcuLi8uLi8uLi9lZmZlY3RzJztcbmltcG9ydCBDb3VudGx5QW5hbHl0aWNzIGZyb20gXCIuLi8uLi8uLi9Db3VudGx5QW5hbHl0aWNzXCI7XG5pbXBvcnQgeyBNYXRyaXhDbGllbnRQZWcgfSBmcm9tIFwiLi4vLi4vLi4vTWF0cml4Q2xpZW50UGVnXCI7XG5pbXBvcnQgeyBnZXRLZXlCaW5kaW5nc01hbmFnZXIsIE1lc3NhZ2VDb21wb3NlckFjdGlvbiB9IGZyb20gJy4uLy4uLy4uL0tleUJpbmRpbmdzTWFuYWdlcic7XG5pbXBvcnQgeyByZXBsYWNlYWJsZUNvbXBvbmVudCB9IGZyb20gXCIuLi8uLi8uLi91dGlscy9yZXBsYWNlYWJsZUNvbXBvbmVudFwiO1xuaW1wb3J0IFNldHRpbmdzU3RvcmUgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvU2V0dGluZ3NTdG9yZSc7XG5pbXBvcnQgeyBSb29tUGVybWFsaW5rQ3JlYXRvciB9IGZyb20gXCIuLi8uLi8uLi91dGlscy9wZXJtYWxpbmtzL1Blcm1hbGlua3NcIjtcbmltcG9ydCB7IFJvb20gfSBmcm9tICdtYXRyaXgtanMtc2RrL3NyYy9tb2RlbHMvcm9vbSc7XG5pbXBvcnQgRXJyb3JEaWFsb2cgZnJvbSBcIi4uL2RpYWxvZ3MvRXJyb3JEaWFsb2dcIjtcbmltcG9ydCBRdWVzdGlvbkRpYWxvZyBmcm9tIFwiLi4vZGlhbG9ncy9RdWVzdGlvbkRpYWxvZ1wiO1xuaW1wb3J0IHsgQWN0aW9uUGF5bG9hZCB9IGZyb20gXCIuLi8uLi8uLi9kaXNwYXRjaGVyL3BheWxvYWRzXCI7XG5pbXBvcnQgeyBkZWNvcmF0ZVN0YXJ0U2VuZGluZ1RpbWUsIHNlbmRSb3VuZFRyaXBNZXRyaWMgfSBmcm9tIFwiLi4vLi4vLi4vc2VuZFRpbWVQZXJmb3JtYW5jZU1ldHJpY3NcIjtcbmltcG9ydCBSb29tQ29udGV4dCwgeyBUaW1lbGluZVJlbmRlcmluZ1R5cGUgfSBmcm9tICcuLi8uLi8uLi9jb250ZXh0cy9Sb29tQ29udGV4dCc7XG5pbXBvcnQgRG9jdW1lbnRQb3NpdGlvbiBmcm9tIFwiLi4vLi4vLi4vZWRpdG9yL3Bvc2l0aW9uXCI7XG5pbXBvcnQgeyBDb21wb3NlclR5cGUgfSBmcm9tIFwiLi4vLi4vLi4vZGlzcGF0Y2hlci9wYXlsb2Fkcy9Db21wb3Nlckluc2VydFBheWxvYWRcIjtcblxuZnVuY3Rpb24gYWRkUmVwbHlUb01lc3NhZ2VDb250ZW50KFxuICAgIGNvbnRlbnQ6IElDb250ZW50LFxuICAgIHJlcGx5VG9FdmVudDogTWF0cml4RXZlbnQsXG4gICAgcGVybWFsaW5rQ3JlYXRvcjogUm9vbVBlcm1hbGlua0NyZWF0b3IsXG4pOiB2b2lkIHtcbiAgICBjb25zdCByZXBseUNvbnRlbnQgPSBSZXBseUNoYWluLm1ha2VSZXBseU1peEluKHJlcGx5VG9FdmVudCk7XG4gICAgT2JqZWN0LmFzc2lnbihjb250ZW50LCByZXBseUNvbnRlbnQpO1xuXG4gICAgLy8gUGFydCBvZiBSZXBsaWVzIGZhbGxiYWNrIHN1cHBvcnQgLSBwcmVwZW5kIHRoZSB0ZXh0IHdlJ3JlIHNlbmRpbmdcbiAgICAvLyB3aXRoIHRoZSB0ZXh0IHdlJ3JlIHJlcGx5aW5nIHRvXG4gICAgY29uc3QgbmVzdGVkUmVwbHkgPSBSZXBseUNoYWluLmdldE5lc3RlZFJlcGx5VGV4dChyZXBseVRvRXZlbnQsIHBlcm1hbGlua0NyZWF0b3IpO1xuICAgIGlmIChuZXN0ZWRSZXBseSkge1xuICAgICAgICBpZiAoY29udGVudC5mb3JtYXR0ZWRfYm9keSkge1xuICAgICAgICAgICAgY29udGVudC5mb3JtYXR0ZWRfYm9keSA9IG5lc3RlZFJlcGx5Lmh0bWwgKyBjb250ZW50LmZvcm1hdHRlZF9ib2R5O1xuICAgICAgICB9XG4gICAgICAgIGNvbnRlbnQuYm9keSA9IG5lc3RlZFJlcGx5LmJvZHkgKyBjb250ZW50LmJvZHk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXR0YWNoUmVsYXRpb24oXG4gICAgY29udGVudDogSUNvbnRlbnQsXG4gICAgcmVsYXRpb24/OiBJRXZlbnRSZWxhdGlvbixcbik6IHZvaWQge1xuICAgIGlmIChyZWxhdGlvbikge1xuICAgICAgICBjb250ZW50WydtLnJlbGF0ZXNfdG8nXSA9IHtcbiAgICAgICAgICAgIC4uLnJlbGF0aW9uLCAvLyB0aGUgY29tcG9zZXIgY2FuIGhhdmUgYSBkZWZhdWx0XG4gICAgICAgICAgICAuLi5jb250ZW50WydtLnJlbGF0ZXNfdG8nXSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8vIGV4cG9ydGVkIGZvciB0ZXN0c1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VDb250ZW50KFxuICAgIG1vZGVsOiBFZGl0b3JNb2RlbCxcbiAgICByZXBseVRvRXZlbnQ6IE1hdHJpeEV2ZW50LFxuICAgIHJlbGF0aW9uOiBJRXZlbnRSZWxhdGlvbixcbiAgICBwZXJtYWxpbmtDcmVhdG9yOiBSb29tUGVybWFsaW5rQ3JlYXRvcixcbik6IElDb250ZW50IHtcbiAgICBjb25zdCBpc0Vtb3RlID0gY29udGFpbnNFbW90ZShtb2RlbCk7XG4gICAgaWYgKGlzRW1vdGUpIHtcbiAgICAgICAgbW9kZWwgPSBzdHJpcEVtb3RlQ29tbWFuZChtb2RlbCk7XG4gICAgfVxuICAgIGlmIChzdGFydHNXaXRoKG1vZGVsLCBcIi8vXCIpKSB7XG4gICAgICAgIG1vZGVsID0gc3RyaXBQcmVmaXgobW9kZWwsIFwiL1wiKTtcbiAgICB9XG4gICAgbW9kZWwgPSB1bmVzY2FwZU1lc3NhZ2UobW9kZWwpO1xuXG4gICAgY29uc3QgYm9keSA9IHRleHRTZXJpYWxpemUobW9kZWwpO1xuICAgIGNvbnN0IGNvbnRlbnQ6IElDb250ZW50ID0ge1xuICAgICAgICBtc2d0eXBlOiBpc0Vtb3RlID8gXCJtLmVtb3RlXCIgOiBcIm0udGV4dFwiLFxuICAgICAgICBib2R5OiBib2R5LFxuICAgIH07XG4gICAgY29uc3QgZm9ybWF0dGVkQm9keSA9IGh0bWxTZXJpYWxpemVJZk5lZWRlZChtb2RlbCwgeyBmb3JjZUhUTUw6ICEhcmVwbHlUb0V2ZW50IH0pO1xuICAgIGlmIChmb3JtYXR0ZWRCb2R5KSB7XG4gICAgICAgIGNvbnRlbnQuZm9ybWF0ID0gXCJvcmcubWF0cml4LmN1c3RvbS5odG1sXCI7XG4gICAgICAgIGNvbnRlbnQuZm9ybWF0dGVkX2JvZHkgPSBmb3JtYXR0ZWRCb2R5O1xuICAgIH1cblxuICAgIGlmIChyZXBseVRvRXZlbnQpIHtcbiAgICAgICAgYWRkUmVwbHlUb01lc3NhZ2VDb250ZW50KGNvbnRlbnQsIHJlcGx5VG9FdmVudCwgcGVybWFsaW5rQ3JlYXRvcik7XG4gICAgfVxuXG4gICAgaWYgKHJlbGF0aW9uKSB7XG4gICAgICAgIGNvbnRlbnRbJ20ucmVsYXRlc190byddID0ge1xuICAgICAgICAgICAgLi4ucmVsYXRpb24sXG4gICAgICAgICAgICAuLi5jb250ZW50WydtLnJlbGF0ZXNfdG8nXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGVudDtcbn1cblxuLy8gZXhwb3J0ZWQgZm9yIHRlc3RzXG5leHBvcnQgZnVuY3Rpb24gaXNRdWlja1JlYWN0aW9uKG1vZGVsOiBFZGl0b3JNb2RlbCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHBhcnRzID0gbW9kZWwucGFydHM7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCA9PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgdGV4dCA9IHRleHRTZXJpYWxpemUobW9kZWwpO1xuICAgIC8vIHNob3J0Y3V0IHRha2VzIHRoZSBmb3JtIFwiKzplbW9qaTpcIiBvciBcIisgOmVtb2ppOlwiXCJcbiAgICAvLyBjYW4gYmUgaW4gMSBvciAyIHBhcnRzXG4gICAgaWYgKHBhcnRzLmxlbmd0aCA8PSAyKSB7XG4gICAgICAgIGNvbnN0IGhhc1Nob3J0Y3V0ID0gdGV4dC5zdGFydHNXaXRoKFwiK1wiKSB8fCB0ZXh0LnN0YXJ0c1dpdGgoXCIrIFwiKTtcbiAgICAgICAgY29uc3QgZW1vamlNYXRjaCA9IHRleHQubWF0Y2goRU1PSklfUkVHRVgpO1xuICAgICAgICBpZiAoaGFzU2hvcnRjdXQgJiYgZW1vamlNYXRjaCAmJiBlbW9qaU1hdGNoLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZW1vamlNYXRjaFswXSA9PT0gdGV4dC5zdWJzdHJpbmcoMSkgfHxcbiAgICAgICAgICAgICAgICBlbW9qaU1hdGNoWzBdID09PSB0ZXh0LnN1YnN0cmluZygyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmludGVyZmFjZSBJU2VuZE1lc3NhZ2VDb21wb3NlclByb3BzIGV4dGVuZHMgTWF0cml4Q2xpZW50UHJvcHMge1xuICAgIHJvb206IFJvb207XG4gICAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gICAgcGVybWFsaW5rQ3JlYXRvcjogUm9vbVBlcm1hbGlua0NyZWF0b3I7XG4gICAgcmVsYXRpb24/OiBJRXZlbnRSZWxhdGlvbjtcbiAgICByZXBseVRvRXZlbnQ/OiBNYXRyaXhFdmVudDtcbiAgICBkaXNhYmxlZD86IGJvb2xlYW47XG4gICAgb25DaGFuZ2U/KG1vZGVsOiBFZGl0b3JNb2RlbCk6IHZvaWQ7XG59XG5cbkByZXBsYWNlYWJsZUNvbXBvbmVudChcInZpZXdzLnJvb21zLlNlbmRNZXNzYWdlQ29tcG9zZXJcIilcbmV4cG9ydCBjbGFzcyBTZW5kTWVzc2FnZUNvbXBvc2VyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PElTZW5kTWVzc2FnZUNvbXBvc2VyUHJvcHM+IHtcbiAgICBzdGF0aWMgY29udGV4dFR5cGUgPSBSb29tQ29udGV4dDtcbiAgICBwdWJsaWMgY29udGV4dCE6IFJlYWN0LkNvbnRleHRUeXBlPHR5cGVvZiBSb29tQ29udGV4dD47XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IHByZXBhcmVUb0VuY3J5cHQ/OiBEZWJvdW5jZWRGdW5jPCgpID0+IHZvaWQ+O1xuICAgIHByaXZhdGUgcmVhZG9ubHkgZWRpdG9yUmVmID0gY3JlYXRlUmVmPEJhc2ljTWVzc2FnZUNvbXBvc2VyPigpO1xuICAgIHByaXZhdGUgbW9kZWw6IEVkaXRvck1vZGVsID0gbnVsbDtcbiAgICBwcml2YXRlIGN1cnJlbnRseUNvbXBvc2VkRWRpdG9yU3RhdGU6IFNlcmlhbGl6ZWRQYXJ0W10gPSBudWxsO1xuICAgIHByaXZhdGUgZGlzcGF0Y2hlclJlZjogc3RyaW5nO1xuICAgIHByaXZhdGUgc2VuZEhpc3RvcnlNYW5hZ2VyOiBTZW5kSGlzdG9yeU1hbmFnZXI7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wczogSVNlbmRNZXNzYWdlQ29tcG9zZXJQcm9wcywgY29udGV4dDogUmVhY3QuQ29udGV4dFR5cGU8dHlwZW9mIFJvb21Db250ZXh0Pikge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm14Q2xpZW50LmlzQ3J5cHRvRW5hYmxlZCgpICYmIHRoaXMucHJvcHMubXhDbGllbnQuaXNSb29tRW5jcnlwdGVkKHRoaXMucHJvcHMucm9vbS5yb29tSWQpKSB7XG4gICAgICAgICAgICB0aGlzLnByZXBhcmVUb0VuY3J5cHQgPSB0aHJvdHRsZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5teENsaWVudC5wcmVwYXJlVG9FbmNyeXB0KHRoaXMucHJvcHMucm9vbSk7XG4gICAgICAgICAgICB9LCA2MDAwMCwgeyBsZWFkaW5nOiB0cnVlLCB0cmFpbGluZzogZmFsc2UgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCB0aGlzLnNhdmVTdG9yZWRFZGl0b3JTdGF0ZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IElTZW5kTWVzc2FnZUNvbXBvc2VyUHJvcHMpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgcmVwbHlpbmdUb1RocmVhZCA9IHRoaXMucHJvcHMucmVsYXRpb24/LmtleSA9PT0gUmVsYXRpb25UeXBlLlRocmVhZDtcbiAgICAgICAgY29uc3QgZGlmZmVyZW50RXZlbnRUYXJnZXQgPSB0aGlzLnByb3BzLnJlbGF0aW9uPy5ldmVudF9pZCAhPT0gcHJldlByb3BzLnJlbGF0aW9uPy5ldmVudF9pZDtcblxuICAgICAgICBjb25zdCB0aHJlYWRDaGFuZ2VkID0gcmVwbHlpbmdUb1RocmVhZCAmJiAoZGlmZmVyZW50RXZlbnRUYXJnZXQpO1xuICAgICAgICBpZiAodGhyZWFkQ2hhbmdlZCkge1xuICAgICAgICAgICAgY29uc3QgcGFydENyZWF0b3IgPSBuZXcgQ29tbWFuZFBhcnRDcmVhdG9yKHRoaXMucHJvcHMucm9vbSwgdGhpcy5wcm9wcy5teENsaWVudCk7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHRoaXMucmVzdG9yZVN0b3JlZEVkaXRvclN0YXRlKHBhcnRDcmVhdG9yKSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucmVzZXQocGFydHMpO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3JSZWYuY3VycmVudD8uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgb25LZXlEb3duID0gKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCA9PiB7XG4gICAgICAgIC8vIGlnbm9yZSBhbnkga2V5cHJlc3Mgd2hpbGUgZG9pbmcgSU1FIGNvbXBvc2l0aW9uc1xuICAgICAgICBpZiAodGhpcy5lZGl0b3JSZWYuY3VycmVudD8uaXNDb21wb3NpbmcoZXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVwbHlpbmdUb1RocmVhZCA9IHRoaXMucHJvcHMucmVsYXRpb24/LmtleSA9PT0gUmVsYXRpb25UeXBlLlRocmVhZDtcbiAgICAgICAgY29uc3QgYWN0aW9uID0gZ2V0S2V5QmluZGluZ3NNYW5hZ2VyKCkuZ2V0TWVzc2FnZUNvbXBvc2VyQWN0aW9uKGV2ZW50KTtcbiAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZUNvbXBvc2VyQWN0aW9uLlNlbmQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VDb21wb3NlckFjdGlvbi5TZWxlY3RQcmV2U2VuZEhpc3Rvcnk6XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VDb21wb3NlckFjdGlvbi5TZWxlY3ROZXh0U2VuZEhpc3Rvcnk6IHtcbiAgICAgICAgICAgICAgICAvLyBUcnkgc2VsZWN0IGNvbXBvc2VyIGhpc3RvcnlcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZCA9IHRoaXMuc2VsZWN0U2VuZEhpc3RvcnkoYWN0aW9uID09PSBNZXNzYWdlQ29tcG9zZXJBY3Rpb24uU2VsZWN0UHJldlNlbmRIaXN0b3J5KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UncmUgc2VsZWN0aW5nIGhpc3RvcnksIHNvIHByZXZlbnQgdGhlIGtleSBldmVudCBmcm9tIGRvaW5nIGFueXRoaW5nIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VDb21wb3NlckFjdGlvbi5FZGl0UHJldk1lc3NhZ2U6XG4gICAgICAgICAgICAgICAgLy8gc2VsZWN0aW9uIG11c3QgYmUgY29sbGFwc2VkIGFuZCBjYXJldCBhdCBzdGFydFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVkaXRvclJlZi5jdXJyZW50Py5pc1NlbGVjdGlvbkNvbGxhcHNlZCgpICYmIHRoaXMuZWRpdG9yUmVmLmN1cnJlbnQ/LmlzQ2FyZXRBdFN0YXJ0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnRzID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5saXZlVGltZWxpbmUuZ2V0RXZlbnRzKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHJlcGx5aW5nVG9UaHJlYWQgPyBbXSA6IHRoaXMucHJvcHMucm9vbS5nZXRQZW5kaW5nRXZlbnRzKCkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlZGl0RXZlbnQgPSBmaW5kRWRpdGFibGVFdmVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZvcndhcmQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVkaXRFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UncmUgc2VsZWN0aW5nIGhpc3RvcnksIHNvIHByZXZlbnQgdGhlIGtleSBldmVudCBmcm9tIGRvaW5nIGFueXRoaW5nIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogQWN0aW9uLkVkaXRFdmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZWRpdEV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lUmVuZGVyaW5nVHlwZTogdGhpcy5jb250ZXh0LnRpbWVsaW5lUmVuZGVyaW5nVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBNZXNzYWdlQ29tcG9zZXJBY3Rpb24uQ2FuY2VsRWRpdGluZzpcbiAgICAgICAgICAgICAgICBkaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdyZXBseV90b19ldmVudCcsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQudGltZWxpbmVSZW5kZXJpbmdUeXBlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmVwYXJlVG9FbmNyeXB0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgbGFzdCFcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmVwYXJlVG9FbmNyeXB0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHdlIGtlZXAgc2VudCBtZXNzYWdlcy9jb21tYW5kcyBpbiBhIHNlcGFyYXRlIGhpc3RvcnkgKHNlcGFyYXRlIGZyb20gdW5kbyBoaXN0b3J5KVxuICAgIC8vIHNvIHlvdSBjYW4gYWx0K3VwL2Rvd24gaW4gdGhlbVxuICAgIHByaXZhdGUgc2VsZWN0U2VuZEhpc3RvcnkodXA6IGJvb2xlYW4pOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgZGVsdGEgPSB1cCA/IC0xIDogMTtcbiAgICAgICAgLy8gVHJ1ZSBpZiB3ZSBhcmUgbm90IGN1cnJlbnRseSBzZWxlY3RpbmcgaGlzdG9yeSwgYnV0IGNvbXBvc2luZyBhIG1lc3NhZ2VcbiAgICAgICAgaWYgKHRoaXMuc2VuZEhpc3RvcnlNYW5hZ2VyLmN1cnJlbnRJbmRleCA9PT0gdGhpcy5zZW5kSGlzdG9yeU1hbmFnZXIuaGlzdG9yeS5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFdlIGNhbid0IGdvIGFueSBmdXJ0aGVyIC0gdGhlcmUgaXNuJ3QgYW55IG1vcmUgaGlzdG9yeSwgc28gbm9wLlxuICAgICAgICAgICAgaWYgKCF1cCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3VycmVudGx5Q29tcG9zZWRFZGl0b3JTdGF0ZSA9IHRoaXMubW9kZWwuc2VyaWFsaXplUGFydHMoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbmRIaXN0b3J5TWFuYWdlci5jdXJyZW50SW5kZXggKyBkZWx0YSA9PT0gdGhpcy5zZW5kSGlzdG9yeU1hbmFnZXIuaGlzdG9yeS5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFRydWUgd2hlbiB3ZSByZXR1cm4gdG8gdGhlIG1lc3NhZ2UgYmVpbmcgY29tcG9zZWQgY3VycmVudGx5XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnJlc2V0KHRoaXMuY3VycmVudGx5Q29tcG9zZWRFZGl0b3JTdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnNlbmRIaXN0b3J5TWFuYWdlci5jdXJyZW50SW5kZXggPSB0aGlzLnNlbmRIaXN0b3J5TWFuYWdlci5oaXN0b3J5Lmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcGFydHMsIHJlcGx5RXZlbnRJZCB9ID0gdGhpcy5zZW5kSGlzdG9yeU1hbmFnZXIuZ2V0SXRlbShkZWx0YSk7XG4gICAgICAgIGRpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICBhY3Rpb246ICdyZXBseV90b19ldmVudCcsXG4gICAgICAgICAgICBldmVudDogcmVwbHlFdmVudElkID8gdGhpcy5wcm9wcy5yb29tLmZpbmRFdmVudEJ5SWQocmVwbHlFdmVudElkKSA6IG51bGwsXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQudGltZWxpbmVSZW5kZXJpbmdUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBhcnRzKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnJlc2V0KHBhcnRzKTtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yUmVmLmN1cnJlbnQ/LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc1NsYXNoQ29tbWFuZCgpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSB0aGlzLm1vZGVsLnBhcnRzO1xuICAgICAgICBjb25zdCBmaXJzdFBhcnQgPSBwYXJ0c1swXTtcbiAgICAgICAgaWYgKGZpcnN0UGFydCkge1xuICAgICAgICAgICAgaWYgKGZpcnN0UGFydC50eXBlID09PSBUeXBlLkNvbW1hbmQgJiYgZmlyc3RQYXJ0LnRleHQuc3RhcnRzV2l0aChcIi9cIikgJiYgIWZpcnN0UGFydC50ZXh0LnN0YXJ0c1dpdGgoXCIvL1wiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYmUgZXh0cmEgcmVzaWxpZW50IHdoZW4gc29tZWhvdyB0aGUgQXV0b2NvbXBsZXRlV3JhcHBlck1vZGVsIG9yXG4gICAgICAgICAgICAvLyBDb21tYW5kUGFydENyZWF0b3IgZmFpbHMgdG8gaW5zZXJ0IGEgY29tbWFuZCBwYXJ0LCBzbyB3ZSBkb24ndCBzZW5kXG4gICAgICAgICAgICAvLyBhIGNvbW1hbmQgYXMgYSBtZXNzYWdlXG4gICAgICAgICAgICBpZiAoZmlyc3RQYXJ0LnRleHQuc3RhcnRzV2l0aChcIi9cIikgJiYgIWZpcnN0UGFydC50ZXh0LnN0YXJ0c1dpdGgoXCIvL1wiKVxuICAgICAgICAgICAgICAgICYmIChmaXJzdFBhcnQudHlwZSA9PT0gVHlwZS5QbGFpbiB8fCBmaXJzdFBhcnQudHlwZSA9PT0gVHlwZS5QaWxsQ2FuZGlkYXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNlbmRRdWlja1JlYWN0aW9uKCk6IHZvaWQge1xuICAgICAgICBjb25zdCB0aW1lbGluZSA9IHRoaXMuY29udGV4dC5saXZlVGltZWxpbmU7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IHRpbWVsaW5lLmdldEV2ZW50cygpO1xuICAgICAgICBjb25zdCByZWFjdGlvbiA9IHRoaXMubW9kZWwucGFydHNbMV0udGV4dDtcbiAgICAgICAgZm9yIChsZXQgaSA9IGV2ZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKGV2ZW50c1tpXS5nZXRUeXBlKCkgPT09IEV2ZW50VHlwZS5Sb29tTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGxldCBzaG91bGRSZWFjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdE1lc3NhZ2UgPSBldmVudHNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgdXNlcklkID0gTWF0cml4Q2xpZW50UGVnLmdldCgpLmdldFVzZXJJZCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VSZWFjdGlvbnMgPSB0aGlzLnByb3BzLnJvb20uZ2V0VW5maWx0ZXJlZFRpbWVsaW5lU2V0KClcbiAgICAgICAgICAgICAgICAgICAgLmdldFJlbGF0aW9uc0ZvckV2ZW50KGxhc3RNZXNzYWdlLmdldElkKCksIFJlbGF0aW9uVHlwZS5Bbm5vdGF0aW9uLCBFdmVudFR5cGUuUmVhY3Rpb24pO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhbHJlYWR5IHNlbnQgdGhpcyByZWFjdGlvbiwgZG9uJ3QgcmVkYWN0IGJ1dCBkb24ndCByZS1zZW5kXG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VSZWFjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbXlSZWFjdGlvbkV2ZW50cyA9IG1lc3NhZ2VSZWFjdGlvbnMuZ2V0QW5ub3RhdGlvbnNCeVNlbmRlcigpW3VzZXJJZF0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG15UmVhY3Rpb25LZXlzID0gWy4uLm15UmVhY3Rpb25FdmVudHNdXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGV2ZW50ID0+ICFldmVudC5pc1JlZGFjdGVkKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGV2ZW50ID0+IGV2ZW50LmdldFJlbGF0aW9uKCkua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkUmVhY3QgPSAhbXlSZWFjdGlvbktleXMuaW5jbHVkZXMocmVhY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkUmVhY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgTWF0cml4Q2xpZW50UGVnLmdldCgpLnNlbmRFdmVudChsYXN0TWVzc2FnZS5nZXRSb29tSWQoKSwgRXZlbnRUeXBlLlJlYWN0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIm0ucmVsYXRlc190b1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJyZWxfdHlwZVwiOiBSZWxhdGlvblR5cGUuQW5ub3RhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImV2ZW50X2lkXCI6IGxhc3RNZXNzYWdlLmdldElkKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJrZXlcIjogcmVhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZGlzLmRpc3BhdGNoKHsgYWN0aW9uOiBcIm1lc3NhZ2Vfc2VudFwiIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0U2xhc2hDb21tYW5kKCk6IFtDb21tYW5kLCBzdHJpbmcsIHN0cmluZ10ge1xuICAgICAgICBjb25zdCBjb21tYW5kVGV4dCA9IHRoaXMubW9kZWwucGFydHMucmVkdWNlKCh0ZXh0LCBwYXJ0KSA9PiB7XG4gICAgICAgICAgICAvLyB1c2UgbXhpZCB0byB0ZXh0aWZ5IHVzZXIgcGlsbHMgaW4gYSBjb21tYW5kXG4gICAgICAgICAgICBpZiAocGFydC50eXBlID09PSBcInVzZXItcGlsbFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQgKyBwYXJ0LnJlc291cmNlSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGV4dCArIHBhcnQudGV4dDtcbiAgICAgICAgfSwgXCJcIik7XG4gICAgICAgIGNvbnN0IHsgY21kLCBhcmdzIH0gPSBnZXRDb21tYW5kKGNvbW1hbmRUZXh0KTtcbiAgICAgICAgcmV0dXJuIFtjbWQsIGFyZ3MsIGNvbW1hbmRUZXh0XTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIHJ1blNsYXNoQ29tbWFuZChjbWQ6IENvbW1hbmQsIGFyZ3M6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCB0aHJlYWRJZCA9IHRoaXMucHJvcHMucmVsYXRpb24/LnJlbF90eXBlID09PSBSZWxhdGlvblR5cGUuVGhyZWFkXG4gICAgICAgICAgICA/IHRoaXMucHJvcHMucmVsYXRpb24/LmV2ZW50X2lkXG4gICAgICAgICAgICA6IG51bGw7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY21kLnJ1bih0aGlzLnByb3BzLnJvb20ucm9vbUlkLCB0aHJlYWRJZCwgYXJncyk7XG4gICAgICAgIGxldCBtZXNzYWdlQ29udGVudDtcbiAgICAgICAgbGV0IGVycm9yID0gcmVzdWx0LmVycm9yO1xuICAgICAgICBpZiAocmVzdWx0LnByb21pc2UpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGNtZC5jYXRlZ29yeSA9PT0gQ29tbWFuZENhdGVnb3JpZXMubWVzc2FnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGNvbW1hbmQgcmV0dXJucyBhIG1vZGlmaWVkIG1lc3NhZ2UgdGhhdCB3ZSBuZWVkIHRvIHBhc3Mgb25cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUNvbnRlbnQgPSBhd2FpdCByZXN1bHQucHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCByZXN1bHQucHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkNvbW1hbmQgZmFpbHVyZTogJXNcIiwgZXJyb3IpO1xuICAgICAgICAgICAgLy8gYXNzdW1lIHRoZSBlcnJvciBpcyBhIHNlcnZlciBlcnJvciB3aGVuIHRoZSBjb21tYW5kIGlzIGFzeW5jXG4gICAgICAgICAgICBjb25zdCBpc1NlcnZlckVycm9yID0gISFyZXN1bHQucHJvbWlzZTtcbiAgICAgICAgICAgIGNvbnN0IHRpdGxlID0gaXNTZXJ2ZXJFcnJvciA/IF90ZChcIlNlcnZlciBlcnJvclwiKSA6IF90ZChcIkNvbW1hbmQgZXJyb3JcIik7XG5cbiAgICAgICAgICAgIGxldCBlcnJUZXh0O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBlcnJUZXh0ID0gZXJyb3I7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBlcnJUZXh0ID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyVGV4dCA9IF90KFwiU2VydmVyIHVuYXZhaWxhYmxlLCBvdmVybG9hZGVkLCBvciBzb21ldGhpbmcgZWxzZSB3ZW50IHdyb25nLlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgTW9kYWwuY3JlYXRlVHJhY2tlZERpYWxvZyh0aXRsZSwgJycsIEVycm9yRGlhbG9nLCB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IF90KHRpdGxlKSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogZXJyVGV4dCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIkNvbW1hbmQgc3VjY2Vzcy5cIik7XG4gICAgICAgICAgICBpZiAobWVzc2FnZUNvbnRlbnQpIHJldHVybiBtZXNzYWdlQ29udGVudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBzZW5kTWVzc2FnZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLm1vZGVsO1xuXG4gICAgICAgIGlmIChtb2RlbC5pc0VtcHR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXBsYWNlIGVtb3RpY29uIGF0IHRoZSBlbmQgb2YgdGhlIG1lc3NhZ2VcbiAgICAgICAgaWYgKFNldHRpbmdzU3RvcmUuZ2V0VmFsdWUoJ01lc3NhZ2VDb21wb3NlcklucHV0LmF1dG9SZXBsYWNlRW1vamknKSkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXhPZkxhc3RQYXJ0ID0gbW9kZWwucGFydHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uSW5MYXN0UGFydCA9IG1vZGVsLnBhcnRzW2luZGV4T2ZMYXN0UGFydF0udGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmVkaXRvclJlZi5jdXJyZW50Py5yZXBsYWNlRW1vdGljb24oXG4gICAgICAgICAgICAgICAgbmV3IERvY3VtZW50UG9zaXRpb24oaW5kZXhPZkxhc3RQYXJ0LCBwb3NpdGlvbkluTGFzdFBhcnQpLFxuICAgICAgICAgICAgICAgIFJFR0VYX0VNT1RJQ09OLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlcGx5VG9FdmVudCA9IHRoaXMucHJvcHMucmVwbHlUb0V2ZW50O1xuICAgICAgICBsZXQgc2hvdWxkU2VuZCA9IHRydWU7XG4gICAgICAgIGxldCBjb250ZW50O1xuXG4gICAgICAgIGlmICghY29udGFpbnNFbW90ZShtb2RlbCkgJiYgdGhpcy5pc1NsYXNoQ29tbWFuZCgpKSB7XG4gICAgICAgICAgICBjb25zdCBbY21kLCBhcmdzLCBjb21tYW5kVGV4dF0gPSB0aGlzLmdldFNsYXNoQ29tbWFuZCgpO1xuICAgICAgICAgICAgaWYgKGNtZCkge1xuICAgICAgICAgICAgICAgIGlmIChjbWQuY2F0ZWdvcnkgPT09IENvbW1hbmRDYXRlZ29yaWVzLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBhd2FpdCB0aGlzLnJ1blNsYXNoQ29tbWFuZChjbWQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVwbHlUb0V2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRSZXBseVRvTWVzc2FnZUNvbnRlbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBseVRvRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5wZXJtYWxpbmtDcmVhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhdHRhY2hSZWxhdGlvbihjb250ZW50LCB0aGlzLnByb3BzLnJlbGF0aW9uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1blNsYXNoQ29tbWFuZChjbWQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRTZW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBhc2sgdGhlIHVzZXIgaWYgdGhlaXIgdW5rbm93biBjb21tYW5kIHNob3VsZCBiZSBzZW50IGFzIGEgbWVzc2FnZVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZmluaXNoZWQgfSA9IE1vZGFsLmNyZWF0ZVRyYWNrZWREaWFsb2coXCJVbmtub3duIGNvbW1hbmRcIiwgXCJcIiwgUXVlc3Rpb25EaWFsb2csIHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IF90KFwiVW5rbm93biBDb21tYW5kXCIpLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgX3QoXCJVbnJlY29nbmlzZWQgY29tbWFuZDogJShjb21tYW5kVGV4dClzXCIsIHsgY29tbWFuZFRleHQgfSkgfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBfdChcIllvdSBjYW4gdXNlIDxjb2RlPi9oZWxwPC9jb2RlPiB0byBsaXN0IGF2YWlsYWJsZSBjb21tYW5kcy4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkRpZCB5b3UgbWVhbiB0byBzZW5kIHRoaXMgYXMgYSBtZXNzYWdlP1wiLCB7fSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiB0ID0+IDxjb2RlPnsgdCB9PC9jb2RlPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSB9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IF90KFwiSGludDogQmVnaW4geW91ciBtZXNzYWdlIHdpdGggPGNvZGU+Ly88L2NvZGU+IHRvIHN0YXJ0IGl0IHdpdGggYSBzbGFzaC5cIiwge30sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogdCA9PiA8Y29kZT57IHQgfTwvY29kZT4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj4sXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbjogX3QoJ1NlbmQgYXMgbWVzc2FnZScpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IFtzZW5kQW55d2F5XSA9IGF3YWl0IGZpbmlzaGVkO1xuICAgICAgICAgICAgICAgIC8vIGlmICFzZW5kQW55d2F5IGJhaWwgdG8gbGV0IHRoZSB1c2VyIGVkaXQgdGhlIGNvbXBvc2VyIGFuZCB0cnkgYWdhaW5cbiAgICAgICAgICAgICAgICBpZiAoIXNlbmRBbnl3YXkpIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1F1aWNrUmVhY3Rpb24obW9kZWwpKSB7XG4gICAgICAgICAgICBzaG91bGRTZW5kID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnNlbmRRdWlja1JlYWN0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdWxkU2VuZCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gQ291bnRseUFuYWx5dGljcy5nZXRUaW1lc3RhbXAoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcm9vbUlkIH0gPSB0aGlzLnByb3BzLnJvb207XG4gICAgICAgICAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gY3JlYXRlTWVzc2FnZUNvbnRlbnQoXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgICAgICAgICByZXBseVRvRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMucmVsYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMucGVybWFsaW5rQ3JlYXRvcixcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9uJ3QgYm90aGVyIHNlbmRpbmcgYW4gZW1wdHkgbWVzc2FnZVxuICAgICAgICAgICAgaWYgKCFjb250ZW50LmJvZHkudHJpbSgpKSByZXR1cm47XG5cbiAgICAgICAgICAgIGlmIChTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFwiUGVyZm9ybWFuY2UuYWRkU2VuZE1lc3NhZ2VUaW1pbmdNZXRhZGF0YVwiKSkge1xuICAgICAgICAgICAgICAgIGRlY29yYXRlU3RhcnRTZW5kaW5nVGltZShjb250ZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdGhyZWFkSWQgPSB0aGlzLnByb3BzLnJlbGF0aW9uPy5yZWxfdHlwZSA9PT0gUmVsYXRpb25UeXBlLlRocmVhZFxuICAgICAgICAgICAgICAgID8gdGhpcy5wcm9wcy5yZWxhdGlvbi5ldmVudF9pZFxuICAgICAgICAgICAgICAgIDogbnVsbDtcblxuICAgICAgICAgICAgY29uc3QgcHJvbSA9IHRoaXMucHJvcHMubXhDbGllbnQuc2VuZE1lc3NhZ2Uocm9vbUlkLCB0aHJlYWRJZCwgY29udGVudCk7XG4gICAgICAgICAgICBpZiAocmVwbHlUb0V2ZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgcmVwbHlfdG9fZXZlbnQgYXMgd2UgcHV0IHRoZSBtZXNzYWdlIGludG8gdGhlIHF1ZXVlXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHNlbmQgZmFpbHMsIHJldHJ5IHdpbGwgaGFuZGxlIHJlc2VuZGluZy5cbiAgICAgICAgICAgICAgICBkaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdyZXBseV90b19ldmVudCcsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQudGltZWxpbmVSZW5kZXJpbmdUeXBlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzLmRpc3BhdGNoKHsgYWN0aW9uOiBcIm1lc3NhZ2Vfc2VudFwiIH0pO1xuICAgICAgICAgICAgQ0hBVF9FRkZFQ1RTLmZvckVhY2goKGVmZmVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb250YWluc0Vtb2ppKGNvbnRlbnQsIGVmZmVjdC5lbW9qaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBpbml0aWFsIHRocmVhZHMgbGF1bmNoLCBjaGF0IGVmZmVjdHMgYXJlIGRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlZSAjMTk3MzFcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNOb3RUaHJlYWQgPSB0aGlzLnByb3BzLnJlbGF0aW9uPy5yZWxfdHlwZSAhPT0gUmVsYXRpb25UeXBlLlRocmVhZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFwiZmVhdHVyZV90aHJlYWRcIikgfHwgaXNOb3RUaHJlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcy5kaXNwYXRjaCh7IGFjdGlvbjogYGVmZmVjdHMuJHtlZmZlY3QuY29tbWFuZH1gIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZShcIlBlcmZvcm1hbmNlLmFkZFNlbmRNZXNzYWdlVGltaW5nTWV0YWRhdGFcIikpIHtcbiAgICAgICAgICAgICAgICBwcm9tLnRoZW4ocmVzcCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRSb3VuZFRyaXBNZXRyaWModGhpcy5wcm9wcy5teENsaWVudCwgcm9vbUlkLCByZXNwLmV2ZW50X2lkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIENvdW50bHlBbmFseXRpY3MuaW5zdGFuY2UudHJhY2tTZW5kTWVzc2FnZShzdGFydFRpbWUsIHByb20sIHJvb21JZCwgZmFsc2UsICEhcmVwbHlUb0V2ZW50LCBjb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2VuZEhpc3RvcnlNYW5hZ2VyLnNhdmUobW9kZWwsIHJlcGx5VG9FdmVudCk7XG4gICAgICAgIC8vIGNsZWFyIGNvbXBvc2VyXG4gICAgICAgIG1vZGVsLnJlc2V0KFtdKTtcbiAgICAgICAgdGhpcy5lZGl0b3JSZWYuY3VycmVudD8uY2xlYXJVbmRvSGlzdG9yeSgpO1xuICAgICAgICB0aGlzLmVkaXRvclJlZi5jdXJyZW50Py5mb2N1cygpO1xuICAgICAgICB0aGlzLmNsZWFyU3RvcmVkRWRpdG9yU3RhdGUoKTtcbiAgICAgICAgaWYgKFNldHRpbmdzU3RvcmUuZ2V0VmFsdWUoXCJzY3JvbGxUb0JvdHRvbU9uTWVzc2FnZVNlbnRcIikpIHtcbiAgICAgICAgICAgIGRpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcInNjcm9sbF90b19ib3R0b21cIixcbiAgICAgICAgICAgICAgICB0aW1lbGluZVJlbmRlcmluZ1R5cGU6IHRoaXMuY29udGV4dC50aW1lbGluZVJlbmRlcmluZ1R5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBkaXMudW5yZWdpc3Rlcih0aGlzLmRpc3BhdGNoZXJSZWYpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCB0aGlzLnNhdmVTdG9yZWRFZGl0b3JTdGF0ZSk7XG4gICAgICAgIHRoaXMuc2F2ZVN0b3JlZEVkaXRvclN0YXRlKCk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogW1JFQUNULVdBUk5JTkddIE1vdmUgdGhpcyB0byBjb25zdHJ1Y3RvclxuICAgIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgY29uc3QgcGFydENyZWF0b3IgPSBuZXcgQ29tbWFuZFBhcnRDcmVhdG9yKHRoaXMucHJvcHMucm9vbSwgdGhpcy5wcm9wcy5teENsaWVudCk7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gdGhpcy5yZXN0b3JlU3RvcmVkRWRpdG9yU3RhdGUocGFydENyZWF0b3IpIHx8IFtdO1xuICAgICAgICB0aGlzLm1vZGVsID0gbmV3IEVkaXRvck1vZGVsKHBhcnRzLCBwYXJ0Q3JlYXRvcik7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlclJlZiA9IGRpcy5yZWdpc3Rlcih0aGlzLm9uQWN0aW9uKTtcbiAgICAgICAgdGhpcy5zZW5kSGlzdG9yeU1hbmFnZXIgPSBuZXcgU2VuZEhpc3RvcnlNYW5hZ2VyKHRoaXMucHJvcHMucm9vbS5yb29tSWQsICdteF9jaWRlcl9oaXN0b3J5XycpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0IGVkaXRvclN0YXRlS2V5KCkge1xuICAgICAgICBsZXQga2V5ID0gYG14X2NpZGVyX3N0YXRlXyR7dGhpcy5wcm9wcy5yb29tLnJvb21JZH1gO1xuICAgICAgICBjb25zdCB0aHJlYWQgPSB0aGlzLnByb3BzLnJlcGx5VG9FdmVudD8uZ2V0VGhyZWFkKCk7XG4gICAgICAgIGlmICh0aHJlYWQpIHtcbiAgICAgICAgICAgIGtleSArPSBgXyR7dGhyZWFkLmlkfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNsZWFyU3RvcmVkRWRpdG9yU3RhdGUoKTogdm9pZCB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuZWRpdG9yU3RhdGVLZXkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgcmVzdG9yZVN0b3JlZEVkaXRvclN0YXRlKHBhcnRDcmVhdG9yOiBQYXJ0Q3JlYXRvcik6IFBhcnRbXSB7XG4gICAgICAgIGNvbnN0IHJlcGx5aW5nVG9UaHJlYWQgPSB0aGlzLnByb3BzLnJlbGF0aW9uPy5rZXkgPT09IFJlbGF0aW9uVHlwZS5UaHJlYWQ7XG4gICAgICAgIGlmIChyZXBseWluZ1RvVGhyZWFkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGpzb24gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLmVkaXRvclN0YXRlS2V5KTtcbiAgICAgICAgaWYgKGpzb24pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXJ0czogc2VyaWFsaXplZFBhcnRzLCByZXBseUV2ZW50SWQgfSA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHM6IFBhcnRbXSA9IHNlcmlhbGl6ZWRQYXJ0cy5tYXAocCA9PiBwYXJ0Q3JlYXRvci5kZXNlcmlhbGl6ZVBhcnQocCkpO1xuICAgICAgICAgICAgICAgIGlmIChyZXBseUV2ZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ3JlcGx5X3RvX2V2ZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiB0aGlzLnByb3BzLnJvb20uZmluZEV2ZW50QnlJZChyZXBseUV2ZW50SWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LnRpbWVsaW5lUmVuZGVyaW5nVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0cztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzaG91bGQgc2F2ZSBzdGF0ZSB3aGVuIGVkaXRvciBoYXMgY29udGVudHMgb3IgcmVwbHkgaXMgb3BlblxuICAgIHByaXZhdGUgc2hvdWxkU2F2ZVN0b3JlZEVkaXRvclN0YXRlID0gKCk6IGJvb2xlYW4gPT4ge1xuICAgICAgICByZXR1cm4gIXRoaXMubW9kZWwuaXNFbXB0eSB8fCAhIXRoaXMucHJvcHMucmVwbHlUb0V2ZW50O1xuICAgIH07XG5cbiAgICBwcml2YXRlIHNhdmVTdG9yZWRFZGl0b3JTdGF0ZSA9ICgpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkU2F2ZVN0b3JlZEVkaXRvclN0YXRlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBTZW5kSGlzdG9yeU1hbmFnZXIuY3JlYXRlSXRlbSh0aGlzLm1vZGVsLCB0aGlzLnByb3BzLnJlcGx5VG9FdmVudCk7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0aGlzLmVkaXRvclN0YXRlS2V5LCBKU09OLnN0cmluZ2lmeShpdGVtKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyU3RvcmVkRWRpdG9yU3RhdGUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcml2YXRlIG9uQWN0aW9uID0gKHBheWxvYWQ6IEFjdGlvblBheWxvYWQpOiB2b2lkID0+IHtcbiAgICAgICAgLy8gZG9uJ3QgbGV0IHRoZSB1c2VyIGludG8gdGhlIGNvbXBvc2VyIGlmIGl0IGlzIGRpc2FibGVkIC0gYWxsIG9mIHRoZXNlIGJyYW5jaGVzIGxlYWRcbiAgICAgICAgLy8gdG8gdGhlIGN1cnNvciBiZWluZyBpbiB0aGUgY29tcG9zZXJcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZGlzYWJsZWQpIHJldHVybjtcblxuICAgICAgICBzd2l0Y2ggKHBheWxvYWQuYWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlICdyZXBseV90b19ldmVudCc6XG4gICAgICAgICAgICBjYXNlIEFjdGlvbi5Gb2N1c1NlbmRNZXNzYWdlQ29tcG9zZXI6XG4gICAgICAgICAgICAgICAgaWYgKChwYXlsb2FkLmNvbnRleHQgPz8gVGltZWxpbmVSZW5kZXJpbmdUeXBlLlJvb20pID09PSB0aGlzLmNvbnRleHQudGltZWxpbmVSZW5kZXJpbmdUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yUmVmLmN1cnJlbnQ/LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBBY3Rpb24uQ29tcG9zZXJJbnNlcnQ6XG4gICAgICAgICAgICAgICAgaWYgKHBheWxvYWQudGltZWxpbmVSZW5kZXJpbmdUeXBlICE9PSB0aGlzLmNvbnRleHQudGltZWxpbmVSZW5kZXJpbmdUeXBlKSBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5jb21wb3NlclR5cGUgIT09IENvbXBvc2VyVHlwZS5TZW5kKSBicmVhaztcblxuICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLnVzZXJJZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRvclJlZi5jdXJyZW50Py5pbnNlcnRNZW50aW9uKHBheWxvYWQudXNlcklkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBheWxvYWQuZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0b3JSZWYuY3VycmVudD8uaW5zZXJ0UXVvdGVkTWVzc2FnZShwYXlsb2FkLmV2ZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBheWxvYWQudGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRvclJlZi5jdXJyZW50Py5pbnNlcnRQbGFpbnRleHQocGF5bG9hZC50ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvblBhc3RlID0gKGV2ZW50OiBDbGlwYm9hcmRFdmVudDxIVE1MRGl2RWxlbWVudD4pOiBib29sZWFuID0+IHtcbiAgICAgICAgY29uc3QgeyBjbGlwYm9hcmREYXRhIH0gPSBldmVudDtcbiAgICAgICAgLy8gUHJpb3JpdGl6ZSB0ZXh0IG9uIHRoZSBjbGlwYm9hcmQgb3ZlciBmaWxlcyBpZiBSVEYgaXMgcHJlc2VudCBhcyBPZmZpY2Ugb24gbWFjT1MgcHV0cyBhIGJpdG1hcFxuICAgICAgICAvLyBpbiB0aGUgY2xpcGJvYXJkIGFzIHdlbGwgYXMgdGhlIGNvbnRlbnQgYmVpbmcgY29waWVkLiBNb2Rlcm4gdmVyc2lvbnMgb2YgT2ZmaWNlIHNlZW0gdG8gbm90IGRvIHRoaXMgYW55bW9yZS5cbiAgICAgICAgLy8gV2UgY2hlY2sgdGV4dC9ydGYgaW5zdGVhZCBvZiB0ZXh0L3BsYWluIGFzIHdoZW4gY29weStwYXN0aW5nIGEgZmlsZSBmcm9tIEZpbmRlciBvciBHbm9tZSBJbWFnZSBWaWV3ZXJcbiAgICAgICAgLy8gaXQgcHV0cyB0aGUgZmlsZW5hbWUgaW4gYXMgdGV4dC9wbGFpbiB3aGljaCB3ZSB3YW50IHRvIGlnbm9yZS5cbiAgICAgICAgaWYgKGNsaXBib2FyZERhdGEuZmlsZXMubGVuZ3RoICYmICFjbGlwYm9hcmREYXRhLnR5cGVzLmluY2x1ZGVzKFwidGV4dC9ydGZcIikpIHtcbiAgICAgICAgICAgIENvbnRlbnRNZXNzYWdlcy5zaGFyZWRJbnN0YW5jZSgpLnNlbmRDb250ZW50TGlzdFRvUm9vbShcbiAgICAgICAgICAgICAgICBBcnJheS5mcm9tKGNsaXBib2FyZERhdGEuZmlsZXMpLCB0aGlzLnByb3BzLnJvb20ucm9vbUlkLCB0aGlzLnByb3BzLnJlbGF0aW9uLCB0aGlzLnByb3BzLm14Q2xpZW50LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyB0byBza2lwIGludGVybmFsIG9uUGFzdGUgaGFuZGxlclxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25DaGFuZ2UgPSAoKTogdm9pZCA9PiB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uQ2hhbmdlKSB0aGlzLnByb3BzLm9uQ2hhbmdlKHRoaXMubW9kZWwpO1xuICAgIH07XG5cbiAgICBwcml2YXRlIGZvY3VzQ29tcG9zZXIgPSAoKTogdm9pZCA9PiB7XG4gICAgICAgIHRoaXMuZWRpdG9yUmVmLmN1cnJlbnQ/LmZvY3VzKCk7XG4gICAgfTtcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgdGhyZWFkSWQgPSB0aGlzLnByb3BzLnJlbGF0aW9uPy5yZWxfdHlwZSA9PT0gUmVsYXRpb25UeXBlLlRocmVhZFxuICAgICAgICAgICAgPyB0aGlzLnByb3BzLnJlbGF0aW9uLmV2ZW50X2lkXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm14X1NlbmRNZXNzYWdlQ29tcG9zZXJcIiBvbkNsaWNrPXt0aGlzLmZvY3VzQ29tcG9zZXJ9IG9uS2V5RG93bj17dGhpcy5vbktleURvd259PlxuICAgICAgICAgICAgICAgIDxCYXNpY01lc3NhZ2VDb21wb3NlclxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5vbkNoYW5nZX1cbiAgICAgICAgICAgICAgICAgICAgcmVmPXt0aGlzLmVkaXRvclJlZn1cbiAgICAgICAgICAgICAgICAgICAgbW9kZWw9e3RoaXMubW9kZWx9XG4gICAgICAgICAgICAgICAgICAgIHJvb209e3RoaXMucHJvcHMucm9vbX1cbiAgICAgICAgICAgICAgICAgICAgdGhyZWFkSWQ9e3RocmVhZElkfVxuICAgICAgICAgICAgICAgICAgICBsYWJlbD17dGhpcy5wcm9wcy5wbGFjZWhvbGRlcn1cbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9e3RoaXMucHJvcHMucGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICAgICAgICAgIG9uUGFzdGU9e3RoaXMub25QYXN0ZX1cbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e3RoaXMucHJvcHMuZGlzYWJsZWR9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuY29uc3QgU2VuZE1lc3NhZ2VDb21wb3NlcldpdGhNYXRyaXhDbGllbnQgPSB3aXRoTWF0cml4Q2xpZW50SE9DKFNlbmRNZXNzYWdlQ29tcG9zZXIpO1xuZXhwb3J0IGRlZmF1bHQgU2VuZE1lc3NhZ2VDb21wb3NlcldpdGhNYXRyaXhDbGllbnQ7XG4iXX0=