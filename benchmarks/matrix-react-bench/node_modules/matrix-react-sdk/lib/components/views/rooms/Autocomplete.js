"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateCompletionDomId = exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _lodash = require("lodash");

var _SettingsStore = _interopRequireDefault(require("../../../settings/SettingsStore"));

var _Autocompleter = _interopRequireDefault(require("../../../autocomplete/Autocompleter"));

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _RoomContext = _interopRequireDefault(require("../../../contexts/RoomContext"));

var _dec, _class, _class2, _temp;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const MAX_PROVIDER_MATCHES = 20;

const generateCompletionDomId = number => `mx_Autocomplete_Completion_${number}`;

exports.generateCompletionDomId = generateCompletionDomId;
let Autocomplete = (_dec = (0, _replaceableComponent.replaceableComponent)("views.rooms.Autocomplete"), _dec(_class = (_temp = _class2 = class Autocomplete extends _react.default.PureComponent {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "autocompleter", void 0);
    (0, _defineProperty2.default)(this, "queryRequested", void 0);
    (0, _defineProperty2.default)(this, "debounceCompletionsRequest", void 0);
    (0, _defineProperty2.default)(this, "containerRef", /*#__PURE__*/(0, _react.createRef)());
    (0, _defineProperty2.default)(this, "hide", () => {
      this.setState({
        hide: true,
        selectionOffset: 1,
        completions: [],
        completionList: []
      });
    });
    (0, _defineProperty2.default)(this, "onConfirmCompletion", () => {
      this.onCompletionClicked(this.state.selectionOffset);
    });
    (0, _defineProperty2.default)(this, "onCompletionClicked", selectionOffset => {
      const count = this.countCompletions();

      if (count === 0 || selectionOffset < 1 || selectionOffset > count) {
        return false;
      }

      this.props.onConfirm(this.state.completionList[selectionOffset - 1]);
      this.hide();
      return true;
    });
    this.state = {
      // list of completionResults, each containing completions
      completions: [],
      // array of completions, so we can look up current selection by offset quickly
      completionList: [],
      // how far down the completion list we are (THIS IS 1-INDEXED!)
      selectionOffset: 1,
      // whether we should show completions if they're available
      shouldShowCompletions: true,
      hide: false,
      forceComplete: false
    };
  }

  componentDidMount() {
    this.autocompleter = new _Autocompleter.default(this.props.room, this.context.timelineRenderingType);
    this.applyNewProps();
  }

  applyNewProps(oldQuery, oldRoom) {
    if (oldRoom && this.props.room.roomId !== oldRoom.roomId) {
      this.autocompleter.destroy();
      this.autocompleter = new _Autocompleter.default(this.props.room);
    } // Query hasn't changed so don't try to complete it


    if (oldQuery === this.props.query) {
      return;
    }

    this.complete(this.props.query, this.props.selection);
  }

  componentWillUnmount() {
    this.autocompleter.destroy();
  }

  complete(query, selection) {
    this.queryRequested = query;

    if (this.debounceCompletionsRequest) {
      clearTimeout(this.debounceCompletionsRequest);
    }

    if (query === "") {
      this.setState({
        // Clear displayed completions
        completions: [],
        completionList: [],
        // Reset selected completion
        selectionOffset: 1,
        // Hide the autocomplete box
        hide: true
      });
      return Promise.resolve(null);
    }

    let autocompleteDelay = _SettingsStore.default.getValue("autocompleteDelay"); // Don't debounce if we are already showing completions


    if (this.state.completions.length > 0 || this.state.forceComplete) {
      autocompleteDelay = 0;
    }

    return new Promise(resolve => {
      this.debounceCompletionsRequest = setTimeout(() => {
        resolve(this.processQuery(query, selection));
      }, autocompleteDelay);
    });
  }

  processQuery(query, selection) {
    return this.autocompleter.getCompletions(query, selection, this.state.forceComplete, MAX_PROVIDER_MATCHES).then(completions => {
      // Only ever process the completions for the most recent query being processed
      if (query !== this.queryRequested) {
        return;
      }

      this.processCompletions(completions);
    });
  }

  processCompletions(completions) {
    const completionList = (0, _lodash.flatMap)(completions, provider => provider.completions); // Reset selection when completion list becomes empty.

    let selectionOffset = 1;

    if (completionList.length > 0) {
      /* If the currently selected completion is still in the completion list,
       try to find it and jump to it. If not, select composer.
       */
      const currentSelection = this.state.selectionOffset <= 1 ? null : this.state.completionList[this.state.selectionOffset - 1].completion;
      selectionOffset = completionList.findIndex(completion => completion.completion === currentSelection);

      if (selectionOffset === -1) {
        selectionOffset = 1;
      } else {
        selectionOffset++; // selectionOffset is 1-indexed!
      }
    }

    let hide = true; // If `completion.command.command` is truthy, then a provider has matched with the query

    const anyMatches = completions.some(completion => !!completion.command.command);

    if (anyMatches) {
      hide = false;

      if (this.props.onSelectionChange) {
        this.props.onSelectionChange(selectionOffset - 1);
      }
    }

    this.setState({
      completions,
      completionList,
      selectionOffset,
      hide,
      // Force complete is turned off each time since we can't edit the query in that case
      forceComplete: false
    });
  }

  hasSelection() {
    return this.countCompletions() > 0 && this.state.selectionOffset !== 0;
  }

  countCompletions() {
    return this.state.completionList.length;
  } // called from MessageComposerInput


  moveSelection(delta) {
    const completionCount = this.countCompletions();
    if (completionCount === 0) return; // there are no items to move the selection through
    // Note: selectionOffset 0 represents the unsubstituted text, while 1 means first pill selected

    const index = (this.state.selectionOffset + delta + completionCount - 1) % completionCount;
    this.setSelection(1 + index);
  }

  onEscape(e) {
    const completionCount = this.countCompletions();

    if (completionCount === 0) {
      // autocomplete is already empty, so don't preventDefault
      return;
    }

    e.preventDefault(); // selectionOffset = 0, so we don't end up completing when autocomplete is hidden

    this.hide();
  }

  forceComplete() {
    return new Promise(resolve => {
      this.setState({
        forceComplete: true,
        hide: false
      }, () => {
        this.complete(this.props.query, this.props.selection).then(() => {
          resolve(this.countCompletions());
        });
      });
    });
  }

  setSelection(selectionOffset) {
    this.setState({
      selectionOffset,
      hide: false
    });

    if (this.props.onSelectionChange) {
      this.props.onSelectionChange(selectionOffset - 1);
    }
  }

  componentDidUpdate(prevProps) {
    this.applyNewProps(prevProps.query, prevProps.room); // this is the selected completion, so scroll it into view if needed

    const selectedCompletion = this.refs[`completion${this.state.selectionOffset}`];

    if (selectedCompletion) {
      selectedCompletion.scrollIntoView({
        behavior: "auto",
        block: "nearest"
      });
    } else if (this.containerRef.current) {
      this.containerRef.current.scrollTo({
        top: 0
      });
    }
  }

  render() {
    let position = 1;
    const renderedCompletions = this.state.completions.map((completionResult, i) => {
      const completions = completionResult.completions.map((completion, j) => {
        const selected = position === this.state.selectionOffset;
        const className = (0, _classnames.default)('mx_Autocomplete_Completion', {
          selected
        });
        const componentPosition = position;
        position++;

        const onClick = () => {
          this.onCompletionClicked(componentPosition);
        };

        return /*#__PURE__*/_react.default.cloneElement(completion.component, {
          "key": j,
          "ref": `completion${componentPosition}`,
          "id": generateCompletionDomId(componentPosition - 1),
          // 0 index the completion IDs
          className,
          onClick,
          "aria-selected": selected
        });
      });
      return completions.length > 0 ? /*#__PURE__*/_react.default.createElement("div", {
        key: i,
        className: "mx_Autocomplete_ProviderSection",
        role: "presentation"
      }, /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_Autocomplete_provider_name"
      }, completionResult.provider.getName()), completionResult.provider.renderCompletions(completions)) : null;
    }).filter(completion => !!completion);
    return !this.state.hide && renderedCompletions.length > 0 ? /*#__PURE__*/_react.default.createElement("div", {
      id: "mx_Autocomplete",
      className: "mx_Autocomplete",
      ref: this.containerRef,
      role: "listbox"
    }, renderedCompletions) : null;
  }

}, (0, _defineProperty2.default)(_class2, "contextType", _RoomContext.default), _temp)) || _class);
exports.default = Autocomplete;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL3Jvb21zL0F1dG9jb21wbGV0ZS50c3giXSwibmFtZXMiOlsiTUFYX1BST1ZJREVSX01BVENIRVMiLCJnZW5lcmF0ZUNvbXBsZXRpb25Eb21JZCIsIm51bWJlciIsIkF1dG9jb21wbGV0ZSIsIlJlYWN0IiwiUHVyZUNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJzZXRTdGF0ZSIsImhpZGUiLCJzZWxlY3Rpb25PZmZzZXQiLCJjb21wbGV0aW9ucyIsImNvbXBsZXRpb25MaXN0Iiwib25Db21wbGV0aW9uQ2xpY2tlZCIsInN0YXRlIiwiY291bnQiLCJjb3VudENvbXBsZXRpb25zIiwib25Db25maXJtIiwic2hvdWxkU2hvd0NvbXBsZXRpb25zIiwiZm9yY2VDb21wbGV0ZSIsImNvbXBvbmVudERpZE1vdW50IiwiYXV0b2NvbXBsZXRlciIsIkF1dG9jb21wbGV0ZXIiLCJyb29tIiwiY29udGV4dCIsInRpbWVsaW5lUmVuZGVyaW5nVHlwZSIsImFwcGx5TmV3UHJvcHMiLCJvbGRRdWVyeSIsIm9sZFJvb20iLCJyb29tSWQiLCJkZXN0cm95IiwicXVlcnkiLCJjb21wbGV0ZSIsInNlbGVjdGlvbiIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicXVlcnlSZXF1ZXN0ZWQiLCJkZWJvdW5jZUNvbXBsZXRpb25zUmVxdWVzdCIsImNsZWFyVGltZW91dCIsIlByb21pc2UiLCJyZXNvbHZlIiwiYXV0b2NvbXBsZXRlRGVsYXkiLCJTZXR0aW5nc1N0b3JlIiwiZ2V0VmFsdWUiLCJsZW5ndGgiLCJzZXRUaW1lb3V0IiwicHJvY2Vzc1F1ZXJ5IiwiZ2V0Q29tcGxldGlvbnMiLCJ0aGVuIiwicHJvY2Vzc0NvbXBsZXRpb25zIiwicHJvdmlkZXIiLCJjdXJyZW50U2VsZWN0aW9uIiwiY29tcGxldGlvbiIsImZpbmRJbmRleCIsImFueU1hdGNoZXMiLCJzb21lIiwiY29tbWFuZCIsIm9uU2VsZWN0aW9uQ2hhbmdlIiwiaGFzU2VsZWN0aW9uIiwibW92ZVNlbGVjdGlvbiIsImRlbHRhIiwiY29tcGxldGlvbkNvdW50IiwiaW5kZXgiLCJzZXRTZWxlY3Rpb24iLCJvbkVzY2FwZSIsImUiLCJwcmV2ZW50RGVmYXVsdCIsImNvbXBvbmVudERpZFVwZGF0ZSIsInByZXZQcm9wcyIsInNlbGVjdGVkQ29tcGxldGlvbiIsInJlZnMiLCJzY3JvbGxJbnRvVmlldyIsImJlaGF2aW9yIiwiYmxvY2siLCJjb250YWluZXJSZWYiLCJjdXJyZW50Iiwic2Nyb2xsVG8iLCJ0b3AiLCJyZW5kZXIiLCJwb3NpdGlvbiIsInJlbmRlcmVkQ29tcGxldGlvbnMiLCJtYXAiLCJjb21wbGV0aW9uUmVzdWx0IiwiaSIsImoiLCJzZWxlY3RlZCIsImNsYXNzTmFtZSIsImNvbXBvbmVudFBvc2l0aW9uIiwib25DbGljayIsImNsb25lRWxlbWVudCIsImNvbXBvbmVudCIsImdldE5hbWUiLCJyZW5kZXJDb21wbGV0aW9ucyIsImZpbHRlciIsIlJvb21Db250ZXh0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWlCQTs7QUFDQTs7QUFDQTs7QUFJQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7QUFFQSxNQUFNQSxvQkFBb0IsR0FBRyxFQUE3Qjs7QUFFTyxNQUFNQyx1QkFBdUIsR0FBSUMsTUFBRCxJQUFhLDhCQUE2QkEsTUFBTyxFQUFqRjs7O0lBd0JjQyxZLFdBRHBCLGdEQUFxQiwwQkFBckIsQyxtQ0FBRCxNQUNxQkEsWUFEckIsU0FDMENDLGVBQU1DLGFBRGhELENBQzhFO0FBUTFFQyxFQUFBQSxXQUFXLENBQUNDLEtBQUQsRUFBUTtBQUNmLFVBQU1BLEtBQU47QUFEZTtBQUFBO0FBQUE7QUFBQSxxRUFKSSx1QkFJSjtBQUFBLGdEQStKSixNQUFZO0FBQ3ZCLFdBQUtDLFFBQUwsQ0FBYztBQUNWQyxRQUFBQSxJQUFJLEVBQUUsSUFESTtBQUVWQyxRQUFBQSxlQUFlLEVBQUUsQ0FGUDtBQUdWQyxRQUFBQSxXQUFXLEVBQUUsRUFISDtB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SUFBSSxFQUFDO0FBQW5GLE9BQ01NLG1CQUROLENBREcsR0FJSCxJQUpKO0FBS0g7O0FBdlF5RSxDLHdEQU05Q2Msb0IiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMTYgQXZpcmFsIERhc2d1cHRhXG5Db3B5cmlnaHQgMjAxNyBOZXcgVmVjdG9yIEx0ZFxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVSZWYsIEtleWJvYXJkRXZlbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IGZsYXRNYXAgfSBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgeyBJQ29tcGxldGlvbiwgSVNlbGVjdGlvblJhbmdlLCBJUHJvdmlkZXJDb21wbGV0aW9ucyB9IGZyb20gJy4uLy4uLy4uL2F1dG9jb21wbGV0ZS9BdXRvY29tcGxldGVyJztcbmltcG9ydCB7IFJvb20gfSBmcm9tICdtYXRyaXgtanMtc2RrL3NyYy9tb2RlbHMvcm9vbSc7XG5cbmltcG9ydCBTZXR0aW5nc1N0b3JlIGZyb20gXCIuLi8uLi8uLi9zZXR0aW5ncy9TZXR0aW5nc1N0b3JlXCI7XG5pbXBvcnQgQXV0b2NvbXBsZXRlciBmcm9tICcuLi8uLi8uLi9hdXRvY29tcGxldGUvQXV0b2NvbXBsZXRlcic7XG5pbXBvcnQgeyByZXBsYWNlYWJsZUNvbXBvbmVudCB9IGZyb20gXCIuLi8uLi8uLi91dGlscy9yZXBsYWNlYWJsZUNvbXBvbmVudFwiO1xuaW1wb3J0IFJvb21Db250ZXh0IGZyb20gJy4uLy4uLy4uL2NvbnRleHRzL1Jvb21Db250ZXh0JztcblxuY29uc3QgTUFYX1BST1ZJREVSX01BVENIRVMgPSAyMDtcblxuZXhwb3J0IGNvbnN0IGdlbmVyYXRlQ29tcGxldGlvbkRvbUlkID0gKG51bWJlcikgPT4gYG14X0F1dG9jb21wbGV0ZV9Db21wbGV0aW9uXyR7bnVtYmVyfWA7XG5cbmludGVyZmFjZSBJUHJvcHMge1xuICAgIC8vIHRoZSBxdWVyeSBzdHJpbmcgZm9yIHdoaWNoIHRvIHNob3cgYXV0b2NvbXBsZXRlIHN1Z2dlc3Rpb25zXG4gICAgcXVlcnk6IHN0cmluZztcbiAgICAvLyBtZXRob2QgaW52b2tlZCB3aXRoIHJhbmdlIGFuZCB0ZXh0IGNvbnRlbnQgd2hlbiBjb21wbGV0aW9uIGlzIGNvbmZpcm1lZFxuICAgIG9uQ29uZmlybTogKGNvbXBsZXRpb246IElDb21wbGV0aW9uKSA9PiB2b2lkO1xuICAgIC8vIG1ldGhvZCBpbnZva2VkIHdoZW4gc2VsZWN0ZWQgKGlmIGFueSkgY29tcGxldGlvbiBjaGFuZ2VzXG4gICAgb25TZWxlY3Rpb25DaGFuZ2U/OiAocGFydEluZGV4OiBudW1iZXIpID0+IHZvaWQ7XG4gICAgc2VsZWN0aW9uOiBJU2VsZWN0aW9uUmFuZ2U7XG4gICAgLy8gVGhlIHJvb20gaW4gd2hpY2ggd2UncmUgYXV0b2NvbXBsZXRpbmdcbiAgICByb29tOiBSb29tO1xufVxuXG5pbnRlcmZhY2UgSVN0YXRlIHtcbiAgICBjb21wbGV0aW9uczogSVByb3ZpZGVyQ29tcGxldGlvbnNbXTtcbiAgICBjb21wbGV0aW9uTGlzdDogSUNvbXBsZXRpb25bXTtcbiAgICBzZWxlY3Rpb25PZmZzZXQ6IG51bWJlcjtcbiAgICBzaG91bGRTaG93Q29tcGxldGlvbnM6IGJvb2xlYW47XG4gICAgaGlkZTogYm9vbGVhbjtcbiAgICBmb3JjZUNvbXBsZXRlOiBib29sZWFuO1xufVxuXG5AcmVwbGFjZWFibGVDb21wb25lbnQoXCJ2aWV3cy5yb29tcy5BdXRvY29tcGxldGVcIilcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1dG9jb21wbGV0ZSBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8SVByb3BzLCBJU3RhdGU+IHtcbiAgICBhdXRvY29tcGxldGVyOiBBdXRvY29tcGxldGVyO1xuICAgIHF1ZXJ5UmVxdWVzdGVkOiBzdHJpbmc7XG4gICAgZGVib3VuY2VDb21wbGV0aW9uc1JlcXVlc3Q6IG51bWJlcjtcbiAgICBwcml2YXRlIGNvbnRhaW5lclJlZiA9IGNyZWF0ZVJlZjxIVE1MRGl2RWxlbWVudD4oKTtcblxuICAgIHB1YmxpYyBzdGF0aWMgY29udGV4dFR5cGUgPSBSb29tQ29udGV4dDtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgLy8gbGlzdCBvZiBjb21wbGV0aW9uUmVzdWx0cywgZWFjaCBjb250YWluaW5nIGNvbXBsZXRpb25zXG4gICAgICAgICAgICBjb21wbGV0aW9uczogW10sXG5cbiAgICAgICAgICAgIC8vIGFycmF5IG9mIGNvbXBsZXRpb25zLCBzbyB3ZSBjYW4gbG9vayB1cCBjdXJyZW50IHNlbGVjdGlvbiBieSBvZmZzZXQgcXVpY2tseVxuICAgICAgICAgICAgY29tcGxldGlvbkxpc3Q6IFtdLFxuXG4gICAgICAgICAgICAvLyBob3cgZmFyIGRvd24gdGhlIGNvbXBsZXRpb24gbGlzdCB3ZSBhcmUgKFRISVMgSVMgMS1JTkRFWEVEISlcbiAgICAgICAgICAgIHNlbGVjdGlvbk9mZnNldDogMSxcblxuICAgICAgICAgICAgLy8gd2hldGhlciB3ZSBzaG91bGQgc2hvdyBjb21wbGV0aW9ucyBpZiB0aGV5J3JlIGF2YWlsYWJsZVxuICAgICAgICAgICAgc2hvdWxkU2hvd0NvbXBsZXRpb25zOiB0cnVlLFxuXG4gICAgICAgICAgICBoaWRlOiBmYWxzZSxcblxuICAgICAgICAgICAgZm9yY2VDb21wbGV0ZTogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlciA9IG5ldyBBdXRvY29tcGxldGVyKHRoaXMucHJvcHMucm9vbSwgdGhpcy5jb250ZXh0LnRpbWVsaW5lUmVuZGVyaW5nVHlwZSk7XG4gICAgICAgIHRoaXMuYXBwbHlOZXdQcm9wcygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXBwbHlOZXdQcm9wcyhvbGRRdWVyeT86IHN0cmluZywgb2xkUm9vbT86IFJvb20pOiB2b2lkIHtcbiAgICAgICAgaWYgKG9sZFJvb20gJiYgdGhpcy5wcm9wcy5yb29tLnJvb21JZCAhPT0gb2xkUm9vbS5yb29tSWQpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZXIgPSBuZXcgQXV0b2NvbXBsZXRlcih0aGlzLnByb3BzLnJvb20pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUXVlcnkgaGFzbid0IGNoYW5nZWQgc28gZG9uJ3QgdHJ5IHRvIGNvbXBsZXRlIGl0XG4gICAgICAgIGlmIChvbGRRdWVyeSA9PT0gdGhpcy5wcm9wcy5xdWVyeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb21wbGV0ZSh0aGlzLnByb3BzLnF1ZXJ5LCB0aGlzLnByb3BzLnNlbGVjdGlvbik7XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjb21wbGV0ZShxdWVyeTogc3RyaW5nLCBzZWxlY3Rpb246IElTZWxlY3Rpb25SYW5nZSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICB0aGlzLnF1ZXJ5UmVxdWVzdGVkID0gcXVlcnk7XG4gICAgICAgIGlmICh0aGlzLmRlYm91bmNlQ29tcGxldGlvbnNSZXF1ZXN0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWJvdW5jZUNvbXBsZXRpb25zUmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXJ5ID09PSBcIlwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAvLyBDbGVhciBkaXNwbGF5ZWQgY29tcGxldGlvbnNcbiAgICAgICAgICAgICAgICBjb21wbGV0aW9uczogW10sXG4gICAgICAgICAgICAgICAgY29tcGxldGlvbkxpc3Q6IFtdLFxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IHNlbGVjdGVkIGNvbXBsZXRpb25cbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25PZmZzZXQ6IDEsXG4gICAgICAgICAgICAgICAgLy8gSGlkZSB0aGUgYXV0b2NvbXBsZXRlIGJveFxuICAgICAgICAgICAgICAgIGhpZGU6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGF1dG9jb21wbGV0ZURlbGF5ID0gU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZShcImF1dG9jb21wbGV0ZURlbGF5XCIpO1xuXG4gICAgICAgIC8vIERvbid0IGRlYm91bmNlIGlmIHdlIGFyZSBhbHJlYWR5IHNob3dpbmcgY29tcGxldGlvbnNcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuY29tcGxldGlvbnMubGVuZ3RoID4gMCB8fCB0aGlzLnN0YXRlLmZvcmNlQ29tcGxldGUpIHtcbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZURlbGF5ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kZWJvdW5jZUNvbXBsZXRpb25zUmVxdWVzdCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5wcm9jZXNzUXVlcnkocXVlcnksIHNlbGVjdGlvbikpO1xuICAgICAgICAgICAgfSwgYXV0b2NvbXBsZXRlRGVsYXkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHByb2Nlc3NRdWVyeShxdWVyeTogc3RyaW5nLCBzZWxlY3Rpb246IElTZWxlY3Rpb25SYW5nZSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5hdXRvY29tcGxldGVyLmdldENvbXBsZXRpb25zKFxuICAgICAgICAgICAgcXVlcnksIHNlbGVjdGlvbiwgdGhpcy5zdGF0ZS5mb3JjZUNvbXBsZXRlLCBNQVhfUFJPVklERVJfTUFUQ0hFUyxcbiAgICAgICAgKS50aGVuKChjb21wbGV0aW9ucykgPT4ge1xuICAgICAgICAgICAgLy8gT25seSBldmVyIHByb2Nlc3MgdGhlIGNvbXBsZXRpb25zIGZvciB0aGUgbW9zdCByZWNlbnQgcXVlcnkgYmVpbmcgcHJvY2Vzc2VkXG4gICAgICAgICAgICBpZiAocXVlcnkgIT09IHRoaXMucXVlcnlSZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NDb21wbGV0aW9ucyhjb21wbGV0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgcHJvY2Vzc0NvbXBsZXRpb25zKGNvbXBsZXRpb25zOiBJUHJvdmlkZXJDb21wbGV0aW9uc1tdKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGNvbXBsZXRpb25MaXN0ID0gZmxhdE1hcChjb21wbGV0aW9ucywgKHByb3ZpZGVyKSA9PiBwcm92aWRlci5jb21wbGV0aW9ucyk7XG5cbiAgICAgICAgLy8gUmVzZXQgc2VsZWN0aW9uIHdoZW4gY29tcGxldGlvbiBsaXN0IGJlY29tZXMgZW1wdHkuXG4gICAgICAgIGxldCBzZWxlY3Rpb25PZmZzZXQgPSAxO1xuICAgICAgICBpZiAoY29tcGxldGlvbkxpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLyogSWYgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjb21wbGV0aW9uIGlzIHN0aWxsIGluIHRoZSBjb21wbGV0aW9uIGxpc3QsXG4gICAgICAgICAgICAgdHJ5IHRvIGZpbmQgaXQgYW5kIGp1bXAgdG8gaXQuIElmIG5vdCwgc2VsZWN0IGNvbXBvc2VyLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U2VsZWN0aW9uID0gdGhpcy5zdGF0ZS5zZWxlY3Rpb25PZmZzZXQgPD0gMSA/IG51bGwgOlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuY29tcGxldGlvbkxpc3RbdGhpcy5zdGF0ZS5zZWxlY3Rpb25PZmZzZXQgLSAxXS5jb21wbGV0aW9uO1xuICAgICAgICAgICAgc2VsZWN0aW9uT2Zmc2V0ID0gY29tcGxldGlvbkxpc3QuZmluZEluZGV4KFxuICAgICAgICAgICAgICAgIChjb21wbGV0aW9uKSA9PiBjb21wbGV0aW9uLmNvbXBsZXRpb24gPT09IGN1cnJlbnRTZWxlY3Rpb24pO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbk9mZnNldCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25PZmZzZXQgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25PZmZzZXQrKzsgLy8gc2VsZWN0aW9uT2Zmc2V0IGlzIDEtaW5kZXhlZCFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBoaWRlID0gdHJ1ZTtcbiAgICAgICAgLy8gSWYgYGNvbXBsZXRpb24uY29tbWFuZC5jb21tYW5kYCBpcyB0cnV0aHksIHRoZW4gYSBwcm92aWRlciBoYXMgbWF0Y2hlZCB3aXRoIHRoZSBxdWVyeVxuICAgICAgICBjb25zdCBhbnlNYXRjaGVzID0gY29tcGxldGlvbnMuc29tZSgoY29tcGxldGlvbikgPT4gISFjb21wbGV0aW9uLmNvbW1hbmQuY29tbWFuZCk7XG4gICAgICAgIGlmIChhbnlNYXRjaGVzKSB7XG4gICAgICAgICAgICBoaWRlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vblNlbGVjdGlvbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25TZWxlY3Rpb25DaGFuZ2Uoc2VsZWN0aW9uT2Zmc2V0IC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGNvbXBsZXRpb25zLFxuICAgICAgICAgICAgY29tcGxldGlvbkxpc3QsXG4gICAgICAgICAgICBzZWxlY3Rpb25PZmZzZXQsXG4gICAgICAgICAgICBoaWRlLFxuICAgICAgICAgICAgLy8gRm9yY2UgY29tcGxldGUgaXMgdHVybmVkIG9mZiBlYWNoIHRpbWUgc2luY2Ugd2UgY2FuJ3QgZWRpdCB0aGUgcXVlcnkgaW4gdGhhdCBjYXNlXG4gICAgICAgICAgICBmb3JjZUNvbXBsZXRlOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIGhhc1NlbGVjdGlvbigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY291bnRDb21wbGV0aW9ucygpID4gMCAmJiB0aGlzLnN0YXRlLnNlbGVjdGlvbk9mZnNldCAhPT0gMDtcbiAgICB9XG5cbiAgICBwdWJsaWMgY291bnRDb21wbGV0aW9ucygpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5jb21wbGV0aW9uTGlzdC5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gY2FsbGVkIGZyb20gTWVzc2FnZUNvbXBvc2VySW5wdXRcbiAgICBwdWJsaWMgbW92ZVNlbGVjdGlvbihkZWx0YTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGNvbXBsZXRpb25Db3VudCA9IHRoaXMuY291bnRDb21wbGV0aW9ucygpO1xuICAgICAgICBpZiAoY29tcGxldGlvbkNvdW50ID09PSAwKSByZXR1cm47IC8vIHRoZXJlIGFyZSBubyBpdGVtcyB0byBtb3ZlIHRoZSBzZWxlY3Rpb24gdGhyb3VnaFxuXG4gICAgICAgIC8vIE5vdGU6IHNlbGVjdGlvbk9mZnNldCAwIHJlcHJlc2VudHMgdGhlIHVuc3Vic3RpdHV0ZWQgdGV4dCwgd2hpbGUgMSBtZWFucyBmaXJzdCBwaWxsIHNlbGVjdGVkXG4gICAgICAgIGNvbnN0IGluZGV4ID0gKHRoaXMuc3RhdGUuc2VsZWN0aW9uT2Zmc2V0ICsgZGVsdGEgKyBjb21wbGV0aW9uQ291bnQgLSAxKSAlIGNvbXBsZXRpb25Db3VudDtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oMSArIGluZGV4KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb25Fc2NhcGUoZTogS2V5Ym9hcmRFdmVudCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBjb21wbGV0aW9uQ291bnQgPSB0aGlzLmNvdW50Q29tcGxldGlvbnMoKTtcbiAgICAgICAgaWYgKGNvbXBsZXRpb25Db3VudCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gYXV0b2NvbXBsZXRlIGlzIGFscmVhZHkgZW1wdHksIHNvIGRvbid0IHByZXZlbnREZWZhdWx0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gc2VsZWN0aW9uT2Zmc2V0ID0gMCwgc28gd2UgZG9uJ3QgZW5kIHVwIGNvbXBsZXRpbmcgd2hlbiBhdXRvY29tcGxldGUgaXMgaGlkZGVuXG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGlkZSA9ICgpOiB2b2lkID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBoaWRlOiB0cnVlLFxuICAgICAgICAgICAgc2VsZWN0aW9uT2Zmc2V0OiAxLFxuICAgICAgICAgICAgY29tcGxldGlvbnM6IFtdLFxuICAgICAgICAgICAgY29tcGxldGlvbkxpc3Q6IFtdLFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcHVibGljIGZvcmNlQ29tcGxldGUoKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBmb3JjZUNvbXBsZXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGhpZGU6IGZhbHNlLFxuICAgICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGUodGhpcy5wcm9wcy5xdWVyeSwgdGhpcy5wcm9wcy5zZWxlY3Rpb24pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuY291bnRDb21wbGV0aW9ucygpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb25Db25maXJtQ29tcGxldGlvbiA9ICgpOiB2b2lkID0+IHtcbiAgICAgICAgdGhpcy5vbkNvbXBsZXRpb25DbGlja2VkKHRoaXMuc3RhdGUuc2VsZWN0aW9uT2Zmc2V0KTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbkNvbXBsZXRpb25DbGlja2VkID0gKHNlbGVjdGlvbk9mZnNldDogbnVtYmVyKTogYm9vbGVhbiA9PiB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5jb3VudENvbXBsZXRpb25zKCk7XG4gICAgICAgIGlmIChjb3VudCA9PT0gMCB8fCBzZWxlY3Rpb25PZmZzZXQgPCAxIHx8IHNlbGVjdGlvbk9mZnNldCA+IGNvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByb3BzLm9uQ29uZmlybSh0aGlzLnN0YXRlLmNvbXBsZXRpb25MaXN0W3NlbGVjdGlvbk9mZnNldCAtIDFdKTtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHByaXZhdGUgc2V0U2VsZWN0aW9uKHNlbGVjdGlvbk9mZnNldDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBzZWxlY3Rpb25PZmZzZXQsIGhpZGU6IGZhbHNlIH0pO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5vblNlbGVjdGlvbkNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblNlbGVjdGlvbkNoYW5nZShzZWxlY3Rpb25PZmZzZXQgLSAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IElQcm9wcykge1xuICAgICAgICB0aGlzLmFwcGx5TmV3UHJvcHMocHJldlByb3BzLnF1ZXJ5LCBwcmV2UHJvcHMucm9vbSk7XG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIHNlbGVjdGVkIGNvbXBsZXRpb24sIHNvIHNjcm9sbCBpdCBpbnRvIHZpZXcgaWYgbmVlZGVkXG4gICAgICAgIGNvbnN0IHNlbGVjdGVkQ29tcGxldGlvbiA9IHRoaXMucmVmc1tgY29tcGxldGlvbiR7dGhpcy5zdGF0ZS5zZWxlY3Rpb25PZmZzZXR9YF0gYXMgSFRNTEVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkQ29tcGxldGlvbikge1xuICAgICAgICAgICAgc2VsZWN0ZWRDb21wbGV0aW9uLnNjcm9sbEludG9WaWV3KHtcbiAgICAgICAgICAgICAgICBiZWhhdmlvcjogXCJhdXRvXCIsXG4gICAgICAgICAgICAgICAgYmxvY2s6IFwibmVhcmVzdFwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jb250YWluZXJSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXJSZWYuY3VycmVudC5zY3JvbGxUbyh7IHRvcDogMCB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHBvc2l0aW9uID0gMTtcbiAgICAgICAgY29uc3QgcmVuZGVyZWRDb21wbGV0aW9ucyA9IHRoaXMuc3RhdGUuY29tcGxldGlvbnMubWFwKChjb21wbGV0aW9uUmVzdWx0LCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb21wbGV0aW9ucyA9IGNvbXBsZXRpb25SZXN1bHQuY29tcGxldGlvbnMubWFwKChjb21wbGV0aW9uLCBqKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBwb3NpdGlvbiA9PT0gdGhpcy5zdGF0ZS5zZWxlY3Rpb25PZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gY2xhc3NOYW1lcygnbXhfQXV0b2NvbXBsZXRlX0NvbXBsZXRpb24nLCB7IHNlbGVjdGVkIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudFBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgcG9zaXRpb24rKztcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9uQ2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Db21wbGV0aW9uQ2xpY2tlZChjb21wb25lbnRQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY29tcGxldGlvbi5jb21wb25lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgXCJrZXlcIjogaixcbiAgICAgICAgICAgICAgICAgICAgXCJyZWZcIjogYGNvbXBsZXRpb24ke2NvbXBvbmVudFBvc2l0aW9ufWAsXG4gICAgICAgICAgICAgICAgICAgIFwiaWRcIjogZ2VuZXJhdGVDb21wbGV0aW9uRG9tSWQoY29tcG9uZW50UG9zaXRpb24gLSAxKSwgLy8gMCBpbmRleCB0aGUgY29tcGxldGlvbiBJRHNcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrLFxuICAgICAgICAgICAgICAgICAgICBcImFyaWEtc2VsZWN0ZWRcIjogc2VsZWN0ZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRpb25zLmxlbmd0aCA+IDAgPyAoXG4gICAgICAgICAgICAgICAgPGRpdiBrZXk9e2l9IGNsYXNzTmFtZT1cIm14X0F1dG9jb21wbGV0ZV9Qcm92aWRlclNlY3Rpb25cIiByb2xlPVwicHJlc2VudGF0aW9uXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXhfQXV0b2NvbXBsZXRlX3Byb3ZpZGVyX25hbWVcIj57IGNvbXBsZXRpb25SZXN1bHQucHJvdmlkZXIuZ2V0TmFtZSgpIH08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgeyBjb21wbGV0aW9uUmVzdWx0LnByb3ZpZGVyLnJlbmRlckNvbXBsZXRpb25zKGNvbXBsZXRpb25zKSB9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApIDogbnVsbDtcbiAgICAgICAgfSkuZmlsdGVyKChjb21wbGV0aW9uKSA9PiAhIWNvbXBsZXRpb24pO1xuXG4gICAgICAgIHJldHVybiAhdGhpcy5zdGF0ZS5oaWRlICYmIHJlbmRlcmVkQ29tcGxldGlvbnMubGVuZ3RoID4gMCA/IChcbiAgICAgICAgICAgIDxkaXYgaWQ9XCJteF9BdXRvY29tcGxldGVcIiBjbGFzc05hbWU9XCJteF9BdXRvY29tcGxldGVcIiByZWY9e3RoaXMuY29udGFpbmVyUmVmfSByb2xlPVwibGlzdGJveFwiPlxuICAgICAgICAgICAgICAgIHsgcmVuZGVyZWRDb21wbGV0aW9ucyB9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKSA6IG51bGw7XG4gICAgfVxufVxuIl19