"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.HEADER_HEIGHT = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var React = _interopRequireWildcard(require("react"));

var _utils = require("matrix-js-sdk/src/utils");

var _classnames = _interopRequireDefault(require("classnames"));

var _RovingTabIndex = require("../../../accessibility/RovingTabIndex");

var _languageHandler = require("../../../languageHandler");

var _AccessibleButton = _interopRequireDefault(require("../../views/elements/AccessibleButton"));

var _RoomTile = _interopRequireDefault(require("./RoomTile"));

var _ContextMenu = _interopRequireWildcard(require("../../structures/ContextMenu"));

var _RoomListStore = _interopRequireWildcard(require("../../../stores/room-list/RoomListStore"));

var _models = require("../../../stores/room-list/algorithms/models");

var _models2 = require("../../../stores/room-list/models");

var _dispatcher = _interopRequireDefault(require("../../../dispatcher/dispatcher"));

var _actions = require("../../../dispatcher/actions");

var _NotificationBadge = _interopRequireDefault(require("./NotificationBadge"));

var _AccessibleTooltipButton = _interopRequireDefault(require("../elements/AccessibleTooltipButton"));

var _Keyboard = require("../../../Keyboard");

var _reResizable = require("re-resizable");

var _polyfill = require("../../../@types/polyfill");

var _RoomNotificationStateStore = require("../../../stores/notifications/RoomNotificationStateStore");

var _RoomListLayoutStore = _interopRequireDefault(require("../../../stores/room-list/RoomListLayoutStore"));

var _arrays = require("../../../utils/arrays");

var _objects = require("../../../utils/objects");

var _IconizedContextMenu = _interopRequireDefault(require("../context_menus/IconizedContextMenu"));

var _KeyBindingsManager = require("../../../KeyBindingsManager");

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _UIComponents = require("../../../customisations/helpers/UIComponents");

var _UIFeature = require("../../../settings/UIFeature");

var _dec, _class;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const SHOW_N_BUTTON_HEIGHT = 28; // As defined by CSS

const RESIZE_HANDLE_HEIGHT = 4; // As defined by CSS

const HEADER_HEIGHT = 32; // As defined by CSS

exports.HEADER_HEIGHT = HEADER_HEIGHT;
const MAX_PADDING_HEIGHT = SHOW_N_BUTTON_HEIGHT + RESIZE_HANDLE_HEIGHT; // HACK: We really shouldn't have to do this.

(0, _polyfill.polyfillTouchEvent)();
let RoomSublist = (_dec = (0, _replaceableComponent.replaceableComponent)("views.rooms.RoomSublist"), _dec(_class = class RoomSublist extends React.Component {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "headerButton", /*#__PURE__*/(0, React.createRef)());
    (0, _defineProperty2.default)(this, "sublistRef", /*#__PURE__*/(0, React.createRef)());
    (0, _defineProperty2.default)(this, "tilesRef", /*#__PURE__*/(0, React.createRef)());
    (0, _defineProperty2.default)(this, "dispatcherRef", void 0);
    (0, _defineProperty2.default)(this, "layout", void 0);
    (0, _defineProperty2.default)(this, "heightAtStart", void 0);
    (0, _defineProperty2.default)(this, "isBeingFiltered", void 0);
    (0, _defineProperty2.default)(this, "notificationState", void 0);
    (0, _defineProperty2.default)(this, "onListsUpdated", () => {
      const stateUpdates = {}; // &any is to avoid a cast on the initializer

      if (this.props.extraTiles) {
        const nameCondition = _RoomListStore.default.instance.getFirstNameFilterCondition();

        if (nameCondition) {
          stateUpdates.filteredExtraTiles = this.props.extraTiles.filter(t => nameCondition.matches((0, _utils.normalize)(t.props.displayName || "")));
        } else if (this.state.filteredExtraTiles) {
          stateUpdates.filteredExtraTiles = null;
        }
      }

      const currentRooms = this.state.rooms;
      const newRooms = (0, _arrays.arrayFastClone)(_RoomListStore.default.instance.orderedLists[this.props.tagId] || []);

      if ((0, _arrays.arrayHasOrderChange)(currentRooms, newRooms)) {
        stateUpdates.rooms = newRooms;
      }

      const isStillBeingFiltered = !!_RoomListStore.default.instance.getFirstNameFilterCondition();

      if (isStillBeingFiltered !== this.isBeingFiltered) {
        this.isBeingFiltered = isStillBeingFiltered;

        if (isStillBeingFiltered) {
          stateUpdates.isExpanded = true;
        } else {
          stateUpdates.isExpanded = !this.layout.isCollapsed;
        }
      }

      if (Object.keys(stateUpdates).length > 0) {
        this.setState(stateUpdates);
      }
    });
    (0, _defineProperty2.default)(this, "onAction", payload => {
      if (payload.action === "view_room" && payload.show_room_tile && this.state.rooms) {
        // XXX: we have to do this a tick later because we have incorrect intermediate props during a room change
        // where we lose the room we are changing from temporarily and then it comes back in an update right after.
        setImmediate(() => {
          const roomIndex = this.state.rooms.findIndex(r => r.roomId === payload.room_id);

          if (!this.state.isExpanded && roomIndex > -1) {
            this.toggleCollapsed();
          } // extend the visible section to include the room if it is entirely invisible


          if (roomIndex >= this.numVisibleTiles) {
            this.layout.visibleTiles = this.layout.tilesWithPadding(roomIndex + 1, MAX_PADDING_HEIGHT);
            this.forceUpdate(); // because the layout doesn't trigger a re-render
          }
        });
      }
    });
    (0, _defineProperty2.default)(this, "onAddRoom", e => {
      e.stopPropagation();
      if (this.props.onAddRoom) this.props.onAddRoom();
    });
    (0, _defineProperty2.default)(this, "onResize", (e, travelDirection, refToElement, delta) => {
      const newHeight = this.heightAtStart + delta.height;
      this.applyHeightChange(newHeight);
      this.setState({
        height: newHeight
      });
    });
    (0, _defineProperty2.default)(this, "onResizeStart", () => {
      this.heightAtStart = this.state.height;
      this.setState({
        isResizing: true
      });
    });
    (0, _defineProperty2.default)(this, "onResizeStop", (e, travelDirection, refToElement, delta) => {
      const newHeight = this.heightAtStart + delta.height;
      this.applyHeightChange(newHeight);
      this.setState({
        isResizing: false,
        height: newHeight
      });
    });
    (0, _defineProperty2.default)(this, "onShowAllClick", () => {
      // read number of visible tiles before we mutate it
      const numVisibleTiles = this.numVisibleTiles;
      const newHeight = this.layout.tilesToPixelsWithPadding(this.numTiles, this.padding);
      this.applyHeightChange(newHeight);
      this.setState({
        height: newHeight
      }, () => {
        // focus the top-most new room
        this.focusRoomTile(numVisibleTiles);
      });
    });
    (0, _defineProperty2.default)(this, "onShowLessClick", () => {
      const newHeight = this.layout.tilesToPixelsWithPadding(this.layout.defaultVisibleTiles, this.padding);
      this.applyHeightChange(newHeight);
      this.setState({
        height: newHeight
      });
    });
    (0, _defineProperty2.default)(this, "focusRoomTile", index => {
      if (!this.sublistRef.current) return;
      const elements = this.sublistRef.current.querySelectorAll(".mx_RoomTile");
      const element = elements && elements[index];

      if (element) {
        element.focus();
      }
    });
    (0, _defineProperty2.default)(this, "onOpenMenuClick", ev => {
      ev.preventDefault();
      ev.stopPropagation();
      const target = ev.target;
      this.setState({
        contextMenuPosition: target.getBoundingClientRect()
      });
    });
    (0, _defineProperty2.default)(this, "onContextMenu", ev => {
      ev.preventDefault();
      ev.stopPropagation();
      this.setState({
        contextMenuPosition: {
          left: ev.clientX,
          top: ev.clientY,
          height: 0
        }
      });
    });
    (0, _defineProperty2.default)(this, "onAddRoomContextMenu", ev => {
      ev.preventDefault();
      ev.stopPropagation();
      const target = ev.target;
      this.setState({
        addRoomContextMenuPosition: target.getBoundingClientRect()
      });
    });
    (0, _defineProperty2.default)(this, "onCloseMenu", () => {
      this.setState({
        contextMenuPosition: null
      });
    });
    (0, _defineProperty2.default)(this, "onCloseAddRoomMenu", () => {
      this.setState({
        addRoomContextMenuPosition: null
      });
    });
    (0, _defineProperty2.default)(this, "onUnreadFirstChanged", () => {
      const isUnreadFirst = _RoomListStore.default.instance.getListOrder(this.props.tagId) === _models.ListAlgorithm.Importance;

      const newAlgorithm = isUnreadFirst ? _models.ListAlgorithm.Natural : _models.ListAlgorithm.Importance;

      _RoomListStore.default.instance.setListOrder(this.props.tagId, newAlgorithm);

      this.forceUpdate(); // because if the sublist doesn't have any changes then we will miss the list order change
    });
    (0, _defineProperty2.default)(this, "onTagSortChanged", async sort => {
      await _RoomListStore.default.instance.setTagSorting(this.props.tagId, sort);
    });
    (0, _defineProperty2.default)(this, "onMessagePreviewChanged", () => {
      this.layout.showPreviews = !this.layout.showPreviews;
      this.forceUpdate(); // because the layout doesn't trigger a re-render
    });
    (0, _defineProperty2.default)(this, "onBadgeClick", ev => {
      ev.preventDefault();
      ev.stopPropagation();
      let room;

      if (this.props.tagId === _models2.DefaultTagID.Invite) {
        // switch to first room as that'll be the top of the list for the user
        room = this.state.rooms && this.state.rooms[0];
      } else {
        // find the first room with a count of the same colour as the badge count
        room = _RoomListStore.default.instance.unfilteredLists[this.props.tagId].find(r => {
          const notifState = this.notificationState.getForRoom(r);
          return notifState.count > 0 && notifState.color === this.notificationState.color;
        });
      }

      if (room) {
        _dispatcher.default.dispatch({
          action: _actions.Action.ViewRoom,
          room_id: room.roomId,
          show_room_tile: true // to make sure the room gets scrolled into view

        });
      }
    });
    (0, _defineProperty2.default)(this, "onHeaderClick", () => {
      const possibleSticky = this.headerButton.current.parentElement;
      const sublist = possibleSticky.parentElement.parentElement;
      const list = sublist.parentElement.parentElement; // the scrollTop is capped at the height of the header in LeftPanel, the top header is always sticky

      const listScrollTop = Math.round(list.scrollTop);
      const isAtTop = listScrollTop <= Math.round(HEADER_HEIGHT);
      const isAtBottom = listScrollTop >= Math.round(list.scrollHeight - list.offsetHeight);
      const isStickyTop = possibleSticky.classList.contains('mx_RoomSublist_headerContainer_stickyTop');
      const isStickyBottom = possibleSticky.classList.contains('mx_RoomSublist_headerContainer_stickyBottom');

      if (isStickyBottom && !isAtBottom || isStickyTop && !isAtTop) {
        // is sticky - jump to list
        sublist.scrollIntoView({
          behavior: 'smooth'
        });
      } else {
        // on screen - toggle collapse
        const isExpanded = this.state.isExpanded;
        this.toggleCollapsed(); // if the bottom list is collapsed then scroll it in so it doesn't expand off screen

        if (!isExpanded && isStickyBottom) {
          setImmediate(() => {
            sublist.scrollIntoView({
              behavior: 'smooth'
            });
          });
        }
      }
    });
    (0, _defineProperty2.default)(this, "toggleCollapsed", () => {
      this.layout.isCollapsed = this.state.isExpanded;
      this.setState({
        isExpanded: !this.layout.isCollapsed
      });

      if (this.props.onListCollapse) {
        this.props.onListCollapse(!this.layout.isCollapsed);
      }
    });
    (0, _defineProperty2.default)(this, "onHeaderKeyDown", ev => {
      const action = (0, _KeyBindingsManager.getKeyBindingsManager)().getRoomListAction(ev);

      switch (action) {
        case _KeyBindingsManager.RoomListAction.CollapseSection:
          ev.stopPropagation();

          if (this.state.isExpanded) {
            // Collapse the room sublist if it isn't already
            this.toggleCollapsed();
          }

          break;

        case _KeyBindingsManager.RoomListAction.ExpandSection:
          {
            ev.stopPropagation();

            if (!this.state.isExpanded) {
              // Expand the room sublist if it isn't already
              this.toggleCollapsed();
            } else if (this.sublistRef.current) {
              // otherwise focus the first room
              const element = this.sublistRef.current.querySelector(".mx_RoomTile");

              if (element) {
                element.focus();
              }
            }

            break;
          }
      }
    });
    (0, _defineProperty2.default)(this, "onKeyDown", ev => {
      switch (ev.key) {
        // On ARROW_LEFT go to the sublist header
        case _Keyboard.Key.ARROW_LEFT:
          ev.stopPropagation();
          this.headerButton.current.focus();
          break;
        // Consume ARROW_RIGHT so it doesn't cause focus to get sent to composer

        case _Keyboard.Key.ARROW_RIGHT:
          ev.stopPropagation();
      }
    });
    this.layout = _RoomListLayoutStore.default.instance.getLayoutFor(this.props.tagId);
    this.heightAtStart = 0;
    this.isBeingFiltered = !!_RoomListStore.default.instance.getFirstNameFilterCondition();
    this.notificationState = _RoomNotificationStateStore.RoomNotificationStateStore.instance.getListState(this.props.tagId);
    this.state = {
      contextMenuPosition: null,
      addRoomContextMenuPosition: null,
      isResizing: false,
      isExpanded: this.isBeingFiltered ? this.isBeingFiltered : !this.layout.isCollapsed,
      height: 0,
      // to be fixed in a moment, we need `rooms` to calculate this.
      rooms: (0, _arrays.arrayFastClone)(_RoomListStore.default.instance.orderedLists[this.props.tagId] || [])
    }; // Why Object.assign() and not this.state.height? Because TypeScript says no.

    this.state = Object.assign(this.state, {
      height: this.calculateInitialHeight()
    });
  }

  calculateInitialHeight() {
    const requestedVisibleTiles = Math.max(Math.floor(this.layout.visibleTiles), this.layout.minVisibleTiles);
    const tileCount = Math.min(this.numTiles, requestedVisibleTiles);
    return this.layout.tilesToPixelsWithPadding(tileCount, this.padding);
  }

  get padding() {
    let padding = RESIZE_HANDLE_HEIGHT; // this is used for calculating the max height of the whole container,
    // and takes into account whether there should be room reserved for the show more/less button
    // when fully expanded. We can't rely purely on the layout's defaultVisible tile count
    // because there are conditions in which we need to know that the 'show more' button
    // is present while well under the default tile limit.

    const needsShowMore = this.numTiles > this.numVisibleTiles; // ...but also check this or we'll miss if the section is expanded and we need a
    // 'show less'

    const needsShowLess = this.numTiles > this.layout.defaultVisibleTiles;

    if (needsShowMore || needsShowLess) {
      padding += SHOW_N_BUTTON_HEIGHT;
    }

    return padding;
  }

  get extraTiles() {
    if (this.state.filteredExtraTiles) {
      return this.state.filteredExtraTiles;
    }

    if (this.props.extraTiles) {
      return this.props.extraTiles;
    }

    return null;
  }

  get numTiles() {
    return RoomSublist.calcNumTiles(this.state.rooms, this.extraTiles);
  }

  static calcNumTiles(rooms, extraTiles) {
    return (rooms || []).length + (extraTiles || []).length;
  }

  get numVisibleTiles() {
    const nVisible = Math.ceil(this.layout.visibleTiles);
    return Math.min(nVisible, this.numTiles);
  }

  componentDidUpdate(prevProps, prevState) {
    const prevExtraTiles = prevState.filteredExtraTiles || prevProps.extraTiles; // as the rooms can come in one by one we need to reevaluate
    // the amount of available rooms to cap the amount of requested visible rooms by the layout

    if (RoomSublist.calcNumTiles(prevState.rooms, prevExtraTiles) !== this.numTiles) {
      this.setState({
        height: this.calculateInitialHeight()
      });
    }
  }

  shouldComponentUpdate(nextProps, nextState) {
    if ((0, _objects.objectHasDiff)(this.props, nextProps)) {
      // Something we don't care to optimize has updated, so update.
      return true;
    } // Do the same check used on props for state, without the rooms we're going to no-op


    const prevStateNoRooms = (0, _objects.objectExcluding)(this.state, ['rooms']);
    const nextStateNoRooms = (0, _objects.objectExcluding)(nextState, ['rooms']);

    if ((0, _objects.objectHasDiff)(prevStateNoRooms, nextStateNoRooms)) {
      return true;
    } // If we're supposed to handle extra tiles, take the performance hit and re-render all the
    // time so we don't have to consider them as part of the visible room optimization.


    const prevExtraTiles = this.props.extraTiles || [];
    const nextExtraTiles = nextState.filteredExtraTiles || nextProps.extraTiles || [];

    if (prevExtraTiles.length > 0 || nextExtraTiles.length > 0) {
      return true;
    } // If we're about to update the height of the list, we don't really care about which rooms
    // are visible or not for no-op purposes, so ensure that the height calculation runs through.


    if (RoomSublist.calcNumTiles(nextState.rooms, nextExtraTiles) !== this.numTiles) {
      return true;
    } // Before we go analyzing the rooms, we can see if we're collapsed. If we're collapsed, we don't need
    // to render anything. We do this after the height check though to ensure that the height gets appropriately
    // calculated for when/if we become uncollapsed.


    if (!nextState.isExpanded) {
      return false;
    } // Quickly double check we're not about to break something due to the number of rooms changing.


    if (this.state.rooms.length !== nextState.rooms.length) {
      return true;
    } // Finally, determine if the room update (as presumably that's all that's left) is within
    // our visible range. If it is, then do a render. If the update is outside our visible range
    // then we can skip the update.
    //
    // We also optimize for order changing here: if the update did happen in our visible range
    // but doesn't result in the list re-sorting itself then there's no reason for us to update
    // on our own.


    const prevSlicedRooms = this.state.rooms.slice(0, this.numVisibleTiles);
    const nextSlicedRooms = nextState.rooms.slice(0, this.numVisibleTiles);

    if ((0, _arrays.arrayHasOrderChange)(prevSlicedRooms, nextSlicedRooms)) {
      return true;
    } // Finally, nothing happened so no-op the update


    return false;
  }

  componentDidMount() {
    var _this$tilesRef$curren;

    this.dispatcherRef = _dispatcher.default.register(this.onAction);

    _RoomListStore.default.instance.on(_RoomListStore.LISTS_UPDATE_EVENT, this.onListsUpdated); // Using the passive option to not block the main thread
    // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#improving_scrolling_performance_with_passive_listeners


    (_this$tilesRef$curren = this.tilesRef.current) === null || _this$tilesRef$curren === void 0 ? void 0 : _this$tilesRef$curren.addEventListener("scroll", this.onScrollPrevent, {
      passive: true
    });
  }

  componentWillUnmount() {
    var _this$tilesRef$curren2;

    _dispatcher.default.unregister(this.dispatcherRef);

    _RoomListStore.default.instance.off(_RoomListStore.LISTS_UPDATE_EVENT, this.onListsUpdated);

    (_this$tilesRef$curren2 = this.tilesRef.current) === null || _this$tilesRef$curren2 === void 0 ? void 0 : _this$tilesRef$curren2.removeEventListener("scroll", this.onScrollPrevent);
  }

  applyHeightChange(newHeight) {
    const heightInTiles = Math.ceil(this.layout.pixelsToTiles(newHeight - this.padding));
    this.layout.visibleTiles = Math.min(this.numTiles, heightInTiles);
  }

  renderVisibleTiles() {
    if (!this.state.isExpanded) {
      // don't waste time on rendering
      return [];
    }

    const tiles = [];

    if (this.state.rooms) {
      const visibleRooms = this.state.rooms.slice(0, this.numVisibleTiles);

      for (const room of visibleRooms) {
        tiles.push( /*#__PURE__*/React.createElement(_RoomTile.default, {
          room: room,
          key: `room-${room.roomId}`,
          showMessagePreview: this.layout.showPreviews,
          isMinimized: this.props.isMinimized,
          tag: this.props.tagId
        }));
      }
    }

    if (this.extraTiles) {
      // HACK: We break typing here, but this 'extra tiles' property shouldn't exist.
      tiles.push(...this.extraTiles);
    } // We only have to do this because of the extra tiles. We do it conditionally
    // to avoid spending cycles on slicing. It's generally fine to do this though
    // as users are unlikely to have more than a handful of tiles when the extra
    // tiles are used.


    if (tiles.length > this.numVisibleTiles) {
      return tiles.slice(0, this.numVisibleTiles);
    }

    return tiles;
  }

  renderMenu() {
    let contextMenu = null;

    if (this.state.contextMenuPosition) {
      const isAlphabetical = _RoomListStore.default.instance.getTagSorting(this.props.tagId) === _models.SortAlgorithm.Alphabetic;

      const isUnreadFirst = _RoomListStore.default.instance.getListOrder(this.props.tagId) === _models.ListAlgorithm.Importance; // Invites don't get some nonsense options, so only add them if we have to.


      let otherSections = null;

      if (this.props.tagId !== _models2.DefaultTagID.Invite) {
        otherSections = /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("hr", null), /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("div", {
          className: "mx_RoomSublist_contextMenu_title"
        }, (0, _languageHandler._t)("Appearance")), /*#__PURE__*/React.createElement(_ContextMenu.StyledMenuItemCheckbox, {
          onClose: this.onCloseMenu,
          onChange: this.onUnreadFirstChanged,
          checked: isUnreadFirst
        }, (0, _languageHandler._t)("Show rooms with unread messages first")), /*#__PURE__*/React.createElement(_ContextMenu.StyledMenuItemCheckbox, {
          onClose: this.onCloseMenu,
          onChange: this.onMessagePreviewChanged,
          checked: this.layout.showPreviews
        }, (0, _languageHandler._t)("Show previews of messages"))));
      }

      contextMenu = /*#__PURE__*/React.createElement(_ContextMenu.default, {
        chevronFace: _ContextMenu.ChevronFace.None,
        left: this.state.contextMenuPosition.left,
        top: this.state.contextMenuPosition.top + this.state.contextMenuPosition.height,
        onFinished: this.onCloseMenu
      }, /*#__PURE__*/React.createElement("div", {
        className: "mx_RoomSublist_contextMenu"
      }, /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("div", {
        className: "mx_RoomSublist_contextMenu_title"
      }, (0, _languageHandler._t)("Sort by")), /*#__PURE__*/React.createElement(_ContextMenu.StyledMenuItemRadio, {
        onClose: this.onCloseMenu,
        onChange: () => this.onTagSortChanged(_models.SortAlgorithm.Recent),
        checked: !isAlphabetical,
        name: `mx_${this.props.tagId}_sortBy`
      }, (0, _languageHandler._t)("Activity")), /*#__PURE__*/React.createElement(_ContextMenu.StyledMenuItemRadio, {
        onClose: this.onCloseMenu,
        onChange: () => this.onTagSortChanged(_models.SortAlgorithm.Alphabetic),
        checked: isAlphabetical,
        name: `mx_${this.props.tagId}_sortBy`
      }, (0, _languageHandler._t)("A-Z"))), otherSections));
    } else if (this.state.addRoomContextMenuPosition) {
      contextMenu = /*#__PURE__*/React.createElement(_IconizedContextMenu.default, {
        chevronFace: _ContextMenu.ChevronFace.None,
        left: this.state.addRoomContextMenuPosition.left - 7 // center align with the handle
        ,
        top: this.state.addRoomContextMenuPosition.top + this.state.addRoomContextMenuPosition.height,
        onFinished: this.onCloseAddRoomMenu,
        compact: true
      }, this.props.addRoomContextMenu(this.onCloseAddRoomMenu));
    }

    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(_ContextMenu.ContextMenuTooltipButton, {
      className: "mx_RoomSublist_menuButton",
      onClick: this.onOpenMenuClick,
      title: (0, _languageHandler._t)("List options"),
      isExpanded: !!this.state.contextMenuPosition
    }), contextMenu);
  }

  renderHeader() {
    return /*#__PURE__*/React.createElement(_RovingTabIndex.RovingTabIndexWrapper, {
      inputRef: this.headerButton
    }, ({
      onFocus,
      isActive,
      ref
    }) => {
      const tabIndex = isActive ? 0 : -1;
      let ariaLabel = (0, _languageHandler._t)("Jump to first unread room.");

      if (this.props.tagId === _models2.DefaultTagID.Invite) {
        ariaLabel = (0, _languageHandler._t)("Jump to first invite.");
      }

      const badge = /*#__PURE__*/React.createElement(_NotificationBadge.default, {
        forceCount: true,
        notification: this.notificationState,
        onClick: this.onBadgeClick,
        tabIndex: tabIndex,
        "aria-label": ariaLabel,
        showUnsentTooltip: true
      });
      let addRoomButton = null;

      if (!!this.props.onAddRoom && (0, _UIComponents.shouldShowComponent)(_UIFeature.UIComponent.CreateRooms)) {
        addRoomButton = /*#__PURE__*/React.createElement(_AccessibleTooltipButton.default, {
          tabIndex: tabIndex,
          onClick: this.onAddRoom,
          className: "mx_RoomSublist_auxButton",
          tooltipClassName: "mx_RoomSublist_addRoomTooltip",
          "aria-label": this.props.addRoomLabel || (0, _languageHandler._t)("Add room"),
          title: this.props.addRoomLabel
        });
      } else if (this.props.addRoomContextMenu) {
        // We assume that shouldShowComponent() is checked by the context menu itself.
        addRoomButton = /*#__PURE__*/React.createElement(_ContextMenu.ContextMenuTooltipButton, {
          tabIndex: tabIndex,
          onClick: this.onAddRoomContextMenu,
          className: "mx_RoomSublist_auxButton",
          tooltipClassName: "mx_RoomSublist_addRoomTooltip",
          "aria-label": this.props.addRoomLabel || (0, _languageHandler._t)("Add room"),
          title: this.props.addRoomLabel,
          isExpanded: !!this.state.addRoomContextMenuPosition
        });
      }

      const collapseClasses = (0, _classnames.default)({
        'mx_RoomSublist_collapseBtn': true,
        'mx_RoomSublist_collapseBtn_collapsed': !this.state.isExpanded
      });
      const classes = (0, _classnames.default)({
        'mx_RoomSublist_headerContainer': true,
        'mx_RoomSublist_headerContainer_withAux': !!addRoomButton
      });
      const badgeContainer = /*#__PURE__*/React.createElement("div", {
        className: "mx_RoomSublist_badgeContainer"
      }, badge);
      let Button = _AccessibleButton.default;

      if (this.props.isMinimized) {
        Button = _AccessibleTooltipButton.default;
      } // Note: the addRoomButton conditionally gets moved around
      // the DOM depending on whether or not the list is minimized.
      // If we're minimized, we want it below the header so it
      // doesn't become sticky.
      // The same applies to the notification badge.


      return /*#__PURE__*/React.createElement("div", {
        className: classes,
        onKeyDown: this.onHeaderKeyDown,
        onFocus: onFocus,
        "aria-label": this.props.label
      }, /*#__PURE__*/React.createElement("div", {
        className: "mx_RoomSublist_stickable"
      }, /*#__PURE__*/React.createElement(Button, {
        onFocus: onFocus,
        inputRef: ref,
        tabIndex: tabIndex,
        className: "mx_RoomSublist_headerText",
        role: "treeitem",
        "aria-expanded": this.state.isExpanded,
        "aria-level": 1,
        onClick: this.onHeaderClick,
        onContextMenu: this.onContextMenu,
        title: this.props.isMinimized ? this.props.label : undefined
      }, /*#__PURE__*/React.createElement("span", {
        className: collapseClasses
      }), /*#__PURE__*/React.createElement("span", null, this.props.label)), this.renderMenu(), this.props.isMinimized ? null : badgeContainer, this.props.isMinimized ? null : addRoomButton), this.props.isMinimized ? badgeContainer : null, this.props.isMinimized ? addRoomButton : null);
    });
  }

  onScrollPrevent(e) {
    // the RoomTile calls scrollIntoView and the browser may scroll a div we do not wish to be scrollable
    // this fixes https://github.com/vector-im/element-web/issues/14413
    e.target.scrollTop = 0;
  }

  render() {
    var _this$props$extraTile;

    const visibleTiles = this.renderVisibleTiles();
    const classes = (0, _classnames.default)({
      'mx_RoomSublist': true,
      'mx_RoomSublist_hasMenuOpen': !!this.state.contextMenuPosition,
      'mx_RoomSublist_minimized': this.props.isMinimized,
      'mx_RoomSublist_hidden': !this.state.rooms.length && !((_this$props$extraTile = this.props.extraTiles) !== null && _this$props$extraTile !== void 0 && _this$props$extraTile.length) && this.props.alwaysVisible !== true
    });
    let content = null;

    if (visibleTiles.length > 0) {
      const layout = this.layout; // to shorten calls

      const minTiles = Math.min(layout.minVisibleTiles, this.numTiles);
      const showMoreAtMinHeight = minTiles < this.numTiles;
      const minHeightPadding = RESIZE_HANDLE_HEIGHT + (showMoreAtMinHeight ? SHOW_N_BUTTON_HEIGHT : 0);
      const minTilesPx = layout.tilesToPixelsWithPadding(minTiles, minHeightPadding);
      const maxTilesPx = layout.tilesToPixelsWithPadding(this.numTiles, this.padding);
      const showMoreBtnClasses = (0, _classnames.default)({
        'mx_RoomSublist_showNButton': true
      }); // If we're hiding rooms, show a 'show more' button to the user. This button
      // floats above the resize handle, if we have one present. If the user has all
      // tiles visible, it becomes 'show less'.

      let showNButton = null;

      if (maxTilesPx > this.state.height) {
        // the height of all the tiles is greater than the section height: we need a 'show more' button
        const nonPaddedHeight = this.state.height - RESIZE_HANDLE_HEIGHT - SHOW_N_BUTTON_HEIGHT;
        const amountFullyShown = Math.floor(nonPaddedHeight / this.layout.tileHeight);
        const numMissing = this.numTiles - amountFullyShown;
        const label = (0, _languageHandler._t)("Show %(count)s more", {
          count: numMissing
        });
        let showMoreText = /*#__PURE__*/React.createElement("span", {
          className: "mx_RoomSublist_showNButtonText"
        }, label);
        if (this.props.isMinimized) showMoreText = null;
        showNButton = /*#__PURE__*/React.createElement(_RovingTabIndex.RovingAccessibleButton, {
          role: "treeitem",
          onClick: this.onShowAllClick,
          className: showMoreBtnClasses,
          "aria-label": label
        }, /*#__PURE__*/React.createElement("span", {
          className: "mx_RoomSublist_showMoreButtonChevron mx_RoomSublist_showNButtonChevron"
        }), showMoreText);
      } else if (this.numTiles > this.layout.defaultVisibleTiles) {
        // we have all tiles visible - add a button to show less
        const label = (0, _languageHandler._t)("Show less");
        let showLessText = /*#__PURE__*/React.createElement("span", {
          className: "mx_RoomSublist_showNButtonText"
        }, label);
        if (this.props.isMinimized) showLessText = null;
        showNButton = /*#__PURE__*/React.createElement(_RovingTabIndex.RovingAccessibleButton, {
          role: "treeitem",
          onClick: this.onShowLessClick,
          className: showMoreBtnClasses,
          "aria-label": label
        }, /*#__PURE__*/React.createElement("span", {
          className: "mx_RoomSublist_showLessButtonChevron mx_RoomSublist_showNButtonChevron"
        }), showLessText);
      } // Figure out if we need a handle


      const handles = {
        bottom: true,
        // the only one we need, but the others must be explicitly false
        bottomLeft: false,
        bottomRight: false,
        left: false,
        right: false,
        top: false,
        topLeft: false,
        topRight: false
      };

      if (layout.visibleTiles >= this.numTiles && this.numTiles <= layout.minVisibleTiles) {
        // we're at a minimum, don't have a bottom handle
        handles.bottom = false;
      } // We have to account for padding so we can accommodate a 'show more' button and
      // the resize handle, which are pinned to the bottom of the container. This is the
      // easiest way to have a resize handle below the button as otherwise we're writing
      // our own resize handling and that doesn't sound fun.
      //
      // The layout class has some helpers for dealing with padding, as we don't want to
      // apply it in all cases. If we apply it in all cases, the resizing feels like it
      // goes backwards and can become wildly incorrect (visibleTiles says 18 when there's
      // only mathematically 7 possible).


      const handleWrapperClasses = (0, _classnames.default)({
        'mx_RoomSublist_resizerHandles': true,
        'mx_RoomSublist_resizerHandles_showNButton': !!showNButton
      });
      content = /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(_reResizable.Resizable, {
        size: {
          height: this.state.height
        },
        minHeight: minTilesPx,
        maxHeight: maxTilesPx,
        onResizeStart: this.onResizeStart,
        onResizeStop: this.onResizeStop,
        onResize: this.onResize,
        handleWrapperClass: handleWrapperClasses,
        handleClasses: {
          bottom: "mx_RoomSublist_resizerHandle"
        },
        className: "mx_RoomSublist_resizeBox",
        enable: handles
      }, /*#__PURE__*/React.createElement("div", {
        className: "mx_RoomSublist_tiles",
        ref: this.tilesRef
      }, visibleTiles), showNButton));
    } else if (this.props.showSkeleton && this.state.isExpanded) {
      content = /*#__PURE__*/React.createElement("div", {
        className: "mx_RoomSublist_skeletonUI"
      });
    }

    return /*#__PURE__*/React.createElement("div", {
      ref: this.sublistRef,
      className: classes,
      role: "group",
      "aria-label": this.props.label,
      onKeyDown: this.onKeyDown
    }, this.renderHeader(), content);
  }

}) || _class);
exports.default = RoomSublist;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL3Jvb21zL1Jvb21TdWJsaXN0LnRzeCJdLCJuYW1lcyI6WyJTSE9XX05fQlVUVE9OX0hFSUdIVCIsIlJFU0laRV9IQU5ETEVfSEVJR0hUIiwiSEVBREVSX0hFSUdIVCIsIk1BWF9QQURESU5HX0hFSUdIVCIsIlJvb21TdWJsaXN0IiwiUmVhY3QiLCJDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsInByb3BzIiwic3RhdGVVcGRhdGVzIiwiZXh0cmFUaWxlcyIsIm5hbWVDb25kaXRpb24iLCJSb29tTGlzdFN0b3JlIiwiaW5zdGFuY2UiLCJnZXRGaXJzdE5hbWVGaWx0ZXJDb25kaXRpb24iLCJmaWx0ZXJlZEV4dHJhVGlsZXMiLCJmaWx0ZXIiLCJ0IiwibWF0Y2hlcyIsImRpc3BsYXlOYW1lIiwic3RhdGUiLCJjdXJyZW50Um9vbXMiLCJyb29tcyIsIm5ld1Jvb21zIiwib3JkZXJlZExpc3RzIiwidGFnSWQiLCJpc1N0aWxsQmVpbmdGaWx0ZXJlZCIsImlzQmVpbmdGaWx0ZXJlZCIsImlzRXhwYW5kZWQiLCJsYXlvdXQiLCJpc0NvbGxhcHNlZCIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJzZXRTdGF0ZSIsInBheWxvYWQiLCJhY3Rpb24iLCJzaG93X3Jvb21fdGlsZSIsInNldEltbWVkaWF0ZSIsInJvb21JbmRleCIsImZpbmRJbmRleCIsInIiLCJyb29tSWQiLCJyb29tX2lkIiwidG9nZ2xlQ29sbGFwc2VkIiwibnVtVmlzaWJsZVRpbGVzIiwidmlzaWJsZVRpbGVzIiwidGlsZXNXaXRoUGFkZGluZyIsImZvcmNlVXBkYXRlIiwiZSIsInN0b3BQcm9wYWdhdGlvbiIsIm9uQWRkUm9vbSIsInRyYXZlbERpcmVjdGlvbiIsInJlZlRvRWxlbWVudCIsImRlbHRhIiwibmV3SGVpZ2h0IiwiaGVpZ2h0QXRTdGFydCIsImhlaWdodCIsImFwcGx5SGVpZ2h0Q2hhbmdlIiwiaXNSZXNpemluZyIsInRpbGVzVG9QaXhlbHNXaXRoUGFkZGluZyIsIm51bVRpbGVzIiwicGFkZGluZyIsImZvY3VzUm9vbVRpbGUiLCJkZWZhdWx0VmlzaWJsZVRpbGVzIiwiaW5kZXgiLCJzdWJsaXN0UmVmIiwiY3VycmVudCIsImVsZW1lbnRzIiwicXVlcnlTZWxlY3RvckFsbCIsImVsZW1lbnQiLCJmb2N1cyIsImV2IiwicHJldmVudERlZmF1bHQiLCJ0YXJnZXQiLCJjb250ZXh0TWVudVBvc2l0aW9uIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwibGVmdCIsImNsaWVudFgiLCJ0b3AiLCJjbGllbnRZIiwiYWRkUm9vbUNvbnRleHRNZW51UG9zaXRpb24iLCJpc1VucmVhZEZpcnN0IiwiZ2V0TGlzdE9yZGVyIiwiTGlzdEFsZ29yaXRobSIsIkltcG9ydGFuY2UiLCJuZXdBbGdvcml0aG0iLCJOYXR1cmFsIiwic2V0TGlzdE9yZGVyIiwic29ydCIsInNldFRhZ1NvcnRpbmciLCJzaG93UHJldmlld3MiLCJyb29tIiwiRGVmYXVsdFRhZ0lEIiwiSW52aXRlIiwidW5maWx0ZXJlZExpc3RzIiwiZmluZCIsIm5vdGlmU3RhdGUiLCJub3RpZmljYXRpb25TdGF0ZSIsImdldEZvclJvb20iLCJjb3VudCIsImNvbG9yIiwiZGlzIiwiZGlzcGF0Y2giLCJBY3Rpb24iLCJWaWV3Um9vbSIsInBvc3NpYmxlU3RpY2t5IiwiaGVhZGVyQnV0dG9uIiwicGFyZW50RWxlbWVudCIsInN1Ymxpc3QiLCJsaXN0IiwibGlzdFNjcm9sbFRvcCIsIk1hdGgiLCJyb3VuZCIsInNjcm9sbFRvcCIsImlzQXRUb3AiLCJpc0F0Qm90dG9tIiwic2Nyb2xsSGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0IiwiaXNTdGlja3lUb3AiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsImlzU3RpY2t5Qm90dG9tIiwic2Nyb2xsSW50b1ZpZXciLCJiZWhhdmlvciIsIm9uTGlzdENvbGxhcHNlIiwiZ2V0Um9vbUxpc3RBY3Rpb24iLCJSb29tTGlzdEFjdGlvbiIsIkNvbGxhcHNlU2VjdGlvbiIsIkV4cGFuZFNlY3Rpb24iLCJxdWVyeVNlbGVjdG9yIiwia2V5IiwiS2V5IiwiQVJST1dfTEVGVCIsIkFSUk9XX1JJR0hUIiwiUm9vbUxpc3RMYXlvdXRTdG9yZSIsImdldExheW91dEZvciIsIlJvb21Ob3RpZmljYXRpb25TdGF0ZVN0b3JlIiwiZ2V0TGlzdFN0YXRlIiwiYXNzaWduIiwiY2FsY3VsYXRlSW5pdGlhbEhlaWdodCIsInJlcXVlc3RlZFZpc2libGVUaWxlcyIsIm1heCIsImZsb29yIiwibWluVmlzaWJsZVRpbGVzIiwidGlsZUNvdW50IiwibWluIiwibmVlZHNTaG93TW9yZSIsIm5lZWRzU2hvd0xlc3MiLCJjYWxjTnVtVGlsZXMiLCJuVmlzaWJsZSIsImNlaWwiLCJjb21wb25lbnREaWRVcGRhdGUiLCJwcmV2UHJvcHMiLCJwcmV2U3RhdGUiLCJwcmV2RXh0cmFUaWxlcyIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsIm5leHRQcm9wcyIsIm5leHRTdGF0ZSIsInByZXZTdGF0ZU5vUm9vbXMiLCJuZXh0U3RhdGVOb1Jvb21zIiwibmV4dEV4dHJhVGlsZXMiLCJwcmV2U2xpY2VkUm9vbXMiLCJzbGljZSIsIm5leHRTbGljZWRSb29tcyIsImNvbXBvbmVudERpZE1vdW50IiwiZGlzcGF0Y2hlclJlZiIsImRlZmF1bHREaXNwYXRjaGVyIiwicmVnaXN0ZXIiLCJvbkFjdGlvbiIsIm9uIiwiTElTVFNfVVBEQVRFX0VWRU5UIiwib25MaXN0c1VwZGF0ZWQiLCJ0aWxlc1JlZiIsImFkZEV2ZW50TGlzdGVuZXIiLCJvblNjcm9sbFByZXZlbnQiLCJwYXNzaXZlIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJ1bnJlZ2lzdGVyIiwib2ZmIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhlaWdodEluVGlsZXMiLCJwaXhlbHNUb1RpbGVzIiwicmVuZGVyVmlzaWJsZVRpbGVzIiwidGlsZXMiLCJ2aXNpYmxlUm9vbXMiLCJwdXNoIiwiaXNNaW5pbWl6ZWQiLCJyZW5kZXJNZW51IiwiY29udGV4dE1lbnUiLCJpc0FscGhhYmV0aWNhbCIsImdldFRhZ1NvcnRpbmciLCJTb3J0QWxnb3JpdGhtIiwiQWxwaGFiZXRpYyIsIm90aGVyU2VjdGlvbnMiLCJvbkNsb3NlTWVudSIsIm9uVW5yZWFkRmlyc3RDaGFuZ2VkIiwib25NZXNzYWdlUHJldmlld0NoYW5nZWQiLCJDaGV2cm9uRmFjZSIsIk5vbmUiLCJvblRhZ1NvcnRDaGFuZ2VkIiwiUmVjZW50Iiwib25DbG9zZUFkZFJvb21NZW51IiwiYWRkUm9vbUNvbnRleHRNZW51Iiwib25PcGVuTWVudUNsaWNrIiwicmVuZGVySGVhZGVyIiwib25Gb2N1cyIsImlzQWN0aXZlIiwicmVmIiwidGFiSW5kZXgiLCJhcmlhTGFiZWwiLCJiYWRnZSIsIm9uQmFkZ2VDbGljayIsImFkZFJvb21CdXR0b24iLCJVSUNvbXBvbmVudCIsIkNyZWF0ZVJvb21zIiwiYWRkUm9vbUxhYmVsIiwib25BZGRSb29tQ29udGV4dE1lbnUiLCJjb2xsYXBzZUNsYXNzZXMiLCJjbGFzc2VzIiwiYmFkZ2VDb250YWluZXIiLCJCdXR0b24iLCJBY2Nlc3NpYmxlQnV0dG9uIiwiQWNjZXNzaWJsZVRvb2x0aXBCdXR0b24iLCJvbkhlYWRlcktleURvd24iLCJsYWJlbCIsIm9uSGVhZGVyQ2xpY2siLCJvbkNvbnRleHRNZW51IiwidW5kZWZpbmVkIiwicmVuZGVyIiwiYWx3YXlzVmlzaWJsZSIsImNvbnRlbnQiLCJtaW5UaWxlcyIsInNob3dNb3JlQXRNaW5IZWlnaHQiLCJtaW5IZWlnaHRQYWRkaW5nIiwibWluVGlsZXNQeCIsIm1heFRpbGVzUHgiLCJzaG93TW9yZUJ0bkNsYXNzZXMiLCJzaG93TkJ1dHRvbiIsIm5vblBhZGRlZEhlaWdodCIsImFtb3VudEZ1bGx5U2hvd24iLCJ0aWxlSGVpZ2h0IiwibnVtTWlzc2luZyIsInNob3dNb3JlVGV4dCIsIm9uU2hvd0FsbENsaWNrIiwic2hvd0xlc3NUZXh0Iiwib25TaG93TGVzc0NsaWNrIiwiaGFuZGxlcyIsImJvdHRvbSIsImJvdHRvbUxlZnQiLCJib3R0b21SaWdodCIsInJpZ2h0IiwidG9wTGVmdCIsInRvcFJpZ2h0IiwiaGFuZGxlV3JhcHBlckNsYXNzZXMiLCJvblJlc2l6ZVN0YXJ0Iiwib25SZXNpemVTdG9wIiwib25SZXNpemUiLCJzaG93U2tlbGV0b24iLCJvbktleURvd24iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBa0JBOztBQUVBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQU1BOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUdBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7OztBQUVBLE1BQU1BLG9CQUFvQixHQUFHLEVBQTdCLEMsQ0FBaUM7O0FBQ2pDLE1BQU1DLG9CQUFvQixHQUFHLENBQTdCLEMsQ0FBZ0M7O0FBQ3pCLE1BQU1DLGFBQWEsR0FBRyxFQUF0QixDLENBQTBCOzs7QUFFakMsTUFBTUMsa0JBQWtCLEdBQUdILG9CQUFvQixHQUFHQyxvQkFBbEQsQyxDQUVBOztBQUNBO0lBdUNxQkcsVyxXQURwQixnREFBcUIseUJBQXJCLEMsZ0JBQUQsTUFDcUJBLFdBRHJCLFNBQ3lDQyxLQUFLLENBQUNDLFNBRC9DLENBQ3lFO0FBVXJFQyxFQUFBQSxXQUFXLENBQUNDLEtBQUQsRUFBZ0I7QUFDdkIsVUFBTUEsS0FBTjtBQUR1QixxRUFUSixzQkFTSTtBQUFBLG1FQVJOLHNCQVFNO0FBQUEsaUVBUFIsc0JBT1E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMERBa0pGLE1BQU07QUFDM0IsWUFBTUMsWUFBMEIsR0FBRyxFQUFuQyxDQUQyQixDQUNZOztBQUV2QyxVQUFJLEtBQUtELEtBQUwsQ0FBV0UsVUFBZixFQUEyQjtBQUN2QixjQUFNQyxhQUFhLEdBQUdDLHVCQUFjQyxRQUFkLENBQXVCQywyQkFBdkIsRUFBdEI7O0FBQ0EsWUFBSUgsYUFBSixFQUFtQjtBQUNmRixVQUFB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QVpKLEVBZU1nTSxXQWZOLENBREosQ0FESjtBQXFCSCxLQXRIRCxNQXNITyxJQUFJLEtBQUt0TyxLQUFMLENBQVcwUCxZQUFYLElBQTJCLEtBQUs5TyxLQUFMLENBQVdRLFVBQTFDLEVBQXNEO0FBQ3pEMk0sTUFBQUEsT0FBTyxnQkFBRztBQUFLLFFBQUEsU0FBUyxFQUFDO0FBQWYsUUFBVjtBQUNIOztBQUVELHdCQUNJO0FBQ0ksTUFBQSxHQUFHLEVBQUUsS0FBS3JLLFVBRGQ7QUFFSSxNQUFBLFNBQVMsRUFBRXlKLE9BRmY7QUFHSSxNQUFBLElBQUksRUFBQyxPQUhUO0FBSUksb0JBQVksS0FBS25OLEtBQUwsQ0FBV3lOLEtBSjNCO0FBS0ksTUFBQSxTQUFTLEVBQUUsS0FBS2tDO0FBTHBCLE9BT00sS0FBS3RELFlBQUwsRUFQTixFQVFNMEIsT0FSTixDQURKO0FBWUg7O0FBN3lCb0UsQyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxNSwgMjAxNiBPcGVuTWFya2V0IEx0ZFxuQ29weXJpZ2h0IDIwMTcsIDIwMTggVmVjdG9yIENyZWF0aW9ucyBMdGRcbkNvcHlyaWdodCAyMDIwIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBjcmVhdGVSZWYsIFJlYWN0Q29tcG9uZW50RWxlbWVudCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgbm9ybWFsaXplIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL3V0aWxzXCI7XG5pbXBvcnQgeyBSb29tIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL21vZGVscy9yb29tXCI7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IFJvdmluZ0FjY2Vzc2libGVCdXR0b24sIFJvdmluZ1RhYkluZGV4V3JhcHBlciB9IGZyb20gXCIuLi8uLi8uLi9hY2Nlc3NpYmlsaXR5L1JvdmluZ1RhYkluZGV4XCI7XG5pbXBvcnQgeyBfdCB9IGZyb20gXCIuLi8uLi8uLi9sYW5ndWFnZUhhbmRsZXJcIjtcbmltcG9ydCBBY2Nlc3NpYmxlQnV0dG9uIGZyb20gXCIuLi8uLi92aWV3cy9lbGVtZW50cy9BY2Nlc3NpYmxlQnV0dG9uXCI7XG5pbXBvcnQgUm9vbVRpbGUgZnJvbSBcIi4vUm9vbVRpbGVcIjtcbmltcG9ydCB7IExpc3RMYXlvdXQgfSBmcm9tIFwiLi4vLi4vLi4vc3RvcmVzL3Jvb20tbGlzdC9MaXN0TGF5b3V0XCI7XG5pbXBvcnQgQ29udGV4dE1lbnUsIHtcbiAgICBDaGV2cm9uRmFjZSxcbiAgICBDb250ZXh0TWVudVRvb2x0aXBCdXR0b24sXG4gICAgU3R5bGVkTWVudUl0ZW1DaGVja2JveCxcbiAgICBTdHlsZWRNZW51SXRlbVJhZGlvLFxufSBmcm9tIFwiLi4vLi4vc3RydWN0dXJlcy9Db250ZXh0TWVudVwiO1xuaW1wb3J0IFJvb21MaXN0U3RvcmUsIHsgTElTVFNfVVBEQVRFX0VWRU5UIH0gZnJvbSBcIi4uLy4uLy4uL3N0b3Jlcy9yb29tLWxpc3QvUm9vbUxpc3RTdG9yZVwiO1xuaW1wb3J0IHsgTGlzdEFsZ29yaXRobSwgU29ydEFsZ29yaXRobSB9IGZyb20gXCIuLi8uLi8uLi9zdG9yZXMvcm9vbS1saXN0L2FsZ29yaXRobXMvbW9kZWxzXCI7XG5pbXBvcnQgeyBEZWZhdWx0VGFnSUQsIFRhZ0lEIH0gZnJvbSBcIi4uLy4uLy4uL3N0b3Jlcy9yb29tLWxpc3QvbW9kZWxzXCI7XG5pbXBvcnQgZGlzIGZyb20gXCIuLi8uLi8uLi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXJcIjtcbmltcG9ydCBkZWZhdWx0RGlzcGF0Y2hlciBmcm9tIFwiLi4vLi4vLi4vZGlzcGF0Y2hlci9kaXNwYXRjaGVyXCI7XG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tIFwiLi4vLi4vLi4vZGlzcGF0Y2hlci9hY3Rpb25zXCI7XG5pbXBvcnQgTm90aWZpY2F0aW9uQmFkZ2UgZnJvbSBcIi4vTm90aWZpY2F0aW9uQmFkZ2VcIjtcbmltcG9ydCBBY2Nlc3NpYmxlVG9vbHRpcEJ1dHRvbiBmcm9tIFwiLi4vZWxlbWVudHMvQWNjZXNzaWJsZVRvb2x0aXBCdXR0b25cIjtcbmltcG9ydCB7IEtleSB9IGZyb20gXCIuLi8uLi8uLi9LZXlib2FyZFwiO1xuaW1wb3J0IHsgQWN0aW9uUGF5bG9hZCB9IGZyb20gXCIuLi8uLi8uLi9kaXNwYXRjaGVyL3BheWxvYWRzXCI7XG5pbXBvcnQgeyBFbmFibGUsIFJlc2l6YWJsZSB9IGZyb20gXCJyZS1yZXNpemFibGVcIjtcbmltcG9ydCB7IERpcmVjdGlvbiB9IGZyb20gXCJyZS1yZXNpemFibGUvbGliL3Jlc2l6ZXJcIjtcbmltcG9ydCB7IHBvbHlmaWxsVG91Y2hFdmVudCB9IGZyb20gXCIuLi8uLi8uLi9AdHlwZXMvcG9seWZpbGxcIjtcbmltcG9ydCBSZXNpemVOb3RpZmllciBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvUmVzaXplTm90aWZpZXJcIjtcbmltcG9ydCB7IFJvb21Ob3RpZmljYXRpb25TdGF0ZVN0b3JlIH0gZnJvbSBcIi4uLy4uLy4uL3N0b3Jlcy9ub3RpZmljYXRpb25zL1Jvb21Ob3RpZmljYXRpb25TdGF0ZVN0b3JlXCI7XG5pbXBvcnQgUm9vbUxpc3RMYXlvdXRTdG9yZSBmcm9tIFwiLi4vLi4vLi4vc3RvcmVzL3Jvb20tbGlzdC9Sb29tTGlzdExheW91dFN0b3JlXCI7XG5pbXBvcnQgeyBhcnJheUZhc3RDbG9uZSwgYXJyYXlIYXNPcmRlckNoYW5nZSB9IGZyb20gXCIuLi8uLi8uLi91dGlscy9hcnJheXNcIjtcbmltcG9ydCB7IG9iamVjdEV4Y2x1ZGluZywgb2JqZWN0SGFzRGlmZiB9IGZyb20gXCIuLi8uLi8uLi91dGlscy9vYmplY3RzXCI7XG5pbXBvcnQgRXh0cmFUaWxlIGZyb20gXCIuL0V4dHJhVGlsZVwiO1xuaW1wb3J0IHsgTGlzdE5vdGlmaWNhdGlvblN0YXRlIH0gZnJvbSBcIi4uLy4uLy4uL3N0b3Jlcy9ub3RpZmljYXRpb25zL0xpc3ROb3RpZmljYXRpb25TdGF0ZVwiO1xuaW1wb3J0IEljb25pemVkQ29udGV4dE1lbnUgZnJvbSBcIi4uL2NvbnRleHRfbWVudXMvSWNvbml6ZWRDb250ZXh0TWVudVwiO1xuaW1wb3J0IHsgZ2V0S2V5QmluZGluZ3NNYW5hZ2VyLCBSb29tTGlzdEFjdGlvbiB9IGZyb20gXCIuLi8uLi8uLi9LZXlCaW5kaW5nc01hbmFnZXJcIjtcbmltcG9ydCB7IHJlcGxhY2VhYmxlQ29tcG9uZW50IH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL3JlcGxhY2VhYmxlQ29tcG9uZW50XCI7XG5pbXBvcnQgeyBzaG91bGRTaG93Q29tcG9uZW50IH0gZnJvbSBcIi4uLy4uLy4uL2N1c3RvbWlzYXRpb25zL2hlbHBlcnMvVUlDb21wb25lbnRzXCI7XG5pbXBvcnQgeyBVSUNvbXBvbmVudCB9IGZyb20gXCIuLi8uLi8uLi9zZXR0aW5ncy9VSUZlYXR1cmVcIjtcblxuY29uc3QgU0hPV19OX0JVVFRPTl9IRUlHSFQgPSAyODsgLy8gQXMgZGVmaW5lZCBieSBDU1NcbmNvbnN0IFJFU0laRV9IQU5ETEVfSEVJR0hUID0gNDsgLy8gQXMgZGVmaW5lZCBieSBDU1NcbmV4cG9ydCBjb25zdCBIRUFERVJfSEVJR0hUID0gMzI7IC8vIEFzIGRlZmluZWQgYnkgQ1NTXG5cbmNvbnN0IE1BWF9QQURESU5HX0hFSUdIVCA9IFNIT1dfTl9CVVRUT05fSEVJR0hUICsgUkVTSVpFX0hBTkRMRV9IRUlHSFQ7XG5cbi8vIEhBQ0s6IFdlIHJlYWxseSBzaG91bGRuJ3QgaGF2ZSB0byBkbyB0aGlzLlxucG9seWZpbGxUb3VjaEV2ZW50KCk7XG5cbmludGVyZmFjZSBJUHJvcHMge1xuICAgIGZvclJvb21zOiBib29sZWFuO1xuICAgIHN0YXJ0QXNIaWRkZW46IGJvb2xlYW47XG4gICAgbGFiZWw6IHN0cmluZztcbiAgICBvbkFkZFJvb20/OiAoKSA9PiB2b2lkO1xuICAgIGFkZFJvb21Db250ZXh0TWVudT86IChvbkZpbmlzaGVkOiAoKSA9PiB2b2lkKSA9PiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgYWRkUm9vbUxhYmVsOiBzdHJpbmc7XG4gICAgaXNNaW5pbWl6ZWQ6IGJvb2xlYW47XG4gICAgdGFnSWQ6IFRhZ0lEO1xuICAgIHNob3dTa2VsZXRvbj86IGJvb2xlYW47XG4gICAgYWx3YXlzVmlzaWJsZT86IGJvb2xlYW47XG4gICAgcmVzaXplTm90aWZpZXI6IFJlc2l6ZU5vdGlmaWVyO1xuICAgIGV4dHJhVGlsZXM/OiBSZWFjdENvbXBvbmVudEVsZW1lbnQ8dHlwZW9mIEV4dHJhVGlsZT5bXTtcbiAgICBvbkxpc3RDb2xsYXBzZT86IChpc0V4cGFuZGVkOiBib29sZWFuKSA9PiB2b2lkO1xuXG4gICAgLy8gVE9ETzogQWNjb3VudCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3ZlY3Rvci1pbS9lbGVtZW50LXdlYi9pc3N1ZXMvMTQxNzlcbn1cblxuLy8gVE9ETzogVXNlIHJlLXJlc2l6ZXIncyBOdW1iZXJTaXplIHdoZW4gaXQgaXMgZXhwb3NlZCBhcyB0aGUgdHlwZVxuaW50ZXJmYWNlIFJlc2l6ZURlbHRhIHtcbiAgICB3aWR0aDogbnVtYmVyO1xuICAgIGhlaWdodDogbnVtYmVyO1xufVxuXG50eXBlIFBhcnRpYWxET01SZWN0ID0gUGljazxET01SZWN0LCBcImxlZnRcIiB8IFwidG9wXCIgfCBcImhlaWdodFwiPjtcblxuaW50ZXJmYWNlIElTdGF0ZSB7XG4gICAgY29udGV4dE1lbnVQb3NpdGlvbjogUGFydGlhbERPTVJlY3Q7XG4gICAgYWRkUm9vbUNvbnRleHRNZW51UG9zaXRpb246IFBhcnRpYWxET01SZWN0O1xuICAgIGlzUmVzaXppbmc6IGJvb2xlYW47XG4gICAgaXNFeHBhbmRlZDogYm9vbGVhbjsgLy8gdXNlZCBmb3IgdGhlIGZvciBleHBhbmQgb2YgdGhlIHN1Ymxpc3Qgd2hlbiB0aGUgcm9vbSBsaXN0IGlzIGJlaW5nIGZpbHRlcmVkXG4gICAgaGVpZ2h0OiBudW1iZXI7XG4gICAgcm9vbXM6IFJvb21bXTtcbiAgICBmaWx0ZXJlZEV4dHJhVGlsZXM/OiBSZWFjdENvbXBvbmVudEVsZW1lbnQ8dHlwZW9mIEV4dHJhVGlsZT5bXTtcbn1cblxuQHJlcGxhY2VhYmxlQ29tcG9uZW50KFwidmlld3Mucm9vbXMuUm9vbVN1Ymxpc3RcIilcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJvb21TdWJsaXN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PElQcm9wcywgSVN0YXRlPiB7XG4gICAgcHJpdmF0ZSBoZWFkZXJCdXR0b24gPSBjcmVhdGVSZWY8SFRNTERpdkVsZW1lbnQ+KCk7XG4gICAgcHJpdmF0ZSBzdWJsaXN0UmVmID0gY3JlYXRlUmVmPEhUTUxEaXZFbGVtZW50PigpO1xuICAgIHByaXZhdGUgdGlsZXNSZWYgPSBjcmVhdGVSZWY8SFRNTERpdkVsZW1lbnQ+KCk7XG4gICAgcHJpdmF0ZSBkaXNwYXRjaGVyUmVmOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBsYXlvdXQ6IExpc3RMYXlvdXQ7XG4gICAgcHJpdmF0ZSBoZWlnaHRBdFN0YXJ0OiBudW1iZXI7XG4gICAgcHJpdmF0ZSBpc0JlaW5nRmlsdGVyZWQ6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBub3RpZmljYXRpb25TdGF0ZTogTGlzdE5vdGlmaWNhdGlvblN0YXRlO1xuXG4gICAgY29uc3RydWN0b3IocHJvcHM6IElQcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5sYXlvdXQgPSBSb29tTGlzdExheW91dFN0b3JlLmluc3RhbmNlLmdldExheW91dEZvcih0aGlzLnByb3BzLnRhZ0lkKTtcbiAgICAgICAgdGhpcy5oZWlnaHRBdFN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5pc0JlaW5nRmlsdGVyZWQgPSAhIVJvb21MaXN0U3RvcmUuaW5zdGFuY2UuZ2V0Rmlyc3ROYW1lRmlsdGVyQ29uZGl0aW9uKCk7XG4gICAgICAgIHRoaXMubm90aWZpY2F0aW9uU3RhdGUgPSBSb29tTm90aWZpY2F0aW9uU3RhdGVTdG9yZS5pbnN0YW5jZS5nZXRMaXN0U3RhdGUodGhpcy5wcm9wcy50YWdJZCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBjb250ZXh0TWVudVBvc2l0aW9uOiBudWxsLFxuICAgICAgICAgICAgYWRkUm9vbUNvbnRleHRNZW51UG9zaXRpb246IG51bGwsXG4gICAgICAgICAgICBpc1Jlc2l6aW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGlzRXhwYW5kZWQ6IHRoaXMuaXNCZWluZ0ZpbHRlcmVkID8gdGhpcy5pc0JlaW5nRmlsdGVyZWQgOiAhdGhpcy5sYXlvdXQuaXNDb2xsYXBzZWQsXG4gICAgICAgICAgICBoZWlnaHQ6IDAsIC8vIHRvIGJlIGZpeGVkIGluIGEgbW9tZW50LCB3ZSBuZWVkIGByb29tc2AgdG8gY2FsY3VsYXRlIHRoaXMuXG4gICAgICAgICAgICByb29tczogYXJyYXlGYXN0Q2xvbmUoUm9vbUxpc3RTdG9yZS5pbnN0YW5jZS5vcmRlcmVkTGlzdHNbdGhpcy5wcm9wcy50YWdJZF0gfHwgW10pLFxuICAgICAgICB9O1xuICAgICAgICAvLyBXaHkgT2JqZWN0LmFzc2lnbigpIGFuZCBub3QgdGhpcy5zdGF0ZS5oZWlnaHQ/IEJlY2F1c2UgVHlwZVNjcmlwdCBzYXlzIG5vLlxuICAgICAgICB0aGlzLnN0YXRlID0gT2JqZWN0LmFzc2lnbih0aGlzLnN0YXRlLCB7IGhlaWdodDogdGhpcy5jYWxjdWxhdGVJbml0aWFsSGVpZ2h0KCkgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVJbml0aWFsSGVpZ2h0KCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ZWRWaXNpYmxlVGlsZXMgPSBNYXRoLm1heChNYXRoLmZsb29yKHRoaXMubGF5b3V0LnZpc2libGVUaWxlcyksIHRoaXMubGF5b3V0Lm1pblZpc2libGVUaWxlcyk7XG4gICAgICAgIGNvbnN0IHRpbGVDb3VudCA9IE1hdGgubWluKHRoaXMubnVtVGlsZXMsIHJlcXVlc3RlZFZpc2libGVUaWxlcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dC50aWxlc1RvUGl4ZWxzV2l0aFBhZGRpbmcodGlsZUNvdW50LCB0aGlzLnBhZGRpbmcpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0IHBhZGRpbmcoKSB7XG4gICAgICAgIGxldCBwYWRkaW5nID0gUkVTSVpFX0hBTkRMRV9IRUlHSFQ7XG4gICAgICAgIC8vIHRoaXMgaXMgdXNlZCBmb3IgY2FsY3VsYXRpbmcgdGhlIG1heCBoZWlnaHQgb2YgdGhlIHdob2xlIGNvbnRhaW5lcixcbiAgICAgICAgLy8gYW5kIHRha2VzIGludG8gYWNjb3VudCB3aGV0aGVyIHRoZXJlIHNob3VsZCBiZSByb29tIHJlc2VydmVkIGZvciB0aGUgc2hvdyBtb3JlL2xlc3MgYnV0dG9uXG4gICAgICAgIC8vIHdoZW4gZnVsbHkgZXhwYW5kZWQuIFdlIGNhbid0IHJlbHkgcHVyZWx5IG9uIHRoZSBsYXlvdXQncyBkZWZhdWx0VmlzaWJsZSB0aWxlIGNvdW50XG4gICAgICAgIC8vIGJlY2F1c2UgdGhlcmUgYXJlIGNvbmRpdGlvbnMgaW4gd2hpY2ggd2UgbmVlZCB0byBrbm93IHRoYXQgdGhlICdzaG93IG1vcmUnIGJ1dHRvblxuICAgICAgICAvLyBpcyBwcmVzZW50IHdoaWxlIHdlbGwgdW5kZXIgdGhlIGRlZmF1bHQgdGlsZSBsaW1pdC5cbiAgICAgICAgY29uc3QgbmVlZHNTaG93TW9yZSA9IHRoaXMubnVtVGlsZXMgPiB0aGlzLm51bVZpc2libGVUaWxlcztcblxuICAgICAgICAvLyAuLi5idXQgYWxzbyBjaGVjayB0aGlzIG9yIHdlJ2xsIG1pc3MgaWYgdGhlIHNlY3Rpb24gaXMgZXhwYW5kZWQgYW5kIHdlIG5lZWQgYVxuICAgICAgICAvLyAnc2hvdyBsZXNzJ1xuICAgICAgICBjb25zdCBuZWVkc1Nob3dMZXNzID0gdGhpcy5udW1UaWxlcyA+IHRoaXMubGF5b3V0LmRlZmF1bHRWaXNpYmxlVGlsZXM7XG5cbiAgICAgICAgaWYgKG5lZWRzU2hvd01vcmUgfHwgbmVlZHNTaG93TGVzcykge1xuICAgICAgICAgICAgcGFkZGluZyArPSBTSE9XX05fQlVUVE9OX0hFSUdIVDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFkZGluZztcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldCBleHRyYVRpbGVzKCk6IFJlYWN0Q29tcG9uZW50RWxlbWVudDx0eXBlb2YgRXh0cmFUaWxlPltdIHwgbnVsbCB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmZpbHRlcmVkRXh0cmFUaWxlcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuZmlsdGVyZWRFeHRyYVRpbGVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmV4dHJhVGlsZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLmV4dHJhVGlsZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXQgbnVtVGlsZXMoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIFJvb21TdWJsaXN0LmNhbGNOdW1UaWxlcyh0aGlzLnN0YXRlLnJvb21zLCB0aGlzLmV4dHJhVGlsZXMpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGNhbGNOdW1UaWxlcyhyb29tczogUm9vbVtdLCBleHRyYVRpbGVzOiBhbnlbXSkge1xuICAgICAgICByZXR1cm4gKHJvb21zIHx8IFtdKS5sZW5ndGggKyAoZXh0cmFUaWxlcyB8fCBbXSkubGVuZ3RoO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0IG51bVZpc2libGVUaWxlcygpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBuVmlzaWJsZSA9IE1hdGguY2VpbCh0aGlzLmxheW91dC52aXNpYmxlVGlsZXMpO1xuICAgICAgICByZXR1cm4gTWF0aC5taW4oblZpc2libGUsIHRoaXMubnVtVGlsZXMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzOiBSZWFkb25seTxJUHJvcHM+LCBwcmV2U3RhdGU6IFJlYWRvbmx5PElTdGF0ZT4pIHtcbiAgICAgICAgY29uc3QgcHJldkV4dHJhVGlsZXMgPSBwcmV2U3RhdGUuZmlsdGVyZWRFeHRyYVRpbGVzIHx8IHByZXZQcm9wcy5leHRyYVRpbGVzO1xuICAgICAgICAvLyBhcyB0aGUgcm9vbXMgY2FuIGNvbWUgaW4gb25lIGJ5IG9uZSB3ZSBuZWVkIHRvIHJlZXZhbHVhdGVcbiAgICAgICAgLy8gdGhlIGFtb3VudCBvZiBhdmFpbGFibGUgcm9vbXMgdG8gY2FwIHRoZSBhbW91bnQgb2YgcmVxdWVzdGVkIHZpc2libGUgcm9vbXMgYnkgdGhlIGxheW91dFxuICAgICAgICBpZiAoUm9vbVN1Ymxpc3QuY2FsY051bVRpbGVzKHByZXZTdGF0ZS5yb29tcywgcHJldkV4dHJhVGlsZXMpICE9PSB0aGlzLm51bVRpbGVzKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgaGVpZ2h0OiB0aGlzLmNhbGN1bGF0ZUluaXRpYWxIZWlnaHQoKSB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzOiBSZWFkb25seTxJUHJvcHM+LCBuZXh0U3RhdGU6IFJlYWRvbmx5PElTdGF0ZT4pOiBib29sZWFuIHtcbiAgICAgICAgaWYgKG9iamVjdEhhc0RpZmYodGhpcy5wcm9wcywgbmV4dFByb3BzKSkge1xuICAgICAgICAgICAgLy8gU29tZXRoaW5nIHdlIGRvbid0IGNhcmUgdG8gb3B0aW1pemUgaGFzIHVwZGF0ZWQsIHNvIHVwZGF0ZS5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG8gdGhlIHNhbWUgY2hlY2sgdXNlZCBvbiBwcm9wcyBmb3Igc3RhdGUsIHdpdGhvdXQgdGhlIHJvb21zIHdlJ3JlIGdvaW5nIHRvIG5vLW9wXG4gICAgICAgIGNvbnN0IHByZXZTdGF0ZU5vUm9vbXMgPSBvYmplY3RFeGNsdWRpbmcodGhpcy5zdGF0ZSwgWydyb29tcyddKTtcbiAgICAgICAgY29uc3QgbmV4dFN0YXRlTm9Sb29tcyA9IG9iamVjdEV4Y2x1ZGluZyhuZXh0U3RhdGUsIFsncm9vbXMnXSk7XG4gICAgICAgIGlmIChvYmplY3RIYXNEaWZmKHByZXZTdGF0ZU5vUm9vbXMsIG5leHRTdGF0ZU5vUm9vbXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlJ3JlIHN1cHBvc2VkIHRvIGhhbmRsZSBleHRyYSB0aWxlcywgdGFrZSB0aGUgcGVyZm9ybWFuY2UgaGl0IGFuZCByZS1yZW5kZXIgYWxsIHRoZVxuICAgICAgICAvLyB0aW1lIHNvIHdlIGRvbid0IGhhdmUgdG8gY29uc2lkZXIgdGhlbSBhcyBwYXJ0IG9mIHRoZSB2aXNpYmxlIHJvb20gb3B0aW1pemF0aW9uLlxuICAgICAgICBjb25zdCBwcmV2RXh0cmFUaWxlcyA9IHRoaXMucHJvcHMuZXh0cmFUaWxlcyB8fCBbXTtcbiAgICAgICAgY29uc3QgbmV4dEV4dHJhVGlsZXMgPSAobmV4dFN0YXRlLmZpbHRlcmVkRXh0cmFUaWxlcyB8fCBuZXh0UHJvcHMuZXh0cmFUaWxlcykgfHwgW107XG4gICAgICAgIGlmIChwcmV2RXh0cmFUaWxlcy5sZW5ndGggPiAwIHx8IG5leHRFeHRyYVRpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gdXBkYXRlIHRoZSBoZWlnaHQgb2YgdGhlIGxpc3QsIHdlIGRvbid0IHJlYWxseSBjYXJlIGFib3V0IHdoaWNoIHJvb21zXG4gICAgICAgIC8vIGFyZSB2aXNpYmxlIG9yIG5vdCBmb3Igbm8tb3AgcHVycG9zZXMsIHNvIGVuc3VyZSB0aGF0IHRoZSBoZWlnaHQgY2FsY3VsYXRpb24gcnVucyB0aHJvdWdoLlxuICAgICAgICBpZiAoUm9vbVN1Ymxpc3QuY2FsY051bVRpbGVzKG5leHRTdGF0ZS5yb29tcywgbmV4dEV4dHJhVGlsZXMpICE9PSB0aGlzLm51bVRpbGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlZm9yZSB3ZSBnbyBhbmFseXppbmcgdGhlIHJvb21zLCB3ZSBjYW4gc2VlIGlmIHdlJ3JlIGNvbGxhcHNlZC4gSWYgd2UncmUgY29sbGFwc2VkLCB3ZSBkb24ndCBuZWVkXG4gICAgICAgIC8vIHRvIHJlbmRlciBhbnl0aGluZy4gV2UgZG8gdGhpcyBhZnRlciB0aGUgaGVpZ2h0IGNoZWNrIHRob3VnaCB0byBlbnN1cmUgdGhhdCB0aGUgaGVpZ2h0IGdldHMgYXBwcm9wcmlhdGVseVxuICAgICAgICAvLyBjYWxjdWxhdGVkIGZvciB3aGVuL2lmIHdlIGJlY29tZSB1bmNvbGxhcHNlZC5cbiAgICAgICAgaWYgKCFuZXh0U3RhdGUuaXNFeHBhbmRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUXVpY2tseSBkb3VibGUgY2hlY2sgd2UncmUgbm90IGFib3V0IHRvIGJyZWFrIHNvbWV0aGluZyBkdWUgdG8gdGhlIG51bWJlciBvZiByb29tcyBjaGFuZ2luZy5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUucm9vbXMubGVuZ3RoICE9PSBuZXh0U3RhdGUucm9vbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmFsbHksIGRldGVybWluZSBpZiB0aGUgcm9vbSB1cGRhdGUgKGFzIHByZXN1bWFibHkgdGhhdCdzIGFsbCB0aGF0J3MgbGVmdCkgaXMgd2l0aGluXG4gICAgICAgIC8vIG91ciB2aXNpYmxlIHJhbmdlLiBJZiBpdCBpcywgdGhlbiBkbyBhIHJlbmRlci4gSWYgdGhlIHVwZGF0ZSBpcyBvdXRzaWRlIG91ciB2aXNpYmxlIHJhbmdlXG4gICAgICAgIC8vIHRoZW4gd2UgY2FuIHNraXAgdGhlIHVwZGF0ZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2UgYWxzbyBvcHRpbWl6ZSBmb3Igb3JkZXIgY2hhbmdpbmcgaGVyZTogaWYgdGhlIHVwZGF0ZSBkaWQgaGFwcGVuIGluIG91ciB2aXNpYmxlIHJhbmdlXG4gICAgICAgIC8vIGJ1dCBkb2Vzbid0IHJlc3VsdCBpbiB0aGUgbGlzdCByZS1zb3J0aW5nIGl0c2VsZiB0aGVuIHRoZXJlJ3Mgbm8gcmVhc29uIGZvciB1cyB0byB1cGRhdGVcbiAgICAgICAgLy8gb24gb3VyIG93bi5cbiAgICAgICAgY29uc3QgcHJldlNsaWNlZFJvb21zID0gdGhpcy5zdGF0ZS5yb29tcy5zbGljZSgwLCB0aGlzLm51bVZpc2libGVUaWxlcyk7XG4gICAgICAgIGNvbnN0IG5leHRTbGljZWRSb29tcyA9IG5leHRTdGF0ZS5yb29tcy5zbGljZSgwLCB0aGlzLm51bVZpc2libGVUaWxlcyk7XG4gICAgICAgIGlmIChhcnJheUhhc09yZGVyQ2hhbmdlKHByZXZTbGljZWRSb29tcywgbmV4dFNsaWNlZFJvb21zKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5hbGx5LCBub3RoaW5nIGhhcHBlbmVkIHNvIG5vLW9wIHRoZSB1cGRhdGVcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHB1YmxpYyBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyUmVmID0gZGVmYXVsdERpc3BhdGNoZXIucmVnaXN0ZXIodGhpcy5vbkFjdGlvbik7XG4gICAgICAgIFJvb21MaXN0U3RvcmUuaW5zdGFuY2Uub24oTElTVFNfVVBEQVRFX0VWRU5ULCB0aGlzLm9uTGlzdHNVcGRhdGVkKTtcbiAgICAgICAgLy8gVXNpbmcgdGhlIHBhc3NpdmUgb3B0aW9uIHRvIG5vdCBibG9jayB0aGUgbWFpbiB0aHJlYWRcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXIjaW1wcm92aW5nX3Njcm9sbGluZ19wZXJmb3JtYW5jZV93aXRoX3Bhc3NpdmVfbGlzdGVuZXJzXG4gICAgICAgIHRoaXMudGlsZXNSZWYuY3VycmVudD8uYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsUHJldmVudCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgZGVmYXVsdERpc3BhdGNoZXIudW5yZWdpc3Rlcih0aGlzLmRpc3BhdGNoZXJSZWYpO1xuICAgICAgICBSb29tTGlzdFN0b3JlLmluc3RhbmNlLm9mZihMSVNUU19VUERBVEVfRVZFTlQsIHRoaXMub25MaXN0c1VwZGF0ZWQpO1xuICAgICAgICB0aGlzLnRpbGVzUmVmLmN1cnJlbnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbFByZXZlbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgb25MaXN0c1VwZGF0ZWQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlVXBkYXRlczogSVN0YXRlICYgYW55ID0ge307IC8vICZhbnkgaXMgdG8gYXZvaWQgYSBjYXN0IG9uIHRoZSBpbml0aWFsaXplclxuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmV4dHJhVGlsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVDb25kaXRpb24gPSBSb29tTGlzdFN0b3JlLmluc3RhbmNlLmdldEZpcnN0TmFtZUZpbHRlckNvbmRpdGlvbigpO1xuICAgICAgICAgICAgaWYgKG5hbWVDb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZVVwZGF0ZXMuZmlsdGVyZWRFeHRyYVRpbGVzID0gdGhpcy5wcm9wcy5leHRyYVRpbGVzXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIodCA9PiBuYW1lQ29uZGl0aW9uLm1hdGNoZXMobm9ybWFsaXplKHQucHJvcHMuZGlzcGxheU5hbWUgfHwgXCJcIikpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5maWx0ZXJlZEV4dHJhVGlsZXMpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZVVwZGF0ZXMuZmlsdGVyZWRFeHRyYVRpbGVzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRSb29tcyA9IHRoaXMuc3RhdGUucm9vbXM7XG4gICAgICAgIGNvbnN0IG5ld1Jvb21zID0gYXJyYXlGYXN0Q2xvbmUoUm9vbUxpc3RTdG9yZS5pbnN0YW5jZS5vcmRlcmVkTGlzdHNbdGhpcy5wcm9wcy50YWdJZF0gfHwgW10pO1xuICAgICAgICBpZiAoYXJyYXlIYXNPcmRlckNoYW5nZShjdXJyZW50Um9vbXMsIG5ld1Jvb21zKSkge1xuICAgICAgICAgICAgc3RhdGVVcGRhdGVzLnJvb21zID0gbmV3Um9vbXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc1N0aWxsQmVpbmdGaWx0ZXJlZCA9ICEhUm9vbUxpc3RTdG9yZS5pbnN0YW5jZS5nZXRGaXJzdE5hbWVGaWx0ZXJDb25kaXRpb24oKTtcbiAgICAgICAgaWYgKGlzU3RpbGxCZWluZ0ZpbHRlcmVkICE9PSB0aGlzLmlzQmVpbmdGaWx0ZXJlZCkge1xuICAgICAgICAgICAgdGhpcy5pc0JlaW5nRmlsdGVyZWQgPSBpc1N0aWxsQmVpbmdGaWx0ZXJlZDtcbiAgICAgICAgICAgIGlmIChpc1N0aWxsQmVpbmdGaWx0ZXJlZCkge1xuICAgICAgICAgICAgICAgIHN0YXRlVXBkYXRlcy5pc0V4cGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGVVcGRhdGVzLmlzRXhwYW5kZWQgPSAhdGhpcy5sYXlvdXQuaXNDb2xsYXBzZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoc3RhdGVVcGRhdGVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHN0YXRlVXBkYXRlcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbkFjdGlvbiA9IChwYXlsb2FkOiBBY3Rpb25QYXlsb2FkKSA9PiB7XG4gICAgICAgIGlmIChwYXlsb2FkLmFjdGlvbiA9PT0gXCJ2aWV3X3Jvb21cIiAmJiBwYXlsb2FkLnNob3dfcm9vbV90aWxlICYmIHRoaXMuc3RhdGUucm9vbXMpIHtcbiAgICAgICAgICAgIC8vIFhYWDogd2UgaGF2ZSB0byBkbyB0aGlzIGEgdGljayBsYXRlciBiZWNhdXNlIHdlIGhhdmUgaW5jb3JyZWN0IGludGVybWVkaWF0ZSBwcm9wcyBkdXJpbmcgYSByb29tIGNoYW5nZVxuICAgICAgICAgICAgLy8gd2hlcmUgd2UgbG9zZSB0aGUgcm9vbSB3ZSBhcmUgY2hhbmdpbmcgZnJvbSB0ZW1wb3JhcmlseSBhbmQgdGhlbiBpdCBjb21lcyBiYWNrIGluIGFuIHVwZGF0ZSByaWdodCBhZnRlci5cbiAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm9vbUluZGV4ID0gdGhpcy5zdGF0ZS5yb29tcy5maW5kSW5kZXgoKHIpID0+IHIucm9vbUlkID09PSBwYXlsb2FkLnJvb21faWQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmlzRXhwYW5kZWQgJiYgcm9vbUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b2dnbGVDb2xsYXBzZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXh0ZW5kIHRoZSB2aXNpYmxlIHNlY3Rpb24gdG8gaW5jbHVkZSB0aGUgcm9vbSBpZiBpdCBpcyBlbnRpcmVseSBpbnZpc2libGVcbiAgICAgICAgICAgICAgICBpZiAocm9vbUluZGV4ID49IHRoaXMubnVtVmlzaWJsZVRpbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0LnZpc2libGVUaWxlcyA9IHRoaXMubGF5b3V0LnRpbGVzV2l0aFBhZGRpbmcocm9vbUluZGV4ICsgMSwgTUFYX1BBRERJTkdfSEVJR0hUKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpOyAvLyBiZWNhdXNlIHRoZSBsYXlvdXQgZG9lc24ndCB0cmlnZ2VyIGEgcmUtcmVuZGVyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbkFkZFJvb20gPSAoZSkgPT4ge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkFkZFJvb20pIHRoaXMucHJvcHMub25BZGRSb29tKCk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgYXBwbHlIZWlnaHRDaGFuZ2UobmV3SGVpZ2h0OiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgaGVpZ2h0SW5UaWxlcyA9IE1hdGguY2VpbCh0aGlzLmxheW91dC5waXhlbHNUb1RpbGVzKG5ld0hlaWdodCAtIHRoaXMucGFkZGluZykpO1xuICAgICAgICB0aGlzLmxheW91dC52aXNpYmxlVGlsZXMgPSBNYXRoLm1pbih0aGlzLm51bVRpbGVzLCBoZWlnaHRJblRpbGVzKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uUmVzaXplID0gKFxuICAgICAgICBlOiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCxcbiAgICAgICAgdHJhdmVsRGlyZWN0aW9uOiBEaXJlY3Rpb24sXG4gICAgICAgIHJlZlRvRWxlbWVudDogSFRNTERpdkVsZW1lbnQsXG4gICAgICAgIGRlbHRhOiBSZXNpemVEZWx0YSxcbiAgICApID0+IHtcbiAgICAgICAgY29uc3QgbmV3SGVpZ2h0ID0gdGhpcy5oZWlnaHRBdFN0YXJ0ICsgZGVsdGEuaGVpZ2h0O1xuICAgICAgICB0aGlzLmFwcGx5SGVpZ2h0Q2hhbmdlKG5ld0hlaWdodCk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBoZWlnaHQ6IG5ld0hlaWdodCB9KTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvblJlc2l6ZVN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmhlaWdodEF0U3RhcnQgPSB0aGlzLnN0YXRlLmhlaWdodDtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGlzUmVzaXppbmc6IHRydWUgfSk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25SZXNpemVTdG9wID0gKFxuICAgICAgICBlOiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCxcbiAgICAgICAgdHJhdmVsRGlyZWN0aW9uOiBEaXJlY3Rpb24sXG4gICAgICAgIHJlZlRvRWxlbWVudDogSFRNTERpdkVsZW1lbnQsXG4gICAgICAgIGRlbHRhOiBSZXNpemVEZWx0YSxcbiAgICApID0+IHtcbiAgICAgICAgY29uc3QgbmV3SGVpZ2h0ID0gdGhpcy5oZWlnaHRBdFN0YXJ0ICsgZGVsdGEuaGVpZ2h0O1xuICAgICAgICB0aGlzLmFwcGx5SGVpZ2h0Q2hhbmdlKG5ld0hlaWdodCk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBpc1Jlc2l6aW5nOiBmYWxzZSwgaGVpZ2h0OiBuZXdIZWlnaHQgfSk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25TaG93QWxsQ2xpY2sgPSAoKSA9PiB7XG4gICAgICAgIC8vIHJlYWQgbnVtYmVyIG9mIHZpc2libGUgdGlsZXMgYmVmb3JlIHdlIG11dGF0ZSBpdFxuICAgICAgICBjb25zdCBudW1WaXNpYmxlVGlsZXMgPSB0aGlzLm51bVZpc2libGVUaWxlcztcbiAgICAgICAgY29uc3QgbmV3SGVpZ2h0ID0gdGhpcy5sYXlvdXQudGlsZXNUb1BpeGVsc1dpdGhQYWRkaW5nKHRoaXMubnVtVGlsZXMsIHRoaXMucGFkZGluZyk7XG4gICAgICAgIHRoaXMuYXBwbHlIZWlnaHRDaGFuZ2UobmV3SGVpZ2h0KTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGhlaWdodDogbmV3SGVpZ2h0IH0sICgpID0+IHtcbiAgICAgICAgICAgIC8vIGZvY3VzIHRoZSB0b3AtbW9zdCBuZXcgcm9vbVxuICAgICAgICAgICAgdGhpcy5mb2N1c1Jvb21UaWxlKG51bVZpc2libGVUaWxlcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBwcml2YXRlIG9uU2hvd0xlc3NDbGljayA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgbmV3SGVpZ2h0ID0gdGhpcy5sYXlvdXQudGlsZXNUb1BpeGVsc1dpdGhQYWRkaW5nKHRoaXMubGF5b3V0LmRlZmF1bHRWaXNpYmxlVGlsZXMsIHRoaXMucGFkZGluZyk7XG4gICAgICAgIHRoaXMuYXBwbHlIZWlnaHRDaGFuZ2UobmV3SGVpZ2h0KTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGhlaWdodDogbmV3SGVpZ2h0IH0pO1xuICAgIH07XG5cbiAgICBwcml2YXRlIGZvY3VzUm9vbVRpbGUgPSAoaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuc3VibGlzdFJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5zdWJsaXN0UmVmLmN1cnJlbnQucXVlcnlTZWxlY3RvckFsbDxIVE1MRGl2RWxlbWVudD4oXCIubXhfUm9vbVRpbGVcIik7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50cyAmJiBlbGVtZW50c1tpbmRleF07XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbk9wZW5NZW51Q2xpY2sgPSAoZXY6IFJlYWN0Lk1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGV2LnRhcmdldCBhcyBIVE1MQnV0dG9uRWxlbWVudDtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGNvbnRleHRNZW51UG9zaXRpb246IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB9KTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbkNvbnRleHRNZW51ID0gKGV2OiBSZWFjdC5Nb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGNvbnRleHRNZW51UG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBldi5jbGllbnRYLFxuICAgICAgICAgICAgICAgIHRvcDogZXYuY2xpZW50WSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbkFkZFJvb21Db250ZXh0TWVudSA9IChldjogUmVhY3QuTW91c2VFdmVudCkgPT4ge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXYudGFyZ2V0IGFzIEhUTUxCdXR0b25FbGVtZW50O1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgYWRkUm9vbUNvbnRleHRNZW51UG9zaXRpb246IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB9KTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbkNsb3NlTWVudSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGNvbnRleHRNZW51UG9zaXRpb246IG51bGwgfSk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25DbG9zZUFkZFJvb21NZW51ID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgYWRkUm9vbUNvbnRleHRNZW51UG9zaXRpb246IG51bGwgfSk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25VbnJlYWRGaXJzdENoYW5nZWQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzVW5yZWFkRmlyc3QgPSBSb29tTGlzdFN0b3JlLmluc3RhbmNlLmdldExpc3RPcmRlcih0aGlzLnByb3BzLnRhZ0lkKSA9PT0gTGlzdEFsZ29yaXRobS5JbXBvcnRhbmNlO1xuICAgICAgICBjb25zdCBuZXdBbGdvcml0aG0gPSBpc1VucmVhZEZpcnN0ID8gTGlzdEFsZ29yaXRobS5OYXR1cmFsIDogTGlzdEFsZ29yaXRobS5JbXBvcnRhbmNlO1xuICAgICAgICBSb29tTGlzdFN0b3JlLmluc3RhbmNlLnNldExpc3RPcmRlcih0aGlzLnByb3BzLnRhZ0lkLCBuZXdBbGdvcml0aG0pO1xuICAgICAgICB0aGlzLmZvcmNlVXBkYXRlKCk7IC8vIGJlY2F1c2UgaWYgdGhlIHN1Ymxpc3QgZG9lc24ndCBoYXZlIGFueSBjaGFuZ2VzIHRoZW4gd2Ugd2lsbCBtaXNzIHRoZSBsaXN0IG9yZGVyIGNoYW5nZVxuICAgIH07XG5cbiAgICBwcml2YXRlIG9uVGFnU29ydENoYW5nZWQgPSBhc3luYyAoc29ydDogU29ydEFsZ29yaXRobSkgPT4ge1xuICAgICAgICBhd2FpdCBSb29tTGlzdFN0b3JlLmluc3RhbmNlLnNldFRhZ1NvcnRpbmcodGhpcy5wcm9wcy50YWdJZCwgc29ydCk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25NZXNzYWdlUHJldmlld0NoYW5nZWQgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMubGF5b3V0LnNob3dQcmV2aWV3cyA9ICF0aGlzLmxheW91dC5zaG93UHJldmlld3M7XG4gICAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKTsgLy8gYmVjYXVzZSB0aGUgbGF5b3V0IGRvZXNuJ3QgdHJpZ2dlciBhIHJlLXJlbmRlclxuICAgIH07XG5cbiAgICBwcml2YXRlIG9uQmFkZ2VDbGljayA9IChldjogUmVhY3QuTW91c2VFdmVudCkgPT4ge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICBsZXQgcm9vbTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMudGFnSWQgPT09IERlZmF1bHRUYWdJRC5JbnZpdGUpIHtcbiAgICAgICAgICAgIC8vIHN3aXRjaCB0byBmaXJzdCByb29tIGFzIHRoYXQnbGwgYmUgdGhlIHRvcCBvZiB0aGUgbGlzdCBmb3IgdGhlIHVzZXJcbiAgICAgICAgICAgIHJvb20gPSB0aGlzLnN0YXRlLnJvb21zICYmIHRoaXMuc3RhdGUucm9vbXNbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBmaXJzdCByb29tIHdpdGggYSBjb3VudCBvZiB0aGUgc2FtZSBjb2xvdXIgYXMgdGhlIGJhZGdlIGNvdW50XG4gICAgICAgICAgICByb29tID0gUm9vbUxpc3RTdG9yZS5pbnN0YW5jZS51bmZpbHRlcmVkTGlzdHNbdGhpcy5wcm9wcy50YWdJZF0uZmluZCgocjogUm9vbSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vdGlmU3RhdGUgPSB0aGlzLm5vdGlmaWNhdGlvblN0YXRlLmdldEZvclJvb20ocik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vdGlmU3RhdGUuY291bnQgPiAwICYmIG5vdGlmU3RhdGUuY29sb3IgPT09IHRoaXMubm90aWZpY2F0aW9uU3RhdGUuY29sb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyb29tKSB7XG4gICAgICAgICAgICBkaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogQWN0aW9uLlZpZXdSb29tLFxuICAgICAgICAgICAgICAgIHJvb21faWQ6IHJvb20ucm9vbUlkLFxuICAgICAgICAgICAgICAgIHNob3dfcm9vbV90aWxlOiB0cnVlLCAvLyB0byBtYWtlIHN1cmUgdGhlIHJvb20gZ2V0cyBzY3JvbGxlZCBpbnRvIHZpZXdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25IZWFkZXJDbGljayA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgcG9zc2libGVTdGlja3kgPSB0aGlzLmhlYWRlckJ1dHRvbi5jdXJyZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHN1Ymxpc3QgPSBwb3NzaWJsZVN0aWNreS5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGxpc3QgPSBzdWJsaXN0LnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgLy8gdGhlIHNjcm9sbFRvcCBpcyBjYXBwZWQgYXQgdGhlIGhlaWdodCBvZiB0aGUgaGVhZGVyIGluIExlZnRQYW5lbCwgdGhlIHRvcCBoZWFkZXIgaXMgYWx3YXlzIHN0aWNreVxuICAgICAgICBjb25zdCBsaXN0U2Nyb2xsVG9wID0gTWF0aC5yb3VuZChsaXN0LnNjcm9sbFRvcCk7XG4gICAgICAgIGNvbnN0IGlzQXRUb3AgPSBsaXN0U2Nyb2xsVG9wIDw9IE1hdGgucm91bmQoSEVBREVSX0hFSUdIVCk7XG4gICAgICAgIGNvbnN0IGlzQXRCb3R0b20gPSBsaXN0U2Nyb2xsVG9wID49IE1hdGgucm91bmQobGlzdC5zY3JvbGxIZWlnaHQgLSBsaXN0Lm9mZnNldEhlaWdodCk7XG4gICAgICAgIGNvbnN0IGlzU3RpY2t5VG9wID0gcG9zc2libGVTdGlja3kuY2xhc3NMaXN0LmNvbnRhaW5zKCdteF9Sb29tU3VibGlzdF9oZWFkZXJDb250YWluZXJfc3RpY2t5VG9wJyk7XG4gICAgICAgIGNvbnN0IGlzU3RpY2t5Qm90dG9tID0gcG9zc2libGVTdGlja3kuY2xhc3NMaXN0LmNvbnRhaW5zKCdteF9Sb29tU3VibGlzdF9oZWFkZXJDb250YWluZXJfc3RpY2t5Qm90dG9tJyk7XG5cbiAgICAgICAgaWYgKChpc1N0aWNreUJvdHRvbSAmJiAhaXNBdEJvdHRvbSkgfHwgKGlzU3RpY2t5VG9wICYmICFpc0F0VG9wKSkge1xuICAgICAgICAgICAgLy8gaXMgc3RpY2t5IC0ganVtcCB0byBsaXN0XG4gICAgICAgICAgICBzdWJsaXN0LnNjcm9sbEludG9WaWV3KHsgYmVoYXZpb3I6ICdzbW9vdGgnIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gb24gc2NyZWVuIC0gdG9nZ2xlIGNvbGxhcHNlXG4gICAgICAgICAgICBjb25zdCBpc0V4cGFuZGVkID0gdGhpcy5zdGF0ZS5pc0V4cGFuZGVkO1xuICAgICAgICAgICAgdGhpcy50b2dnbGVDb2xsYXBzZWQoKTtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBib3R0b20gbGlzdCBpcyBjb2xsYXBzZWQgdGhlbiBzY3JvbGwgaXQgaW4gc28gaXQgZG9lc24ndCBleHBhbmQgb2ZmIHNjcmVlblxuICAgICAgICAgICAgaWYgKCFpc0V4cGFuZGVkICYmIGlzU3RpY2t5Qm90dG9tKSB7XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3VibGlzdC5zY3JvbGxJbnRvVmlldyh7IGJlaGF2aW9yOiAnc21vb3RoJyB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcml2YXRlIHRvZ2dsZUNvbGxhcHNlZCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5sYXlvdXQuaXNDb2xsYXBzZWQgPSB0aGlzLnN0YXRlLmlzRXhwYW5kZWQ7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBpc0V4cGFuZGVkOiAhdGhpcy5sYXlvdXQuaXNDb2xsYXBzZWQgfSk7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uTGlzdENvbGxhcHNlKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uTGlzdENvbGxhcHNlKCF0aGlzLmxheW91dC5pc0NvbGxhcHNlZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbkhlYWRlcktleURvd24gPSAoZXY6IFJlYWN0LktleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9uID0gZ2V0S2V5QmluZGluZ3NNYW5hZ2VyKCkuZ2V0Um9vbUxpc3RBY3Rpb24oZXYpO1xuICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBSb29tTGlzdEFjdGlvbi5Db2xsYXBzZVNlY3Rpb246XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuaXNFeHBhbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb2xsYXBzZSB0aGUgcm9vbSBzdWJsaXN0IGlmIGl0IGlzbid0IGFscmVhZHlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b2dnbGVDb2xsYXBzZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFJvb21MaXN0QWN0aW9uLkV4cGFuZFNlY3Rpb246IHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RhdGUuaXNFeHBhbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFeHBhbmQgdGhlIHJvb20gc3VibGlzdCBpZiBpdCBpc24ndCBhbHJlYWR5XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlQ29sbGFwc2VkKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN1Ymxpc3RSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgZm9jdXMgdGhlIGZpcnN0IHJvb21cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuc3VibGlzdFJlZi5jdXJyZW50LnF1ZXJ5U2VsZWN0b3IoXCIubXhfUm9vbVRpbGVcIikgYXMgSFRNTERpdkVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbktleURvd24gPSAoZXY6IFJlYWN0LktleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgICAgc3dpdGNoIChldi5rZXkpIHtcbiAgICAgICAgICAgIC8vIE9uIEFSUk9XX0xFRlQgZ28gdG8gdGhlIHN1Ymxpc3QgaGVhZGVyXG4gICAgICAgICAgICBjYXNlIEtleS5BUlJPV19MRUZUOlxuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVyQnV0dG9uLmN1cnJlbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIENvbnN1bWUgQVJST1dfUklHSFQgc28gaXQgZG9lc24ndCBjYXVzZSBmb2N1cyB0byBnZXQgc2VudCB0byBjb21wb3NlclxuICAgICAgICAgICAgY2FzZSBLZXkuQVJST1dfUklHSFQ6XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSByZW5kZXJWaXNpYmxlVGlsZXMoKTogUmVhY3QuUmVhY3RFbGVtZW50W10ge1xuICAgICAgICBpZiAoIXRoaXMuc3RhdGUuaXNFeHBhbmRlZCkge1xuICAgICAgICAgICAgLy8gZG9uJ3Qgd2FzdGUgdGltZSBvbiByZW5kZXJpbmdcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRpbGVzOiBSZWFjdC5SZWFjdEVsZW1lbnRbXSA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnJvb21zKSB7XG4gICAgICAgICAgICBjb25zdCB2aXNpYmxlUm9vbXMgPSB0aGlzLnN0YXRlLnJvb21zLnNsaWNlKDAsIHRoaXMubnVtVmlzaWJsZVRpbGVzKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgcm9vbSBvZiB2aXNpYmxlUm9vbXMpIHtcbiAgICAgICAgICAgICAgICB0aWxlcy5wdXNoKDxSb29tVGlsZVxuICAgICAgICAgICAgICAgICAgICByb29tPXtyb29tfVxuICAgICAgICAgICAgICAgICAgICBrZXk9e2Byb29tLSR7cm9vbS5yb29tSWR9YH1cbiAgICAgICAgICAgICAgICAgICAgc2hvd01lc3NhZ2VQcmV2aWV3PXt0aGlzLmxheW91dC5zaG93UHJldmlld3N9XG4gICAgICAgICAgICAgICAgICAgIGlzTWluaW1pemVkPXt0aGlzLnByb3BzLmlzTWluaW1pemVkfVxuICAgICAgICAgICAgICAgICAgICB0YWc9e3RoaXMucHJvcHMudGFnSWR9XG4gICAgICAgICAgICAgICAgLz4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZXh0cmFUaWxlcykge1xuICAgICAgICAgICAgLy8gSEFDSzogV2UgYnJlYWsgdHlwaW5nIGhlcmUsIGJ1dCB0aGlzICdleHRyYSB0aWxlcycgcHJvcGVydHkgc2hvdWxkbid0IGV4aXN0LlxuICAgICAgICAgICAgKHRpbGVzIGFzIGFueVtdKS5wdXNoKC4uLnRoaXMuZXh0cmFUaWxlcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBvbmx5IGhhdmUgdG8gZG8gdGhpcyBiZWNhdXNlIG9mIHRoZSBleHRyYSB0aWxlcy4gV2UgZG8gaXQgY29uZGl0aW9uYWxseVxuICAgICAgICAvLyB0byBhdm9pZCBzcGVuZGluZyBjeWNsZXMgb24gc2xpY2luZy4gSXQncyBnZW5lcmFsbHkgZmluZSB0byBkbyB0aGlzIHRob3VnaFxuICAgICAgICAvLyBhcyB1c2VycyBhcmUgdW5saWtlbHkgdG8gaGF2ZSBtb3JlIHRoYW4gYSBoYW5kZnVsIG9mIHRpbGVzIHdoZW4gdGhlIGV4dHJhXG4gICAgICAgIC8vIHRpbGVzIGFyZSB1c2VkLlxuICAgICAgICBpZiAodGlsZXMubGVuZ3RoID4gdGhpcy5udW1WaXNpYmxlVGlsZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aWxlcy5zbGljZSgwLCB0aGlzLm51bVZpc2libGVUaWxlcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGlsZXM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZW5kZXJNZW51KCk6IFJlYWN0LlJlYWN0RWxlbWVudCB7XG4gICAgICAgIGxldCBjb250ZXh0TWVudSA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmNvbnRleHRNZW51UG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGlzQWxwaGFiZXRpY2FsID0gUm9vbUxpc3RTdG9yZS5pbnN0YW5jZS5nZXRUYWdTb3J0aW5nKHRoaXMucHJvcHMudGFnSWQpID09PSBTb3J0QWxnb3JpdGhtLkFscGhhYmV0aWM7XG4gICAgICAgICAgICBjb25zdCBpc1VucmVhZEZpcnN0ID0gUm9vbUxpc3RTdG9yZS5pbnN0YW5jZS5nZXRMaXN0T3JkZXIodGhpcy5wcm9wcy50YWdJZCkgPT09IExpc3RBbGdvcml0aG0uSW1wb3J0YW5jZTtcblxuICAgICAgICAgICAgLy8gSW52aXRlcyBkb24ndCBnZXQgc29tZSBub25zZW5zZSBvcHRpb25zLCBzbyBvbmx5IGFkZCB0aGVtIGlmIHdlIGhhdmUgdG8uXG4gICAgICAgICAgICBsZXQgb3RoZXJTZWN0aW9ucyA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy50YWdJZCAhPT0gRGVmYXVsdFRhZ0lELkludml0ZSkge1xuICAgICAgICAgICAgICAgIG90aGVyU2VjdGlvbnMgPSAoXG4gICAgICAgICAgICAgICAgICAgIDxSZWFjdC5GcmFnbWVudD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxociAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nbXhfUm9vbVN1Ymxpc3RfY29udGV4dE1lbnVfdGl0bGUnPnsgX3QoXCJBcHBlYXJhbmNlXCIpIH08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8U3R5bGVkTWVudUl0ZW1DaGVja2JveFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsb3NlPXt0aGlzLm9uQ2xvc2VNZW51fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5vblVucmVhZEZpcnN0Q2hhbmdlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17aXNVbnJlYWRGaXJzdH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgX3QoXCJTaG93IHJvb21zIHdpdGggdW5yZWFkIG1lc3NhZ2VzIGZpcnN0XCIpIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L1N0eWxlZE1lbnVJdGVtQ2hlY2tib3g+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFN0eWxlZE1lbnVJdGVtQ2hlY2tib3hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbG9zZT17dGhpcy5vbkNsb3NlTWVudX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25NZXNzYWdlUHJldmlld0NoYW5nZWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e3RoaXMubGF5b3V0LnNob3dQcmV2aWV3c31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgX3QoXCJTaG93IHByZXZpZXdzIG9mIG1lc3NhZ2VzXCIpIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L1N0eWxlZE1lbnVJdGVtQ2hlY2tib3g+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9SZWFjdC5GcmFnbWVudD5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZXh0TWVudSA9IChcbiAgICAgICAgICAgICAgICA8Q29udGV4dE1lbnVcbiAgICAgICAgICAgICAgICAgICAgY2hldnJvbkZhY2U9e0NoZXZyb25GYWNlLk5vbmV9XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ9e3RoaXMuc3RhdGUuY29udGV4dE1lbnVQb3NpdGlvbi5sZWZ0fVxuICAgICAgICAgICAgICAgICAgICB0b3A9e3RoaXMuc3RhdGUuY29udGV4dE1lbnVQb3NpdGlvbi50b3AgKyB0aGlzLnN0YXRlLmNvbnRleHRNZW51UG9zaXRpb24uaGVpZ2h0fVxuICAgICAgICAgICAgICAgICAgICBvbkZpbmlzaGVkPXt0aGlzLm9uQ2xvc2VNZW51fVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJteF9Sb29tU3VibGlzdF9jb250ZXh0TWVudVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nbXhfUm9vbVN1Ymxpc3RfY29udGV4dE1lbnVfdGl0bGUnPnsgX3QoXCJTb3J0IGJ5XCIpIH08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8U3R5bGVkTWVudUl0ZW1SYWRpb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsb3NlPXt0aGlzLm9uQ2xvc2VNZW51fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KCkgPT4gdGhpcy5vblRhZ1NvcnRDaGFuZ2VkKFNvcnRBbGdvcml0aG0uUmVjZW50KX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17IWlzQWxwaGFiZXRpY2FsfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPXtgbXhfJHt0aGlzLnByb3BzLnRhZ0lkfV9zb3J0QnlgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBfdChcIkFjdGl2aXR5XCIpIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L1N0eWxlZE1lbnVJdGVtUmFkaW8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFN0eWxlZE1lbnVJdGVtUmFkaW9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbG9zZT17dGhpcy5vbkNsb3NlTWVudX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eygpID0+IHRoaXMub25UYWdTb3J0Q2hhbmdlZChTb3J0QWxnb3JpdGhtLkFscGhhYmV0aWMpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkPXtpc0FscGhhYmV0aWNhbH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT17YG14XyR7dGhpcy5wcm9wcy50YWdJZH1fc29ydEJ5YH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgX3QoXCJBLVpcIikgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvU3R5bGVkTWVudUl0ZW1SYWRpbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgeyBvdGhlclNlY3Rpb25zIH1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9Db250ZXh0TWVudT5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5hZGRSb29tQ29udGV4dE1lbnVQb3NpdGlvbikge1xuICAgICAgICAgICAgY29udGV4dE1lbnUgPSAoXG4gICAgICAgICAgICAgICAgPEljb25pemVkQ29udGV4dE1lbnVcbiAgICAgICAgICAgICAgICAgICAgY2hldnJvbkZhY2U9e0NoZXZyb25GYWNlLk5vbmV9XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ9e3RoaXMuc3RhdGUuYWRkUm9vbUNvbnRleHRNZW51UG9zaXRpb24ubGVmdCAtIDd9IC8vIGNlbnRlciBhbGlnbiB3aXRoIHRoZSBoYW5kbGVcbiAgICAgICAgICAgICAgICAgICAgdG9wPXt0aGlzLnN0YXRlLmFkZFJvb21Db250ZXh0TWVudVBvc2l0aW9uLnRvcCArIHRoaXMuc3RhdGUuYWRkUm9vbUNvbnRleHRNZW51UG9zaXRpb24uaGVpZ2h0fVxuICAgICAgICAgICAgICAgICAgICBvbkZpbmlzaGVkPXt0aGlzLm9uQ2xvc2VBZGRSb29tTWVudX1cbiAgICAgICAgICAgICAgICAgICAgY29tcGFjdFxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgeyB0aGlzLnByb3BzLmFkZFJvb21Db250ZXh0TWVudSh0aGlzLm9uQ2xvc2VBZGRSb29tTWVudSkgfVxuICAgICAgICAgICAgICAgIDwvSWNvbml6ZWRDb250ZXh0TWVudT5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPFJlYWN0LkZyYWdtZW50PlxuICAgICAgICAgICAgICAgIDxDb250ZXh0TWVudVRvb2x0aXBCdXR0b25cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibXhfUm9vbVN1Ymxpc3RfbWVudUJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMub25PcGVuTWVudUNsaWNrfVxuICAgICAgICAgICAgICAgICAgICB0aXRsZT17X3QoXCJMaXN0IG9wdGlvbnNcIil9XG4gICAgICAgICAgICAgICAgICAgIGlzRXhwYW5kZWQ9eyEhdGhpcy5zdGF0ZS5jb250ZXh0TWVudVBvc2l0aW9ufVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgeyBjb250ZXh0TWVudSB9XG4gICAgICAgICAgICA8L1JlYWN0LkZyYWdtZW50PlxuICAgICAgICApO1xuICAgIH1cblxuICAgIHByaXZhdGUgcmVuZGVySGVhZGVyKCk6IFJlYWN0LlJlYWN0RWxlbWVudCB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8Um92aW5nVGFiSW5kZXhXcmFwcGVyIGlucHV0UmVmPXt0aGlzLmhlYWRlckJ1dHRvbn0+XG4gICAgICAgICAgICAgICAgeyAoeyBvbkZvY3VzLCBpc0FjdGl2ZSwgcmVmIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFiSW5kZXggPSBpc0FjdGl2ZSA/IDAgOiAtMTtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgYXJpYUxhYmVsID0gX3QoXCJKdW1wIHRvIGZpcnN0IHVucmVhZCByb29tLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMudGFnSWQgPT09IERlZmF1bHRUYWdJRC5JbnZpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyaWFMYWJlbCA9IF90KFwiSnVtcCB0byBmaXJzdCBpbnZpdGUuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFkZ2UgPSAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8Tm90aWZpY2F0aW9uQmFkZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZUNvdW50PXt0cnVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbj17dGhpcy5ub3RpZmljYXRpb25TdGF0ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uQmFkZ2VDbGlja31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJJbmRleD17dGFiSW5kZXh9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJpYS1sYWJlbD17YXJpYUxhYmVsfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dVbnNlbnRUb29sdGlwPXt0cnVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgYWRkUm9vbUJ1dHRvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghIXRoaXMucHJvcHMub25BZGRSb29tICYmIHNob3VsZFNob3dDb21wb25lbnQoVUlDb21wb25lbnQuQ3JlYXRlUm9vbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRSb29tQnV0dG9uID0gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxBY2Nlc3NpYmxlVG9vbHRpcEJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJJbmRleD17dGFiSW5kZXh9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMub25BZGRSb29tfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJteF9Sb29tU3VibGlzdF9hdXhCdXR0b25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwQ2xhc3NOYW1lPVwibXhfUm9vbVN1Ymxpc3RfYWRkUm9vbVRvb2x0aXBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPXt0aGlzLnByb3BzLmFkZFJvb21MYWJlbCB8fCBfdChcIkFkZCByb29tXCIpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT17dGhpcy5wcm9wcy5hZGRSb29tTGFiZWx9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy5hZGRSb29tQ29udGV4dE1lbnUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IHNob3VsZFNob3dDb21wb25lbnQoKSBpcyBjaGVja2VkIGJ5IHRoZSBjb250ZXh0IG1lbnUgaXRzZWxmLlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUm9vbUJ1dHRvbiA9IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q29udGV4dE1lbnVUb29sdGlwQnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYkluZGV4PXt0YWJJbmRleH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5vbkFkZFJvb21Db250ZXh0TWVudX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibXhfUm9vbVN1Ymxpc3RfYXV4QnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcENsYXNzTmFtZT1cIm14X1Jvb21TdWJsaXN0X2FkZFJvb21Ub29sdGlwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJpYS1sYWJlbD17dGhpcy5wcm9wcy5hZGRSb29tTGFiZWwgfHwgX3QoXCJBZGQgcm9vbVwiKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9e3RoaXMucHJvcHMuYWRkUm9vbUxhYmVsfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0V4cGFuZGVkPXshIXRoaXMuc3RhdGUuYWRkUm9vbUNvbnRleHRNZW51UG9zaXRpb259XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2xsYXBzZUNsYXNzZXMgPSBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdteF9Sb29tU3VibGlzdF9jb2xsYXBzZUJ0bic6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbXhfUm9vbVN1Ymxpc3RfY29sbGFwc2VCdG5fY29sbGFwc2VkJzogIXRoaXMuc3RhdGUuaXNFeHBhbmRlZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xhc3NlcyA9IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgJ214X1Jvb21TdWJsaXN0X2hlYWRlckNvbnRhaW5lcic6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbXhfUm9vbVN1Ymxpc3RfaGVhZGVyQ29udGFpbmVyX3dpdGhBdXgnOiAhIWFkZFJvb21CdXR0b24sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhZGdlQ29udGFpbmVyID0gKFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJteF9Sb29tU3VibGlzdF9iYWRnZUNvbnRhaW5lclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgYmFkZ2UgfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IEJ1dHRvbjogUmVhY3QuQ29tcG9uZW50VHlwZTxSZWFjdC5Db21wb25lbnRQcm9wczx0eXBlb2YgQWNjZXNzaWJsZUJ1dHRvbj4+ID0gQWNjZXNzaWJsZUJ1dHRvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuaXNNaW5pbWl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEJ1dHRvbiA9IEFjY2Vzc2libGVUb29sdGlwQnV0dG9uO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogdGhlIGFkZFJvb21CdXR0b24gY29uZGl0aW9uYWxseSBnZXRzIG1vdmVkIGFyb3VuZFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgRE9NIGRlcGVuZGluZyBvbiB3aGV0aGVyIG9yIG5vdCB0aGUgbGlzdCBpcyBtaW5pbWl6ZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIG1pbmltaXplZCwgd2Ugd2FudCBpdCBiZWxvdyB0aGUgaGVhZGVyIHNvIGl0XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvZXNuJ3QgYmVjb21lIHN0aWNreS5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHNhbWUgYXBwbGllcyB0byB0aGUgbm90aWZpY2F0aW9uIGJhZGdlLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3Nlc31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbktleURvd249e3RoaXMub25IZWFkZXJLZXlEb3dufVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRm9jdXM9e29uRm9jdXN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJpYS1sYWJlbD17dGhpcy5wcm9wcy5sYWJlbH1cbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm14X1Jvb21TdWJsaXN0X3N0aWNrYWJsZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkZvY3VzPXtvbkZvY3VzfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRSZWY9e3JlZn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYkluZGV4PXt0YWJJbmRleH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIm14X1Jvb21TdWJsaXN0X2hlYWRlclRleHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZT1cInRyZWVpdGVtXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyaWEtZXhwYW5kZWQ9e3RoaXMuc3RhdGUuaXNFeHBhbmRlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyaWEtbGV2ZWw9ezF9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uSGVhZGVyQ2xpY2t9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNvbnRleHRNZW51PXt0aGlzLm9uQ29udGV4dE1lbnV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT17dGhpcy5wcm9wcy5pc01pbmltaXplZCA/IHRoaXMucHJvcHMubGFiZWwgOiB1bmRlZmluZWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17Y29sbGFwc2VDbGFzc2VzfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+eyB0aGlzLnByb3BzLmxhYmVsIH08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHRoaXMucmVuZGVyTWVudSgpIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB0aGlzLnByb3BzLmlzTWluaW1pemVkID8gbnVsbCA6IGJhZGdlQ29udGFpbmVyIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB0aGlzLnByb3BzLmlzTWluaW1pemVkID8gbnVsbCA6IGFkZFJvb21CdXR0b24gfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdGhpcy5wcm9wcy5pc01pbmltaXplZCA/IGJhZGdlQ29udGFpbmVyIDogbnVsbCB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB0aGlzLnByb3BzLmlzTWluaW1pemVkID8gYWRkUm9vbUJ1dHRvbiA6IG51bGwgfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSB9XG4gICAgICAgICAgICA8L1JvdmluZ1RhYkluZGV4V3JhcHBlcj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uU2Nyb2xsUHJldmVudChlOiBFdmVudCkge1xuICAgICAgICAvLyB0aGUgUm9vbVRpbGUgY2FsbHMgc2Nyb2xsSW50b1ZpZXcgYW5kIHRoZSBicm93c2VyIG1heSBzY3JvbGwgYSBkaXYgd2UgZG8gbm90IHdpc2ggdG8gYmUgc2Nyb2xsYWJsZVxuICAgICAgICAvLyB0aGlzIGZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS92ZWN0b3ItaW0vZWxlbWVudC13ZWIvaXNzdWVzLzE0NDEzXG4gICAgICAgIChlLnRhcmdldCBhcyBIVE1MRGl2RWxlbWVudCkuc2Nyb2xsVG9wID0gMDtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVuZGVyKCk6IFJlYWN0LlJlYWN0RWxlbWVudCB7XG4gICAgICAgIGNvbnN0IHZpc2libGVUaWxlcyA9IHRoaXMucmVuZGVyVmlzaWJsZVRpbGVzKCk7XG4gICAgICAgIGNvbnN0IGNsYXNzZXMgPSBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgICdteF9Sb29tU3VibGlzdCc6IHRydWUsXG4gICAgICAgICAgICAnbXhfUm9vbVN1Ymxpc3RfaGFzTWVudU9wZW4nOiAhIXRoaXMuc3RhdGUuY29udGV4dE1lbnVQb3NpdGlvbixcbiAgICAgICAgICAgICdteF9Sb29tU3VibGlzdF9taW5pbWl6ZWQnOiB0aGlzLnByb3BzLmlzTWluaW1pemVkLFxuICAgICAgICAgICAgJ214X1Jvb21TdWJsaXN0X2hpZGRlbic6IChcbiAgICAgICAgICAgICAgICAhdGhpcy5zdGF0ZS5yb29tcy5sZW5ndGggJiYgIXRoaXMucHJvcHMuZXh0cmFUaWxlcz8ubGVuZ3RoICYmIHRoaXMucHJvcHMuYWx3YXlzVmlzaWJsZSAhPT0gdHJ1ZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IGNvbnRlbnQgPSBudWxsO1xuICAgICAgICBpZiAodmlzaWJsZVRpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGxheW91dCA9IHRoaXMubGF5b3V0OyAvLyB0byBzaG9ydGVuIGNhbGxzXG5cbiAgICAgICAgICAgIGNvbnN0IG1pblRpbGVzID0gTWF0aC5taW4obGF5b3V0Lm1pblZpc2libGVUaWxlcywgdGhpcy5udW1UaWxlcyk7XG4gICAgICAgICAgICBjb25zdCBzaG93TW9yZUF0TWluSGVpZ2h0ID0gbWluVGlsZXMgPCB0aGlzLm51bVRpbGVzO1xuICAgICAgICAgICAgY29uc3QgbWluSGVpZ2h0UGFkZGluZyA9IFJFU0laRV9IQU5ETEVfSEVJR0hUICsgKHNob3dNb3JlQXRNaW5IZWlnaHQgPyBTSE9XX05fQlVUVE9OX0hFSUdIVCA6IDApO1xuICAgICAgICAgICAgY29uc3QgbWluVGlsZXNQeCA9IGxheW91dC50aWxlc1RvUGl4ZWxzV2l0aFBhZGRpbmcobWluVGlsZXMsIG1pbkhlaWdodFBhZGRpbmcpO1xuICAgICAgICAgICAgY29uc3QgbWF4VGlsZXNQeCA9IGxheW91dC50aWxlc1RvUGl4ZWxzV2l0aFBhZGRpbmcodGhpcy5udW1UaWxlcywgdGhpcy5wYWRkaW5nKTtcbiAgICAgICAgICAgIGNvbnN0IHNob3dNb3JlQnRuQ2xhc3NlcyA9IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgICAgICdteF9Sb29tU3VibGlzdF9zaG93TkJ1dHRvbic6IHRydWUsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gSWYgd2UncmUgaGlkaW5nIHJvb21zLCBzaG93IGEgJ3Nob3cgbW9yZScgYnV0dG9uIHRvIHRoZSB1c2VyLiBUaGlzIGJ1dHRvblxuICAgICAgICAgICAgLy8gZmxvYXRzIGFib3ZlIHRoZSByZXNpemUgaGFuZGxlLCBpZiB3ZSBoYXZlIG9uZSBwcmVzZW50LiBJZiB0aGUgdXNlciBoYXMgYWxsXG4gICAgICAgICAgICAvLyB0aWxlcyB2aXNpYmxlLCBpdCBiZWNvbWVzICdzaG93IGxlc3MnLlxuICAgICAgICAgICAgbGV0IHNob3dOQnV0dG9uID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKG1heFRpbGVzUHggPiB0aGlzLnN0YXRlLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIHRoZSBoZWlnaHQgb2YgYWxsIHRoZSB0aWxlcyBpcyBncmVhdGVyIHRoYW4gdGhlIHNlY3Rpb24gaGVpZ2h0OiB3ZSBuZWVkIGEgJ3Nob3cgbW9yZScgYnV0dG9uXG4gICAgICAgICAgICAgICAgY29uc3Qgbm9uUGFkZGVkSGVpZ2h0ID0gdGhpcy5zdGF0ZS5oZWlnaHQgLSBSRVNJWkVfSEFORExFX0hFSUdIVCAtIFNIT1dfTl9CVVRUT05fSEVJR0hUO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFtb3VudEZ1bGx5U2hvd24gPSBNYXRoLmZsb29yKG5vblBhZGRlZEhlaWdodCAvIHRoaXMubGF5b3V0LnRpbGVIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bU1pc3NpbmcgPSB0aGlzLm51bVRpbGVzIC0gYW1vdW50RnVsbHlTaG93bjtcbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbCA9IF90KFwiU2hvdyAlKGNvdW50KXMgbW9yZVwiLCB7IGNvdW50OiBudW1NaXNzaW5nIH0pO1xuICAgICAgICAgICAgICAgIGxldCBzaG93TW9yZVRleHQgPSAoXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT0nbXhfUm9vbVN1Ymxpc3Rfc2hvd05CdXR0b25UZXh0Jz5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbGFiZWwgfVxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5pc01pbmltaXplZCkgc2hvd01vcmVUZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzaG93TkJ1dHRvbiA9IChcbiAgICAgICAgICAgICAgICAgICAgPFJvdmluZ0FjY2Vzc2libGVCdXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU9XCJ0cmVlaXRlbVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uU2hvd0FsbENsaWNrfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzaG93TW9yZUJ0bkNsYXNzZXN9XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPXtsYWJlbH1cbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPSdteF9Sb29tU3VibGlzdF9zaG93TW9yZUJ1dHRvbkNoZXZyb24gbXhfUm9vbVN1Ymxpc3Rfc2hvd05CdXR0b25DaGV2cm9uJz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IC8qIHNldCBieSBDU1MgbWFza2luZyAqLyB9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICB7IHNob3dNb3JlVGV4dCB9XG4gICAgICAgICAgICAgICAgICAgIDwvUm92aW5nQWNjZXNzaWJsZUJ1dHRvbj5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm51bVRpbGVzID4gdGhpcy5sYXlvdXQuZGVmYXVsdFZpc2libGVUaWxlcykge1xuICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgYWxsIHRpbGVzIHZpc2libGUgLSBhZGQgYSBidXR0b24gdG8gc2hvdyBsZXNzXG4gICAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBfdChcIlNob3cgbGVzc1wiKTtcbiAgICAgICAgICAgICAgICBsZXQgc2hvd0xlc3NUZXh0ID0gKFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9J214X1Jvb21TdWJsaXN0X3Nob3dOQnV0dG9uVGV4dCc+XG4gICAgICAgICAgICAgICAgICAgICAgICB7IGxhYmVsIH1cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuaXNNaW5pbWl6ZWQpIHNob3dMZXNzVGV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgc2hvd05CdXR0b24gPSAoXG4gICAgICAgICAgICAgICAgICAgIDxSb3ZpbmdBY2Nlc3NpYmxlQnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICByb2xlPVwidHJlZWl0ZW1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5vblNob3dMZXNzQ2xpY2t9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3Nob3dNb3JlQnRuQ2xhc3Nlc31cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9e2xhYmVsfVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9J214X1Jvb21TdWJsaXN0X3Nob3dMZXNzQnV0dG9uQ2hldnJvbiBteF9Sb29tU3VibGlzdF9zaG93TkJ1dHRvbkNoZXZyb24nPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgLyogc2V0IGJ5IENTUyBtYXNraW5nICovIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsgc2hvd0xlc3NUZXh0IH1cbiAgICAgICAgICAgICAgICAgICAgPC9Sb3ZpbmdBY2Nlc3NpYmxlQnV0dG9uPlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpZ3VyZSBvdXQgaWYgd2UgbmVlZCBhIGhhbmRsZVxuICAgICAgICAgICAgY29uc3QgaGFuZGxlczogRW5hYmxlID0ge1xuICAgICAgICAgICAgICAgIGJvdHRvbTogdHJ1ZSwgLy8gdGhlIG9ubHkgb25lIHdlIG5lZWQsIGJ1dCB0aGUgb3RoZXJzIG11c3QgYmUgZXhwbGljaXRseSBmYWxzZVxuICAgICAgICAgICAgICAgIGJvdHRvbUxlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGJvdHRvbVJpZ2h0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICByaWdodDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdG9wOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0b3BMZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0b3BSaWdodDogZmFsc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGxheW91dC52aXNpYmxlVGlsZXMgPj0gdGhpcy5udW1UaWxlcyAmJiB0aGlzLm51bVRpbGVzIDw9IGxheW91dC5taW5WaXNpYmxlVGlsZXMpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSdyZSBhdCBhIG1pbmltdW0sIGRvbid0IGhhdmUgYSBib3R0b20gaGFuZGxlXG4gICAgICAgICAgICAgICAgaGFuZGxlcy5ib3R0b20gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBhY2NvdW50IGZvciBwYWRkaW5nIHNvIHdlIGNhbiBhY2NvbW1vZGF0ZSBhICdzaG93IG1vcmUnIGJ1dHRvbiBhbmRcbiAgICAgICAgICAgIC8vIHRoZSByZXNpemUgaGFuZGxlLCB3aGljaCBhcmUgcGlubmVkIHRvIHRoZSBib3R0b20gb2YgdGhlIGNvbnRhaW5lci4gVGhpcyBpcyB0aGVcbiAgICAgICAgICAgIC8vIGVhc2llc3Qgd2F5IHRvIGhhdmUgYSByZXNpemUgaGFuZGxlIGJlbG93IHRoZSBidXR0b24gYXMgb3RoZXJ3aXNlIHdlJ3JlIHdyaXRpbmdcbiAgICAgICAgICAgIC8vIG91ciBvd24gcmVzaXplIGhhbmRsaW5nIGFuZCB0aGF0IGRvZXNuJ3Qgc291bmQgZnVuLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoZSBsYXlvdXQgY2xhc3MgaGFzIHNvbWUgaGVscGVycyBmb3IgZGVhbGluZyB3aXRoIHBhZGRpbmcsIGFzIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgICAgIC8vIGFwcGx5IGl0IGluIGFsbCBjYXNlcy4gSWYgd2UgYXBwbHkgaXQgaW4gYWxsIGNhc2VzLCB0aGUgcmVzaXppbmcgZmVlbHMgbGlrZSBpdFxuICAgICAgICAgICAgLy8gZ29lcyBiYWNrd2FyZHMgYW5kIGNhbiBiZWNvbWUgd2lsZGx5IGluY29ycmVjdCAodmlzaWJsZVRpbGVzIHNheXMgMTggd2hlbiB0aGVyZSdzXG4gICAgICAgICAgICAvLyBvbmx5IG1hdGhlbWF0aWNhbGx5IDcgcG9zc2libGUpLlxuXG4gICAgICAgICAgICBjb25zdCBoYW5kbGVXcmFwcGVyQ2xhc3NlcyA9IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgICAgICdteF9Sb29tU3VibGlzdF9yZXNpemVySGFuZGxlcyc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ214X1Jvb21TdWJsaXN0X3Jlc2l6ZXJIYW5kbGVzX3Nob3dOQnV0dG9uJzogISFzaG93TkJ1dHRvbixcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gKFxuICAgICAgICAgICAgICAgIDxSZWFjdC5GcmFnbWVudD5cbiAgICAgICAgICAgICAgICAgICAgPFJlc2l6YWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZT17eyBoZWlnaHQ6IHRoaXMuc3RhdGUuaGVpZ2h0IH0gYXMgYW55fVxuICAgICAgICAgICAgICAgICAgICAgICAgbWluSGVpZ2h0PXttaW5UaWxlc1B4fVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0PXttYXhUaWxlc1B4fVxuICAgICAgICAgICAgICAgICAgICAgICAgb25SZXNpemVTdGFydD17dGhpcy5vblJlc2l6ZVN0YXJ0fVxuICAgICAgICAgICAgICAgICAgICAgICAgb25SZXNpemVTdG9wPXt0aGlzLm9uUmVzaXplU3RvcH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uUmVzaXplPXt0aGlzLm9uUmVzaXplfVxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlV3JhcHBlckNsYXNzPXtoYW5kbGVXcmFwcGVyQ2xhc3Nlc31cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUNsYXNzZXM9e3sgYm90dG9tOiBcIm14X1Jvb21TdWJsaXN0X3Jlc2l6ZXJIYW5kbGVcIiB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibXhfUm9vbVN1Ymxpc3RfcmVzaXplQm94XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZT17aGFuZGxlc31cbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJteF9Sb29tU3VibGlzdF90aWxlc1wiIHJlZj17dGhpcy50aWxlc1JlZn0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB2aXNpYmxlVGlsZXMgfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICB7IHNob3dOQnV0dG9uIH1cbiAgICAgICAgICAgICAgICAgICAgPC9SZXNpemFibGU+XG4gICAgICAgICAgICAgICAgPC9SZWFjdC5GcmFnbWVudD5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy5zaG93U2tlbGV0b24gJiYgdGhpcy5zdGF0ZS5pc0V4cGFuZGVkKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gPGRpdiBjbGFzc05hbWU9XCJteF9Sb29tU3VibGlzdF9za2VsZXRvblVJXCIgLz47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIHJlZj17dGhpcy5zdWJsaXN0UmVmfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3Nlc31cbiAgICAgICAgICAgICAgICByb2xlPVwiZ3JvdXBcIlxuICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9e3RoaXMucHJvcHMubGFiZWx9XG4gICAgICAgICAgICAgICAgb25LZXlEb3duPXt0aGlzLm9uS2V5RG93bn1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7IHRoaXMucmVuZGVySGVhZGVyKCkgfVxuICAgICAgICAgICAgICAgIHsgY29udGVudCB9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG59XG4iXX0=