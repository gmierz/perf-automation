"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _FormattingUtils = require("../../../utils/FormattingUtils");

var _SettingsStore = _interopRequireDefault(require("../../../settings/SettingsStore"));

var _AccessibleButton = _interopRequireDefault(require("../elements/AccessibleButton"));

var _NotificationState = require("../../../stores/notifications/NotificationState");

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _Tooltip = _interopRequireDefault(require("../elements/Tooltip"));

var _languageHandler = require("../../../languageHandler");

var _NotificationColor = require("../../../stores/notifications/NotificationColor");

const _excluded = ["notification", "showUnsentTooltip", "forceCount", "roomId", "onClick"];

var _dec, _class;

let NotificationBadge = (_dec = (0, _replaceableComponent.replaceableComponent)("views.rooms.NotificationBadge"), _dec(_class = class NotificationBadge extends _react.default.PureComponent {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "countWatcherRef", void 0);
    (0, _defineProperty2.default)(this, "countPreferenceChanged", () => {
      this.setState({
        showCounts: _SettingsStore.default.getValue("Notifications.alwaysShowBadgeCounts", this.roomId)
      });
    });
    (0, _defineProperty2.default)(this, "onNotificationUpdate", () => {
      this.forceUpdate(); // notification state changed - update
    });
    (0, _defineProperty2.default)(this, "onMouseOver", e => {
      e.stopPropagation();
      this.setState({
        showTooltip: true
      });
    });
    (0, _defineProperty2.default)(this, "onMouseLeave", () => {
      this.setState({
        showTooltip: false
      });
    });
    this.props.notification.on(_NotificationState.NOTIFICATION_STATE_UPDATE, this.onNotificationUpdate);
    this.state = {
      showCounts: _SettingsStore.default.getValue("Notifications.alwaysShowBadgeCounts", this.roomId),
      showTooltip: false
    };
    this.countWatcherRef = _SettingsStore.default.watchSetting("Notifications.alwaysShowBadgeCounts", this.roomId, this.countPreferenceChanged);
  }

  get roomId() {
    // We should convert this to null for safety with the SettingsStore
    return this.props.roomId || null;
  }

  componentWillUnmount() {
    _SettingsStore.default.unwatchSetting(this.countWatcherRef);

    this.props.notification.off(_NotificationState.NOTIFICATION_STATE_UPDATE, this.onNotificationUpdate);
  }

  componentDidUpdate(prevProps) {
    if (prevProps.notification) {
      prevProps.notification.off(_NotificationState.NOTIFICATION_STATE_UPDATE, this.onNotificationUpdate);
    }

    this.props.notification.on(_NotificationState.NOTIFICATION_STATE_UPDATE, this.onNotificationUpdate);
  }

  render() {
    /* eslint @typescript-eslint/no-unused-vars: ["error", { "ignoreRestSiblings": true }] */
    const _this$props = this.props,
          {
      notification,
      showUnsentTooltip,
      forceCount,
      roomId,
      onClick
    } = _this$props,
          props = (0, _objectWithoutProperties2.default)(_this$props, _excluded); // Don't show a badge if we don't need to

    if (notification.isIdle) return null; // TODO: Update these booleans for FTUE Notifications: https://github.com/vector-im/element-web/issues/14261
    // As of writing, that is "if red, show count always" and "optionally show counts instead of dots".
    // See git diff for what that boolean state looks like.
    // XXX: We ignore this.state.showCounts (the setting which controls counts vs dots).

    const hasAnySymbol = notification.symbol || notification.count > 0;
    let isEmptyBadge = !hasAnySymbol || !notification.hasUnreadCount;

    if (forceCount) {
      isEmptyBadge = false;
      if (!notification.hasUnreadCount) return null; // Can't render a badge
    }

    let symbol = notification.symbol || (0, _FormattingUtils.formatCount)(notification.count);
    if (isEmptyBadge) symbol = "";
    const classes = (0, _classnames.default)({
      'mx_NotificationBadge': true,
      'mx_NotificationBadge_visible': isEmptyBadge ? true : notification.hasUnreadCount,
      'mx_NotificationBadge_highlighted': notification.hasMentions,
      'mx_NotificationBadge_dot': isEmptyBadge,
      'mx_NotificationBadge_2char': symbol.length > 0 && symbol.length < 3,
      'mx_NotificationBadge_3char': symbol.length > 2
    });

    if (onClick) {
      let label;
      let tooltip;

      if (showUnsentTooltip && this.state.showTooltip && notification.color === _NotificationColor.NotificationColor.Unsent) {
        label = (0, _languageHandler._t)("Message didn't send. Click for info.");
        tooltip = /*#__PURE__*/_react.default.createElement(_Tooltip.default, {
          className: "mx_RoleButton_tooltip",
          label: label
        });
      }

      return /*#__PURE__*/_react.default.createElement(_AccessibleButton.default, (0, _extends2.default)({
        "aria-label": label
      }, props, {
        className: classes,
        onClick: onClick,
        onMouseOver: this.onMouseOver,
        onMouseLeave: this.onMouseLeave
      }), /*#__PURE__*/_react.default.createElement("span", {
        className: "mx_NotificationBadge_count"
      }, symbol), tooltip);
    }

    return /*#__PURE__*/_react.default.createElement("div", {
      className: classes
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: "mx_NotificationBadge_count"
    }, symbol));
  }

}) || _class);
exports.default = NotificationBadge;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL3Jvb21zL05vdGlmaWNhdGlvbkJhZGdlLnRzeCJdLCJuYW1lcyI6WyJOb3RpZmljYXRpb25CYWRnZSIsIlJlYWN0IiwiUHVyZUNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJzZXRTdGF0ZSIsInNob3dDb3VudHMiLCJTZXR0aW5nc1N0b3JlIiwiZ2V0VmFsdWUiLCJyb29tSWQiLCJmb3JjZVVwZGF0ZSIsImUiLCJzdG9wUHJvcGFnYXRpb24iLCJzaG93VG9vbHRpcCIsIm5vdGlmaWNhdGlvbiIsIm9uIiwiTk9USUZJQ0FUSU9OX1NUQVRFX1VQREFURSIsIm9uTm90aWZpY2F0aW9uVXBkYXRlIiwic3RhdGUiLCJjb3VudFdhdGNoZXJSZWYiLCJ3YXRjaFNldHRpbmciLCJjb3VudFByZWZlcmVuY2VDaGFuZ2VkIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJ1bndhdGNoU2V0dGluZyIsIm9mZiIsImNvbXBvbmVudERpZFVwZGF0ZSIsInByZXZQcm9wcyIsInJlbmRlciIsInNob3dVbnNlbnRUb29sdGlwIiwiZm9yY2VDb3VudCIsIm9uQ2xpY2siLCJpc0lkbGUiLCJoYXNBbnlTeW1ib2wiLCJzeW1ib2wiLCJjb3VudCIsImlzRW1wdHlCYWRnZSIsImhhc1VucmVhZENvdW50IiwiY2xhc3NlcyIsImhhc01lbnRpb25zIiwibGVuZ3RoIiwibGFiZWwiLCJ0b29sdGlwIiwiY29sb3IiLCJOb3RpZmljYXRpb25Db2xvciIsIlVuc2VudCIsIm9uTW91c2VPdmVyIiwib25Nb3VzZUxlYXZlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7OztJQStCcUJBLGlCLFdBRHBCLGdEQUFxQiwrQkFBckIsQyxnQkFBRCxNQUNxQkEsaUJBRHJCLFNBQytDQyxlQUFNQyxhQURyRCxDQUN5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QU0sTUFBQSxTQUFTLEVBQUM7QUFBaEIsT0FBK0NKLE1BQS9DLENBREosQ0FESjtBQUtIOztBQW5Ib0csQyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAyMCBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBSZWFjdCwgeyBNb3VzZUV2ZW50IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuaW1wb3J0IHsgZm9ybWF0Q291bnQgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvRm9ybWF0dGluZ1V0aWxzXCI7XG5pbXBvcnQgU2V0dGluZ3NTdG9yZSBmcm9tIFwiLi4vLi4vLi4vc2V0dGluZ3MvU2V0dGluZ3NTdG9yZVwiO1xuaW1wb3J0IEFjY2Vzc2libGVCdXR0b24gZnJvbSBcIi4uL2VsZW1lbnRzL0FjY2Vzc2libGVCdXR0b25cIjtcbmltcG9ydCB7IFhPUiB9IGZyb20gXCIuLi8uLi8uLi9AdHlwZXMvY29tbW9uXCI7XG5pbXBvcnQgeyBOT1RJRklDQVRJT05fU1RBVEVfVVBEQVRFLCBOb3RpZmljYXRpb25TdGF0ZSB9IGZyb20gXCIuLi8uLi8uLi9zdG9yZXMvbm90aWZpY2F0aW9ucy9Ob3RpZmljYXRpb25TdGF0ZVwiO1xuaW1wb3J0IHsgcmVwbGFjZWFibGVDb21wb25lbnQgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvcmVwbGFjZWFibGVDb21wb25lbnRcIjtcbmltcG9ydCBUb29sdGlwIGZyb20gXCIuLi9lbGVtZW50cy9Ub29sdGlwXCI7XG5pbXBvcnQgeyBfdCB9IGZyb20gXCIuLi8uLi8uLi9sYW5ndWFnZUhhbmRsZXJcIjtcbmltcG9ydCB7IE5vdGlmaWNhdGlvbkNvbG9yIH0gZnJvbSBcIi4uLy4uLy4uL3N0b3Jlcy9ub3RpZmljYXRpb25zL05vdGlmaWNhdGlvbkNvbG9yXCI7XG5cbmludGVyZmFjZSBJUHJvcHMge1xuICAgIG5vdGlmaWNhdGlvbjogTm90aWZpY2F0aW9uU3RhdGU7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgYmFkZ2Ugd2lsbCBzaG93IGEgY291bnQgaWYgYXQgYWxsIHBvc3NpYmxlLiBUaGlzIGlzIHR5cGljYWxseVxuICAgICAqIHVzZWQgdG8gb3ZlcnJpZGUgdGhlIHVzZXIncyBwcmVmZXJlbmNlIGZvciB0aGluZ3MgbGlrZSByb29tIHN1Ymxpc3RzLlxuICAgICAqL1xuICAgIGZvcmNlQ291bnQ/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJvb20gSUQsIGlmIGFueSwgdGhlIGJhZGdlIHJlcHJlc2VudHMuXG4gICAgICovXG4gICAgcm9vbUlkPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgSUNsaWNrYWJsZVByb3BzIGV4dGVuZHMgSVByb3BzLCBSZWFjdC5JbnB1dEhUTUxBdHRyaWJ1dGVzPEVsZW1lbnQ+IHtcbiAgICBzaG93VW5zZW50VG9vbHRpcD86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogSWYgc3BlY2lmaWVkIHdpbGwgcmV0dXJuIGFuIEFjY2Vzc2libGVCdXR0b24gaW5zdGVhZCBvZiBhIGRpdi5cbiAgICAgKi9cbiAgICBvbkNsaWNrPyhldjogUmVhY3QuTW91c2VFdmVudCk7XG59XG5cbmludGVyZmFjZSBJU3RhdGUge1xuICAgIHNob3dDb3VudHM6IGJvb2xlYW47IC8vIHdoZXRoZXIgb3Igbm90IHRvIHNob3cgY291bnRzLiBJbmRlcGVuZGVudCBvZiBwcm9wcy5mb3JjZUNvdW50XG4gICAgc2hvd1Rvb2x0aXA6IGJvb2xlYW47XG59XG5cbkByZXBsYWNlYWJsZUNvbXBvbmVudChcInZpZXdzLnJvb21zLk5vdGlmaWNhdGlvbkJhZGdlXCIpXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb3RpZmljYXRpb25CYWRnZSBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8WE9SPElQcm9wcywgSUNsaWNrYWJsZVByb3BzPiwgSVN0YXRlPiB7XG4gICAgcHJpdmF0ZSBjb3VudFdhdGNoZXJSZWY6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzOiBJUHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnByb3BzLm5vdGlmaWNhdGlvbi5vbihOT1RJRklDQVRJT05fU1RBVEVfVVBEQVRFLCB0aGlzLm9uTm90aWZpY2F0aW9uVXBkYXRlKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgc2hvd0NvdW50czogU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZShcIk5vdGlmaWNhdGlvbnMuYWx3YXlzU2hvd0JhZGdlQ291bnRzXCIsIHRoaXMucm9vbUlkKSxcbiAgICAgICAgICAgIHNob3dUb29sdGlwOiBmYWxzZSxcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmNvdW50V2F0Y2hlclJlZiA9IFNldHRpbmdzU3RvcmUud2F0Y2hTZXR0aW5nKFxuICAgICAgICAgICAgXCJOb3RpZmljYXRpb25zLmFsd2F5c1Nob3dCYWRnZUNvdW50c1wiLCB0aGlzLnJvb21JZCxcbiAgICAgICAgICAgIHRoaXMuY291bnRQcmVmZXJlbmNlQ2hhbmdlZCxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldCByb29tSWQoKTogc3RyaW5nIHtcbiAgICAgICAgLy8gV2Ugc2hvdWxkIGNvbnZlcnQgdGhpcyB0byBudWxsIGZvciBzYWZldHkgd2l0aCB0aGUgU2V0dGluZ3NTdG9yZVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5yb29tSWQgfHwgbnVsbDtcbiAgICB9XG5cbiAgICBwdWJsaWMgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIFNldHRpbmdzU3RvcmUudW53YXRjaFNldHRpbmcodGhpcy5jb3VudFdhdGNoZXJSZWYpO1xuICAgICAgICB0aGlzLnByb3BzLm5vdGlmaWNhdGlvbi5vZmYoTk9USUZJQ0FUSU9OX1NUQVRFX1VQREFURSwgdGhpcy5vbk5vdGlmaWNhdGlvblVwZGF0ZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IFJlYWRvbmx5PElQcm9wcz4pIHtcbiAgICAgICAgaWYgKHByZXZQcm9wcy5ub3RpZmljYXRpb24pIHtcbiAgICAgICAgICAgIHByZXZQcm9wcy5ub3RpZmljYXRpb24ub2ZmKE5PVElGSUNBVElPTl9TVEFURV9VUERBVEUsIHRoaXMub25Ob3RpZmljYXRpb25VcGRhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcm9wcy5ub3RpZmljYXRpb24ub24oTk9USUZJQ0FUSU9OX1NUQVRFX1VQREFURSwgdGhpcy5vbk5vdGlmaWNhdGlvblVwZGF0ZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjb3VudFByZWZlcmVuY2VDaGFuZ2VkID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgc2hvd0NvdW50czogU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZShcIk5vdGlmaWNhdGlvbnMuYWx3YXlzU2hvd0JhZGdlQ291bnRzXCIsIHRoaXMucm9vbUlkKSB9KTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbk5vdGlmaWNhdGlvblVwZGF0ZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpOyAvLyBub3RpZmljYXRpb24gc3RhdGUgY2hhbmdlZCAtIHVwZGF0ZVxuICAgIH07XG5cbiAgICBwcml2YXRlIG9uTW91c2VPdmVyID0gKGU6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBzaG93VG9vbHRpcDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25Nb3VzZUxlYXZlID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHNob3dUb29sdGlwOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHB1YmxpYyByZW5kZXIoKTogUmVhY3QuUmVhY3RFbGVtZW50IHtcbiAgICAgICAgLyogZXNsaW50IEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcImlnbm9yZVJlc3RTaWJsaW5nc1wiOiB0cnVlIH1dICovXG4gICAgICAgIGNvbnN0IHsgbm90aWZpY2F0aW9uLCBzaG93VW5zZW50VG9vbHRpcCwgZm9yY2VDb3VudCwgcm9vbUlkLCBvbkNsaWNrLCAuLi5wcm9wcyB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICAvLyBEb24ndCBzaG93IGEgYmFkZ2UgaWYgd2UgZG9uJ3QgbmVlZCB0b1xuICAgICAgICBpZiAobm90aWZpY2F0aW9uLmlzSWRsZSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgLy8gVE9ETzogVXBkYXRlIHRoZXNlIGJvb2xlYW5zIGZvciBGVFVFIE5vdGlmaWNhdGlvbnM6IGh0dHBzOi8vZ2l0aHViLmNvbS92ZWN0b3ItaW0vZWxlbWVudC13ZWIvaXNzdWVzLzE0MjYxXG4gICAgICAgIC8vIEFzIG9mIHdyaXRpbmcsIHRoYXQgaXMgXCJpZiByZWQsIHNob3cgY291bnQgYWx3YXlzXCIgYW5kIFwib3B0aW9uYWxseSBzaG93IGNvdW50cyBpbnN0ZWFkIG9mIGRvdHNcIi5cbiAgICAgICAgLy8gU2VlIGdpdCBkaWZmIGZvciB3aGF0IHRoYXQgYm9vbGVhbiBzdGF0ZSBsb29rcyBsaWtlLlxuICAgICAgICAvLyBYWFg6IFdlIGlnbm9yZSB0aGlzLnN0YXRlLnNob3dDb3VudHMgKHRoZSBzZXR0aW5nIHdoaWNoIGNvbnRyb2xzIGNvdW50cyB2cyBkb3RzKS5cbiAgICAgICAgY29uc3QgaGFzQW55U3ltYm9sID0gbm90aWZpY2F0aW9uLnN5bWJvbCB8fCBub3RpZmljYXRpb24uY291bnQgPiAwO1xuICAgICAgICBsZXQgaXNFbXB0eUJhZGdlID0gIWhhc0FueVN5bWJvbCB8fCAhbm90aWZpY2F0aW9uLmhhc1VucmVhZENvdW50O1xuICAgICAgICBpZiAoZm9yY2VDb3VudCkge1xuICAgICAgICAgICAgaXNFbXB0eUJhZGdlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIW5vdGlmaWNhdGlvbi5oYXNVbnJlYWRDb3VudCkgcmV0dXJuIG51bGw7IC8vIENhbid0IHJlbmRlciBhIGJhZGdlXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3ltYm9sID0gbm90aWZpY2F0aW9uLnN5bWJvbCB8fCBmb3JtYXRDb3VudChub3RpZmljYXRpb24uY291bnQpO1xuICAgICAgICBpZiAoaXNFbXB0eUJhZGdlKSBzeW1ib2wgPSBcIlwiO1xuXG4gICAgICAgIGNvbnN0IGNsYXNzZXMgPSBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgICdteF9Ob3RpZmljYXRpb25CYWRnZSc6IHRydWUsXG4gICAgICAgICAgICAnbXhfTm90aWZpY2F0aW9uQmFkZ2VfdmlzaWJsZSc6IGlzRW1wdHlCYWRnZSA/IHRydWUgOiBub3RpZmljYXRpb24uaGFzVW5yZWFkQ291bnQsXG4gICAgICAgICAgICAnbXhfTm90aWZpY2F0aW9uQmFkZ2VfaGlnaGxpZ2h0ZWQnOiBub3RpZmljYXRpb24uaGFzTWVudGlvbnMsXG4gICAgICAgICAgICAnbXhfTm90aWZpY2F0aW9uQmFkZ2VfZG90JzogaXNFbXB0eUJhZGdlLFxuICAgICAgICAgICAgJ214X05vdGlmaWNhdGlvbkJhZGdlXzJjaGFyJzogc3ltYm9sLmxlbmd0aCA+IDAgJiYgc3ltYm9sLmxlbmd0aCA8IDMsXG4gICAgICAgICAgICAnbXhfTm90aWZpY2F0aW9uQmFkZ2VfM2NoYXInOiBzeW1ib2wubGVuZ3RoID4gMixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgIGxldCBsYWJlbDogc3RyaW5nO1xuICAgICAgICAgICAgbGV0IHRvb2x0aXA6IEpTWC5FbGVtZW50O1xuICAgICAgICAgICAgaWYgKHNob3dVbnNlbnRUb29sdGlwICYmIHRoaXMuc3RhdGUuc2hvd1Rvb2x0aXAgJiYgbm90aWZpY2F0aW9uLmNvbG9yID09PSBOb3RpZmljYXRpb25Db2xvci5VbnNlbnQpIHtcbiAgICAgICAgICAgICAgICBsYWJlbCA9IF90KFwiTWVzc2FnZSBkaWRuJ3Qgc2VuZC4gQ2xpY2sgZm9yIGluZm8uXCIpO1xuICAgICAgICAgICAgICAgIHRvb2x0aXAgPSA8VG9vbHRpcCBjbGFzc05hbWU9XCJteF9Sb2xlQnV0dG9uX3Rvb2x0aXBcIiBsYWJlbD17bGFiZWx9IC8+O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxBY2Nlc3NpYmxlQnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9e2xhYmVsfVxuICAgICAgICAgICAgICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3Nlc31cbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17b25DbGlja31cbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZU92ZXI9e3RoaXMub25Nb3VzZU92ZXJ9XG4gICAgICAgICAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17dGhpcy5vbk1vdXNlTGVhdmV9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJteF9Ob3RpZmljYXRpb25CYWRnZV9jb3VudFwiPnsgc3ltYm9sIH08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIHsgdG9vbHRpcCB9XG4gICAgICAgICAgICAgICAgPC9BY2Nlc3NpYmxlQnV0dG9uPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3Nlc30+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwibXhfTm90aWZpY2F0aW9uQmFkZ2VfY291bnRcIj57IHN5bWJvbCB9PC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxufVxuIl19