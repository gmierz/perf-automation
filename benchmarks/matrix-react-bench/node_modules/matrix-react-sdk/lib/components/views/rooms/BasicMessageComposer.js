"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.REGEX_EMOTICON = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classnames = _interopRequireDefault(require("classnames"));

var _react = _interopRequireWildcard(require("react"));

var _emoticon = _interopRequireDefault(require("emojibase-regex/emoticon"));

var _history = _interopRequireDefault(require("../../../editor/history"));

var _caret = require("../../../editor/caret");

var _operations = require("../../../editor/operations");

var _dom = require("../../../editor/dom");

var _Autocomplete = _interopRequireWildcard(require("../rooms/Autocomplete"));

var _parts = require("../../../editor/parts");

var _deserialize = require("../../../editor/deserialize");

var _render = require("../../../editor/render");

var _TypingStore = _interopRequireDefault(require("../../../stores/TypingStore"));

var _SettingsStore = _interopRequireDefault(require("../../../settings/SettingsStore"));

var _Keyboard = require("../../../Keyboard");

var _emoji = require("../../../emoji");

var _SlashCommands = require("../../../SlashCommands");

var _range = _interopRequireDefault(require("../../../editor/range"));

var _MessageComposerFormatBar = _interopRequireWildcard(require("./MessageComposerFormatBar"));

var _KeyBindingsManager = require("../../../KeyBindingsManager");

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _logger = require("matrix-js-sdk/src/logger");

var _dec, _class;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// matches emoticons which follow the start of a line or whitespace
const REGEX_EMOTICON_WHITESPACE = new RegExp('(?:^|\\s)(' + _emoticon.default.source + ')\\s|:^$');
const REGEX_EMOTICON = new RegExp('(?:^|\\s)(' + _emoticon.default.source + ')$');
exports.REGEX_EMOTICON = REGEX_EMOTICON;
const IS_MAC = navigator.platform.indexOf("Mac") !== -1;
const SURROUND_WITH_CHARACTERS = ["\"", "_", "`", "'", "*", "~", "$"];
const SURROUND_WITH_DOUBLE_CHARACTERS = new Map([["(", ")"], ["[", "]"], ["{", "}"], ["<", ">"]]);

function ctrlShortcutLabel(key) {
  return (IS_MAC ? "âŒ˜" : "Ctrl") + "+" + key;
}

function cloneSelection(selection) {
  return {
    anchorNode: selection.anchorNode,
    anchorOffset: selection.anchorOffset,
    focusNode: selection.focusNode,
    focusOffset: selection.focusOffset,
    isCollapsed: selection.isCollapsed,
    rangeCount: selection.rangeCount,
    type: selection.type
  };
}

function selectionEquals(a, b) {
  return a.anchorNode === b.anchorNode && a.anchorOffset === b.anchorOffset && a.focusNode === b.focusNode && a.focusOffset === b.focusOffset && a.isCollapsed === b.isCollapsed && a.rangeCount === b.rangeCount && a.type === b.type;
}

let BasicMessageEditor = (_dec = (0, _replaceableComponent.replaceableComponent)("views.rooms.BasicMessageEditor"), _dec(_class = class BasicMessageEditor extends _react.default.Component {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "editorRef", /*#__PURE__*/(0, _react.createRef)());
    (0, _defineProperty2.default)(this, "autocompleteRef", /*#__PURE__*/(0, _react.createRef)());
    (0, _defineProperty2.default)(this, "formatBarRef", /*#__PURE__*/(0, _react.createRef)());
    (0, _defineProperty2.default)(this, "modifiedFlag", false);
    (0, _defineProperty2.default)(this, "isIMEComposing", false);
    (0, _defineProperty2.default)(this, "hasTextSelected", false);
    (0, _defineProperty2.default)(this, "_isCaretAtEnd", void 0);
    (0, _defineProperty2.default)(this, "lastCaret", void 0);
    (0, _defineProperty2.default)(this, "lastSelection", void 0);
    (0, _defineProperty2.default)(this, "emoticonSettingHandle", void 0);
    (0, _defineProperty2.default)(this, "shouldShowPillAvatarSettingHandle", void 0);
    (0, _defineProperty2.default)(this, "surroundWithHandle", void 0);
    (0, _defineProperty2.default)(this, "historyManager", new _history.default());
    (0, _defineProperty2.default)(this, "updateEditorState", (selection, inputType, diff) => {
      (0, _render.renderModel)(this.editorRef.current, this.props.model);

      if (selection) {
        // set the caret/selection
        try {
          (0, _caret.setSelection)(this.editorRef.current, this.props.model, selection);
        } catch (err) {
          _logger.logger.error(err);
        } // if caret selection is a range, take the end position


        const position = selection instanceof _range.default ? selection.end : selection;
        this.setLastCaretFromPosition(position);
      }

      const {
        isEmpty
      } = this.props.model;

      if (this.props.placeholder) {
        if (isEmpty) {
          this.showPlaceholder();
        } else {
          this.hidePlaceholder();
        }
      }

      if (isEmpty) {
        this.formatBarRef.current.hide();
      }

      this.setState({
        autoComplete: this.props.model.autoComplete,
        // if a change is happening then clear the showVisualBell
        showVisualBell: diff ? false : this.state.showVisualBell
      });
      this.historyManager.tryPush(this.props.model, selection, inputType, diff);
      let isTyping = !this.props.model.isEmpty; // If the user is entering a command, only consider them typing if it is one which sends a message into the room

      if (isTyping && this.props.model.parts[0].type === "command") {
        const {
          cmd
        } = (0, _SlashCommands.parseCommandString)(this.props.model.parts[0].text);

        const command = _SlashCommands.CommandMap.get(cmd);

        if (!command || !command.isEnabled() || command.category !== _SlashCommands.CommandCategories.messages) {
          isTyping = false;
        }
      }

      _TypingStore.default.sharedInstance().setSelfTyping(this.props.room.roomId, this.props.threadId, isTyping);

      if (this.props.onChange) {
        this.props.onChange();
      }
    });
    (0, _defineProperty2.default)(this, "onCompositionStart", () => {
      this.isIMEComposing = true; // even if the model is empty, the composition text shouldn't be mixed with the placeholder

      this.hidePlaceholder();
    });
    (0, _defineProperty2.default)(this, "onCompositionEnd", () => {
      this.isIMEComposing = false; // some browsers (Chrome) don't fire an input event after ending a composition,
      // so trigger a model update after the composition is done by calling the input handler.
      // however, modifying the DOM (caused by the editor model update) from the compositionend handler seems
      // to confuse the IME in Chrome, likely causing https://github.com/vector-im/element-web/issues/10913 ,
      // so we do it async
      // however, doing this async seems to break things in Safari for some reason, so browser sniff.

      const ua = navigator.userAgent.toLowerCase();
      const isSafari = ua.includes('safari/') && !ua.includes('chrome/');

      if (isSafari) {
        this.onInput({
          inputType: "insertCompositionText"
        });
      } else {
        Promise.resolve().then(() => {
          this.onInput({
            inputType: "insertCompositionText"
          });
        });
      }
    });
    (0, _defineProperty2.default)(this, "onCutCopy", (event, type) => {
      const selection = document.getSelection();
      const text = selection.toString();

      if (text) {
        const {
          model
        } = this.props;
        const range = (0, _dom.getRangeForSelection)(this.editorRef.current, model, selection);
        const selectedParts = range.parts.map(p => p.serialize());
        event.clipboardData.setData("application/x-element-composer", JSON.stringify(selectedParts));
        event.clipboardData.setData("text/plain", text); // so plain copy/paste works

        if (type === "cut") {
          // Remove the text, updating the model as appropriate
          this.modifiedFlag = true;
          (0, _operations.replaceRangeAndMoveCaret)(range, []);
        }

        event.preventDefault();
      }
    });
    (0, _defineProperty2.default)(this, "onCopy", event => {
      this.onCutCopy(event, "copy");
    });
    (0, _defineProperty2.default)(this, "onCut", event => {
      this.onCutCopy(event, "cut");
    });
    (0, _defineProperty2.default)(this, "onPaste", event => {
      event.preventDefault(); // we always handle the paste ourselves

      if (this.props.onPaste && this.props.onPaste(event, this.props.model)) {
        // to prevent double handling, allow props.onPaste to skip internal onPaste
        return true;
      }

      const {
        model
      } = this.props;
      const {
        partCreator
      } = model;
      const partsText = event.clipboardData.getData("application/x-element-composer");
      let parts;

      if (partsText) {
        const serializedTextParts = JSON.parse(partsText);
        const deserializedParts = serializedTextParts.map(p => partCreator.deserializePart(p));
        parts = deserializedParts;
      } else {
        const text = event.clipboardData.getData("text/plain");
        parts = (0, _deserialize.parsePlainTextMessage)(text, partCreator);
      }

      this.modifiedFlag = true;
      const range = (0, _dom.getRangeForSelection)(this.editorRef.current, model, document.getSelection());
      (0, _operations.replaceRangeAndMoveCaret)(range, parts);
    });
    (0, _defineProperty2.default)(this, "onInput", event => {
      // ignore any input while doing IME compositions
      if (this.isIMEComposing) {
        return;
      }

      this.modifiedFlag = true;
      const sel = document.getSelection();
      const {
        caret,
        text
      } = (0, _dom.getCaretOffsetAndText)(this.editorRef.current, sel);
      this.props.model.update(text, event.inputType, caret);
    });
    (0, _defineProperty2.default)(this, "onBlur", () => {
      document.removeEventListener("selectionchange", this.onSelectionChange);
    });
    (0, _defineProperty2.default)(this, "onFocus", () => {
      document.addEventListener("selectionchange", this.onSelectionChange); // force to recalculate

      this.lastSelection = null;
      this.refreshLastCaretIfNeeded();
    });
    (0, _defineProperty2.default)(this, "onSelectionChange", () => {
      const {
        isEmpty
      } = this.props.model;
      this.refreshLastCaretIfNeeded();
      const selection = document.getSelection();

      if (this.hasTextSelected && selection.isCollapsed) {
        this.hasTextSelected = false;

        if (this.formatBarRef.current) {
          this.formatBarRef.current.hide();
        }
      } else if (!selection.isCollapsed && !isEmpty) {
        this.hasTextSelected = true;

        if (this.formatBarRef.current) {
          const selectionRect = selection.getRangeAt(0).getBoundingClientRect();
          this.formatBarRef.current.showAt(selectionRect);
        }
      }
    });
    (0, _defineProperty2.default)(this, "onKeyDown", event => {
      var _model$autoComplete;

      const model = this.props.model;
      let handled = false;

      if (this.state.surroundWith && document.getSelection().type !== "Caret") {
        // This surrounds the selected text with a character. This is
        // intentionally left out of the keybinding manager as the keybinds
        // here shouldn't be changeable
        const selectionRange = (0, _dom.getRangeForSelection)(this.editorRef.current, this.props.model, document.getSelection()); // trim the range as we want it to exclude leading/trailing spaces

        selectionRange.trim();

        if ([...SURROUND_WITH_DOUBLE_CHARACTERS.keys(), ...SURROUND_WITH_CHARACTERS].includes(event.key)) {
          this.historyManager.ensureLastChangesPushed(this.props.model);
          this.modifiedFlag = true;
          (0, _operations.toggleInlineFormat)(selectionRange, event.key, SURROUND_WITH_DOUBLE_CHARACTERS.get(event.key));
          handled = true;
        }
      }

      const autocompleteAction = (0, _KeyBindingsManager.getKeyBindingsManager)().getAutocompleteAction(event);

      if ((_model$autoComplete = model.autoComplete) !== null && _model$autoComplete !== void 0 && _model$autoComplete.hasCompletions()) {
        const autoComplete = model.autoComplete;

        switch (autocompleteAction) {
          case _KeyBindingsManager.AutocompleteAction.ForceComplete:
          case _KeyBindingsManager.AutocompleteAction.Complete:
            this.historyManager.ensureLastChangesPushed(this.props.model);
            this.modifiedFlag = true;
            autoComplete.confirmCompletion();
            handled = true;
            break;

          case _KeyBindingsManager.AutocompleteAction.PrevSelection:
            autoComplete.selectPreviousSelection();
            handled = true;
            break;

          case _KeyBindingsManager.AutocompleteAction.NextSelection:
            autoComplete.selectNextSelection();
            handled = true;
            break;

          case _KeyBindingsManager.AutocompleteAction.Cancel:
            autoComplete.onEscape(event);
            handled = true;
            break;

          default:
            return;
          // don't preventDefault on anything else
        }
      } else if (autocompleteAction === _KeyBindingsManager.AutocompleteAction.ForceComplete && !this.state.showVisualBell) {
        // there is no current autocomplete window, try to open it
        this.tabCompleteName();
        handled = true;
      } else if (event.key === _Keyboard.Key.BACKSPACE || event.key === _Keyboard.Key.DELETE) {
        this.formatBarRef.current.hide();
      }

      if (handled) {
        event.preventDefault();
        event.stopPropagation();
        return;
      }

      const action = (0, _KeyBindingsManager.getKeyBindingsManager)().getMessageComposerAction(event);

      switch (action) {
        case _KeyBindingsManager.MessageComposerAction.FormatBold:
          this.onFormatAction(_MessageComposerFormatBar.Formatting.Bold);
          handled = true;
          break;

        case _KeyBindingsManager.MessageComposerAction.FormatItalics:
          this.onFormatAction(_MessageComposerFormatBar.Formatting.Italics);
          handled = true;
          break;

        case _KeyBindingsManager.MessageComposerAction.FormatQuote:
          this.onFormatAction(_MessageComposerFormatBar.Formatting.Quote);
          handled = true;
          break;

        case _KeyBindingsManager.MessageComposerAction.EditRedo:
          if (this.historyManager.canRedo()) {
            const {
              parts,
              caret
            } = this.historyManager.redo(); // pass matching inputType so historyManager doesn't push echo
            // when invoked from rerender callback.

            model.reset(parts, caret, "historyRedo");
          }

          handled = true;
          break;

        case _KeyBindingsManager.MessageComposerAction.EditUndo:
          if (this.historyManager.canUndo()) {
            const {
              parts,
              caret
            } = this.historyManager.undo(this.props.model); // pass matching inputType so historyManager doesn't push echo
            // when invoked from rerender callback.

            model.reset(parts, caret, "historyUndo");
          }

          handled = true;
          break;

        case _KeyBindingsManager.MessageComposerAction.NewLine:
          this.insertText("\n");
          handled = true;
          break;

        case _KeyBindingsManager.MessageComposerAction.MoveCursorToStart:
          (0, _caret.setSelection)(this.editorRef.current, model, {
            index: 0,
            offset: 0
          });
          handled = true;
          break;

        case _KeyBindingsManager.MessageComposerAction.MoveCursorToEnd:
          (0, _caret.setSelection)(this.editorRef.current, model, {
            index: model.parts.length - 1,
            offset: model.parts[model.parts.length - 1].text.length
          });
          handled = true;
          break;
      }

      if (handled) {
        event.preventDefault();
        event.stopPropagation();
      }
    });
    (0, _defineProperty2.default)(this, "onAutoCompleteConfirm", completion => {
      this.modifiedFlag = true;
      this.props.model.autoComplete.onComponentConfirm(completion);
    });
    (0, _defineProperty2.default)(this, "onAutoCompleteSelectionChange", completionIndex => {
      this.modifiedFlag = true;
      this.setState({
        completionIndex
      });
    });
    (0, _defineProperty2.default)(this, "configureEmoticonAutoReplace", () => {
      this.props.model.setTransformCallback(this.transform);
    });
    (0, _defineProperty2.default)(this, "configureShouldShowPillAvatar", () => {
      const showPillAvatar = _SettingsStore.default.getValue("Pill.shouldShowPillAvatar");

      this.setState({
        showPillAvatar
      });
    });
    (0, _defineProperty2.default)(this, "surroundWithSettingChanged", () => {
      const surroundWith = _SettingsStore.default.getValue("MessageComposerInput.surroundWith");

      this.setState({
        surroundWith
      });
    });
    (0, _defineProperty2.default)(this, "transform", documentPosition => {
      const shouldReplace = _SettingsStore.default.getValue('MessageComposerInput.autoReplaceEmoji');

      if (shouldReplace) this.replaceEmoticon(documentPosition, REGEX_EMOTICON_WHITESPACE);
    });
    (0, _defineProperty2.default)(this, "onFormatAction", action => {
      const range = (0, _dom.getRangeForSelection)(this.editorRef.current, this.props.model, document.getSelection()); // trim the range as we want it to exclude leading/trailing spaces

      range.trim();

      if (range.length === 0) {
        return;
      }

      this.historyManager.ensureLastChangesPushed(this.props.model);
      this.modifiedFlag = true;

      switch (action) {
        case _MessageComposerFormatBar.Formatting.Bold:
          (0, _operations.toggleInlineFormat)(range, "**");
          break;

        case _MessageComposerFormatBar.Formatting.Italics:
          (0, _operations.toggleInlineFormat)(range, "_");
          break;

        case _MessageComposerFormatBar.Formatting.Strikethrough:
          (0, _operations.toggleInlineFormat)(range, "<del>", "</del>");
          break;

        case _MessageComposerFormatBar.Formatting.Code:
          (0, _operations.formatRangeAsCode)(range);
          break;

        case _MessageComposerFormatBar.Formatting.Quote:
          (0, _operations.formatRangeAsQuote)(range);
          break;

        case _MessageComposerFormatBar.Formatting.InsertLink:
          (0, _operations.formatRangeAsLink)(range);
          break;
      }
    });
    this.state = {
      showPillAvatar: _SettingsStore.default.getValue("Pill.shouldShowPillAvatar"),
      surroundWith: _SettingsStore.default.getValue("MessageComposerInput.surroundWith"),
      showVisualBell: false
    };
    this.emoticonSettingHandle = _SettingsStore.default.watchSetting('MessageComposerInput.autoReplaceEmoji', null, this.configureEmoticonAutoReplace);
    this.configureEmoticonAutoReplace();
    this.shouldShowPillAvatarSettingHandle = _SettingsStore.default.watchSetting("Pill.shouldShowPillAvatar", null, this.configureShouldShowPillAvatar);
    this.surroundWithHandle = _SettingsStore.default.watchSetting("MessageComposerInput.surroundWith", null, this.surroundWithSettingChanged);
  }

  componentDidUpdate(prevProps) {
    // We need to re-check the placeholder when the enabled state changes because it causes the
    // placeholder element to remount, which gets rid of the `::before` class. Re-evaluating the
    // placeholder means we get a proper `::before` with the placeholder.
    const enabledChange = this.props.disabled !== prevProps.disabled;
    const placeholderChanged = this.props.placeholder !== prevProps.placeholder;

    if (this.props.placeholder && (placeholderChanged || enabledChange)) {
      const {
        isEmpty
      } = this.props.model;

      if (isEmpty) {
        this.showPlaceholder();
      } else {
        this.hidePlaceholder();
      }
    }
  }

  replaceEmoticon(caretPosition, regex) {
    const {
      model
    } = this.props;
    const range = model.startRange(caretPosition); // expand range max 8 characters backwards from caretPosition,
    // as a space to look for an emoticon

    let n = 8;
    range.expandBackwardsWhile((index, offset) => {
      const part = model.parts[index];
      n -= 1;
      return n >= 0 && [_parts.Type.Plain, _parts.Type.PillCandidate, _parts.Type.Newline].includes(part.type);
    });
    const emoticonMatch = regex.exec(range.text);

    if (emoticonMatch) {
      const query = emoticonMatch[1].replace("-", ""); // try both exact match and lower-case, this means that xd won't match xD but :P will match :p

      const data = _emoji.EMOTICON_TO_EMOJI.get(query) || _emoji.EMOTICON_TO_EMOJI.get(query.toLowerCase());

      if (data) {
        const {
          partCreator
        } = model;
        const firstMatch = emoticonMatch[0];
        const moveStart = firstMatch[0] === " " ? 1 : 0; // we need the range to only comprise of the emoticon
        // because we'll replace the whole range with an emoji,
        // so move the start forward to the start of the emoticon.
        // Take + 1 because index is reported without the possible preceding space.

        range.moveStartForwards(emoticonMatch.index + moveStart); // If the end is a trailing space/newline move end backwards, so that we don't replace it

        if (["\n", " "].includes(firstMatch[firstMatch.length - 1])) {
          range.moveEndBackwards(1);
        } // this returns the amount of added/removed characters during the replace
        // so the caret position can be adjusted.


        return range.replace([partCreator.plain(data.unicode)]);
      }
    }
  }

  showPlaceholder() {
    // escape single quotes
    const placeholder = this.props.placeholder.replace(/'/g, '\\\'');
    this.editorRef.current.style.setProperty("--placeholder", `'${placeholder}'`);
    this.editorRef.current.classList.add("mx_BasicMessageComposer_inputEmpty");
  }

  hidePlaceholder() {
    this.editorRef.current.classList.remove("mx_BasicMessageComposer_inputEmpty");
    this.editorRef.current.style.removeProperty("--placeholder");
  }

  isComposing(event) {
    // checking the event.isComposing flag just in case any browser out there
    // emits events related to the composition after compositionend
    // has been fired
    return !!(this.isIMEComposing || event.nativeEvent && event.nativeEvent.isComposing);
  }

  insertText(textToInsert, inputType = "insertText") {
    const sel = document.getSelection();
    const {
      caret,
      text
    } = (0, _dom.getCaretOffsetAndText)(this.editorRef.current, sel);
    const newText = text.substr(0, caret.offset) + textToInsert + text.substr(caret.offset);
    caret.offset += textToInsert.length;
    this.modifiedFlag = true;
    this.props.model.update(newText, inputType, caret);
  } // this is used later to see if we need to recalculate the caret
  // on selectionchange. If it is just a consequence of typing
  // we don't need to. But if the user is navigating the caret without input
  // we need to recalculate it, to be able to know where to insert content after
  // losing focus


  setLastCaretFromPosition(position) {
    const {
      model
    } = this.props;
    this._isCaretAtEnd = position.isAtEnd(model);
    this.lastCaret = position.asOffset(model);
    this.lastSelection = cloneSelection(document.getSelection());
  }

  refreshLastCaretIfNeeded() {
    // XXX: needed when going up and down in editing messages ... not sure why yet
    // because the editors should stop doing this when when blurred ...
    // maybe it's on focus and the _editorRef isn't available yet or something.
    if (!this.editorRef.current) {
      return;
    }

    const selection = document.getSelection();

    if (!this.lastSelection || !selectionEquals(this.lastSelection, selection)) {
      this.lastSelection = cloneSelection(selection);
      const {
        caret,
        text
      } = (0, _dom.getCaretOffsetAndText)(this.editorRef.current, selection);
      this.lastCaret = caret;
      this._isCaretAtEnd = caret.offset === text.length;
    }

    return this.lastCaret;
  }

  clearUndoHistory() {
    this.historyManager.clear();
  }

  getCaret() {
    return this.lastCaret;
  }

  isSelectionCollapsed() {
    return !this.lastSelection || this.lastSelection.isCollapsed;
  }

  isCaretAtStart() {
    return this.getCaret().offset === 0;
  }

  isCaretAtEnd() {
    return this._isCaretAtEnd;
  }

  async tabCompleteName() {
    try {
      await new Promise(resolve => this.setState({
        showVisualBell: false
      }, resolve));
      const {
        model
      } = this.props;
      const caret = this.getCaret();
      const position = model.positionForOffset(caret.offset, caret.atNodeEnd);
      const range = model.startRange(position);
      range.expandBackwardsWhile((index, offset, part) => {
        return part.text[offset] !== " " && part.text[offset] !== "+" && (part.type === _parts.Type.Plain || part.type === _parts.Type.PillCandidate || part.type === _parts.Type.Command);
      });
      const {
        partCreator
      } = model; // await for auto-complete to be open

      await model.transform(() => {
        const addedLen = range.replace([partCreator.pillCandidate(range.text)]);
        return model.positionForOffset(caret.offset + addedLen, true);
      }); // Don't try to do things with the autocomplete if there is none shown

      if (model.autoComplete) {
        await model.autoComplete.startSelection();

        if (!model.autoComplete.hasSelection()) {
          this.setState({
            showVisualBell: true
          });
          model.autoComplete.close();
        }
      } else {
        this.setState({
          showVisualBell: true
        });
      }
    } catch (err) {
      _logger.logger.error(err);
    }
  }

  isModified() {
    return this.modifiedFlag;
  }

  componentWillUnmount() {
    document.removeEventListener("selectionchange", this.onSelectionChange);
    this.editorRef.current.removeEventListener("input", this.onInput, true);
    this.editorRef.current.removeEventListener("compositionstart", this.onCompositionStart, true);
    this.editorRef.current.removeEventListener("compositionend", this.onCompositionEnd, true);

    _SettingsStore.default.unwatchSetting(this.emoticonSettingHandle);

    _SettingsStore.default.unwatchSetting(this.shouldShowPillAvatarSettingHandle);

    _SettingsStore.default.unwatchSetting(this.surroundWithHandle);
  }

  componentDidMount() {
    const model = this.props.model;
    model.setUpdateCallback(this.updateEditorState);
    const partCreator = model.partCreator; // TODO: does this allow us to get rid of EditorStateTransfer?
    // not really, but we could not serialize the parts, and just change the autoCompleter

    partCreator.setAutoCompleteCreator((0, _parts.getAutoCompleteCreator)(() => this.autocompleteRef.current, query => new Promise(resolve => this.setState({
      query
    }, resolve)))); // initial render of model

    this.updateEditorState(this.getInitialCaretPosition()); // attach input listener by hand so React doesn't proxy the events,
    // as the proxied event doesn't support inputType, which we need.

    this.editorRef.current.addEventListener("input", this.onInput, true);
    this.editorRef.current.addEventListener("compositionstart", this.onCompositionStart, true);
    this.editorRef.current.addEventListener("compositionend", this.onCompositionEnd, true);
    this.editorRef.current.focus();
  }

  getInitialCaretPosition() {
    let caretPosition;

    if (this.props.initialCaret) {
      // if restoring state from a previous editor,
      // restore caret position from the state
      const caret = this.props.initialCaret;
      caretPosition = this.props.model.positionForOffset(caret.offset, caret.atNodeEnd);
    } else {
      // otherwise, set it at the end
      caretPosition = this.props.model.getPositionAtEnd();
    }

    return caretPosition;
  }

  render() {
    let autoComplete;

    if (this.state.autoComplete) {
      const query = this.state.query;
      const queryLen = query.length;
      autoComplete = /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_BasicMessageComposer_AutoCompleteWrapper"
      }, /*#__PURE__*/_react.default.createElement(_Autocomplete.default, {
        ref: this.autocompleteRef,
        query: query,
        onConfirm: this.onAutoCompleteConfirm,
        onSelectionChange: this.onAutoCompleteSelectionChange,
        selection: {
          beginning: true,
          end: queryLen,
          start: queryLen
        },
        room: this.props.room
      }));
    }

    const wrapperClasses = (0, _classnames.default)("mx_BasicMessageComposer", {
      "mx_BasicMessageComposer_input_error": this.state.showVisualBell
    });
    const classes = (0, _classnames.default)("mx_BasicMessageComposer_input", {
      "mx_BasicMessageComposer_input_shouldShowPillAvatar": this.state.showPillAvatar,
      "mx_BasicMessageComposer_input_disabled": this.props.disabled
    });
    const shortcuts = {
      [_MessageComposerFormatBar.Formatting.Bold]: ctrlShortcutLabel("B"),
      [_MessageComposerFormatBar.Formatting.Italics]: ctrlShortcutLabel("I"),
      [_MessageComposerFormatBar.Formatting.Quote]: ctrlShortcutLabel(">")
    };
    const {
      completionIndex
    } = this.state;
    const hasAutocomplete = Boolean(this.state.autoComplete);
    let activeDescendant;

    if (hasAutocomplete && completionIndex >= 0) {
      activeDescendant = (0, _Autocomplete.generateCompletionDomId)(completionIndex);
    }

    return /*#__PURE__*/_react.default.createElement("div", {
      className: wrapperClasses
    }, autoComplete, /*#__PURE__*/_react.default.createElement(_MessageComposerFormatBar.default, {
      ref: this.formatBarRef,
      onAction: this.onFormatAction,
      shortcuts: shortcuts
    }), /*#__PURE__*/_react.default.createElement("div", {
      className: classes,
      contentEditable: this.props.disabled ? null : true,
      tabIndex: 0,
      onBlur: this.onBlur,
      onFocus: this.onFocus,
      onCopy: this.onCopy,
      onCut: this.onCut,
      onPaste: this.onPaste,
      onKeyDown: this.onKeyDown,
      ref: this.editorRef,
      "aria-label": this.props.label,
      role: "textbox",
      "aria-multiline": "true",
      "aria-autocomplete": "list",
      "aria-haspopup": "listbox",
      "aria-expanded": hasAutocomplete,
      "aria-owns": "mx_Autocomplete",
      "aria-activedescendant": activeDescendant,
      dir: "auto",
      "aria-disabled": this.props.disabled
    }));
  }

  focus() {
    this.editorRef.current.focus();
  }

  insertMention(userId) {
    this.modifiedFlag = true;
    const {
      model
    } = this.props;
    const {
      partCreator
    } = model;
    const member = this.props.room.getMember(userId);
    const displayName = member ? member.rawDisplayName : userId;
    const caret = this.getCaret();
    const position = model.positionForOffset(caret.offset, caret.atNodeEnd); // Insert suffix only if the caret is at the start of the composer

    const parts = partCreator.createMentionParts(caret.offset === 0, displayName, userId);
    model.transform(() => {
      const addedLen = model.insert(parts, position);
      return model.positionForOffset(caret.offset + addedLen, true);
    }); // refocus on composer, as we just clicked "Mention"

    this.focus();
  }

  insertQuotedMessage(event) {
    this.modifiedFlag = true;
    const {
      model
    } = this.props;
    const {
      partCreator
    } = model;
    const quoteParts = (0, _deserialize.parseEvent)(event, partCreator, {
      isQuotedMessage: true
    }); // add two newlines

    quoteParts.push(partCreator.newline());
    quoteParts.push(partCreator.newline());
    model.transform(() => {
      const addedLen = model.insert(quoteParts, model.positionForOffset(0));
      return model.positionForOffset(addedLen, true);
    }); // refocus on composer, as we just clicked "Quote"

    this.focus();
  }

  insertPlaintext(text) {
    this.modifiedFlag = true;
    const {
      model
    } = this.props;
    const {
      partCreator
    } = model;
    const caret = this.getCaret();
    const position = model.positionForOffset(caret.offset, caret.atNodeEnd);
    model.transform(() => {
      const addedLen = model.insert([partCreator.plain(text)], position);
      return model.positionForOffset(caret.offset + addedLen, true);
    });
  }

}) || _class);
exports.default = BasicMessageEditor;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL3Jvb21zL0Jhc2ljTWVzc2FnZUNvbXBvc2VyLnRzeCJdLCJuYW1lcyI6WyJSRUdFWF9FTU9USUNPTl9XSElURVNQQUNFIiwiUmVnRXhwIiwiRU1PVElDT05fUkVHRVgiLCJzb3VyY2UiLCJSRUdFWF9FTU9USUNPTiIsIklTX01BQyIsIm5hdmlnYXRvciIsInBsYXRmb3JtIiwiaW5kZXhPZiIsIlNVUlJPVU5EX1dJVEhfQ0hBUkFDVEVSUyIsIlNVUlJPVU5EX1dJVEhfRE9VQkxFX0NIQVJBQ1RFUlMiLCJNYXAiLCJjdHJsU2hvcnRjdXRMYWJlbCIsImtleSIsImNsb25lU2VsZWN0aW9uIiwic2VsZWN0aW9uIiwiYW5jaG9yTm9kZSIsImFuY2hvck9mZnNldCIsImZvY3VzTm9kZSIsImZvY3VzT2Zmc2V0IiwiaXNDb2xsYXBzZWQiLCJyYW5nZUNvdW50IiwidHlwZSIsInNlbGVjdGlvbkVxdWFscyIsImEiLCJiIiwiQmFzaWNNZXNzYWdlRWRpdG9yIiwiUmVhY3QiLCJDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsInByb3BzIiwiSGlzdG9yeU1hbmFnZXIiLCJpbnB1dFR5cGUiLCJkaWZmIiwiZWRpdG9yUmVmIiwiY3VycmVudCIsIm1vZGVsIiwiZXJyIiwibG9nZ2VyIiwiZXJyb3IiLCJwb3NpdGlvbiIsIlJhbmdlIiwiZW5kIiwic2V0TGFzdENhcmV0RnJvbVBvc2l0aW9uIiwiaXNFbXB0eSIsInBsYWNlaG9sZGVyIiwic2hvd1BsYWNlaG9sZGVyIiwiaGlkZVBsYWNlaG9sZGVyIiwiZm9ybWF0QmFyUmVmIiwiaGlkZSIsInNldFN0YXRlIiwiYXV0b0NvbXBsZXRlIiwic2hvd1Zpc3VhbEJlbGwiLCJzdGF0ZSIsImhpc3RvcnlNYW5hZ2VyIiwidHJ5UHVzaCIsImlzVHlwaW5nIiwicGFydHMiLCJjbWQiLCJ0ZXh0IiwiY29tbWFuZCIsIkNvbW1hbmRNYXAiLCJnZXQiLCJpc0VuYWJsZWQiLCJjYXRlZ29yeSIsIkNvbW1hbmRDYXRlZ29yaWVzIiwibWVzc2FnZXMiLCJUeXBpbmdTdG9yZSIsInNoYXJlZEluc3RhbmNlIiwic2V0U2VsZlR5cGluZyIsInJvb20iLCJyb29tSWQiLCJ0aHJlYWRJZCIsIm9uQ2hhbmdlIiwiaXNJTUVDb21wb3NpbmciLCJ1YSIsInVzZXJBZ2VudCIsInRvTG93ZXJDYXNlIiwiaXNTYWZhcmkiLCJpbmNsdWRlcyIsIm9uSW5wdXQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJldmVudCIsImRvY3VtZW50IiwiZ2V0U2VsZWN0aW9uIiwidG9TdHJpbmciLCJyYW5nZSIsInNlbGVjdGVkUGFydHMiLCJtYXAiLCJwIiwic2VyaWFsaXplIiwiY2xpcGJvYXJkRGF0YSIsInNldERhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwibW9kaWZpZWRGbGFnIiwicHJldmVudERlZmF1bHQiLCJvbkN1dENvcHkiLCJvblBhc3RlIiwicGFydENyZWF0b3IiLCJwYXJ0c1RleHQiLCJnZXREYXRhIiwic2VyaWFsaXplZFRleHRQYXJ0cyIsInBhcnNlIiwiZGVzZXJpYWxpemVkUGFydHMiLCJkZXNlcmlhbGl6ZVBhcnQiLCJzZWwiLCJjYXJldCIsInVwZGF0ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJvblNlbGVjdGlvbkNoYW5nZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJsYXN0U2VsZWN0aW9uIiwicmVmcmVzaExhc3RDYXJldElmTmVlZGVkIiwiaGFzVGV4dFNlbGVjdGVkIiwic2VsZWN0aW9uUmVjdCIsImdldFJhbmdlQXQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJzaG93QXQiLCJoYW5kbGVkIiwic3Vycm91bmRXaXRoIiwic2VsZWN0aW9uUmFuZ2UiLCJ0cmltIiwia2V5cyIsImVuc3VyZUxhc3RDaGFuZ2VzUHVzaGVkIiwiYXV0b2NvbXBsZXRlQWN0aW9uIiwiZ2V0QXV0b2NvbXBsZXRlQWN0aW9uIiwiaGFzQ29tcGxldGlvbnMiLCJBdXRvY29tcGxldGVBY3Rpb24iLCJGb3JjZUNvbXBsZXRlIiwiQ29tcGxldGUiLCJjb25maXJtQ29tcGxldGlvbiIsIlByZXZTZWxlY3Rpb24iLCJzZWxlY3RQcmV2aW91c1NlbGVjdGlvbiIsIk5leHRTZWxlY3Rpb24iLCJzZWxlY3ROZXh0U2VsZWN0aW9uIiwiQ2FuY2VsIiwib25Fc2NhcGUiLCJ0YWJDb21wbGV0ZU5hbWUiLCJLZXkiLCJCQUNLU1BBQ0UiLCJERUxFVEUiLCJzdG9wUHJvcGFnYXRpb24iLCJhY3Rpb24iLCJnZXRNZXNzYWdlQ29tcG9zZXJBY3Rpb24iLCJNZXNzYWdlQ29tcG9zZXJBY3Rpb24iLCJGb3JtYXRCb2xkIiwib25Gb3JtYXRBY3Rpb24iLCJGb3JtYXR0aW5nIiwiQm9sZCIsIkZvcm1hdEl0YWxpY3MiLCJJdGFsaWNzIiwiRm9ybWF0UXVvdGUiLCJRdW90ZSIsIkVkaXRSZWRvIiwiY2FuUmVkbyIsInJlZG8iLCJyZXNldCIsIkVkaXRVbmRvIiwiY2FuVW5kbyIsInVuZG8iLCJOZXdMaW5lIiwiaW5zZXJ0VGV4dCIsIk1vdmVDdXJzb3JUb1N0YXJ0IiwiaW5kZXgiLCJvZmZzZXQiLCJNb3ZlQ3Vyc29yVG9FbmQiLCJsZW5ndGgiLCJjb21wbGV0aW9uIiwib25Db21wb25lbnRDb25maXJtIiwiY29tcGxldGlvbkluZGV4Iiwic2V0VHJhbnNmb3JtQ2FsbGJhY2siLCJ0cmFuc2Zvcm0iLCJzaG93UGlsbEF2YXRhciIsIlNldHRpbmdzU3RvcmUiLCJnZXRWYWx1ZSIsImRvY3VtZW50UG9zaXRpb24iLCJzaG91bGRSZXBsYWNlIiwicmVwbGFjZUVtb3RpY29uIiwiU3RyaWtldGhyb3VnaCIsIkNvZGUiLCJJbnNlcnRMaW5rIiwiZW1vdGljb25TZXR0aW5nSGFuZGxlIiwid2F0Y2hTZXR0aW5nIiwiY29uZmlndXJlRW1vdGljb25BdXRvUmVwbGFjZSIsInNob3VsZFNob3dQaWxsQXZhdGFyU2V0dGluZ0hhbmRsZSIsImNvbmZpZ3VyZVNob3VsZFNob3dQaWxsQXZhdGFyIiwic3Vycm91bmRXaXRoSGFuZGxlIiwic3Vycm91bmRXaXRoU2V0dGluZ0NoYW5nZWQiLCJjb21wb25lbnREaWRVcGRhdGUiLCJwcmV2UHJvcHMiLCJlbmFibGVkQ2hhbmdlIiwiZGlzYWJsZWQiLCJwbGFjZWhvbGRlckNoYW5nZWQiLCJjYXJldFBvc2l0aW9uIiwicmVnZXgiLCJzdGFydFJhbmdlIiwibiIsImV4cGFuZEJhY2t3YXJkc1doaWxlIiwicGFydCIsIlR5cGUiLCJQbGFpbiIsIlBpbGxDYW5kaWRhdGUiLCJOZXdsaW5lIiwiZW1vdGljb25NYXRjaCIsImV4ZWMiLCJxdWVyeSIsInJlcGxhY2UiLCJkYXRhIiwiRU1PVElDT05fVE9fRU1PSkkiLCJmaXJzdE1hdGNoIiwibW92ZVN0YXJ0IiwibW92ZVN0YXJ0Rm9yd2FyZHMiLCJtb3ZlRW5kQmFja3dhcmRzIiwicGxhaW4iLCJ1bmljb2RlIiwic3R5bGUiLCJzZXRQcm9wZXJ0eSIsImNsYXNzTGlzdCIsImFkZCIsInJlbW92ZSIsInJlbW92ZVByb3BlcnR5IiwiaXNDb21wb3NpbmciLCJuYXRpdmVFdmVudCIsInRleHRUb0luc2VydCIsIm5ld1RleHQiLCJzdWJzdHIiLCJfaXNDYXJldEF0RW5kIiwiaXNBdEVuZCIsImxhc3RDYXJldCIsImFzT2Zmc2V0IiwiY2xlYXJVbmRvSGlzdG9yeSIsImNsZWFyIiwiZ2V0Q2FyZXQiLCJpc1NlbGVjdGlvbkNvbGxhcHNlZCIsImlzQ2FyZXRBdFN0YXJ0IiwiaXNDYXJldEF0RW5kIiwicG9zaXRpb25Gb3JPZmZzZXQiLCJhdE5vZGVFbmQiLCJDb21tYW5kIiwiYWRkZWRMZW4iLCJwaWxsQ2FuZGlkYXRlIiwic3RhcnRTZWxlY3Rpb24iLCJoYXNTZWxlY3Rpb24iLCJjbG9zZSIsImlzTW9kaWZpZWQiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsIm9uQ29tcG9zaXRpb25TdGFydCIsIm9uQ29tcG9zaXRpb25FbmQiLCJ1bndhdGNoU2V0dGluZyIsImNvbXBvbmVudERpZE1vdW50Iiwic2V0VXBkYXRlQ2FsbGJhY2siLCJ1cGRhdGVFZGl0b3JTdGF0ZSIsInNldEF1dG9Db21wbGV0ZUNyZWF0b3IiLCJhdXRvY29tcGxldGVSZWYiLCJnZXRJbml0aWFsQ2FyZXRQb3NpdGlvbiIsImZvY3VzIiwiaW5pdGlhbENhcmV0IiwiZ2V0UG9zaXRpb25BdEVuZCIsInJlbmRlciIsInF1ZXJ5TGVuIiwib25BdXRvQ29tcGxldGVDb25maXJtIiwib25BdXRvQ29tcGxldGVTZWxlY3Rpb25DaGFuZ2UiLCJiZWdpbm5pbmciLCJzdGFydCIsIndyYXBwZXJDbGFzc2VzIiwiY2xhc3NlcyIsInNob3J0Y3V0cyIsImhhc0F1dG9jb21wbGV0ZSIsIkJvb2xlYW4iLCJhY3RpdmVEZXNjZW5kYW50Iiwib25CbHVyIiwib25Gb2N1cyIsIm9uQ29weSIsIm9uQ3V0Iiwib25LZXlEb3duIiwibGFiZWwiLCJpbnNlcnRNZW50aW9uIiwidXNlcklkIiwibWVtYmVyIiwiZ2V0TWVtYmVyIiwiZGlzcGxheU5hbWUiLCJyYXdEaXNwbGF5TmFtZSIsImNyZWF0ZU1lbnRpb25QYXJ0cyIsImluc2VydCIsImluc2VydFF1b3RlZE1lc3NhZ2UiLCJxdW90ZVBhcnRzIiwiaXNRdW90ZWRNZXNzYWdlIiwicHVzaCIsIm5ld2xpbmUiLCJpbnNlcnRQbGFpbnRleHQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBZ0JBOztBQUNBOztBQUdBOztBQUdBOztBQUNBOztBQUNBOztBQU9BOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQU1BOztBQUNBOztBQUVBOzs7Ozs7OztBQUVBO0FBQ0EsTUFBTUEseUJBQXlCLEdBQUcsSUFBSUMsTUFBSixDQUFXLGVBQWVDLGtCQUFlQyxNQUE5QixHQUF1QyxVQUFsRCxDQUFsQztBQUNPLE1BQU1DLGNBQWMsR0FBRyxJQUFJSCxNQUFKLENBQVcsZUFBZUMsa0JBQWVDLE1BQTlCLEdBQXVDLElBQWxELENBQXZCOztBQUVQLE1BQU1FLE1BQU0sR0FBR0MsU0FBUyxDQUFDQyxRQUFWLENBQW1CQyxP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LENBQXdCRyxRQUF4QixFQUFrQyxJQUFsQyxDQUFQO0FBQ0gsS0FIRCxFQVJpRCxDQVlqRDs7QUFDQSxTQUFLZ0IsS0FBTDtBQUNIOztBQUVNa0MsRUFBQUEsZUFBZSxDQUFDek8sSUFBRCxFQUFxQjtBQUN2QyxTQUFLc0MsWUFBTCxHQUFvQixJQUFwQjtBQUNBLFVBQU07QUFBRTdELE1BQUFBO0FBQUYsUUFBWSxLQUFLTixLQUF2QjtBQUNBLFVBQU07QUFBRXVFLE1BQUFBO0FBQUYsUUFBa0JqRSxLQUF4QjtBQUNBLFVBQU15RSxLQUFLLEdBQUcsS0FBSzhILFFBQUwsRUFBZDtBQUNBLFVBQU1uTSxRQUFRLEdBQUdKLEtBQUssQ0FBQzJNLGlCQUFOLENBQXdCbEksS0FBSyxDQUFDMEQsTUFBOUIsRUFBc0MxRCxLQUFLLENBQUNtSSxTQUE1QyxDQUFqQjtBQUNBNU0sSUFBQUEsS0FBSyxDQUFDMEksU0FBTixDQUFnQixNQUFNO0FBQ2xCLFlBQU1vRSxRQUFRLEdBQUc5TSxLQUFLLENBQUMwUCxNQUFOLENBQWEsQ0FBQ3pMLFdBQVcsQ0FBQ21ILEtBQVosQ0FBa0I3SixJQUFsQixDQUFELENBQWIsRUFBd0NuQixRQUF4QyxDQUFqQjtBQUNBLGFBQU9KLEtBQUssQ0FBQzJNLGlCQUFOLENBQXdCbEksS0FBSyxDQUFDMEQsTUFBTixHQUFlMkUsUUFBdkMsRUFBaUQsSUFBakQsQ0FBUDtBQUNILEtBSEQ7QUFJSDs7QUEvc0IyRSxDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE5IC0gMjAyMSBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZVJlZiwgQ2xpcGJvYXJkRXZlbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBSb29tIH0gZnJvbSAnbWF0cml4LWpzLXNkay9zcmMvbW9kZWxzL3Jvb20nO1xuaW1wb3J0IHsgTWF0cml4RXZlbnQgfSBmcm9tICdtYXRyaXgtanMtc2RrL3NyYy9tb2RlbHMvZXZlbnQnO1xuaW1wb3J0IEVNT1RJQ09OX1JFR0VYIGZyb20gJ2Vtb2ppYmFzZS1yZWdleC9lbW90aWNvbic7XG5cbmltcG9ydCBFZGl0b3JNb2RlbCBmcm9tICcuLi8uLi8uLi9lZGl0b3IvbW9kZWwnO1xuaW1wb3J0IEhpc3RvcnlNYW5hZ2VyIGZyb20gJy4uLy4uLy4uL2VkaXRvci9oaXN0b3J5JztcbmltcG9ydCB7IENhcmV0LCBzZXRTZWxlY3Rpb24gfSBmcm9tICcuLi8uLi8uLi9lZGl0b3IvY2FyZXQnO1xuaW1wb3J0IHtcbiAgICBmb3JtYXRSYW5nZUFzUXVvdGUsXG4gICAgZm9ybWF0UmFuZ2VBc0NvZGUsXG4gICAgdG9nZ2xlSW5saW5lRm9ybWF0LFxuICAgIHJlcGxhY2VSYW5nZUFuZE1vdmVDYXJldCxcbiAgICBmb3JtYXRSYW5nZUFzTGluayxcbn0gZnJvbSAnLi4vLi4vLi4vZWRpdG9yL29wZXJhdGlvbnMnO1xuaW1wb3J0IHsgZ2V0Q2FyZXRPZmZzZXRBbmRUZXh0LCBnZXRSYW5nZUZvclNlbGVjdGlvbiB9IGZyb20gJy4uLy4uLy4uL2VkaXRvci9kb20nO1xuaW1wb3J0IEF1dG9jb21wbGV0ZSwgeyBnZW5lcmF0ZUNvbXBsZXRpb25Eb21JZCB9IGZyb20gJy4uL3Jvb21zL0F1dG9jb21wbGV0ZSc7XG5pbXBvcnQgeyBnZXRBdXRvQ29tcGxldGVDcmVhdG9yLCBUeXBlIH0gZnJvbSAnLi4vLi4vLi4vZWRpdG9yL3BhcnRzJztcbmltcG9ydCB7IHBhcnNlRXZlbnQsIHBhcnNlUGxhaW5UZXh0TWVzc2FnZSB9IGZyb20gJy4uLy4uLy4uL2VkaXRvci9kZXNlcmlhbGl6ZSc7XG5pbXBvcnQgeyByZW5kZXJNb2RlbCB9IGZyb20gJy4uLy4uLy4uL2VkaXRvci9yZW5kZXInO1xuaW1wb3J0IFR5cGluZ1N0b3JlIGZyb20gXCIuLi8uLi8uLi9zdG9yZXMvVHlwaW5nU3RvcmVcIjtcbmltcG9ydCBTZXR0aW5nc1N0b3JlIGZyb20gXCIuLi8uLi8uLi9zZXR0aW5ncy9TZXR0aW5nc1N0b3JlXCI7XG5pbXBvcnQgeyBLZXkgfSBmcm9tIFwiLi4vLi4vLi4vS2V5Ym9hcmRcIjtcbmltcG9ydCB7IEVNT1RJQ09OX1RPX0VNT0pJIH0gZnJvbSBcIi4uLy4uLy4uL2Vtb2ppXCI7XG5pbXBvcnQgeyBDb21tYW5kQ2F0ZWdvcmllcywgQ29tbWFuZE1hcCwgcGFyc2VDb21tYW5kU3RyaW5nIH0gZnJvbSBcIi4uLy4uLy4uL1NsYXNoQ29tbWFuZHNcIjtcbmltcG9ydCBSYW5nZSBmcm9tIFwiLi4vLi4vLi4vZWRpdG9yL3JhbmdlXCI7XG5pbXBvcnQgTWVzc2FnZUNvbXBvc2VyRm9ybWF0QmFyLCB7IEZvcm1hdHRpbmcgfSBmcm9tIFwiLi9NZXNzYWdlQ29tcG9zZXJGb3JtYXRCYXJcIjtcbmltcG9ydCBEb2N1bWVudE9mZnNldCBmcm9tIFwiLi4vLi4vLi4vZWRpdG9yL29mZnNldFwiO1xuaW1wb3J0IHsgSURpZmYgfSBmcm9tIFwiLi4vLi4vLi4vZWRpdG9yL2RpZmZcIjtcbmltcG9ydCBBdXRvY29tcGxldGVXcmFwcGVyTW9kZWwgZnJvbSBcIi4uLy4uLy4uL2VkaXRvci9hdXRvY29tcGxldGVcIjtcbmltcG9ydCBEb2N1bWVudFBvc2l0aW9uIGZyb20gXCIuLi8uLi8uLi9lZGl0b3IvcG9zaXRpb25cIjtcbmltcG9ydCB7IElDb21wbGV0aW9uIH0gZnJvbSBcIi4uLy4uLy4uL2F1dG9jb21wbGV0ZS9BdXRvY29tcGxldGVyXCI7XG5pbXBvcnQgeyBBdXRvY29tcGxldGVBY3Rpb24sIGdldEtleUJpbmRpbmdzTWFuYWdlciwgTWVzc2FnZUNvbXBvc2VyQWN0aW9uIH0gZnJvbSAnLi4vLi4vLi4vS2V5QmluZGluZ3NNYW5hZ2VyJztcbmltcG9ydCB7IHJlcGxhY2VhYmxlQ29tcG9uZW50IH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL3JlcGxhY2VhYmxlQ29tcG9uZW50XCI7XG5cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9sb2dnZXJcIjtcblxuLy8gbWF0Y2hlcyBlbW90aWNvbnMgd2hpY2ggZm9sbG93IHRoZSBzdGFydCBvZiBhIGxpbmUgb3Igd2hpdGVzcGFjZVxuY29uc3QgUkVHRVhfRU1PVElDT05fV0hJVEVTUEFDRSA9IG5ldyBSZWdFeHAoJyg/Ol58XFxcXHMpKCcgKyBFTU9USUNPTl9SRUdFWC5zb3VyY2UgKyAnKVxcXFxzfDpeJCcpO1xuZXhwb3J0IGNvbnN0IFJFR0VYX0VNT1RJQ09OID0gbmV3IFJlZ0V4cCgnKD86XnxcXFxccykoJyArIEVNT1RJQ09OX1JFR0VYLnNvdXJjZSArICcpJCcpO1xuXG5jb25zdCBJU19NQUMgPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZihcIk1hY1wiKSAhPT0gLTE7XG5cbmNvbnN0IFNVUlJPVU5EX1dJVEhfQ0hBUkFDVEVSUyA9IFtcIlxcXCJcIiwgXCJfXCIsIFwiYFwiLCBcIidcIiwgXCIqXCIsIFwiflwiLCBcIiRcIl07XG5jb25zdCBTVVJST1VORF9XSVRIX0RPVUJMRV9DSEFSQUNURVJTID0gbmV3IE1hcChbXG4gICAgW1wiKFwiLCBcIilcIl0sXG4gICAgW1wiW1wiLCBcIl1cIl0sXG4gICAgW1wie1wiLCBcIn1cIl0sXG4gICAgW1wiPFwiLCBcIj5cIl0sXG5dKTtcblxuZnVuY3Rpb24gY3RybFNob3J0Y3V0TGFiZWwoa2V5OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiAoSVNfTUFDID8gXCLijJhcIiA6IFwiQ3RybFwiKSArIFwiK1wiICsga2V5O1xufVxuXG5mdW5jdGlvbiBjbG9uZVNlbGVjdGlvbihzZWxlY3Rpb246IFNlbGVjdGlvbik6IFBhcnRpYWw8U2VsZWN0aW9uPiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYW5jaG9yTm9kZTogc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICAgIGFuY2hvck9mZnNldDogc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgICBmb2N1c09mZnNldDogc2VsZWN0aW9uLmZvY3VzT2Zmc2V0LFxuICAgICAgICBpc0NvbGxhcHNlZDogc2VsZWN0aW9uLmlzQ29sbGFwc2VkLFxuICAgICAgICByYW5nZUNvdW50OiBzZWxlY3Rpb24ucmFuZ2VDb3VudCxcbiAgICAgICAgdHlwZTogc2VsZWN0aW9uLnR5cGUsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uRXF1YWxzKGE6IFBhcnRpYWw8U2VsZWN0aW9uPiwgYjogU2VsZWN0aW9uKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGEuYW5jaG9yTm9kZSA9PT0gYi5hbmNob3JOb2RlICYmXG4gICAgICAgIGEuYW5jaG9yT2Zmc2V0ID09PSBiLmFuY2hvck9mZnNldCAmJlxuICAgICAgICBhLmZvY3VzTm9kZSA9PT0gYi5mb2N1c05vZGUgJiZcbiAgICAgICAgYS5mb2N1c09mZnNldCA9PT0gYi5mb2N1c09mZnNldCAmJlxuICAgICAgICBhLmlzQ29sbGFwc2VkID09PSBiLmlzQ29sbGFwc2VkICYmXG4gICAgICAgIGEucmFuZ2VDb3VudCA9PT0gYi5yYW5nZUNvdW50ICYmXG4gICAgICAgIGEudHlwZSA9PT0gYi50eXBlO1xufVxuXG5pbnRlcmZhY2UgSVByb3BzIHtcbiAgICBtb2RlbDogRWRpdG9yTW9kZWw7XG4gICAgcm9vbTogUm9vbTtcbiAgICB0aHJlYWRJZDogc3RyaW5nO1xuICAgIHBsYWNlaG9sZGVyPzogc3RyaW5nO1xuICAgIGxhYmVsPzogc3RyaW5nO1xuICAgIGluaXRpYWxDYXJldD86IERvY3VtZW50T2Zmc2V0O1xuICAgIGRpc2FibGVkPzogYm9vbGVhbjtcblxuICAgIG9uQ2hhbmdlPygpO1xuICAgIG9uUGFzdGU/KGV2ZW50OiBDbGlwYm9hcmRFdmVudDxIVE1MRGl2RWxlbWVudD4sIG1vZGVsOiBFZGl0b3JNb2RlbCk6IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBJU3RhdGUge1xuICAgIHNob3dQaWxsQXZhdGFyOiBib29sZWFuO1xuICAgIHF1ZXJ5Pzogc3RyaW5nO1xuICAgIHNob3dWaXN1YWxCZWxsPzogYm9vbGVhbjtcbiAgICBhdXRvQ29tcGxldGU/OiBBdXRvY29tcGxldGVXcmFwcGVyTW9kZWw7XG4gICAgY29tcGxldGlvbkluZGV4PzogbnVtYmVyO1xuICAgIHN1cnJvdW5kV2l0aDogYm9vbGVhbjtcbn1cblxuQHJlcGxhY2VhYmxlQ29tcG9uZW50KFwidmlld3Mucm9vbXMuQmFzaWNNZXNzYWdlRWRpdG9yXCIpXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNpY01lc3NhZ2VFZGl0b3IgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8SVByb3BzLCBJU3RhdGU+IHtcbiAgICBwdWJsaWMgcmVhZG9ubHkgZWRpdG9yUmVmID0gY3JlYXRlUmVmPEhUTUxEaXZFbGVtZW50PigpO1xuICAgIHByaXZhdGUgYXV0b2NvbXBsZXRlUmVmID0gY3JlYXRlUmVmPEF1dG9jb21wbGV0ZT4oKTtcbiAgICBwcml2YXRlIGZvcm1hdEJhclJlZiA9IGNyZWF0ZVJlZjxNZXNzYWdlQ29tcG9zZXJGb3JtYXRCYXI+KCk7XG5cbiAgICBwcml2YXRlIG1vZGlmaWVkRmxhZyA9IGZhbHNlO1xuICAgIHByaXZhdGUgaXNJTUVDb21wb3NpbmcgPSBmYWxzZTtcbiAgICBwcml2YXRlIGhhc1RleHRTZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgcHJpdmF0ZSBfaXNDYXJldEF0RW5kOiBib29sZWFuO1xuICAgIHByaXZhdGUgbGFzdENhcmV0OiBEb2N1bWVudE9mZnNldDtcbiAgICBwcml2YXRlIGxhc3RTZWxlY3Rpb246IFJldHVyblR5cGU8dHlwZW9mIGNsb25lU2VsZWN0aW9uPjtcblxuICAgIHByaXZhdGUgcmVhZG9ubHkgZW1vdGljb25TZXR0aW5nSGFuZGxlOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSByZWFkb25seSBzaG91bGRTaG93UGlsbEF2YXRhclNldHRpbmdIYW5kbGU6IHN0cmluZztcbiAgICBwcml2YXRlIHJlYWRvbmx5IHN1cnJvdW5kV2l0aEhhbmRsZTogc3RyaW5nO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgaGlzdG9yeU1hbmFnZXIgPSBuZXcgSGlzdG9yeU1hbmFnZXIoKTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHNob3dQaWxsQXZhdGFyOiBTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFwiUGlsbC5zaG91bGRTaG93UGlsbEF2YXRhclwiKSxcbiAgICAgICAgICAgIHN1cnJvdW5kV2l0aDogU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZShcIk1lc3NhZ2VDb21wb3NlcklucHV0LnN1cnJvdW5kV2l0aFwiKSxcbiAgICAgICAgICAgIHNob3dWaXN1YWxCZWxsOiBmYWxzZSxcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmVtb3RpY29uU2V0dGluZ0hhbmRsZSA9IFNldHRpbmdzU3RvcmUud2F0Y2hTZXR0aW5nKCdNZXNzYWdlQ29tcG9zZXJJbnB1dC5hdXRvUmVwbGFjZUVtb2ppJywgbnVsbCxcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJlRW1vdGljb25BdXRvUmVwbGFjZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJlRW1vdGljb25BdXRvUmVwbGFjZSgpO1xuICAgICAgICB0aGlzLnNob3VsZFNob3dQaWxsQXZhdGFyU2V0dGluZ0hhbmRsZSA9IFNldHRpbmdzU3RvcmUud2F0Y2hTZXR0aW5nKFwiUGlsbC5zaG91bGRTaG93UGlsbEF2YXRhclwiLCBudWxsLFxuICAgICAgICAgICAgdGhpcy5jb25maWd1cmVTaG91bGRTaG93UGlsbEF2YXRhcik7XG4gICAgICAgIHRoaXMuc3Vycm91bmRXaXRoSGFuZGxlID0gU2V0dGluZ3NTdG9yZS53YXRjaFNldHRpbmcoXCJNZXNzYWdlQ29tcG9zZXJJbnB1dC5zdXJyb3VuZFdpdGhcIiwgbnVsbCxcbiAgICAgICAgICAgIHRoaXMuc3Vycm91bmRXaXRoU2V0dGluZ0NoYW5nZWQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzOiBJUHJvcHMpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byByZS1jaGVjayB0aGUgcGxhY2Vob2xkZXIgd2hlbiB0aGUgZW5hYmxlZCBzdGF0ZSBjaGFuZ2VzIGJlY2F1c2UgaXQgY2F1c2VzIHRoZVxuICAgICAgICAvLyBwbGFjZWhvbGRlciBlbGVtZW50IHRvIHJlbW91bnQsIHdoaWNoIGdldHMgcmlkIG9mIHRoZSBgOjpiZWZvcmVgIGNsYXNzLiBSZS1ldmFsdWF0aW5nIHRoZVxuICAgICAgICAvLyBwbGFjZWhvbGRlciBtZWFucyB3ZSBnZXQgYSBwcm9wZXIgYDo6YmVmb3JlYCB3aXRoIHRoZSBwbGFjZWhvbGRlci5cbiAgICAgICAgY29uc3QgZW5hYmxlZENoYW5nZSA9IHRoaXMucHJvcHMuZGlzYWJsZWQgIT09IHByZXZQcm9wcy5kaXNhYmxlZDtcbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXJDaGFuZ2VkID0gdGhpcy5wcm9wcy5wbGFjZWhvbGRlciAhPT0gcHJldlByb3BzLnBsYWNlaG9sZGVyO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5wbGFjZWhvbGRlciAmJiAocGxhY2Vob2xkZXJDaGFuZ2VkIHx8IGVuYWJsZWRDaGFuZ2UpKSB7XG4gICAgICAgICAgICBjb25zdCB7IGlzRW1wdHkgfSA9IHRoaXMucHJvcHMubW9kZWw7XG4gICAgICAgICAgICBpZiAoaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd1BsYWNlaG9sZGVyKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBsYWNlaG9sZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgcmVwbGFjZUVtb3RpY29uKGNhcmV0UG9zaXRpb246IERvY3VtZW50UG9zaXRpb24sIHJlZ2V4OiBSZWdFeHApOiBudW1iZXIge1xuICAgICAgICBjb25zdCB7IG1vZGVsIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCByYW5nZSA9IG1vZGVsLnN0YXJ0UmFuZ2UoY2FyZXRQb3NpdGlvbik7XG4gICAgICAgIC8vIGV4cGFuZCByYW5nZSBtYXggOCBjaGFyYWN0ZXJzIGJhY2t3YXJkcyBmcm9tIGNhcmV0UG9zaXRpb24sXG4gICAgICAgIC8vIGFzIGEgc3BhY2UgdG8gbG9vayBmb3IgYW4gZW1vdGljb25cbiAgICAgICAgbGV0IG4gPSA4O1xuICAgICAgICByYW5nZS5leHBhbmRCYWNrd2FyZHNXaGlsZSgoaW5kZXgsIG9mZnNldCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFydCA9IG1vZGVsLnBhcnRzW2luZGV4XTtcbiAgICAgICAgICAgIG4gLT0gMTtcbiAgICAgICAgICAgIHJldHVybiBuID49IDAgJiYgW1R5cGUuUGxhaW4sIFR5cGUuUGlsbENhbmRpZGF0ZSwgVHlwZS5OZXdsaW5lXS5pbmNsdWRlcyhwYXJ0LnR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZW1vdGljb25NYXRjaCA9IHJlZ2V4LmV4ZWMocmFuZ2UudGV4dCk7XG4gICAgICAgIGlmIChlbW90aWNvbk1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeSA9IGVtb3RpY29uTWF0Y2hbMV0ucmVwbGFjZShcIi1cIiwgXCJcIik7XG4gICAgICAgICAgICAvLyB0cnkgYm90aCBleGFjdCBtYXRjaCBhbmQgbG93ZXItY2FzZSwgdGhpcyBtZWFucyB0aGF0IHhkIHdvbid0IG1hdGNoIHhEIGJ1dCA6UCB3aWxsIG1hdGNoIDpwXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gRU1PVElDT05fVE9fRU1PSkkuZ2V0KHF1ZXJ5KSB8fCBFTU9USUNPTl9UT19FTU9KSS5nZXQocXVlcnkudG9Mb3dlckNhc2UoKSk7XG5cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXJ0Q3JlYXRvciB9ID0gbW9kZWw7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RNYXRjaCA9IGVtb3RpY29uTWF0Y2hbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgbW92ZVN0YXJ0ID0gZmlyc3RNYXRjaFswXSA9PT0gXCIgXCIgPyAxIDogMDtcblxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhlIHJhbmdlIHRvIG9ubHkgY29tcHJpc2Ugb2YgdGhlIGVtb3RpY29uXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB3ZSdsbCByZXBsYWNlIHRoZSB3aG9sZSByYW5nZSB3aXRoIGFuIGVtb2ppLFxuICAgICAgICAgICAgICAgIC8vIHNvIG1vdmUgdGhlIHN0YXJ0IGZvcndhcmQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBlbW90aWNvbi5cbiAgICAgICAgICAgICAgICAvLyBUYWtlICsgMSBiZWNhdXNlIGluZGV4IGlzIHJlcG9ydGVkIHdpdGhvdXQgdGhlIHBvc3NpYmxlIHByZWNlZGluZyBzcGFjZS5cbiAgICAgICAgICAgICAgICByYW5nZS5tb3ZlU3RhcnRGb3J3YXJkcyhlbW90aWNvbk1hdGNoLmluZGV4ICsgbW92ZVN0YXJ0KTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZW5kIGlzIGEgdHJhaWxpbmcgc3BhY2UvbmV3bGluZSBtb3ZlIGVuZCBiYWNrd2FyZHMsIHNvIHRoYXQgd2UgZG9uJ3QgcmVwbGFjZSBpdFxuICAgICAgICAgICAgICAgIGlmIChbXCJcXG5cIiwgXCIgXCJdLmluY2x1ZGVzKGZpcnN0TWF0Y2hbZmlyc3RNYXRjaC5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UubW92ZUVuZEJhY2t3YXJkcygxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB0aGlzIHJldHVybnMgdGhlIGFtb3VudCBvZiBhZGRlZC9yZW1vdmVkIGNoYXJhY3RlcnMgZHVyaW5nIHRoZSByZXBsYWNlXG4gICAgICAgICAgICAgICAgLy8gc28gdGhlIGNhcmV0IHBvc2l0aW9uIGNhbiBiZSBhZGp1c3RlZC5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2UucmVwbGFjZShbcGFydENyZWF0b3IucGxhaW4oZGF0YS51bmljb2RlKV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVFZGl0b3JTdGF0ZSA9IChzZWxlY3Rpb246IENhcmV0LCBpbnB1dFR5cGU/OiBzdHJpbmcsIGRpZmY/OiBJRGlmZik6IHZvaWQgPT4ge1xuICAgICAgICByZW5kZXJNb2RlbCh0aGlzLmVkaXRvclJlZi5jdXJyZW50LCB0aGlzLnByb3BzLm1vZGVsKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbikgeyAvLyBzZXQgdGhlIGNhcmV0L3NlbGVjdGlvblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzZXRTZWxlY3Rpb24odGhpcy5lZGl0b3JSZWYuY3VycmVudCwgdGhpcy5wcm9wcy5tb2RlbCwgc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgY2FyZXQgc2VsZWN0aW9uIGlzIGEgcmFuZ2UsIHRha2UgdGhlIGVuZCBwb3NpdGlvblxuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBzZWxlY3Rpb24gaW5zdGFuY2VvZiBSYW5nZSA/IHNlbGVjdGlvbi5lbmQgOiBzZWxlY3Rpb247XG4gICAgICAgICAgICB0aGlzLnNldExhc3RDYXJldEZyb21Qb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpc0VtcHR5IH0gPSB0aGlzLnByb3BzLm1vZGVsO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5wbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgaWYgKGlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dQbGFjZWhvbGRlcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVQbGFjZWhvbGRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0VtcHR5KSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdEJhclJlZi5jdXJyZW50LmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGF1dG9Db21wbGV0ZTogdGhpcy5wcm9wcy5tb2RlbC5hdXRvQ29tcGxldGUsXG4gICAgICAgICAgICAvLyBpZiBhIGNoYW5nZSBpcyBoYXBwZW5pbmcgdGhlbiBjbGVhciB0aGUgc2hvd1Zpc3VhbEJlbGxcbiAgICAgICAgICAgIHNob3dWaXN1YWxCZWxsOiBkaWZmID8gZmFsc2UgOiB0aGlzLnN0YXRlLnNob3dWaXN1YWxCZWxsLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oaXN0b3J5TWFuYWdlci50cnlQdXNoKHRoaXMucHJvcHMubW9kZWwsIHNlbGVjdGlvbiwgaW5wdXRUeXBlLCBkaWZmKTtcblxuICAgICAgICBsZXQgaXNUeXBpbmcgPSAhdGhpcy5wcm9wcy5tb2RlbC5pc0VtcHR5O1xuICAgICAgICAvLyBJZiB0aGUgdXNlciBpcyBlbnRlcmluZyBhIGNvbW1hbmQsIG9ubHkgY29uc2lkZXIgdGhlbSB0eXBpbmcgaWYgaXQgaXMgb25lIHdoaWNoIHNlbmRzIGEgbWVzc2FnZSBpbnRvIHRoZSByb29tXG4gICAgICAgIGlmIChpc1R5cGluZyAmJiB0aGlzLnByb3BzLm1vZGVsLnBhcnRzWzBdLnR5cGUgPT09IFwiY29tbWFuZFwiKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNtZCB9ID0gcGFyc2VDb21tYW5kU3RyaW5nKHRoaXMucHJvcHMubW9kZWwucGFydHNbMF0udGV4dCk7XG4gICAgICAgICAgICBjb25zdCBjb21tYW5kID0gQ29tbWFuZE1hcC5nZXQoY21kKTtcbiAgICAgICAgICAgIGlmICghY29tbWFuZCB8fCAhY29tbWFuZC5pc0VuYWJsZWQoKSB8fCBjb21tYW5kLmNhdGVnb3J5ICE9PSBDb21tYW5kQ2F0ZWdvcmllcy5tZXNzYWdlcykge1xuICAgICAgICAgICAgICAgIGlzVHlwaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgVHlwaW5nU3RvcmUuc2hhcmVkSW5zdGFuY2UoKS5zZXRTZWxmVHlwaW5nKFxuICAgICAgICAgICAgdGhpcy5wcm9wcy5yb29tLnJvb21JZCxcbiAgICAgICAgICAgIHRoaXMucHJvcHMudGhyZWFkSWQsXG4gICAgICAgICAgICBpc1R5cGluZyxcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByaXZhdGUgc2hvd1BsYWNlaG9sZGVyKCk6IHZvaWQge1xuICAgICAgICAvLyBlc2NhcGUgc2luZ2xlIHF1b3Rlc1xuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IHRoaXMucHJvcHMucGxhY2Vob2xkZXIucmVwbGFjZSgvJy9nLCAnXFxcXFxcJycpO1xuICAgICAgICB0aGlzLmVkaXRvclJlZi5jdXJyZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1wbGFjZWhvbGRlclwiLCBgJyR7cGxhY2Vob2xkZXJ9J2ApO1xuICAgICAgICB0aGlzLmVkaXRvclJlZi5jdXJyZW50LmNsYXNzTGlzdC5hZGQoXCJteF9CYXNpY01lc3NhZ2VDb21wb3Nlcl9pbnB1dEVtcHR5XCIpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGlkZVBsYWNlaG9sZGVyKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmVkaXRvclJlZi5jdXJyZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJteF9CYXNpY01lc3NhZ2VDb21wb3Nlcl9pbnB1dEVtcHR5XCIpO1xuICAgICAgICB0aGlzLmVkaXRvclJlZi5jdXJyZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiLS1wbGFjZWhvbGRlclwiKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uQ29tcG9zaXRpb25TdGFydCA9ICgpOiB2b2lkID0+IHtcbiAgICAgICAgdGhpcy5pc0lNRUNvbXBvc2luZyA9IHRydWU7XG4gICAgICAgIC8vIGV2ZW4gaWYgdGhlIG1vZGVsIGlzIGVtcHR5LCB0aGUgY29tcG9zaXRpb24gdGV4dCBzaG91bGRuJ3QgYmUgbWl4ZWQgd2l0aCB0aGUgcGxhY2Vob2xkZXJcbiAgICAgICAgdGhpcy5oaWRlUGxhY2Vob2xkZXIoKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbkNvbXBvc2l0aW9uRW5kID0gKCk6IHZvaWQgPT4ge1xuICAgICAgICB0aGlzLmlzSU1FQ29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIHNvbWUgYnJvd3NlcnMgKENocm9tZSkgZG9uJ3QgZmlyZSBhbiBpbnB1dCBldmVudCBhZnRlciBlbmRpbmcgYSBjb21wb3NpdGlvbixcbiAgICAgICAgLy8gc28gdHJpZ2dlciBhIG1vZGVsIHVwZGF0ZSBhZnRlciB0aGUgY29tcG9zaXRpb24gaXMgZG9uZSBieSBjYWxsaW5nIHRoZSBpbnB1dCBoYW5kbGVyLlxuXG4gICAgICAgIC8vIGhvd2V2ZXIsIG1vZGlmeWluZyB0aGUgRE9NIChjYXVzZWQgYnkgdGhlIGVkaXRvciBtb2RlbCB1cGRhdGUpIGZyb20gdGhlIGNvbXBvc2l0aW9uZW5kIGhhbmRsZXIgc2VlbXNcbiAgICAgICAgLy8gdG8gY29uZnVzZSB0aGUgSU1FIGluIENocm9tZSwgbGlrZWx5IGNhdXNpbmcgaHR0cHM6Ly9naXRodWIuY29tL3ZlY3Rvci1pbS9lbGVtZW50LXdlYi9pc3N1ZXMvMTA5MTMgLFxuICAgICAgICAvLyBzbyB3ZSBkbyBpdCBhc3luY1xuXG4gICAgICAgIC8vIGhvd2V2ZXIsIGRvaW5nIHRoaXMgYXN5bmMgc2VlbXMgdG8gYnJlYWsgdGhpbmdzIGluIFNhZmFyaSBmb3Igc29tZSByZWFzb24sIHNvIGJyb3dzZXIgc25pZmYuXG5cbiAgICAgICAgY29uc3QgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGlzU2FmYXJpID0gdWEuaW5jbHVkZXMoJ3NhZmFyaS8nKSAmJiAhdWEuaW5jbHVkZXMoJ2Nocm9tZS8nKTtcblxuICAgICAgICBpZiAoaXNTYWZhcmkpIHtcbiAgICAgICAgICAgIHRoaXMub25JbnB1dCh7IGlucHV0VHlwZTogXCJpbnNlcnRDb21wb3NpdGlvblRleHRcIiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25JbnB1dCh7IGlucHV0VHlwZTogXCJpbnNlcnRDb21wb3NpdGlvblRleHRcIiB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHB1YmxpYyBpc0NvbXBvc2luZyhldmVudDogUmVhY3QuS2V5Ym9hcmRFdmVudCk6IGJvb2xlYW4ge1xuICAgICAgICAvLyBjaGVja2luZyB0aGUgZXZlbnQuaXNDb21wb3NpbmcgZmxhZyBqdXN0IGluIGNhc2UgYW55IGJyb3dzZXIgb3V0IHRoZXJlXG4gICAgICAgIC8vIGVtaXRzIGV2ZW50cyByZWxhdGVkIHRvIHRoZSBjb21wb3NpdGlvbiBhZnRlciBjb21wb3NpdGlvbmVuZFxuICAgICAgICAvLyBoYXMgYmVlbiBmaXJlZFxuICAgICAgICByZXR1cm4gISEodGhpcy5pc0lNRUNvbXBvc2luZyB8fCAoZXZlbnQubmF0aXZlRXZlbnQgJiYgZXZlbnQubmF0aXZlRXZlbnQuaXNDb21wb3NpbmcpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uQ3V0Q29weSA9IChldmVudDogQ2xpcGJvYXJkRXZlbnQsIHR5cGU6IHN0cmluZyk6IHZvaWQgPT4ge1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgdGV4dCA9IHNlbGVjdGlvbi50b1N0cmluZygpO1xuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgY29uc3QgeyBtb2RlbCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0UmFuZ2VGb3JTZWxlY3Rpb24odGhpcy5lZGl0b3JSZWYuY3VycmVudCwgbW9kZWwsIHNlbGVjdGlvbik7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZFBhcnRzID0gcmFuZ2UucGFydHMubWFwKHAgPT4gcC5zZXJpYWxpemUoKSk7XG4gICAgICAgICAgICBldmVudC5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJhcHBsaWNhdGlvbi94LWVsZW1lbnQtY29tcG9zZXJcIiwgSlNPTi5zdHJpbmdpZnkoc2VsZWN0ZWRQYXJ0cykpO1xuICAgICAgICAgICAgZXZlbnQuY2xpcGJvYXJkRGF0YS5zZXREYXRhKFwidGV4dC9wbGFpblwiLCB0ZXh0KTsgLy8gc28gcGxhaW4gY29weS9wYXN0ZSB3b3Jrc1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiY3V0XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHRleHQsIHVwZGF0aW5nIHRoZSBtb2RlbCBhcyBhcHByb3ByaWF0ZVxuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZpZWRGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXBsYWNlUmFuZ2VBbmRNb3ZlQ2FyZXQocmFuZ2UsIFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbkNvcHkgPSAoZXZlbnQ6IENsaXBib2FyZEV2ZW50KTogdm9pZCA9PiB7XG4gICAgICAgIHRoaXMub25DdXRDb3B5KGV2ZW50LCBcImNvcHlcIik7XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25DdXQgPSAoZXZlbnQ6IENsaXBib2FyZEV2ZW50KTogdm9pZCA9PiB7XG4gICAgICAgIHRoaXMub25DdXRDb3B5KGV2ZW50LCBcImN1dFwiKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvblBhc3RlID0gKGV2ZW50OiBDbGlwYm9hcmRFdmVudDxIVE1MRGl2RWxlbWVudD4pOiBib29sZWFuID0+IHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gd2UgYWx3YXlzIGhhbmRsZSB0aGUgcGFzdGUgb3Vyc2VsdmVzXG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uUGFzdGUgJiYgdGhpcy5wcm9wcy5vblBhc3RlKGV2ZW50LCB0aGlzLnByb3BzLm1vZGVsKSkge1xuICAgICAgICAgICAgLy8gdG8gcHJldmVudCBkb3VibGUgaGFuZGxpbmcsIGFsbG93IHByb3BzLm9uUGFzdGUgdG8gc2tpcCBpbnRlcm5hbCBvblBhc3RlXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgbW9kZWwgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgcGFydENyZWF0b3IgfSA9IG1vZGVsO1xuICAgICAgICBjb25zdCBwYXJ0c1RleHQgPSBldmVudC5jbGlwYm9hcmREYXRhLmdldERhdGEoXCJhcHBsaWNhdGlvbi94LWVsZW1lbnQtY29tcG9zZXJcIik7XG4gICAgICAgIGxldCBwYXJ0cztcbiAgICAgICAgaWYgKHBhcnRzVGV4dCkge1xuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZFRleHRQYXJ0cyA9IEpTT04ucGFyc2UocGFydHNUZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IGRlc2VyaWFsaXplZFBhcnRzID0gc2VyaWFsaXplZFRleHRQYXJ0cy5tYXAocCA9PiBwYXJ0Q3JlYXRvci5kZXNlcmlhbGl6ZVBhcnQocCkpO1xuICAgICAgICAgICAgcGFydHMgPSBkZXNlcmlhbGl6ZWRQYXJ0cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBldmVudC5jbGlwYm9hcmREYXRhLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpO1xuICAgICAgICAgICAgcGFydHMgPSBwYXJzZVBsYWluVGV4dE1lc3NhZ2UodGV4dCwgcGFydENyZWF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kaWZpZWRGbGFnID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBnZXRSYW5nZUZvclNlbGVjdGlvbih0aGlzLmVkaXRvclJlZi5jdXJyZW50LCBtb2RlbCwgZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCkpO1xuICAgICAgICByZXBsYWNlUmFuZ2VBbmRNb3ZlQ2FyZXQocmFuZ2UsIHBhcnRzKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbklucHV0ID0gKGV2ZW50OiBQYXJ0aWFsPElucHV0RXZlbnQ+KTogdm9pZCA9PiB7XG4gICAgICAgIC8vIGlnbm9yZSBhbnkgaW5wdXQgd2hpbGUgZG9pbmcgSU1FIGNvbXBvc2l0aW9uc1xuICAgICAgICBpZiAodGhpcy5pc0lNRUNvbXBvc2luZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kaWZpZWRGbGFnID0gdHJ1ZTtcbiAgICAgICAgY29uc3Qgc2VsID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHsgY2FyZXQsIHRleHQgfSA9IGdldENhcmV0T2Zmc2V0QW5kVGV4dCh0aGlzLmVkaXRvclJlZi5jdXJyZW50LCBzZWwpO1xuICAgICAgICB0aGlzLnByb3BzLm1vZGVsLnVwZGF0ZSh0ZXh0LCBldmVudC5pbnB1dFR5cGUsIGNhcmV0KTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBpbnNlcnRUZXh0KHRleHRUb0luc2VydDogc3RyaW5nLCBpbnB1dFR5cGUgPSBcImluc2VydFRleHRcIik6IHZvaWQge1xuICAgICAgICBjb25zdCBzZWwgPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgeyBjYXJldCwgdGV4dCB9ID0gZ2V0Q2FyZXRPZmZzZXRBbmRUZXh0KHRoaXMuZWRpdG9yUmVmLmN1cnJlbnQsIHNlbCk7XG4gICAgICAgIGNvbnN0IG5ld1RleHQgPSB0ZXh0LnN1YnN0cigwLCBjYXJldC5vZmZzZXQpICsgdGV4dFRvSW5zZXJ0ICsgdGV4dC5zdWJzdHIoY2FyZXQub2Zmc2V0KTtcbiAgICAgICAgY2FyZXQub2Zmc2V0ICs9IHRleHRUb0luc2VydC5sZW5ndGg7XG4gICAgICAgIHRoaXMubW9kaWZpZWRGbGFnID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wcm9wcy5tb2RlbC51cGRhdGUobmV3VGV4dCwgaW5wdXRUeXBlLCBjYXJldCk7XG4gICAgfVxuXG4gICAgLy8gdGhpcyBpcyB1c2VkIGxhdGVyIHRvIHNlZSBpZiB3ZSBuZWVkIHRvIHJlY2FsY3VsYXRlIHRoZSBjYXJldFxuICAgIC8vIG9uIHNlbGVjdGlvbmNoYW5nZS4gSWYgaXQgaXMganVzdCBhIGNvbnNlcXVlbmNlIG9mIHR5cGluZ1xuICAgIC8vIHdlIGRvbid0IG5lZWQgdG8uIEJ1dCBpZiB0aGUgdXNlciBpcyBuYXZpZ2F0aW5nIHRoZSBjYXJldCB3aXRob3V0IGlucHV0XG4gICAgLy8gd2UgbmVlZCB0byByZWNhbGN1bGF0ZSBpdCwgdG8gYmUgYWJsZSB0byBrbm93IHdoZXJlIHRvIGluc2VydCBjb250ZW50IGFmdGVyXG4gICAgLy8gbG9zaW5nIGZvY3VzXG4gICAgcHJpdmF0ZSBzZXRMYXN0Q2FyZXRGcm9tUG9zaXRpb24ocG9zaXRpb246IERvY3VtZW50UG9zaXRpb24pOiB2b2lkIHtcbiAgICAgICAgY29uc3QgeyBtb2RlbCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgdGhpcy5faXNDYXJldEF0RW5kID0gcG9zaXRpb24uaXNBdEVuZChtb2RlbCk7XG4gICAgICAgIHRoaXMubGFzdENhcmV0ID0gcG9zaXRpb24uYXNPZmZzZXQobW9kZWwpO1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb24gPSBjbG9uZVNlbGVjdGlvbihkb2N1bWVudC5nZXRTZWxlY3Rpb24oKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZWZyZXNoTGFzdENhcmV0SWZOZWVkZWQoKTogRG9jdW1lbnRPZmZzZXQge1xuICAgICAgICAvLyBYWFg6IG5lZWRlZCB3aGVuIGdvaW5nIHVwIGFuZCBkb3duIGluIGVkaXRpbmcgbWVzc2FnZXMgLi4uIG5vdCBzdXJlIHdoeSB5ZXRcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgZWRpdG9ycyBzaG91bGQgc3RvcCBkb2luZyB0aGlzIHdoZW4gd2hlbiBibHVycmVkIC4uLlxuICAgICAgICAvLyBtYXliZSBpdCdzIG9uIGZvY3VzIGFuZCB0aGUgX2VkaXRvclJlZiBpc24ndCBhdmFpbGFibGUgeWV0IG9yIHNvbWV0aGluZy5cbiAgICAgICAgaWYgKCF0aGlzLmVkaXRvclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGlmICghdGhpcy5sYXN0U2VsZWN0aW9uIHx8ICFzZWxlY3Rpb25FcXVhbHModGhpcy5sYXN0U2VsZWN0aW9uLCBzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb24gPSBjbG9uZVNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgICAgICAgICAgY29uc3QgeyBjYXJldCwgdGV4dCB9ID0gZ2V0Q2FyZXRPZmZzZXRBbmRUZXh0KHRoaXMuZWRpdG9yUmVmLmN1cnJlbnQsIHNlbGVjdGlvbik7XG4gICAgICAgICAgICB0aGlzLmxhc3RDYXJldCA9IGNhcmV0O1xuICAgICAgICAgICAgdGhpcy5faXNDYXJldEF0RW5kID0gY2FyZXQub2Zmc2V0ID09PSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sYXN0Q2FyZXQ7XG4gICAgfVxuXG4gICAgcHVibGljIGNsZWFyVW5kb0hpc3RvcnkoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaGlzdG9yeU1hbmFnZXIuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0Q2FyZXQoKTogRG9jdW1lbnRPZmZzZXQge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0Q2FyZXQ7XG4gICAgfVxuXG4gICAgcHVibGljIGlzU2VsZWN0aW9uQ29sbGFwc2VkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gIXRoaXMubGFzdFNlbGVjdGlvbiB8fCB0aGlzLmxhc3RTZWxlY3Rpb24uaXNDb2xsYXBzZWQ7XG4gICAgfVxuXG4gICAgcHVibGljIGlzQ2FyZXRBdFN0YXJ0KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDYXJldCgpLm9mZnNldCA9PT0gMDtcbiAgICB9XG5cbiAgICBwdWJsaWMgaXNDYXJldEF0RW5kKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNDYXJldEF0RW5kO1xuICAgIH1cblxuICAgIHByaXZhdGUgb25CbHVyID0gKCk6IHZvaWQgPT4ge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH07XG5cbiAgICBwcml2YXRlIG9uRm9jdXMgPSAoKTogdm9pZCA9PiB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgICAgIC8vIGZvcmNlIHRvIHJlY2FsY3VsYXRlXG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMucmVmcmVzaExhc3RDYXJldElmTmVlZGVkKCk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25TZWxlY3Rpb25DaGFuZ2UgPSAoKTogdm9pZCA9PiB7XG4gICAgICAgIGNvbnN0IHsgaXNFbXB0eSB9ID0gdGhpcy5wcm9wcy5tb2RlbDtcblxuICAgICAgICB0aGlzLnJlZnJlc2hMYXN0Q2FyZXRJZk5lZWRlZCgpO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzVGV4dFNlbGVjdGVkICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuICAgICAgICAgICAgdGhpcy5oYXNUZXh0U2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvcm1hdEJhclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtYXRCYXJSZWYuY3VycmVudC5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCAmJiAhaXNFbXB0eSkge1xuICAgICAgICAgICAgdGhpcy5oYXNUZXh0U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9ybWF0QmFyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb25SZWN0ID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtYXRCYXJSZWYuY3VycmVudC5zaG93QXQoc2VsZWN0aW9uUmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbktleURvd24gPSAoZXZlbnQ6IFJlYWN0LktleWJvYXJkRXZlbnQpOiB2b2lkID0+IHtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLnByb3BzLm1vZGVsO1xuICAgICAgICBsZXQgaGFuZGxlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnN1cnJvdW5kV2l0aCAmJiBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKS50eXBlICE9PSBcIkNhcmV0XCIpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgc3Vycm91bmRzIHRoZSBzZWxlY3RlZCB0ZXh0IHdpdGggYSBjaGFyYWN0ZXIuIFRoaXMgaXNcbiAgICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgbGVmdCBvdXQgb2YgdGhlIGtleWJpbmRpbmcgbWFuYWdlciBhcyB0aGUga2V5YmluZHNcbiAgICAgICAgICAgIC8vIGhlcmUgc2hvdWxkbid0IGJlIGNoYW5nZWFibGVcblxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uUmFuZ2UgPSBnZXRSYW5nZUZvclNlbGVjdGlvbihcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvclJlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMubW9kZWwsXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCksXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy8gdHJpbSB0aGUgcmFuZ2UgYXMgd2Ugd2FudCBpdCB0byBleGNsdWRlIGxlYWRpbmcvdHJhaWxpbmcgc3BhY2VzXG4gICAgICAgICAgICBzZWxlY3Rpb25SYW5nZS50cmltKCk7XG5cbiAgICAgICAgICAgIGlmIChbLi4uU1VSUk9VTkRfV0lUSF9ET1VCTEVfQ0hBUkFDVEVSUy5rZXlzKCksIC4uLlNVUlJPVU5EX1dJVEhfQ0hBUkFDVEVSU10uaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlzdG9yeU1hbmFnZXIuZW5zdXJlTGFzdENoYW5nZXNQdXNoZWQodGhpcy5wcm9wcy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZmllZEZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRvZ2dsZUlubGluZUZvcm1hdChzZWxlY3Rpb25SYW5nZSwgZXZlbnQua2V5LCBTVVJST1VORF9XSVRIX0RPVUJMRV9DSEFSQUNURVJTLmdldChldmVudC5rZXkpKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGF1dG9jb21wbGV0ZUFjdGlvbiA9IGdldEtleUJpbmRpbmdzTWFuYWdlcigpLmdldEF1dG9jb21wbGV0ZUFjdGlvbihldmVudCk7XG4gICAgICAgIGlmIChtb2RlbC5hdXRvQ29tcGxldGU/Lmhhc0NvbXBsZXRpb25zKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGF1dG9Db21wbGV0ZSA9IG1vZGVsLmF1dG9Db21wbGV0ZTtcbiAgICAgICAgICAgIHN3aXRjaCAoYXV0b2NvbXBsZXRlQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBBdXRvY29tcGxldGVBY3Rpb24uRm9yY2VDb21wbGV0ZTpcbiAgICAgICAgICAgICAgICBjYXNlIEF1dG9jb21wbGV0ZUFjdGlvbi5Db21wbGV0ZTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaXN0b3J5TWFuYWdlci5lbnN1cmVMYXN0Q2hhbmdlc1B1c2hlZCh0aGlzLnByb3BzLm1vZGVsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RpZmllZEZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBhdXRvQ29tcGxldGUuY29uZmlybUNvbXBsZXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQXV0b2NvbXBsZXRlQWN0aW9uLlByZXZTZWxlY3Rpb246XG4gICAgICAgICAgICAgICAgICAgIGF1dG9Db21wbGV0ZS5zZWxlY3RQcmV2aW91c1NlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBBdXRvY29tcGxldGVBY3Rpb24uTmV4dFNlbGVjdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgYXV0b0NvbXBsZXRlLnNlbGVjdE5leHRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQXV0b2NvbXBsZXRlQWN0aW9uLkNhbmNlbDpcbiAgICAgICAgICAgICAgICAgICAgYXV0b0NvbXBsZXRlLm9uRXNjYXBlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZG9uJ3QgcHJldmVudERlZmF1bHQgb24gYW55dGhpbmcgZWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGF1dG9jb21wbGV0ZUFjdGlvbiA9PT0gQXV0b2NvbXBsZXRlQWN0aW9uLkZvcmNlQ29tcGxldGUgJiYgIXRoaXMuc3RhdGUuc2hvd1Zpc3VhbEJlbGwpIHtcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIGN1cnJlbnQgYXV0b2NvbXBsZXRlIHdpbmRvdywgdHJ5IHRvIG9wZW4gaXRcbiAgICAgICAgICAgIHRoaXMudGFiQ29tcGxldGVOYW1lKCk7XG4gICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXkgPT09IEtleS5CQUNLU1BBQ0UgfHwgZXZlbnQua2V5ID09PSBLZXkuREVMRVRFKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdEJhclJlZi5jdXJyZW50LmhpZGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYW5kbGVkKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhY3Rpb24gPSBnZXRLZXlCaW5kaW5nc01hbmFnZXIoKS5nZXRNZXNzYWdlQ29tcG9zZXJBY3Rpb24oZXZlbnQpO1xuICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBNZXNzYWdlQ29tcG9zZXJBY3Rpb24uRm9ybWF0Qm9sZDpcbiAgICAgICAgICAgICAgICB0aGlzLm9uRm9ybWF0QWN0aW9uKEZvcm1hdHRpbmcuQm9sZCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VDb21wb3NlckFjdGlvbi5Gb3JtYXRJdGFsaWNzOlxuICAgICAgICAgICAgICAgIHRoaXMub25Gb3JtYXRBY3Rpb24oRm9ybWF0dGluZy5JdGFsaWNzKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZUNvbXBvc2VyQWN0aW9uLkZvcm1hdFF1b3RlOlxuICAgICAgICAgICAgICAgIHRoaXMub25Gb3JtYXRBY3Rpb24oRm9ybWF0dGluZy5RdW90ZSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VDb21wb3NlckFjdGlvbi5FZGl0UmVkbzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oaXN0b3J5TWFuYWdlci5jYW5SZWRvKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwYXJ0cywgY2FyZXQgfSA9IHRoaXMuaGlzdG9yeU1hbmFnZXIucmVkbygpO1xuICAgICAgICAgICAgICAgICAgICAvLyBwYXNzIG1hdGNoaW5nIGlucHV0VHlwZSBzbyBoaXN0b3J5TWFuYWdlciBkb2Vzbid0IHB1c2ggZWNob1xuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGludm9rZWQgZnJvbSByZXJlbmRlciBjYWxsYmFjay5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwucmVzZXQocGFydHMsIGNhcmV0LCBcImhpc3RvcnlSZWRvXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZUNvbXBvc2VyQWN0aW9uLkVkaXRVbmRvOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhpc3RvcnlNYW5hZ2VyLmNhblVuZG8oKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHBhcnRzLCBjYXJldCB9ID0gdGhpcy5oaXN0b3J5TWFuYWdlci51bmRvKHRoaXMucHJvcHMubW9kZWwpO1xuICAgICAgICAgICAgICAgICAgICAvLyBwYXNzIG1hdGNoaW5nIGlucHV0VHlwZSBzbyBoaXN0b3J5TWFuYWdlciBkb2Vzbid0IHB1c2ggZWNob1xuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGludm9rZWQgZnJvbSByZXJlbmRlciBjYWxsYmFjay5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwucmVzZXQocGFydHMsIGNhcmV0LCBcImhpc3RvcnlVbmRvXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZUNvbXBvc2VyQWN0aW9uLk5ld0xpbmU6XG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRUZXh0KFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBNZXNzYWdlQ29tcG9zZXJBY3Rpb24uTW92ZUN1cnNvclRvU3RhcnQ6XG4gICAgICAgICAgICAgICAgc2V0U2VsZWN0aW9uKHRoaXMuZWRpdG9yUmVmLmN1cnJlbnQsIG1vZGVsLCB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VDb21wb3NlckFjdGlvbi5Nb3ZlQ3Vyc29yVG9FbmQ6XG4gICAgICAgICAgICAgICAgc2V0U2VsZWN0aW9uKHRoaXMuZWRpdG9yUmVmLmN1cnJlbnQsIG1vZGVsLCB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBtb2RlbC5wYXJ0cy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IG1vZGVsLnBhcnRzW21vZGVsLnBhcnRzLmxlbmd0aCAtIDFdLnRleHQubGVuZ3RoLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYW5kbGVkKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBhc3luYyB0YWJDb21wbGV0ZU5hbWUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPihyZXNvbHZlID0+IHRoaXMuc2V0U3RhdGUoeyBzaG93VmlzdWFsQmVsbDogZmFsc2UgfSwgcmVzb2x2ZSkpO1xuICAgICAgICAgICAgY29uc3QgeyBtb2RlbCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGNvbnN0IGNhcmV0ID0gdGhpcy5nZXRDYXJldCgpO1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBtb2RlbC5wb3NpdGlvbkZvck9mZnNldChjYXJldC5vZmZzZXQsIGNhcmV0LmF0Tm9kZUVuZCk7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IG1vZGVsLnN0YXJ0UmFuZ2UocG9zaXRpb24pO1xuICAgICAgICAgICAgcmFuZ2UuZXhwYW5kQmFja3dhcmRzV2hpbGUoKGluZGV4LCBvZmZzZXQsIHBhcnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydC50ZXh0W29mZnNldF0gIT09IFwiIFwiICYmIHBhcnQudGV4dFtvZmZzZXRdICE9PSBcIitcIiAmJiAoXG4gICAgICAgICAgICAgICAgICAgIHBhcnQudHlwZSA9PT0gVHlwZS5QbGFpbiB8fFxuICAgICAgICAgICAgICAgICAgICBwYXJ0LnR5cGUgPT09IFR5cGUuUGlsbENhbmRpZGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgICBwYXJ0LnR5cGUgPT09IFR5cGUuQ29tbWFuZFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgcGFydENyZWF0b3IgfSA9IG1vZGVsO1xuICAgICAgICAgICAgLy8gYXdhaXQgZm9yIGF1dG8tY29tcGxldGUgdG8gYmUgb3BlblxuICAgICAgICAgICAgYXdhaXQgbW9kZWwudHJhbnNmb3JtKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRlZExlbiA9IHJhbmdlLnJlcGxhY2UoW3BhcnRDcmVhdG9yLnBpbGxDYW5kaWRhdGUocmFuZ2UudGV4dCldKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kZWwucG9zaXRpb25Gb3JPZmZzZXQoY2FyZXQub2Zmc2V0ICsgYWRkZWRMZW4sIHRydWUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIERvbid0IHRyeSB0byBkbyB0aGluZ3Mgd2l0aCB0aGUgYXV0b2NvbXBsZXRlIGlmIHRoZXJlIGlzIG5vbmUgc2hvd25cbiAgICAgICAgICAgIGlmIChtb2RlbC5hdXRvQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBtb2RlbC5hdXRvQ29tcGxldGUuc3RhcnRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1vZGVsLmF1dG9Db21wbGV0ZS5oYXNTZWxlY3Rpb24oKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgc2hvd1Zpc3VhbEJlbGw6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmF1dG9Db21wbGV0ZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHNob3dWaXN1YWxCZWxsOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGlzTW9kaWZpZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGlmaWVkRmxhZztcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uQXV0b0NvbXBsZXRlQ29uZmlybSA9IChjb21wbGV0aW9uOiBJQ29tcGxldGlvbik6IHZvaWQgPT4ge1xuICAgICAgICB0aGlzLm1vZGlmaWVkRmxhZyA9IHRydWU7XG4gICAgICAgIHRoaXMucHJvcHMubW9kZWwuYXV0b0NvbXBsZXRlLm9uQ29tcG9uZW50Q29uZmlybShjb21wbGV0aW9uKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbkF1dG9Db21wbGV0ZVNlbGVjdGlvbkNoYW5nZSA9IChjb21wbGV0aW9uSW5kZXg6IG51bWJlcik6IHZvaWQgPT4ge1xuICAgICAgICB0aGlzLm1vZGlmaWVkRmxhZyA9IHRydWU7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBjb21wbGV0aW9uSW5kZXggfSk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgY29uZmlndXJlRW1vdGljb25BdXRvUmVwbGFjZSA9ICgpOiB2b2lkID0+IHtcbiAgICAgICAgdGhpcy5wcm9wcy5tb2RlbC5zZXRUcmFuc2Zvcm1DYWxsYmFjayh0aGlzLnRyYW5zZm9ybSk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgY29uZmlndXJlU2hvdWxkU2hvd1BpbGxBdmF0YXIgPSAoKTogdm9pZCA9PiB7XG4gICAgICAgIGNvbnN0IHNob3dQaWxsQXZhdGFyID0gU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZShcIlBpbGwuc2hvdWxkU2hvd1BpbGxBdmF0YXJcIik7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBzaG93UGlsbEF2YXRhciB9KTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBzdXJyb3VuZFdpdGhTZXR0aW5nQ2hhbmdlZCA9ICgpID0+IHtcbiAgICAgICAgY29uc3Qgc3Vycm91bmRXaXRoID0gU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZShcIk1lc3NhZ2VDb21wb3NlcklucHV0LnN1cnJvdW5kV2l0aFwiKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHN1cnJvdW5kV2l0aCB9KTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSB0cmFuc2Zvcm0gPSAoZG9jdW1lbnRQb3NpdGlvbjogRG9jdW1lbnRQb3NpdGlvbik6IHZvaWQgPT4ge1xuICAgICAgICBjb25zdCBzaG91bGRSZXBsYWNlID0gU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZSgnTWVzc2FnZUNvbXBvc2VySW5wdXQuYXV0b1JlcGxhY2VFbW9qaScpO1xuICAgICAgICBpZiAoc2hvdWxkUmVwbGFjZSkgdGhpcy5yZXBsYWNlRW1vdGljb24oZG9jdW1lbnRQb3NpdGlvbiwgUkVHRVhfRU1PVElDT05fV0hJVEVTUEFDRSk7XG4gICAgfTtcblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgICAgICB0aGlzLmVkaXRvclJlZi5jdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLm9uSW5wdXQsIHRydWUpO1xuICAgICAgICB0aGlzLmVkaXRvclJlZi5jdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjb21wb3NpdGlvbnN0YXJ0XCIsIHRoaXMub25Db21wb3NpdGlvblN0YXJ0LCB0cnVlKTtcbiAgICAgICAgdGhpcy5lZGl0b3JSZWYuY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY29tcG9zaXRpb25lbmRcIiwgdGhpcy5vbkNvbXBvc2l0aW9uRW5kLCB0cnVlKTtcbiAgICAgICAgU2V0dGluZ3NTdG9yZS51bndhdGNoU2V0dGluZyh0aGlzLmVtb3RpY29uU2V0dGluZ0hhbmRsZSk7XG4gICAgICAgIFNldHRpbmdzU3RvcmUudW53YXRjaFNldHRpbmcodGhpcy5zaG91bGRTaG93UGlsbEF2YXRhclNldHRpbmdIYW5kbGUpO1xuICAgICAgICBTZXR0aW5nc1N0b3JlLnVud2F0Y2hTZXR0aW5nKHRoaXMuc3Vycm91bmRXaXRoSGFuZGxlKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLnByb3BzLm1vZGVsO1xuICAgICAgICBtb2RlbC5zZXRVcGRhdGVDYWxsYmFjayh0aGlzLnVwZGF0ZUVkaXRvclN0YXRlKTtcbiAgICAgICAgY29uc3QgcGFydENyZWF0b3IgPSBtb2RlbC5wYXJ0Q3JlYXRvcjtcbiAgICAgICAgLy8gVE9ETzogZG9lcyB0aGlzIGFsbG93IHVzIHRvIGdldCByaWQgb2YgRWRpdG9yU3RhdGVUcmFuc2Zlcj9cbiAgICAgICAgLy8gbm90IHJlYWxseSwgYnV0IHdlIGNvdWxkIG5vdCBzZXJpYWxpemUgdGhlIHBhcnRzLCBhbmQganVzdCBjaGFuZ2UgdGhlIGF1dG9Db21wbGV0ZXJcbiAgICAgICAgcGFydENyZWF0b3Iuc2V0QXV0b0NvbXBsZXRlQ3JlYXRvcihnZXRBdXRvQ29tcGxldGVDcmVhdG9yKFxuICAgICAgICAgICAgKCkgPT4gdGhpcy5hdXRvY29tcGxldGVSZWYuY3VycmVudCxcbiAgICAgICAgICAgIHF1ZXJ5ID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gdGhpcy5zZXRTdGF0ZSh7IHF1ZXJ5IH0sIHJlc29sdmUpKSxcbiAgICAgICAgKSk7XG4gICAgICAgIC8vIGluaXRpYWwgcmVuZGVyIG9mIG1vZGVsXG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yU3RhdGUodGhpcy5nZXRJbml0aWFsQ2FyZXRQb3NpdGlvbigpKTtcbiAgICAgICAgLy8gYXR0YWNoIGlucHV0IGxpc3RlbmVyIGJ5IGhhbmQgc28gUmVhY3QgZG9lc24ndCBwcm94eSB0aGUgZXZlbnRzLFxuICAgICAgICAvLyBhcyB0aGUgcHJveGllZCBldmVudCBkb2Vzbid0IHN1cHBvcnQgaW5wdXRUeXBlLCB3aGljaCB3ZSBuZWVkLlxuICAgICAgICB0aGlzLmVkaXRvclJlZi5jdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLm9uSW5wdXQsIHRydWUpO1xuICAgICAgICB0aGlzLmVkaXRvclJlZi5jdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjb21wb3NpdGlvbnN0YXJ0XCIsIHRoaXMub25Db21wb3NpdGlvblN0YXJ0LCB0cnVlKTtcbiAgICAgICAgdGhpcy5lZGl0b3JSZWYuY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiY29tcG9zaXRpb25lbmRcIiwgdGhpcy5vbkNvbXBvc2l0aW9uRW5kLCB0cnVlKTtcbiAgICAgICAgdGhpcy5lZGl0b3JSZWYuY3VycmVudC5mb2N1cygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0SW5pdGlhbENhcmV0UG9zaXRpb24oKTogRG9jdW1lbnRQb3NpdGlvbiB7XG4gICAgICAgIGxldCBjYXJldFBvc2l0aW9uOiBEb2N1bWVudFBvc2l0aW9uO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5pbml0aWFsQ2FyZXQpIHtcbiAgICAgICAgICAgIC8vIGlmIHJlc3RvcmluZyBzdGF0ZSBmcm9tIGEgcHJldmlvdXMgZWRpdG9yLFxuICAgICAgICAgICAgLy8gcmVzdG9yZSBjYXJldCBwb3NpdGlvbiBmcm9tIHRoZSBzdGF0ZVxuICAgICAgICAgICAgY29uc3QgY2FyZXQgPSB0aGlzLnByb3BzLmluaXRpYWxDYXJldDtcbiAgICAgICAgICAgIGNhcmV0UG9zaXRpb24gPSB0aGlzLnByb3BzLm1vZGVsLnBvc2l0aW9uRm9yT2Zmc2V0KGNhcmV0Lm9mZnNldCwgY2FyZXQuYXROb2RlRW5kKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgc2V0IGl0IGF0IHRoZSBlbmRcbiAgICAgICAgICAgIGNhcmV0UG9zaXRpb24gPSB0aGlzLnByb3BzLm1vZGVsLmdldFBvc2l0aW9uQXRFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FyZXRQb3NpdGlvbjtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uRm9ybWF0QWN0aW9uID0gKGFjdGlvbjogRm9ybWF0dGluZyk6IHZvaWQgPT4ge1xuICAgICAgICBjb25zdCByYW5nZSA9IGdldFJhbmdlRm9yU2VsZWN0aW9uKHRoaXMuZWRpdG9yUmVmLmN1cnJlbnQsIHRoaXMucHJvcHMubW9kZWwsIGRvY3VtZW50LmdldFNlbGVjdGlvbigpKTtcbiAgICAgICAgLy8gdHJpbSB0aGUgcmFuZ2UgYXMgd2Ugd2FudCBpdCB0byBleGNsdWRlIGxlYWRpbmcvdHJhaWxpbmcgc3BhY2VzXG4gICAgICAgIHJhbmdlLnRyaW0oKTtcblxuICAgICAgICBpZiAocmFuZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmhpc3RvcnlNYW5hZ2VyLmVuc3VyZUxhc3RDaGFuZ2VzUHVzaGVkKHRoaXMucHJvcHMubW9kZWwpO1xuICAgICAgICB0aGlzLm1vZGlmaWVkRmxhZyA9IHRydWU7XG4gICAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIEZvcm1hdHRpbmcuQm9sZDpcbiAgICAgICAgICAgICAgICB0b2dnbGVJbmxpbmVGb3JtYXQocmFuZ2UsIFwiKipcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEZvcm1hdHRpbmcuSXRhbGljczpcbiAgICAgICAgICAgICAgICB0b2dnbGVJbmxpbmVGb3JtYXQocmFuZ2UsIFwiX1wiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRm9ybWF0dGluZy5TdHJpa2V0aHJvdWdoOlxuICAgICAgICAgICAgICAgIHRvZ2dsZUlubGluZUZvcm1hdChyYW5nZSwgXCI8ZGVsPlwiLCBcIjwvZGVsPlwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRm9ybWF0dGluZy5Db2RlOlxuICAgICAgICAgICAgICAgIGZvcm1hdFJhbmdlQXNDb2RlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRm9ybWF0dGluZy5RdW90ZTpcbiAgICAgICAgICAgICAgICBmb3JtYXRSYW5nZUFzUXVvdGUocmFuZ2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBGb3JtYXR0aW5nLkluc2VydExpbms6XG4gICAgICAgICAgICAgICAgZm9ybWF0UmFuZ2VBc0xpbmsocmFuZ2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IGF1dG9Db21wbGV0ZTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuYXV0b0NvbXBsZXRlKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeSA9IHRoaXMuc3RhdGUucXVlcnk7XG4gICAgICAgICAgICBjb25zdCBxdWVyeUxlbiA9IHF1ZXJ5Lmxlbmd0aDtcbiAgICAgICAgICAgIGF1dG9Db21wbGV0ZSA9ICg8ZGl2IGNsYXNzTmFtZT1cIm14X0Jhc2ljTWVzc2FnZUNvbXBvc2VyX0F1dG9Db21wbGV0ZVdyYXBwZXJcIj5cbiAgICAgICAgICAgICAgICA8QXV0b2NvbXBsZXRlXG4gICAgICAgICAgICAgICAgICAgIHJlZj17dGhpcy5hdXRvY29tcGxldGVSZWZ9XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5PXtxdWVyeX1cbiAgICAgICAgICAgICAgICAgICAgb25Db25maXJtPXt0aGlzLm9uQXV0b0NvbXBsZXRlQ29uZmlybX1cbiAgICAgICAgICAgICAgICAgICAgb25TZWxlY3Rpb25DaGFuZ2U9e3RoaXMub25BdXRvQ29tcGxldGVTZWxlY3Rpb25DaGFuZ2V9XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbj17eyBiZWdpbm5pbmc6IHRydWUsIGVuZDogcXVlcnlMZW4sIHN0YXJ0OiBxdWVyeUxlbiB9fVxuICAgICAgICAgICAgICAgICAgICByb29tPXt0aGlzLnByb3BzLnJvb219XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2Pik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd3JhcHBlckNsYXNzZXMgPSBjbGFzc05hbWVzKFwibXhfQmFzaWNNZXNzYWdlQ29tcG9zZXJcIiwge1xuICAgICAgICAgICAgXCJteF9CYXNpY01lc3NhZ2VDb21wb3Nlcl9pbnB1dF9lcnJvclwiOiB0aGlzLnN0YXRlLnNob3dWaXN1YWxCZWxsLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2xhc3NlcyA9IGNsYXNzTmFtZXMoXCJteF9CYXNpY01lc3NhZ2VDb21wb3Nlcl9pbnB1dFwiLCB7XG4gICAgICAgICAgICBcIm14X0Jhc2ljTWVzc2FnZUNvbXBvc2VyX2lucHV0X3Nob3VsZFNob3dQaWxsQXZhdGFyXCI6IHRoaXMuc3RhdGUuc2hvd1BpbGxBdmF0YXIsXG4gICAgICAgICAgICBcIm14X0Jhc2ljTWVzc2FnZUNvbXBvc2VyX2lucHV0X2Rpc2FibGVkXCI6IHRoaXMucHJvcHMuZGlzYWJsZWQsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHNob3J0Y3V0cyA9IHtcbiAgICAgICAgICAgIFtGb3JtYXR0aW5nLkJvbGRdOiBjdHJsU2hvcnRjdXRMYWJlbChcIkJcIiksXG4gICAgICAgICAgICBbRm9ybWF0dGluZy5JdGFsaWNzXTogY3RybFNob3J0Y3V0TGFiZWwoXCJJXCIpLFxuICAgICAgICAgICAgW0Zvcm1hdHRpbmcuUXVvdGVdOiBjdHJsU2hvcnRjdXRMYWJlbChcIj5cIiksXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgeyBjb21wbGV0aW9uSW5kZXggfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IGhhc0F1dG9jb21wbGV0ZSA9IEJvb2xlYW4odGhpcy5zdGF0ZS5hdXRvQ29tcGxldGUpO1xuICAgICAgICBsZXQgYWN0aXZlRGVzY2VuZGFudDtcbiAgICAgICAgaWYgKGhhc0F1dG9jb21wbGV0ZSAmJiBjb21wbGV0aW9uSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgYWN0aXZlRGVzY2VuZGFudCA9IGdlbmVyYXRlQ29tcGxldGlvbkRvbUlkKGNvbXBsZXRpb25JbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKDxkaXYgY2xhc3NOYW1lPXt3cmFwcGVyQ2xhc3Nlc30+XG4gICAgICAgICAgICB7IGF1dG9Db21wbGV0ZSB9XG4gICAgICAgICAgICA8TWVzc2FnZUNvbXBvc2VyRm9ybWF0QmFyIHJlZj17dGhpcy5mb3JtYXRCYXJSZWZ9IG9uQWN0aW9uPXt0aGlzLm9uRm9ybWF0QWN0aW9ufSBzaG9ydGN1dHM9e3Nob3J0Y3V0c30gLz5cbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzZXN9XG4gICAgICAgICAgICAgICAgY29udGVudEVkaXRhYmxlPXt0aGlzLnByb3BzLmRpc2FibGVkID8gbnVsbCA6IHRydWV9XG4gICAgICAgICAgICAgICAgdGFiSW5kZXg9ezB9XG4gICAgICAgICAgICAgICAgb25CbHVyPXt0aGlzLm9uQmx1cn1cbiAgICAgICAgICAgICAgICBvbkZvY3VzPXt0aGlzLm9uRm9jdXN9XG4gICAgICAgICAgICAgICAgb25Db3B5PXt0aGlzLm9uQ29weX1cbiAgICAgICAgICAgICAgICBvbkN1dD17dGhpcy5vbkN1dH1cbiAgICAgICAgICAgICAgICBvblBhc3RlPXt0aGlzLm9uUGFzdGV9XG4gICAgICAgICAgICAgICAgb25LZXlEb3duPXt0aGlzLm9uS2V5RG93bn1cbiAgICAgICAgICAgICAgICByZWY9e3RoaXMuZWRpdG9yUmVmfVxuICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9e3RoaXMucHJvcHMubGFiZWx9XG4gICAgICAgICAgICAgICAgcm9sZT1cInRleHRib3hcIlxuICAgICAgICAgICAgICAgIGFyaWEtbXVsdGlsaW5lPVwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgYXJpYS1hdXRvY29tcGxldGU9XCJsaXN0XCJcbiAgICAgICAgICAgICAgICBhcmlhLWhhc3BvcHVwPVwibGlzdGJveFwiXG4gICAgICAgICAgICAgICAgYXJpYS1leHBhbmRlZD17aGFzQXV0b2NvbXBsZXRlfVxuICAgICAgICAgICAgICAgIGFyaWEtb3ducz1cIm14X0F1dG9jb21wbGV0ZVwiXG4gICAgICAgICAgICAgICAgYXJpYS1hY3RpdmVkZXNjZW5kYW50PXthY3RpdmVEZXNjZW5kYW50fVxuICAgICAgICAgICAgICAgIGRpcj1cImF1dG9cIlxuICAgICAgICAgICAgICAgIGFyaWEtZGlzYWJsZWQ9e3RoaXMucHJvcHMuZGlzYWJsZWR9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj4pO1xuICAgIH1cblxuICAgIHB1YmxpYyBmb2N1cygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5lZGl0b3JSZWYuY3VycmVudC5mb2N1cygpO1xuICAgIH1cblxuICAgIHB1YmxpYyBpbnNlcnRNZW50aW9uKHVzZXJJZDogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMubW9kaWZpZWRGbGFnID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBtb2RlbCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBwYXJ0Q3JlYXRvciB9ID0gbW9kZWw7XG4gICAgICAgIGNvbnN0IG1lbWJlciA9IHRoaXMucHJvcHMucm9vbS5nZXRNZW1iZXIodXNlcklkKTtcbiAgICAgICAgY29uc3QgZGlzcGxheU5hbWUgPSBtZW1iZXIgP1xuICAgICAgICAgICAgbWVtYmVyLnJhd0Rpc3BsYXlOYW1lIDogdXNlcklkO1xuICAgICAgICBjb25zdCBjYXJldCA9IHRoaXMuZ2V0Q2FyZXQoKTtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBtb2RlbC5wb3NpdGlvbkZvck9mZnNldChjYXJldC5vZmZzZXQsIGNhcmV0LmF0Tm9kZUVuZCk7XG4gICAgICAgIC8vIEluc2VydCBzdWZmaXggb25seSBpZiB0aGUgY2FyZXQgaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBjb21wb3NlclxuICAgICAgICBjb25zdCBwYXJ0cyA9IHBhcnRDcmVhdG9yLmNyZWF0ZU1lbnRpb25QYXJ0cyhjYXJldC5vZmZzZXQgPT09IDAsIGRpc3BsYXlOYW1lLCB1c2VySWQpO1xuICAgICAgICBtb2RlbC50cmFuc2Zvcm0oKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWRkZWRMZW4gPSBtb2RlbC5pbnNlcnQocGFydHMsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbC5wb3NpdGlvbkZvck9mZnNldChjYXJldC5vZmZzZXQgKyBhZGRlZExlbiwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyByZWZvY3VzIG9uIGNvbXBvc2VyLCBhcyB3ZSBqdXN0IGNsaWNrZWQgXCJNZW50aW9uXCJcbiAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgIH1cblxuICAgIHB1YmxpYyBpbnNlcnRRdW90ZWRNZXNzYWdlKGV2ZW50OiBNYXRyaXhFdmVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLm1vZGlmaWVkRmxhZyA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgbW9kZWwgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgcGFydENyZWF0b3IgfSA9IG1vZGVsO1xuICAgICAgICBjb25zdCBxdW90ZVBhcnRzID0gcGFyc2VFdmVudChldmVudCwgcGFydENyZWF0b3IsIHsgaXNRdW90ZWRNZXNzYWdlOiB0cnVlIH0pO1xuICAgICAgICAvLyBhZGQgdHdvIG5ld2xpbmVzXG4gICAgICAgIHF1b3RlUGFydHMucHVzaChwYXJ0Q3JlYXRvci5uZXdsaW5lKCkpO1xuICAgICAgICBxdW90ZVBhcnRzLnB1c2gocGFydENyZWF0b3IubmV3bGluZSgpKTtcbiAgICAgICAgbW9kZWwudHJhbnNmb3JtKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFkZGVkTGVuID0gbW9kZWwuaW5zZXJ0KHF1b3RlUGFydHMsIG1vZGVsLnBvc2l0aW9uRm9yT2Zmc2V0KDApKTtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbC5wb3NpdGlvbkZvck9mZnNldChhZGRlZExlbiwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyByZWZvY3VzIG9uIGNvbXBvc2VyLCBhcyB3ZSBqdXN0IGNsaWNrZWQgXCJRdW90ZVwiXG4gICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgaW5zZXJ0UGxhaW50ZXh0KHRleHQ6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLm1vZGlmaWVkRmxhZyA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgbW9kZWwgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgcGFydENyZWF0b3IgfSA9IG1vZGVsO1xuICAgICAgICBjb25zdCBjYXJldCA9IHRoaXMuZ2V0Q2FyZXQoKTtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBtb2RlbC5wb3NpdGlvbkZvck9mZnNldChjYXJldC5vZmZzZXQsIGNhcmV0LmF0Tm9kZUVuZCk7XG4gICAgICAgIG1vZGVsLnRyYW5zZm9ybSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhZGRlZExlbiA9IG1vZGVsLmluc2VydChbcGFydENyZWF0b3IucGxhaW4odGV4dCldLCBwb3NpdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWwucG9zaXRpb25Gb3JPZmZzZXQoY2FyZXQub2Zmc2V0ICsgYWRkZWRMZW4sIHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iXX0=