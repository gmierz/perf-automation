"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _highlight = _interopRequireDefault(require("highlight.js"));

var _event = require("matrix-js-sdk/src/@types/event");

var HtmlUtils = _interopRequireWildcard(require("../../../HtmlUtils"));

var _DateUtils = require("../../../DateUtils");

var _Modal = _interopRequireDefault(require("../../../Modal"));

var _dispatcher = _interopRequireDefault(require("../../../dispatcher/dispatcher"));

var _languageHandler = require("../../../languageHandler");

var ContextMenu = _interopRequireWildcard(require("../../structures/ContextMenu"));

var _SettingsStore = _interopRequireDefault(require("../../../settings/SettingsStore"));

var _ReplyChain = _interopRequireDefault(require("../elements/ReplyChain"));

var _pillify = require("../../../utils/pillify");

var _IntegrationManagers = require("../../../integrations/IntegrationManagers");

var _Permalinks = require("../../../utils/permalinks/Permalinks");

var _strings = require("../../../utils/strings");

var _AccessibleTooltipButton = _interopRequireDefault(require("../elements/AccessibleTooltipButton"));

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _UIStore = _interopRequireDefault(require("../../../stores/UIStore"));

var _actions = require("../../../dispatcher/actions");

var _GenericTextContextMenu = _interopRequireDefault(require("../context_menus/GenericTextContextMenu"));

var _Spoiler = _interopRequireDefault(require("../elements/Spoiler"));

var _QuestionDialog = _interopRequireDefault(require("../dialogs/QuestionDialog"));

var _MessageEditHistoryDialog = _interopRequireDefault(require("../dialogs/MessageEditHistoryDialog"));

var _EditMessageComposer = _interopRequireDefault(require("../rooms/EditMessageComposer"));

var _LinkPreviewGroup = _interopRequireDefault(require("../rooms/LinkPreviewGroup"));

var _RoomContext = _interopRequireDefault(require("../../../contexts/RoomContext"));

var _dec, _class, _class2, _temp;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const MAX_HIGHLIGHT_LENGTH = 4096;
let TextualBody = (_dec = (0, _replaceableComponent.replaceableComponent)("views.messages.TextualBody"), _dec(_class = (_temp = _class2 = class TextualBody extends _react.default.Component {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "contentRef", /*#__PURE__*/(0, _react.createRef)());
    (0, _defineProperty2.default)(this, "unmounted", false);
    (0, _defineProperty2.default)(this, "pills", []);
    (0, _defineProperty2.default)(this, "context", void 0);
    (0, _defineProperty2.default)(this, "onCancelClick", () => {
      this.setState({
        widgetHidden: true
      }); // FIXME: persist this somewhere smarter than local storage

      if (global.localStorage) {
        global.localStorage.setItem("hide_preview_" + this.props.mxEvent.getId(), "1");
      }

      this.forceUpdate();
    });
    (0, _defineProperty2.default)(this, "onEmoteSenderClick", () => {
      const mxEvent = this.props.mxEvent;

      _dispatcher.default.dispatch({
        action: _actions.Action.ComposerInsert,
        userId: mxEvent.getSender(),
        timelineRenderingType: this.context.timelineRenderingType
      });
    });
    (0, _defineProperty2.default)(this, "getEventTileOps", () => ({
      isWidgetHidden: () => {
        return this.state.widgetHidden;
      },
      unhideWidget: () => {
        this.setState({
          widgetHidden: false
        });

        if (global.localStorage) {
          global.localStorage.removeItem("hide_preview_" + this.props.mxEvent.getId());
        }
      }
    }));
    (0, _defineProperty2.default)(this, "onStarterLinkClick", (starterLink, ev) => {
      ev.preventDefault(); // We need to add on our scalar token to the starter link, but we may not have one!
      // In addition, we can't fetch one on click and then go to it immediately as that
      // is then treated as a popup!
      // We can get around this by fetching one now and showing a "confirmation dialog" (hurr hurr)
      // which requires the user to click through and THEN we can open the link in a new tab because
      // the window.open command occurs in the same stack frame as the onClick callback.

      const managers = _IntegrationManagers.IntegrationManagers.sharedInstance();

      if (!managers.hasManager()) {
        managers.openNoManagerDialog();
        return;
      } // Go fetch a scalar token


      const integrationManager = managers.getPrimaryManager();
      const scalarClient = integrationManager.getScalarClient();
      scalarClient.connect().then(() => {
        const completeUrl = scalarClient.getStarterLink(starterLink);
        const integrationsUrl = integrationManager.uiUrl;

        _Modal.default.createTrackedDialog('Add an integration', '', _QuestionDialog.default, {
          title: (0, _languageHandler._t)("Add an Integration"),
          description: /*#__PURE__*/_react.default.createElement("div", null, (0, _languageHandler._t)("You are about to be taken to a third-party site so you can " + "authenticate your account for use with %(integrationsUrl)s. " + "Do you wish to continue?", {
            integrationsUrl: integrationsUrl
          })),
          button: (0, _languageHandler._t)("Continue"),

          onFinished(confirmed) {
            if (!confirmed) {
              return;
            }

            const width = window.screen.width > 1024 ? 1024 : window.screen.width;
            const height = window.screen.height > 800 ? 800 : window.screen.height;
            const left = (window.screen.width - width) / 2;
            const top = (window.screen.height - height) / 2;
            const features = `height=${height}, width=${width}, top=${top}, left=${left},`;
            const wnd = window.open(completeUrl, '_blank', features);
            wnd.opener = null;
          }

        });
      });
    });
    (0, _defineProperty2.default)(this, "openHistoryDialog", async () => {
      _Modal.default.createDialog(_MessageEditHistoryDialog.default, {
        mxEvent: this.props.mxEvent
      });
    });
    this.state = {
      links: [],
      widgetHidden: false
    };
  }

  componentDidMount() {
    if (!this.props.editState) {
      this.applyFormatting();
    }
  }

  applyFormatting() {
    const showLineNumbers = _SettingsStore.default.getValue("showCodeLineNumbers");

    this.activateSpoilers([this.contentRef.current]); // pillifyLinks BEFORE linkifyElement because plain room/user URLs in the composer
    // are still sent as plaintext URLs. If these are ever pillified in the composer,
    // we should be pillify them here by doing the linkifying BEFORE the pillifying.

    (0, _pillify.pillifyLinks)([this.contentRef.current], this.props.mxEvent, this.pills);
    HtmlUtils.linkifyElement(this.contentRef.current);
    this.calculateUrlPreview();

    if (this.props.mxEvent.getContent().format === "org.matrix.custom.html") {
      // Handle expansion and add buttons
      const pres = _reactDom.default.findDOMNode(this).getElementsByTagName("pre");

      if (pres.length > 0) {
        for (let i = 0; i < pres.length; i++) {
          // If there already is a div wrapping the codeblock we want to skip this.
          // This happens after the codeblock was edited.
          if (pres[i].parentElement.className == "mx_EventTile_pre_container") continue; // Add code element if it's missing since we depend on it

          if (pres[i].getElementsByTagName("code").length == 0) {
            this.addCodeElement(pres[i]);
          } // Wrap a div around <pre> so that the copy button can be correctly positioned
          // when the <pre> overflows and is scrolled horizontally.


          const div = this.wrapInDiv(pres[i]);
          this.handleCodeBlockExpansion(pres[i]);
          this.addCodeExpansionButton(div, pres[i]);
          this.addCodeCopyButton(div);

          if (showLineNumbers) {
            this.addLineNumbers(pres[i]);
          }
        }
      } // Highlight code


      const codes = _reactDom.default.findDOMNode(this).getElementsByTagName("code");

      if (codes.length > 0) {
        // Do this asynchronously: parsing code takes time and we don't
        // need to block the DOM update on it.
        setTimeout(() => {
          if (this.unmounted) return;

          for (let i = 0; i < codes.length; i++) {
            this.highlightCode(codes[i]);
          }
        }, 10);
      }
    }
  }

  addCodeElement(pre) {
    const code = document.createElement("code");
    code.append(...pre.childNodes);
    pre.appendChild(code);
  }

  addCodeExpansionButton(div, pre) {
    // Calculate how many percent does the pre element take up.
    // If it's less than 30% we don't add the expansion button.
    // We also round the number as it sometimes can be 29.99...
    const percentageOfViewport = Math.round(pre.offsetHeight / _UIStore.default.instance.windowHeight * 100); // TODO: additionally show the button if it's an expanded quoted message

    if (percentageOfViewport < 30) return;
    const button = document.createElement("span");
    button.className = "mx_EventTile_button ";

    if (pre.className == "mx_EventTile_collapsedCodeBlock") {
      button.className += "mx_EventTile_expandButton";
    } else {
      button.className += "mx_EventTile_collapseButton";
    }

    button.onclick = async () => {
      button.className = "mx_EventTile_button ";

      if (pre.className == "mx_EventTile_collapsedCodeBlock") {
        pre.className = "";
        button.className += "mx_EventTile_collapseButton";
      } else {
        pre.className = "mx_EventTile_collapsedCodeBlock";
        button.className += "mx_EventTile_expandButton";
      } // By expanding/collapsing we changed
      // the height, therefore we call this


      this.props.onHeightChanged();
    };

    div.appendChild(button);
  }

  addCodeCopyButton(div) {
    const button = document.createElement("span");
    button.className = "mx_EventTile_button mx_EventTile_copyButton "; // Check if expansion button exists. If so
    // we put the copy button to the bottom

    const expansionButtonExists = div.getElementsByClassName("mx_EventTile_button");
    if (expansionButtonExists.length > 0) button.className += "mx_EventTile_buttonBottom";

    button.onclick = async () => {
      const copyCode = button.parentElement.getElementsByTagName("code")[0];
      const successful = await (0, _strings.copyPlaintext)(copyCode.textContent);
      const buttonRect = button.getBoundingClientRect();
      const {
        close
      } = ContextMenu.createMenu(_GenericTextContextMenu.default, _objectSpread(_objectSpread({}, (0, ContextMenu.toRightOf)(buttonRect, 2)), {}, {
        message: successful ? (0, _languageHandler._t)('Copied!') : (0, _languageHandler._t)('Failed to copy')
      }));
      button.onmouseleave = close;
    };

    div.appendChild(button);
  }

  wrapInDiv(pre) {
    const div = document.createElement("div");
    div.className = "mx_EventTile_pre_container"; // Insert containing div in place of <pre> block

    pre.parentNode.replaceChild(div, pre); // Append <pre> block and copy button to container

    div.appendChild(pre);
    return div;
  }

  handleCodeBlockExpansion(pre) {
    if (!_SettingsStore.default.getValue("expandCodeByDefault")) {
      pre.className = "mx_EventTile_collapsedCodeBlock";
    }
  }

  addLineNumbers(pre) {
    // Calculate number of lines in pre
    const number = pre.innerHTML.replace(/\n(<\/code>)?$/, "").split(/\n/).length;
    const lineNumbers = document.createElement('span');
    lineNumbers.className = 'mx_EventTile_lineNumbers'; // Iterate through lines starting with 1 (number of the first line is 1)

    for (let i = 1; i <= number; i++) {
      const s = document.createElement('span');
      s.textContent = i.toString();
      lineNumbers.appendChild(s);
    }

    pre.prepend(lineNumbers);
    pre.append(document.createElement('span'));
  }

  highlightCode(code) {
    if (code.textContent.length > MAX_HIGHLIGHT_LENGTH) {
      console.log("Code block is bigger than highlight limit (" + code.textContent.length + " > " + MAX_HIGHLIGHT_LENGTH + "): not highlighting");
      return;
    }

    let advertisedLang;

    for (const cl of code.className.split(/\s+/)) {
      if (cl.startsWith('language-')) {
        const maybeLang = cl.split('-', 2)[1];

        if (_highlight.default.getLanguage(maybeLang)) {
          advertisedLang = maybeLang;
          break;
        }
      }
    }

    if (advertisedLang) {
      // If the code says what language it is, highlight it in that language
      // We don't use highlightElement here because we can't force language detection
      // off. It should use the one we've found in the CSS class but we'd rather pass
      // it in explicitly to make sure.
      code.innerHTML = _highlight.default.highlight(advertisedLang, code.textContent).value;
    } else if (_SettingsStore.default.getValue("enableSyntaxHighlightLanguageDetection") && code.parentElement instanceof HTMLPreElement) {
      // User has language detection enabled and the code is within a pre
      // we only auto-highlight if the code block is in a pre), so highlight
      // the block with auto-highlighting enabled.
      // We pass highlightjs the text to highlight rather than letting it
      // work on the DOM with highlightElement because that also adds CSS
      // classes to the pre/code element that we don't want (the CSS
      // conflicts with our own).
      code.innerHTML = _highlight.default.highlightAuto(code.textContent).value;
    }
  }

  componentDidUpdate(prevProps) {
    if (!this.props.editState) {
      const stoppedEditing = prevProps.editState && !this.props.editState;
      const messageWasEdited = prevProps.replacingEventId !== this.props.replacingEventId;

      if (messageWasEdited || stoppedEditing) {
        this.applyFormatting();
      }
    }
  }

  componentWillUnmount() {
    this.unmounted = true;
    (0, _pillify.unmountPills)(this.pills);
  }

  shouldComponentUpdate(nextProps, nextState) {
    //console.info("shouldComponentUpdate: ShowUrlPreview for %s is %s", this.props.mxEvent.getId(), this.props.showUrlPreview);
    // exploit that events are immutable :)
    return nextProps.mxEvent.getId() !== this.props.mxEvent.getId() || nextProps.highlights !== this.props.highlights || nextProps.replacingEventId !== this.props.replacingEventId || nextProps.highlightLink !== this.props.highlightLink || nextProps.showUrlPreview !== this.props.showUrlPreview || nextProps.editState !== this.props.editState || nextState.links !== this.state.links || nextState.widgetHidden !== this.state.widgetHidden;
  }

  calculateUrlPreview() {
    //console.info("calculateUrlPreview: ShowUrlPreview for %s is %s", this.props.mxEvent.getId(), this.props.showUrlPreview);
    if (this.props.showUrlPreview) {
      // pass only the first child which is the event tile otherwise this recurses on edited events
      let links = this.findLinks([this.contentRef.current]);

      if (links.length) {
        // de-duplicate the links using a set here maintains the order
        links = Array.from(new Set(links));
        this.setState({
          links
        }); // lazy-load the hidden state of the preview widget from localstorage

        if (window.localStorage) {
          const hidden = !!window.localStorage.getItem("hide_preview_" + this.props.mxEvent.getId());
          this.setState({
            widgetHidden: hidden
          });
        }
      } else if (this.state.links.length) {
        this.setState({
          links: []
        });
      }
    }
  }

  activateSpoilers(nodes) {
    let node = nodes[0];

    while (node) {
      if (node.tagName === "SPAN" && typeof node.getAttribute("data-mx-spoiler") === "string") {
        const spoilerContainer = document.createElement('span');
        const reason = node.getAttribute("data-mx-spoiler");
        node.removeAttribute("data-mx-spoiler"); // we don't want to recurse

        const spoiler = /*#__PURE__*/_react.default.createElement(_Spoiler.default, {
          reason: reason,
          contentHtml: node.outerHTML
        });

        _reactDom.default.render(spoiler, spoilerContainer);

        node.parentNode.replaceChild(spoilerContainer, node);
        node = spoilerContainer;
      }

      if (node.childNodes && node.childNodes.length) {
        this.activateSpoilers(node.childNodes);
      }

      node = node.nextSibling;
    }
  }

  findLinks(nodes) {
    let links = [];

    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];

      if (node.tagName === "A" && node.getAttribute("href")) {
        if (this.isLinkPreviewable(node)) {
          links.push(node.getAttribute("href"));
        }
      } else if (node.tagName === "PRE" || node.tagName === "CODE" || node.tagName === "BLOCKQUOTE") {
        continue;
      } else if (node.children && node.children.length) {
        links = links.concat(this.findLinks(node.children));
      }
    }

    return links;
  }

  isLinkPreviewable(node) {
    // don't try to preview relative links
    if (!node.getAttribute("href").startsWith("http://") && !node.getAttribute("href").startsWith("https://")) {
      return false;
    } // as a random heuristic to avoid highlighting things like "foo.pl"
    // we require the linked text to either include a / (either from http://
    // or from a full foo.bar/baz style schemeless URL) - or be a markdown-style
    // link, in which case we check the target text differs from the link value.
    // TODO: make this configurable?


    if (node.textContent.indexOf("/") > -1) {
      return true;
    } else {
      const url = node.getAttribute("href");
      const host = url.match(/^https?:\/\/(.*?)(\/|$)/)[1]; // never preview permalinks (if anything we should give a smart
      // preview of the room/user they point to: nobody needs to be reminded
      // what the matrix.to site looks like).

      if ((0, _Permalinks.isPermalinkHost)(host)) return false;

      if (node.textContent.toLowerCase().trim().startsWith(host.toLowerCase())) {
        // it's a "foo.pl" style link
        return false;
      } else {
        // it's a [foo bar](http://foo.com) style link
        return true;
      }
    }
  }

  renderEditedMarker() {
    const date = this.props.mxEvent.replacingEventDate();
    const dateString = date && (0, _DateUtils.formatDate)(date);

    const tooltip = /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_Tooltip_title"
    }, (0, _languageHandler._t)("Edited at %(date)s", {
      date: dateString
    })), /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_Tooltip_sub"
    }, (0, _languageHandler._t)("Click to view edits")));

    return /*#__PURE__*/_react.default.createElement(_AccessibleTooltipButton.default, {
      className: "mx_EventTile_edited",
      onClick: this.openHistoryDialog,
      title: (0, _languageHandler._t)("Edited at %(date)s. Click to view edits.", {
        date: dateString
      }),
      tooltip: tooltip
    }, /*#__PURE__*/_react.default.createElement("span", null, `(${(0, _languageHandler._t)("edited")})`));
  }

  render() {
    if (this.props.editState) {
      return /*#__PURE__*/_react.default.createElement(_EditMessageComposer.default, {
        editState: this.props.editState,
        className: "mx_EventTile_content"
      });
    }

    const mxEvent = this.props.mxEvent;
    const content = mxEvent.getContent(); // only strip reply if this is the original replying event, edits thereafter do not have the fallback

    const stripReply = !mxEvent.replacingEvent() && !!_ReplyChain.default.getParentEventId(mxEvent);
    let body = HtmlUtils.bodyToHtml(content, this.props.highlights, {
      disableBigEmoji: content.msgtype === _event.MsgType.Emote || !_SettingsStore.default.getValue('TextualBody.enableBigEmoji'),
      // Part of Replies fallback support
      stripReplyFallback: stripReply,
      ref: this.contentRef,
      returnString: false
    });

    if (this.props.replacingEventId) {
      body = /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, body, this.renderEditedMarker());
    }

    if (this.props.highlightLink) {
      body = /*#__PURE__*/_react.default.createElement("a", {
        href: this.props.highlightLink
      }, body);
    } else if (content.data && typeof content.data["org.matrix.neb.starter_link"] === "string") {
      body = /*#__PURE__*/_react.default.createElement("a", {
        href: "#",
        onClick: this.onStarterLinkClick.bind(this, content.data["org.matrix.neb.starter_link"])
      }, body);
    }

    let widgets;

    if (this.state.links.length && !this.state.widgetHidden && this.props.showUrlPreview) {
      widgets = /*#__PURE__*/_react.default.createElement(_LinkPreviewGroup.default, {
        links: this.state.links,
        mxEvent: this.props.mxEvent,
        onCancelClick: this.onCancelClick,
        onHeightChanged: this.props.onHeightChanged
      });
    }

    switch (content.msgtype) {
      case _event.MsgType.Emote:
        return /*#__PURE__*/_react.default.createElement("div", {
          className: "mx_MEmoteBody mx_EventTile_content"
        }, "*\xA0", /*#__PURE__*/_react.default.createElement("span", {
          className: "mx_MEmoteBody_sender",
          onClick: this.onEmoteSenderClick
        }, mxEvent.sender ? mxEvent.sender.name : mxEvent.getSender()), "\xA0", body, widgets);

      case _event.MsgType.Notice:
        return /*#__PURE__*/_react.default.createElement("div", {
          className: "mx_MNoticeBody mx_EventTile_content"
        }, body, widgets);

      default:
        // including "m.text"
        return /*#__PURE__*/_react.default.createElement("div", {
          className: "mx_MTextBody mx_EventTile_content"
        }, body, widgets);
    }
  }

}, (0, _defineProperty2.default)(_class2, "contextType", _RoomContext.default), _temp)) || _class);
exports.default = TextualBody;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL21lc3NhZ2VzL1RleHR1YWxCb2R5LnRzeCJdLCJuYW1lcyI6WyJNQVhfSElHSExJR0hUX0xFTkdUSCIsIlRleHR1YWxCb2R5IiwiUmVhY3QiLCJDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsInByb3BzIiwic2V0U3RhdGUiLCJ3aWRnZXRIaWRkZW4iLCJnbG9iYWwiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwibXhFdmVudCIsImdldElkIiwiZm9yY2VVcGRhdGUiLCJkaXMiLCJkaXNwYXRjaCIsImFjdGlvbiIsIkFjdGlvbiIsIkNvbXBvc2VySW5zZXJ0IiwidXNlcklkIiwiZ2V0U2VuZGVyIiwidGltZWxpbmVSZW5kZXJpbmdUeXBlIiwiY29udGV4dCIsImlzV2lkZ2V0SGlkZGVuIiwic3RhdGUiLCJ1bmhpZGVXaWRnZXQiLCJyZW1vdmVJdGVtIiwic3RhcnRlckxpbmsiLCJldiIsInByZXZlbnREZWZhdWx0IiwibWFuYWdlcnMiLCJJbnRlZ3JhdGlvbk1hbmFnZXJzIiwic2hhcmVkSW5zdGFuY2UiLCJoYXNNYW5hZ2VyIiwib3Blbk5vTWFuYWdlckRpYWxvZyIsImludGVncmF0aW9uTWFuYWdlciIsImdldFByaW1hcnlNYW5hZ2VyIiwic2NhbGFyQ2xpZW50IiwiZ2V0U2NhbGFyQ2xpZW50IiwiY29ubmVjdCIsInRoZW4iLCJjb21wbGV0ZVVybCIsImdldFN0YXJ0ZXJMaW5rIiwiaW50ZWdyYXRpb25zVXJsIiwidWlVcmwiLCJNb2RhbCIsImNyZWF0ZVRyYWNrZWREaWFsb2ciLCJRdWVzdGlvbkRpYWxvZyIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJidXR0b24iLCJvbkZpbmlzaGVkIiwiY29uZmlybWVkIiwid2lkdGgiLCJ3aW5kb3ciLCJzY3JlZW4iLCJoZWlnaHQiLCJsZWZ0IiwidG9wIiwiZmVhdHVyZXMiLCJ3bmQiLCJvcGVuIiwib3BlbmVyIiwiY3JlYXRlRGlhbG9nIiwiTWVzc2FnZUVkaXRIaXN0b3J5RGlhbG9nIiwibGlua3MiLCJjb21wb25lbnREaWRNb3VudCIsImVkaXRTdGF0ZSIsImFwcGx5Rm9ybWF0dGluZyIsInNob3dMaW5lTnVtYmVycyIsIlNldHRpbmdzU3RvcmUiLCJnZXRWYWx1ZSIsImFjdGl2YXRlU3BvaWxlcnMiLCJjb250ZW50UmVmIiwiY3VycmVudCIsInBpbGxzIiwiSHRtbFV0aWxzIiwibGlua2lmeUVsZW1lbnQiLCJjYWxjdWxhdGVVcmxQcmV2aWV3IiwiZ2V0Q29udGVudCIsImZvcm1hdCIsInByZXMiLCJSZWFjdERPTSIsImZpbmRET01Ob2RlIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJsZW5ndGgiLCJpIiwicGFyZW50RWxlbWVudCIsImNsYXNzTmFtZSIsImFkZENvZGVFbGVtZW50IiwiZGl2Iiwid3JhcEluRGl2IiwiaGFuZGxlQ29kZUJsb2NrRXhwYW5zaW9uIiwiYWRkQ29kZUV4cGFuc2lvbkJ1dHRvbiIsImFkZENvZGVDb3B5QnV0dG9uIiwiYWRkTGluZU51bWJlcnMiLCJjb2RlcyIsInNldFRpbWVvdXQiLCJ1bm1vdW50ZWQiLCJoaWdobGlnaHRDb2RlIiwicHJlIiwiY29kZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImFwcGVuZCIsImNoaWxkTm9kZXMiLCJhcHBlbmRDaGlsZCIsInBlcmNlbnRhZ2VPZlZpZXdwb3J0IiwiTWF0aCIsInJvdW5kIiwib2Zmc2V0SGVpZ2h0IiwiVUlTdG9yZSIsImluc3RhbmNlIiwid2luZG93SGVpZ2h0Iiwib25jbGljayIsIm9uSGVpZ2h0Q2hhbmdlZCIsImV4cGFuc2lvbkJ1dHRvbkV4aXN0cyIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJjb3B5Q29kZSIsInN1Y2Nlc3NmdWwiLCJ0ZXh0Q29udGVudCIsImJ1dHRvblJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjbG9zZSIsIkNvbnRleHRNZW51IiwiY3JlYXRlTWVudSIsIkdlbmVyaWNUZXh0Q29udGV4dE1lbnUiLCJtZXNzYWdlIiwib25tb3VzZWxlYXZlIiwicGFyZW50Tm9kZSIsInJlcGxhY2VDaGlsZCIsIm51bWJlciIsImlubmVySFRNTCIsInJlcGxhY2UiLCJzcGxpdCIsImxpbmVOdW1iZXJzIiwicyIsInRvU3RyaW5nIiwicHJlcGVuZCIsImNvbnNvbGUiLCJsb2ciLCJhZHZlcnRpc2VkTGFuZyIsImNsIiwic3RhcnRzV2l0aCIsIm1heWJlTGFuZyIsImhpZ2hsaWdodCIsImdldExhbmd1YWdlIiwidmFsdWUiLCJIVE1MUHJlRWxlbWVudCIsImhpZ2hsaWdodEF1dG8iLCJjb21wb25lbnREaWRVcGRhdGUiLCJwcmV2UHJvcHMiLCJzdG9wcGVkRWRpdGluZyIsIm1lc3NhZ2VXYXNFZGl0ZWQiLCJyZXBsYWNpbmdFdmVudElkIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJuZXh0UHJvcHMiLCJuZXh0U3RhdGUiLCJoaWdobGlnaHRzIiwiaGlnaGxpZ2h0TGluayIsInNob3dVcmxQcmV2aWV3IiwiZmluZExpbmtzIiwiQXJyYXkiLCJmcm9tIiwiU2V0IiwiaGlkZGVuIiwiZ2V0SXRlbSIsIm5vZGVzIiwibm9kZSIsInRhZ05hbWUiLCJnZXRBdHRyaWJ1dGUiLCJzcG9pbGVyQ29udGFpbmVyIiwicmVhc29uIiwicmVtb3ZlQXR0cmlidXRlIiwic3BvaWxlciIsIm91dGVySFRNTCIsInJlbmRlciIsIm5leHRTaWJsaW5nIiwiaXNMaW5rUHJldmlld2FibGUiLCJwdXNoIiwiY2hpbGRyZW4iLCJjb25jYXQiLCJpbmRleE9mIiwidXJsIiwiaG9zdCIsIm1hdGNoIiwidG9Mb3dlckNhc2UiLCJ0cmltIiwicmVuZGVyRWRpdGVkTWFya2VyIiwiZGF0ZSIsInJlcGxhY2luZ0V2ZW50RGF0ZSIsImRhdGVTdHJpbmciLCJ0b29sdGlwIiwib3Blbkhpc3RvcnlEaWFsb2ciLCJjb250ZW50Iiwic3RyaXBSZXBseSIsInJlcGxhY2luZ0V2ZW50IiwiUmVwbHlDaGFpbiIsImdldFBhcmVudEV2ZW50SWQiLCJib2R5IiwiYm9keVRvSHRtbCIsImRpc2FibGVCaWdFbW9qaSIsIm1zZ3R5cGUiLCJNc2dUeXBlIiwiRW1vdGUiLCJzdHJpcFJlcGx5RmFsbGJhY2siLCJyZWYiLCJyZXR1cm5TdHJpbmciLCJkYXRhIiwib25TdGFydGVyTGlua0NsaWNrIiwiYmluZCIsIndpZGdldHMiLCJvbkNhbmNlbENsaWNrIiwib25FbW90ZVNlbmRlckNsaWNrIiwic2VuZGVyIiwibmFtZSIsIk5vdGljZSIsIlJvb21Db250ZXh0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWdCQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FBRUEsTUFBTUEsb0JBQW9CLEdBQUcsSUFBN0I7SUFXcUJDLFcsV0FEcEIsZ0RBQXFCLDRCQUFyQixDLG1DQUFELE1BQ3FCQSxXQURyQixTQUN5Q0MsZUFBTUMsU0FEL0MsQ0FDNkU7QUFTekVDLEVBQUFBLFdBQVcsQ0FBQ0MsS0FBRCxFQUFRO0FBQ2YsVUFBTUEsS0FBTjtBQURlLG1FQVJXLHVCQVFYO0FBQUEscURBTkMsS0FNRDtBQUFBLGlEQUxRLEVBS1I7QUFBQTtBQUFBLHlEQTBVSyxNQUFZO0FBQ2hDLFdBQUtDLFFBQUwsQ0FBYztBQUFFQyxRQUFBQSxZQUFZLEVBQUU7QUFBaEIsT0FBZCxFQURnQyxDQUVoQzs7QUFDQSxVQUFJQyxNQUFNLENBQUNDLFlBQVgsRUFBeUI7QUFDckJELFFBQUFBLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQkMsT0FBcEIsQ0FBNEIsa0JBQWtCLEtBQUtMLEtBQUwsQ0FBV00sT0FBWCxDQUFtQkMsS0FBbkIsRUFBOUMsRUFBMEUsR0FBMUU7QUFDSDs7QUFDRCxXQUFLQyxXQUFMO0FBQ0gsS0FqVmtCO0FB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QVgsQ0FBaUJvQixNQUFqQixJQUEyQixDQUFDLEtBQUs3RCxLQUFMLENBQVdqQixZQUF2QyxJQUF1RCxLQUFLRixLQUFMLENBQVc0SixjQUF0RSxFQUFzRjtBQUNsRm1ELE1BQUFBLE9BQU8sZ0JBQUcsNkJBQUMseUJBQUQ7QUFDTixRQUFBLEtBQUssRUFBRSxLQUFLNUwsS0FBTCxDQUFXeUMsS0FEWjtBQUVOLFFBQUEsT0FBTyxFQUFFLEtBQUs1RCxLQUFMLENBQVdNLE9BRmQ7QUFHTixRQUFBLGFBQWEsRUFBRSxLQUFLME0sYUFIZDtBQUlOLFFBQUEsZUFBZSxFQUFFLEtBQUtoTixLQUFMLENBQVc4RztBQUp0QixRQUFWO0FBTUg7O0FBRUQsWUFBUWdGLE9BQU8sQ0FBQ1EsT0FBaEI7QUFDSSxXQUFLQyxlQUFRQyxLQUFiO0FBQ0ksNEJBQ0k7QUFBSyxVQUFBLFNBQVMsRUFBQztBQUFmLGlDQUVJO0FBQ0ksVUFBQSxTQUFTLEVBQUMsc0JBRGQ7QUFFSSxVQUFBLE9BQU8sRUFBRSxLQUFLUztBQUZsQixXQUlNM00sT0FBTyxDQUFDNE0sTUFBUixHQUFpQjVNLE9BQU8sQ0FBQzRNLE1BQVIsQ0FBZUMsSUFBaEMsR0FBdUM3TSxPQUFPLENBQUNTLFNBQVIsRUFKN0MsQ0FGSixVQVNNb0wsSUFUTixFQVVNWSxPQVZOLENBREo7O0FBY0osV0FBS1IsZUFBUWEsTUFBYjtBQUNJLDRCQUNJO0FBQUssVUFBQSxTQUFTLEVBQUM7QUFBZixXQUNNakIsSUFETixFQUVNWSxPQUZOLENBREo7O0FBTUo7QUFBUztBQUNMLDRCQUNJO0FBQUssVUFBQSxTQUFTLEVBQUM7QUFBZixXQUNNWixJQUROLEVBRU1ZLE9BRk4sQ0FESjtBQXhCUjtBQStCSDs7QUF0Z0J3RSxDLHdEQU1wRE0sb0IiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMTUgLSAyMDIxIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZVJlZiwgU3ludGhldGljRXZlbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBoaWdobGlnaHQgZnJvbSAnaGlnaGxpZ2h0LmpzJztcbmltcG9ydCB7IE1zZ1R5cGUgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvQHR5cGVzL2V2ZW50XCI7XG5cbmltcG9ydCAqIGFzIEh0bWxVdGlscyBmcm9tICcuLi8uLi8uLi9IdG1sVXRpbHMnO1xuaW1wb3J0IHsgZm9ybWF0RGF0ZSB9IGZyb20gJy4uLy4uLy4uL0RhdGVVdGlscyc7XG5pbXBvcnQgTW9kYWwgZnJvbSAnLi4vLi4vLi4vTW9kYWwnO1xuaW1wb3J0IGRpcyBmcm9tICcuLi8uLi8uLi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXInO1xuaW1wb3J0IHsgX3QgfSBmcm9tICcuLi8uLi8uLi9sYW5ndWFnZUhhbmRsZXInO1xuaW1wb3J0ICogYXMgQ29udGV4dE1lbnUgZnJvbSAnLi4vLi4vc3RydWN0dXJlcy9Db250ZXh0TWVudSc7XG5pbXBvcnQgeyB0b1JpZ2h0T2YgfSBmcm9tICcuLi8uLi9zdHJ1Y3R1cmVzL0NvbnRleHRNZW51JztcbmltcG9ydCBTZXR0aW5nc1N0b3JlIGZyb20gXCIuLi8uLi8uLi9zZXR0aW5ncy9TZXR0aW5nc1N0b3JlXCI7XG5pbXBvcnQgUmVwbHlDaGFpbiBmcm9tIFwiLi4vZWxlbWVudHMvUmVwbHlDaGFpblwiO1xuaW1wb3J0IHsgcGlsbGlmeUxpbmtzLCB1bm1vdW50UGlsbHMgfSBmcm9tICcuLi8uLi8uLi91dGlscy9waWxsaWZ5JztcbmltcG9ydCB7IEludGVncmF0aW9uTWFuYWdlcnMgfSBmcm9tIFwiLi4vLi4vLi4vaW50ZWdyYXRpb25zL0ludGVncmF0aW9uTWFuYWdlcnNcIjtcbmltcG9ydCB7IGlzUGVybWFsaW5rSG9zdCB9IGZyb20gXCIuLi8uLi8uLi91dGlscy9wZXJtYWxpbmtzL1Blcm1hbGlua3NcIjtcbmltcG9ydCB7IGNvcHlQbGFpbnRleHQgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvc3RyaW5nc1wiO1xuaW1wb3J0IEFjY2Vzc2libGVUb29sdGlwQnV0dG9uIGZyb20gXCIuLi9lbGVtZW50cy9BY2Nlc3NpYmxlVG9vbHRpcEJ1dHRvblwiO1xuaW1wb3J0IHsgcmVwbGFjZWFibGVDb21wb25lbnQgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvcmVwbGFjZWFibGVDb21wb25lbnRcIjtcbmltcG9ydCBVSVN0b3JlIGZyb20gXCIuLi8uLi8uLi9zdG9yZXMvVUlTdG9yZVwiO1xuaW1wb3J0IHsgQ29tcG9zZXJJbnNlcnRQYXlsb2FkIH0gZnJvbSBcIi4uLy4uLy4uL2Rpc3BhdGNoZXIvcGF5bG9hZHMvQ29tcG9zZXJJbnNlcnRQYXlsb2FkXCI7XG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tIFwiLi4vLi4vLi4vZGlzcGF0Y2hlci9hY3Rpb25zXCI7XG5pbXBvcnQgR2VuZXJpY1RleHRDb250ZXh0TWVudSBmcm9tIFwiLi4vY29udGV4dF9tZW51cy9HZW5lcmljVGV4dENvbnRleHRNZW51XCI7XG5pbXBvcnQgU3BvaWxlciBmcm9tIFwiLi4vZWxlbWVudHMvU3BvaWxlclwiO1xuaW1wb3J0IFF1ZXN0aW9uRGlhbG9nIGZyb20gXCIuLi9kaWFsb2dzL1F1ZXN0aW9uRGlhbG9nXCI7XG5pbXBvcnQgTWVzc2FnZUVkaXRIaXN0b3J5RGlhbG9nIGZyb20gXCIuLi9kaWFsb2dzL01lc3NhZ2VFZGl0SGlzdG9yeURpYWxvZ1wiO1xuaW1wb3J0IEVkaXRNZXNzYWdlQ29tcG9zZXIgZnJvbSAnLi4vcm9vbXMvRWRpdE1lc3NhZ2VDb21wb3Nlcic7XG5pbXBvcnQgTGlua1ByZXZpZXdHcm91cCBmcm9tICcuLi9yb29tcy9MaW5rUHJldmlld0dyb3VwJztcbmltcG9ydCB7IElCb2R5UHJvcHMgfSBmcm9tIFwiLi9JQm9keVByb3BzXCI7XG5pbXBvcnQgUm9vbUNvbnRleHQgZnJvbSBcIi4uLy4uLy4uL2NvbnRleHRzL1Jvb21Db250ZXh0XCI7XG5cbmNvbnN0IE1BWF9ISUdITElHSFRfTEVOR1RIID0gNDA5NjtcblxuaW50ZXJmYWNlIElTdGF0ZSB7XG4gICAgLy8gdGhlIFVSTHMgKGlmIGFueSkgdG8gYmUgcHJldmlld2VkIHdpdGggYSBMaW5rUHJldmlld1dpZGdldCBpbnNpZGUgdGhpcyBUZXh0dWFsQm9keS5cbiAgICBsaW5rczogc3RyaW5nW107XG5cbiAgICAvLyB0cmFjayB3aGV0aGVyIHRoZSBwcmV2aWV3IHdpZGdldCBpcyBoaWRkZW5cbiAgICB3aWRnZXRIaWRkZW46IGJvb2xlYW47XG59XG5cbkByZXBsYWNlYWJsZUNvbXBvbmVudChcInZpZXdzLm1lc3NhZ2VzLlRleHR1YWxCb2R5XCIpXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0dWFsQm9keSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxJQm9keVByb3BzLCBJU3RhdGU+IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNvbnRlbnRSZWYgPSBjcmVhdGVSZWY8SFRNTFNwYW5FbGVtZW50PigpO1xuXG4gICAgcHJpdmF0ZSB1bm1vdW50ZWQgPSBmYWxzZTtcbiAgICBwcml2YXRlIHBpbGxzOiBFbGVtZW50W10gPSBbXTtcblxuICAgIHN0YXRpYyBjb250ZXh0VHlwZSA9IFJvb21Db250ZXh0O1xuICAgIHB1YmxpYyBjb250ZXh0ITogUmVhY3QuQ29udGV4dFR5cGU8dHlwZW9mIFJvb21Db250ZXh0PjtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgbGlua3M6IFtdLFxuICAgICAgICAgICAgd2lkZ2V0SGlkZGVuOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3BzLmVkaXRTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5hcHBseUZvcm1hdHRpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXBwbHlGb3JtYXR0aW5nKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBzaG93TGluZU51bWJlcnMgPSBTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFwic2hvd0NvZGVMaW5lTnVtYmVyc1wiKTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZVNwb2lsZXJzKFt0aGlzLmNvbnRlbnRSZWYuY3VycmVudF0pO1xuXG4gICAgICAgIC8vIHBpbGxpZnlMaW5rcyBCRUZPUkUgbGlua2lmeUVsZW1lbnQgYmVjYXVzZSBwbGFpbiByb29tL3VzZXIgVVJMcyBpbiB0aGUgY29tcG9zZXJcbiAgICAgICAgLy8gYXJlIHN0aWxsIHNlbnQgYXMgcGxhaW50ZXh0IFVSTHMuIElmIHRoZXNlIGFyZSBldmVyIHBpbGxpZmllZCBpbiB0aGUgY29tcG9zZXIsXG4gICAgICAgIC8vIHdlIHNob3VsZCBiZSBwaWxsaWZ5IHRoZW0gaGVyZSBieSBkb2luZyB0aGUgbGlua2lmeWluZyBCRUZPUkUgdGhlIHBpbGxpZnlpbmcuXG4gICAgICAgIHBpbGxpZnlMaW5rcyhbdGhpcy5jb250ZW50UmVmLmN1cnJlbnRdLCB0aGlzLnByb3BzLm14RXZlbnQsIHRoaXMucGlsbHMpO1xuICAgICAgICBIdG1sVXRpbHMubGlua2lmeUVsZW1lbnQodGhpcy5jb250ZW50UmVmLmN1cnJlbnQpO1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZVVybFByZXZpZXcoKTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5teEV2ZW50LmdldENvbnRlbnQoKS5mb3JtYXQgPT09IFwib3JnLm1hdHJpeC5jdXN0b20uaHRtbFwiKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgZXhwYW5zaW9uIGFuZCBhZGQgYnV0dG9uc1xuICAgICAgICAgICAgY29uc3QgcHJlcyA9IChSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKSBhcyBFbGVtZW50KS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInByZVwiKTtcbiAgICAgICAgICAgIGlmIChwcmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgYWxyZWFkeSBpcyBhIGRpdiB3cmFwcGluZyB0aGUgY29kZWJsb2NrIHdlIHdhbnQgdG8gc2tpcCB0aGlzLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGhhcHBlbnMgYWZ0ZXIgdGhlIGNvZGVibG9jayB3YXMgZWRpdGVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAocHJlc1tpXS5wYXJlbnRFbGVtZW50LmNsYXNzTmFtZSA9PSBcIm14X0V2ZW50VGlsZV9wcmVfY29udGFpbmVyXCIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgY29kZSBlbGVtZW50IGlmIGl0J3MgbWlzc2luZyBzaW5jZSB3ZSBkZXBlbmQgb24gaXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXNbaV0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjb2RlXCIpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZENvZGVFbGVtZW50KHByZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFdyYXAgYSBkaXYgYXJvdW5kIDxwcmU+IHNvIHRoYXQgdGhlIGNvcHkgYnV0dG9uIGNhbiBiZSBjb3JyZWN0bHkgcG9zaXRpb25lZFxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSA8cHJlPiBvdmVyZmxvd3MgYW5kIGlzIHNjcm9sbGVkIGhvcml6b250YWxseS5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGl2ID0gdGhpcy53cmFwSW5EaXYocHJlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ29kZUJsb2NrRXhwYW5zaW9uKHByZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZENvZGVFeHBhbnNpb25CdXR0b24oZGl2LCBwcmVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRDb2RlQ29weUJ1dHRvbihkaXYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvd0xpbmVOdW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZExpbmVOdW1iZXJzKHByZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSGlnaGxpZ2h0IGNvZGVcbiAgICAgICAgICAgIGNvbnN0IGNvZGVzID0gKFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpIGFzIEVsZW1lbnQpLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiY29kZVwiKTtcbiAgICAgICAgICAgIGlmIChjb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRG8gdGhpcyBhc3luY2hyb25vdXNseTogcGFyc2luZyBjb2RlIHRha2VzIHRpbWUgYW5kIHdlIGRvbid0XG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byBibG9jayB0aGUgRE9NIHVwZGF0ZSBvbiBpdC5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudW5tb3VudGVkKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0Q29kZShjb2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFkZENvZGVFbGVtZW50KHByZTogSFRNTFByZUVsZW1lbnQpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY29kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjb2RlXCIpO1xuICAgICAgICBjb2RlLmFwcGVuZCguLi5wcmUuY2hpbGROb2Rlcyk7XG4gICAgICAgIHByZS5hcHBlbmRDaGlsZChjb2RlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFkZENvZGVFeHBhbnNpb25CdXR0b24oZGl2OiBIVE1MRGl2RWxlbWVudCwgcHJlOiBIVE1MUHJlRWxlbWVudCk6IHZvaWQge1xuICAgICAgICAvLyBDYWxjdWxhdGUgaG93IG1hbnkgcGVyY2VudCBkb2VzIHRoZSBwcmUgZWxlbWVudCB0YWtlIHVwLlxuICAgICAgICAvLyBJZiBpdCdzIGxlc3MgdGhhbiAzMCUgd2UgZG9uJ3QgYWRkIHRoZSBleHBhbnNpb24gYnV0dG9uLlxuICAgICAgICAvLyBXZSBhbHNvIHJvdW5kIHRoZSBudW1iZXIgYXMgaXQgc29tZXRpbWVzIGNhbiBiZSAyOS45OS4uLlxuICAgICAgICBjb25zdCBwZXJjZW50YWdlT2ZWaWV3cG9ydCA9IE1hdGgucm91bmQocHJlLm9mZnNldEhlaWdodCAvIFVJU3RvcmUuaW5zdGFuY2Uud2luZG93SGVpZ2h0ICogMTAwKTtcbiAgICAgICAgLy8gVE9ETzogYWRkaXRpb25hbGx5IHNob3cgdGhlIGJ1dHRvbiBpZiBpdCdzIGFuIGV4cGFuZGVkIHF1b3RlZCBtZXNzYWdlXG4gICAgICAgIGlmIChwZXJjZW50YWdlT2ZWaWV3cG9ydCA8IDMwKSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIGJ1dHRvbi5jbGFzc05hbWUgPSBcIm14X0V2ZW50VGlsZV9idXR0b24gXCI7XG4gICAgICAgIGlmIChwcmUuY2xhc3NOYW1lID09IFwibXhfRXZlbnRUaWxlX2NvbGxhcHNlZENvZGVCbG9ja1wiKSB7XG4gICAgICAgICAgICBidXR0b24uY2xhc3NOYW1lICs9IFwibXhfRXZlbnRUaWxlX2V4cGFuZEJ1dHRvblwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnV0dG9uLmNsYXNzTmFtZSArPSBcIm14X0V2ZW50VGlsZV9jb2xsYXBzZUJ1dHRvblwiO1xuICAgICAgICB9XG5cbiAgICAgICAgYnV0dG9uLm9uY2xpY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBidXR0b24uY2xhc3NOYW1lID0gXCJteF9FdmVudFRpbGVfYnV0dG9uIFwiO1xuICAgICAgICAgICAgaWYgKHByZS5jbGFzc05hbWUgPT0gXCJteF9FdmVudFRpbGVfY29sbGFwc2VkQ29kZUJsb2NrXCIpIHtcbiAgICAgICAgICAgICAgICBwcmUuY2xhc3NOYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICBidXR0b24uY2xhc3NOYW1lICs9IFwibXhfRXZlbnRUaWxlX2NvbGxhcHNlQnV0dG9uXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZS5jbGFzc05hbWUgPSBcIm14X0V2ZW50VGlsZV9jb2xsYXBzZWRDb2RlQmxvY2tcIjtcbiAgICAgICAgICAgICAgICBidXR0b24uY2xhc3NOYW1lICs9IFwibXhfRXZlbnRUaWxlX2V4cGFuZEJ1dHRvblwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCeSBleHBhbmRpbmcvY29sbGFwc2luZyB3ZSBjaGFuZ2VkXG4gICAgICAgICAgICAvLyB0aGUgaGVpZ2h0LCB0aGVyZWZvcmUgd2UgY2FsbCB0aGlzXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uSGVpZ2h0Q2hhbmdlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgIH1cblxuICAgIHByaXZhdGUgYWRkQ29kZUNvcHlCdXR0b24oZGl2OiBIVE1MRGl2RWxlbWVudCk6IHZvaWQge1xuICAgICAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgYnV0dG9uLmNsYXNzTmFtZSA9IFwibXhfRXZlbnRUaWxlX2J1dHRvbiBteF9FdmVudFRpbGVfY29weUJ1dHRvbiBcIjtcblxuICAgICAgICAvLyBDaGVjayBpZiBleHBhbnNpb24gYnV0dG9uIGV4aXN0cy4gSWYgc29cbiAgICAgICAgLy8gd2UgcHV0IHRoZSBjb3B5IGJ1dHRvbiB0byB0aGUgYm90dG9tXG4gICAgICAgIGNvbnN0IGV4cGFuc2lvbkJ1dHRvbkV4aXN0cyA9IGRpdi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwibXhfRXZlbnRUaWxlX2J1dHRvblwiKTtcbiAgICAgICAgaWYgKGV4cGFuc2lvbkJ1dHRvbkV4aXN0cy5sZW5ndGggPiAwKSBidXR0b24uY2xhc3NOYW1lICs9IFwibXhfRXZlbnRUaWxlX2J1dHRvbkJvdHRvbVwiO1xuXG4gICAgICAgIGJ1dHRvbi5vbmNsaWNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29weUNvZGUgPSBidXR0b24ucGFyZW50RWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImNvZGVcIilbMF07XG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzZnVsID0gYXdhaXQgY29weVBsYWludGV4dChjb3B5Q29kZS50ZXh0Q29udGVudCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1dHRvblJlY3QgPSBidXR0b24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBjb25zdCB7IGNsb3NlIH0gPSBDb250ZXh0TWVudS5jcmVhdGVNZW51KEdlbmVyaWNUZXh0Q29udGV4dE1lbnUsIHtcbiAgICAgICAgICAgICAgICAuLi50b1JpZ2h0T2YoYnV0dG9uUmVjdCwgMiksXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogc3VjY2Vzc2Z1bCA/IF90KCdDb3BpZWQhJykgOiBfdCgnRmFpbGVkIHRvIGNvcHknKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnV0dG9uLm9ubW91c2VsZWF2ZSA9IGNsb3NlO1xuICAgICAgICB9O1xuXG4gICAgICAgIGRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgIH1cblxuICAgIHByaXZhdGUgd3JhcEluRGl2KHByZTogSFRNTFByZUVsZW1lbnQpOiBIVE1MRGl2RWxlbWVudCB7XG4gICAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGRpdi5jbGFzc05hbWUgPSBcIm14X0V2ZW50VGlsZV9wcmVfY29udGFpbmVyXCI7XG5cbiAgICAgICAgLy8gSW5zZXJ0IGNvbnRhaW5pbmcgZGl2IGluIHBsYWNlIG9mIDxwcmU+IGJsb2NrXG4gICAgICAgIHByZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChkaXYsIHByZSk7XG4gICAgICAgIC8vIEFwcGVuZCA8cHJlPiBibG9jayBhbmQgY29weSBidXR0b24gdG8gY29udGFpbmVyXG4gICAgICAgIGRpdi5hcHBlbmRDaGlsZChwcmUpO1xuXG4gICAgICAgIHJldHVybiBkaXY7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVDb2RlQmxvY2tFeHBhbnNpb24ocHJlOiBIVE1MUHJlRWxlbWVudCk6IHZvaWQge1xuICAgICAgICBpZiAoIVNldHRpbmdzU3RvcmUuZ2V0VmFsdWUoXCJleHBhbmRDb2RlQnlEZWZhdWx0XCIpKSB7XG4gICAgICAgICAgICBwcmUuY2xhc3NOYW1lID0gXCJteF9FdmVudFRpbGVfY29sbGFwc2VkQ29kZUJsb2NrXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFkZExpbmVOdW1iZXJzKHByZTogSFRNTFByZUVsZW1lbnQpOiB2b2lkIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBsaW5lcyBpbiBwcmVcbiAgICAgICAgY29uc3QgbnVtYmVyID0gcHJlLmlubmVySFRNTC5yZXBsYWNlKC9cXG4oPFxcL2NvZGU+KT8kLywgXCJcIikuc3BsaXQoL1xcbi8pLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbGluZU51bWJlcnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIGxpbmVOdW1iZXJzLmNsYXNzTmFtZSA9ICdteF9FdmVudFRpbGVfbGluZU51bWJlcnMnO1xuICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggbGluZXMgc3RhcnRpbmcgd2l0aCAxIChudW1iZXIgb2YgdGhlIGZpcnN0IGxpbmUgaXMgMSlcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbnVtYmVyOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICBzLnRleHRDb250ZW50ID0gaS50b1N0cmluZygpO1xuICAgICAgICAgICAgbGluZU51bWJlcnMuYXBwZW5kQ2hpbGQocyk7XG4gICAgICAgIH1cbiAgICAgICAgcHJlLnByZXBlbmQobGluZU51bWJlcnMpO1xuICAgICAgICBwcmUuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoaWdobGlnaHRDb2RlKGNvZGU6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgICAgIGlmIChjb2RlLnRleHRDb250ZW50Lmxlbmd0aCA+IE1BWF9ISUdITElHSFRfTEVOR1RIKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICBcIkNvZGUgYmxvY2sgaXMgYmlnZ2VyIHRoYW4gaGlnaGxpZ2h0IGxpbWl0IChcIiArXG4gICAgICAgICAgICAgICAgY29kZS50ZXh0Q29udGVudC5sZW5ndGggKyBcIiA+IFwiICsgTUFYX0hJR0hMSUdIVF9MRU5HVEggK1xuICAgICAgICAgICAgICAgIFwiKTogbm90IGhpZ2hsaWdodGluZ1wiLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBhZHZlcnRpc2VkTGFuZztcbiAgICAgICAgZm9yIChjb25zdCBjbCBvZiBjb2RlLmNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pKSB7XG4gICAgICAgICAgICBpZiAoY2wuc3RhcnRzV2l0aCgnbGFuZ3VhZ2UtJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXliZUxhbmcgPSBjbC5zcGxpdCgnLScsIDIpWzFdO1xuICAgICAgICAgICAgICAgIGlmIChoaWdobGlnaHQuZ2V0TGFuZ3VhZ2UobWF5YmVMYW5nKSkge1xuICAgICAgICAgICAgICAgICAgICBhZHZlcnRpc2VkTGFuZyA9IG1heWJlTGFuZztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFkdmVydGlzZWRMYW5nKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY29kZSBzYXlzIHdoYXQgbGFuZ3VhZ2UgaXQgaXMsIGhpZ2hsaWdodCBpdCBpbiB0aGF0IGxhbmd1YWdlXG4gICAgICAgICAgICAvLyBXZSBkb24ndCB1c2UgaGlnaGxpZ2h0RWxlbWVudCBoZXJlIGJlY2F1c2Ugd2UgY2FuJ3QgZm9yY2UgbGFuZ3VhZ2UgZGV0ZWN0aW9uXG4gICAgICAgICAgICAvLyBvZmYuIEl0IHNob3VsZCB1c2UgdGhlIG9uZSB3ZSd2ZSBmb3VuZCBpbiB0aGUgQ1NTIGNsYXNzIGJ1dCB3ZSdkIHJhdGhlciBwYXNzXG4gICAgICAgICAgICAvLyBpdCBpbiBleHBsaWNpdGx5IHRvIG1ha2Ugc3VyZS5cbiAgICAgICAgICAgIGNvZGUuaW5uZXJIVE1MID0gaGlnaGxpZ2h0LmhpZ2hsaWdodChhZHZlcnRpc2VkTGFuZywgY29kZS50ZXh0Q29udGVudCkudmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFwiZW5hYmxlU3ludGF4SGlnaGxpZ2h0TGFuZ3VhZ2VEZXRlY3Rpb25cIikgJiZcbiAgICAgICAgICAgIGNvZGUucGFyZW50RWxlbWVudCBpbnN0YW5jZW9mIEhUTUxQcmVFbGVtZW50XG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gVXNlciBoYXMgbGFuZ3VhZ2UgZGV0ZWN0aW9uIGVuYWJsZWQgYW5kIHRoZSBjb2RlIGlzIHdpdGhpbiBhIHByZVxuICAgICAgICAgICAgLy8gd2Ugb25seSBhdXRvLWhpZ2hsaWdodCBpZiB0aGUgY29kZSBibG9jayBpcyBpbiBhIHByZSksIHNvIGhpZ2hsaWdodFxuICAgICAgICAgICAgLy8gdGhlIGJsb2NrIHdpdGggYXV0by1oaWdobGlnaHRpbmcgZW5hYmxlZC5cbiAgICAgICAgICAgIC8vIFdlIHBhc3MgaGlnaGxpZ2h0anMgdGhlIHRleHQgdG8gaGlnaGxpZ2h0IHJhdGhlciB0aGFuIGxldHRpbmcgaXRcbiAgICAgICAgICAgIC8vIHdvcmsgb24gdGhlIERPTSB3aXRoIGhpZ2hsaWdodEVsZW1lbnQgYmVjYXVzZSB0aGF0IGFsc28gYWRkcyBDU1NcbiAgICAgICAgICAgIC8vIGNsYXNzZXMgdG8gdGhlIHByZS9jb2RlIGVsZW1lbnQgdGhhdCB3ZSBkb24ndCB3YW50ICh0aGUgQ1NTXG4gICAgICAgICAgICAvLyBjb25mbGljdHMgd2l0aCBvdXIgb3duKS5cbiAgICAgICAgICAgIGNvZGUuaW5uZXJIVE1MID0gaGlnaGxpZ2h0LmhpZ2hsaWdodEF1dG8oY29kZS50ZXh0Q29udGVudCkudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm9wcy5lZGl0U3RhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3BwZWRFZGl0aW5nID0gcHJldlByb3BzLmVkaXRTdGF0ZSAmJiAhdGhpcy5wcm9wcy5lZGl0U3RhdGU7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlV2FzRWRpdGVkID0gcHJldlByb3BzLnJlcGxhY2luZ0V2ZW50SWQgIT09IHRoaXMucHJvcHMucmVwbGFjaW5nRXZlbnRJZDtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlV2FzRWRpdGVkIHx8IHN0b3BwZWRFZGl0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseUZvcm1hdHRpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLnVubW91bnRlZCA9IHRydWU7XG4gICAgICAgIHVubW91bnRQaWxscyh0aGlzLnBpbGxzKTtcbiAgICB9XG5cbiAgICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICAgICAgLy9jb25zb2xlLmluZm8oXCJzaG91bGRDb21wb25lbnRVcGRhdGU6IFNob3dVcmxQcmV2aWV3IGZvciAlcyBpcyAlc1wiLCB0aGlzLnByb3BzLm14RXZlbnQuZ2V0SWQoKSwgdGhpcy5wcm9wcy5zaG93VXJsUHJldmlldyk7XG5cbiAgICAgICAgLy8gZXhwbG9pdCB0aGF0IGV2ZW50cyBhcmUgaW1tdXRhYmxlIDopXG4gICAgICAgIHJldHVybiAobmV4dFByb3BzLm14RXZlbnQuZ2V0SWQoKSAhPT0gdGhpcy5wcm9wcy5teEV2ZW50LmdldElkKCkgfHxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHMuaGlnaGxpZ2h0cyAhPT0gdGhpcy5wcm9wcy5oaWdobGlnaHRzIHx8XG4gICAgICAgICAgICAgICAgbmV4dFByb3BzLnJlcGxhY2luZ0V2ZW50SWQgIT09IHRoaXMucHJvcHMucmVwbGFjaW5nRXZlbnRJZCB8fFxuICAgICAgICAgICAgICAgIG5leHRQcm9wcy5oaWdobGlnaHRMaW5rICE9PSB0aGlzLnByb3BzLmhpZ2hsaWdodExpbmsgfHxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHMuc2hvd1VybFByZXZpZXcgIT09IHRoaXMucHJvcHMuc2hvd1VybFByZXZpZXcgfHxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHMuZWRpdFN0YXRlICE9PSB0aGlzLnByb3BzLmVkaXRTdGF0ZSB8fFxuICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5saW5rcyAhPT0gdGhpcy5zdGF0ZS5saW5rcyB8fFxuICAgICAgICAgICAgICAgIG5leHRTdGF0ZS53aWRnZXRIaWRkZW4gIT09IHRoaXMuc3RhdGUud2lkZ2V0SGlkZGVuKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNhbGN1bGF0ZVVybFByZXZpZXcoKTogdm9pZCB7XG4gICAgICAgIC8vY29uc29sZS5pbmZvKFwiY2FsY3VsYXRlVXJsUHJldmlldzogU2hvd1VybFByZXZpZXcgZm9yICVzIGlzICVzXCIsIHRoaXMucHJvcHMubXhFdmVudC5nZXRJZCgpLCB0aGlzLnByb3BzLnNob3dVcmxQcmV2aWV3KTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5zaG93VXJsUHJldmlldykge1xuICAgICAgICAgICAgLy8gcGFzcyBvbmx5IHRoZSBmaXJzdCBjaGlsZCB3aGljaCBpcyB0aGUgZXZlbnQgdGlsZSBvdGhlcndpc2UgdGhpcyByZWN1cnNlcyBvbiBlZGl0ZWQgZXZlbnRzXG4gICAgICAgICAgICBsZXQgbGlua3MgPSB0aGlzLmZpbmRMaW5rcyhbdGhpcy5jb250ZW50UmVmLmN1cnJlbnRdKTtcbiAgICAgICAgICAgIGlmIChsaW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBkZS1kdXBsaWNhdGUgdGhlIGxpbmtzIHVzaW5nIGEgc2V0IGhlcmUgbWFpbnRhaW5zIHRoZSBvcmRlclxuICAgICAgICAgICAgICAgIGxpbmtzID0gQXJyYXkuZnJvbShuZXcgU2V0KGxpbmtzKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGxpbmtzIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gbGF6eS1sb2FkIHRoZSBoaWRkZW4gc3RhdGUgb2YgdGhlIHByZXZpZXcgd2lkZ2V0IGZyb20gbG9jYWxzdG9yYWdlXG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGlkZGVuID0gISF3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJoaWRlX3ByZXZpZXdfXCIgKyB0aGlzLnByb3BzLm14RXZlbnQuZ2V0SWQoKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyB3aWRnZXRIaWRkZW46IGhpZGRlbiB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUubGlua3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGxpbmtzOiBbXSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYWN0aXZhdGVTcG9pbGVycyhub2RlczogQXJyYXlMaWtlPEVsZW1lbnQ+KTogdm9pZCB7XG4gICAgICAgIGxldCBub2RlID0gbm9kZXNbMF07XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS50YWdOYW1lID09PSBcIlNQQU5cIiAmJiB0eXBlb2Ygbm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW14LXNwb2lsZXJcIikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzcG9pbGVyQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVhc29uID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW14LXNwb2lsZXJcIik7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLW14LXNwb2lsZXJcIik7IC8vIHdlIGRvbid0IHdhbnQgdG8gcmVjdXJzZVxuICAgICAgICAgICAgICAgIGNvbnN0IHNwb2lsZXIgPSA8U3BvaWxlciByZWFzb249e3JlYXNvbn0gY29udGVudEh0bWw9e25vZGUub3V0ZXJIVE1MfSAvPjtcblxuICAgICAgICAgICAgICAgIFJlYWN0RE9NLnJlbmRlcihzcG9pbGVyLCBzcG9pbGVyQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHNwb2lsZXJDb250YWluZXIsIG5vZGUpO1xuXG4gICAgICAgICAgICAgICAgbm9kZSA9IHNwb2lsZXJDb250YWluZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub2RlLmNoaWxkTm9kZXMgJiYgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVTcG9pbGVycyhub2RlLmNoaWxkTm9kZXMgYXMgTm9kZUxpc3RPZjxFbGVtZW50Pik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nIGFzIEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGZpbmRMaW5rcyhub2RlczogQXJyYXlMaWtlPEVsZW1lbnQ+KTogc3RyaW5nW10ge1xuICAgICAgICBsZXQgbGlua3M6IHN0cmluZ1tdID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKG5vZGUudGFnTmFtZSA9PT0gXCJBXCIgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNMaW5rUHJldmlld2FibGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlua3MucHVzaChub2RlLmdldEF0dHJpYnV0ZShcImhyZWZcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS50YWdOYW1lID09PSBcIlBSRVwiIHx8IG5vZGUudGFnTmFtZSA9PT0gXCJDT0RFXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgbm9kZS50YWdOYW1lID09PSBcIkJMT0NLUVVPVEVcIikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkcmVuICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGlua3MgPSBsaW5rcy5jb25jYXQodGhpcy5maW5kTGlua3Mobm9kZS5jaGlsZHJlbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5rcztcbiAgICB9XG5cbiAgICBwcml2YXRlIGlzTGlua1ByZXZpZXdhYmxlKG5vZGU6IEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgICAgLy8gZG9uJ3QgdHJ5IHRvIHByZXZpZXcgcmVsYXRpdmUgbGlua3NcbiAgICAgICAgaWYgKCFub2RlLmdldEF0dHJpYnV0ZShcImhyZWZcIikuc3RhcnRzV2l0aChcImh0dHA6Ly9cIikgJiZcbiAgICAgICAgICAgICFub2RlLmdldEF0dHJpYnV0ZShcImhyZWZcIikuc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcyBhIHJhbmRvbSBoZXVyaXN0aWMgdG8gYXZvaWQgaGlnaGxpZ2h0aW5nIHRoaW5ncyBsaWtlIFwiZm9vLnBsXCJcbiAgICAgICAgLy8gd2UgcmVxdWlyZSB0aGUgbGlua2VkIHRleHQgdG8gZWl0aGVyIGluY2x1ZGUgYSAvIChlaXRoZXIgZnJvbSBodHRwOi8vXG4gICAgICAgIC8vIG9yIGZyb20gYSBmdWxsIGZvby5iYXIvYmF6IHN0eWxlIHNjaGVtZWxlc3MgVVJMKSAtIG9yIGJlIGEgbWFya2Rvd24tc3R5bGVcbiAgICAgICAgLy8gbGluaywgaW4gd2hpY2ggY2FzZSB3ZSBjaGVjayB0aGUgdGFyZ2V0IHRleHQgZGlmZmVycyBmcm9tIHRoZSBsaW5rIHZhbHVlLlxuICAgICAgICAvLyBUT0RPOiBtYWtlIHRoaXMgY29uZmlndXJhYmxlP1xuICAgICAgICBpZiAobm9kZS50ZXh0Q29udGVudC5pbmRleE9mKFwiL1wiKSA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtcbiAgICAgICAgICAgIGNvbnN0IGhvc3QgPSB1cmwubWF0Y2goL15odHRwcz86XFwvXFwvKC4qPykoXFwvfCQpLylbMV07XG5cbiAgICAgICAgICAgIC8vIG5ldmVyIHByZXZpZXcgcGVybWFsaW5rcyAoaWYgYW55dGhpbmcgd2Ugc2hvdWxkIGdpdmUgYSBzbWFydFxuICAgICAgICAgICAgLy8gcHJldmlldyBvZiB0aGUgcm9vbS91c2VyIHRoZXkgcG9pbnQgdG86IG5vYm9keSBuZWVkcyB0byBiZSByZW1pbmRlZFxuICAgICAgICAgICAgLy8gd2hhdCB0aGUgbWF0cml4LnRvIHNpdGUgbG9va3MgbGlrZSkuXG4gICAgICAgICAgICBpZiAoaXNQZXJtYWxpbmtIb3N0KGhvc3QpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChub2RlLnRleHRDb250ZW50LnRvTG93ZXJDYXNlKCkudHJpbSgpLnN0YXJ0c1dpdGgoaG9zdC50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgIC8vIGl0J3MgYSBcImZvby5wbFwiIHN0eWxlIGxpbmtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGl0J3MgYSBbZm9vIGJhcl0oaHR0cDovL2Zvby5jb20pIHN0eWxlIGxpbmtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgb25DYW5jZWxDbGljayA9ICgpOiB2b2lkID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHdpZGdldEhpZGRlbjogdHJ1ZSB9KTtcbiAgICAgICAgLy8gRklYTUU6IHBlcnNpc3QgdGhpcyBzb21ld2hlcmUgc21hcnRlciB0aGFuIGxvY2FsIHN0b3JhZ2VcbiAgICAgICAgaWYgKGdsb2JhbC5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICAgIGdsb2JhbC5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImhpZGVfcHJldmlld19cIiArIHRoaXMucHJvcHMubXhFdmVudC5nZXRJZCgpLCBcIjFcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgIH07XG5cbiAgICBwcml2YXRlIG9uRW1vdGVTZW5kZXJDbGljayA9ICgpOiB2b2lkID0+IHtcbiAgICAgICAgY29uc3QgbXhFdmVudCA9IHRoaXMucHJvcHMubXhFdmVudDtcbiAgICAgICAgZGlzLmRpc3BhdGNoPENvbXBvc2VySW5zZXJ0UGF5bG9hZD4oe1xuICAgICAgICAgICAgYWN0aW9uOiBBY3Rpb24uQ29tcG9zZXJJbnNlcnQsXG4gICAgICAgICAgICB1c2VySWQ6IG14RXZlbnQuZ2V0U2VuZGVyKCksXG4gICAgICAgICAgICB0aW1lbGluZVJlbmRlcmluZ1R5cGU6IHRoaXMuY29udGV4dC50aW1lbGluZVJlbmRlcmluZ1R5cGUsXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBwdWJsaWMgZ2V0RXZlbnRUaWxlT3BzID0gKCkgPT4gKHtcbiAgICAgICAgaXNXaWRnZXRIaWRkZW46ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlLndpZGdldEhpZGRlbjtcbiAgICAgICAgfSxcblxuICAgICAgICB1bmhpZGVXaWRnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyB3aWRnZXRIaWRkZW46IGZhbHNlIH0pO1xuICAgICAgICAgICAgaWYgKGdsb2JhbC5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICBnbG9iYWwubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oXCJoaWRlX3ByZXZpZXdfXCIgKyB0aGlzLnByb3BzLm14RXZlbnQuZ2V0SWQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBwcml2YXRlIG9uU3RhcnRlckxpbmtDbGljayA9IChzdGFydGVyTGluazogc3RyaW5nLCBldjogU3ludGhldGljRXZlbnQpOiB2b2lkID0+IHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBhZGQgb24gb3VyIHNjYWxhciB0b2tlbiB0byB0aGUgc3RhcnRlciBsaW5rLCBidXQgd2UgbWF5IG5vdCBoYXZlIG9uZSFcbiAgICAgICAgLy8gSW4gYWRkaXRpb24sIHdlIGNhbid0IGZldGNoIG9uZSBvbiBjbGljayBhbmQgdGhlbiBnbyB0byBpdCBpbW1lZGlhdGVseSBhcyB0aGF0XG4gICAgICAgIC8vIGlzIHRoZW4gdHJlYXRlZCBhcyBhIHBvcHVwIVxuICAgICAgICAvLyBXZSBjYW4gZ2V0IGFyb3VuZCB0aGlzIGJ5IGZldGNoaW5nIG9uZSBub3cgYW5kIHNob3dpbmcgYSBcImNvbmZpcm1hdGlvbiBkaWFsb2dcIiAoaHVyciBodXJyKVxuICAgICAgICAvLyB3aGljaCByZXF1aXJlcyB0aGUgdXNlciB0byBjbGljayB0aHJvdWdoIGFuZCBUSEVOIHdlIGNhbiBvcGVuIHRoZSBsaW5rIGluIGEgbmV3IHRhYiBiZWNhdXNlXG4gICAgICAgIC8vIHRoZSB3aW5kb3cub3BlbiBjb21tYW5kIG9jY3VycyBpbiB0aGUgc2FtZSBzdGFjayBmcmFtZSBhcyB0aGUgb25DbGljayBjYWxsYmFjay5cblxuICAgICAgICBjb25zdCBtYW5hZ2VycyA9IEludGVncmF0aW9uTWFuYWdlcnMuc2hhcmVkSW5zdGFuY2UoKTtcbiAgICAgICAgaWYgKCFtYW5hZ2Vycy5oYXNNYW5hZ2VyKCkpIHtcbiAgICAgICAgICAgIG1hbmFnZXJzLm9wZW5Ob01hbmFnZXJEaWFsb2coKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdvIGZldGNoIGEgc2NhbGFyIHRva2VuXG4gICAgICAgIGNvbnN0IGludGVncmF0aW9uTWFuYWdlciA9IG1hbmFnZXJzLmdldFByaW1hcnlNYW5hZ2VyKCk7XG4gICAgICAgIGNvbnN0IHNjYWxhckNsaWVudCA9IGludGVncmF0aW9uTWFuYWdlci5nZXRTY2FsYXJDbGllbnQoKTtcbiAgICAgICAgc2NhbGFyQ2xpZW50LmNvbm5lY3QoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRlVXJsID0gc2NhbGFyQ2xpZW50LmdldFN0YXJ0ZXJMaW5rKHN0YXJ0ZXJMaW5rKTtcbiAgICAgICAgICAgIGNvbnN0IGludGVncmF0aW9uc1VybCA9IGludGVncmF0aW9uTWFuYWdlci51aVVybDtcbiAgICAgICAgICAgIE1vZGFsLmNyZWF0ZVRyYWNrZWREaWFsb2coJ0FkZCBhbiBpbnRlZ3JhdGlvbicsICcnLCBRdWVzdGlvbkRpYWxvZywge1xuICAgICAgICAgICAgICAgIHRpdGxlOiBfdChcIkFkZCBhbiBJbnRlZ3JhdGlvblwiKSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsgX3QoXCJZb3UgYXJlIGFib3V0IHRvIGJlIHRha2VuIHRvIGEgdGhpcmQtcGFydHkgc2l0ZSBzbyB5b3UgY2FuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImF1dGhlbnRpY2F0ZSB5b3VyIGFjY291bnQgZm9yIHVzZSB3aXRoICUoaW50ZWdyYXRpb25zVXJsKXMuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkRvIHlvdSB3aXNoIHRvIGNvbnRpbnVlP1wiLCB7IGludGVncmF0aW9uc1VybDogaW50ZWdyYXRpb25zVXJsIH0pIH1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+LFxuICAgICAgICAgICAgICAgIGJ1dHRvbjogX3QoXCJDb250aW51ZVwiKSxcbiAgICAgICAgICAgICAgICBvbkZpbmlzaGVkKGNvbmZpcm1lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbmZpcm1lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gd2luZG93LnNjcmVlbi53aWR0aCA+IDEwMjQgPyAxMDI0IDogd2luZG93LnNjcmVlbi53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gd2luZG93LnNjcmVlbi5oZWlnaHQgPiA4MDAgPyA4MDAgOiB3aW5kb3cuc2NyZWVuLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVmdCA9ICh3aW5kb3cuc2NyZWVuLndpZHRoIC0gd2lkdGgpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9wID0gKHdpbmRvdy5zY3JlZW4uaGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZlYXR1cmVzID0gYGhlaWdodD0ke2hlaWdodH0sIHdpZHRoPSR7d2lkdGh9LCB0b3A9JHt0b3B9LCBsZWZ0PSR7bGVmdH0sYDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd25kID0gd2luZG93Lm9wZW4oY29tcGxldGVVcmwsICdfYmxhbmsnLCBmZWF0dXJlcyk7XG4gICAgICAgICAgICAgICAgICAgIHduZC5vcGVuZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgb3Blbkhpc3RvcnlEaWFsb2cgPSBhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgICAgIE1vZGFsLmNyZWF0ZURpYWxvZyhNZXNzYWdlRWRpdEhpc3RvcnlEaWFsb2csIHsgbXhFdmVudDogdGhpcy5wcm9wcy5teEV2ZW50IH0pO1xuICAgIH07XG5cbiAgICBwcml2YXRlIHJlbmRlckVkaXRlZE1hcmtlcigpIHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IHRoaXMucHJvcHMubXhFdmVudC5yZXBsYWNpbmdFdmVudERhdGUoKTtcbiAgICAgICAgY29uc3QgZGF0ZVN0cmluZyA9IGRhdGUgJiYgZm9ybWF0RGF0ZShkYXRlKTtcblxuICAgICAgICBjb25zdCB0b29sdGlwID0gPGRpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXhfVG9vbHRpcF90aXRsZVwiPlxuICAgICAgICAgICAgICAgIHsgX3QoXCJFZGl0ZWQgYXQgJShkYXRlKXNcIiwgeyBkYXRlOiBkYXRlU3RyaW5nIH0pIH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJteF9Ub29sdGlwX3N1YlwiPlxuICAgICAgICAgICAgICAgIHsgX3QoXCJDbGljayB0byB2aWV3IGVkaXRzXCIpIH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj47XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxBY2Nlc3NpYmxlVG9vbHRpcEJ1dHRvblxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIm14X0V2ZW50VGlsZV9lZGl0ZWRcIlxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMub3Blbkhpc3RvcnlEaWFsb2d9XG4gICAgICAgICAgICAgICAgdGl0bGU9e190KFwiRWRpdGVkIGF0ICUoZGF0ZSlzLiBDbGljayB0byB2aWV3IGVkaXRzLlwiLCB7IGRhdGU6IGRhdGVTdHJpbmcgfSl9XG4gICAgICAgICAgICAgICAgdG9vbHRpcD17dG9vbHRpcH1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8c3Bhbj57IGAoJHtfdChcImVkaXRlZFwiKX0pYCB9PC9zcGFuPlxuICAgICAgICAgICAgPC9BY2Nlc3NpYmxlVG9vbHRpcEJ1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmVkaXRTdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIDxFZGl0TWVzc2FnZUNvbXBvc2VyIGVkaXRTdGF0ZT17dGhpcy5wcm9wcy5lZGl0U3RhdGV9IGNsYXNzTmFtZT1cIm14X0V2ZW50VGlsZV9jb250ZW50XCIgLz47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbXhFdmVudCA9IHRoaXMucHJvcHMubXhFdmVudDtcbiAgICAgICAgY29uc3QgY29udGVudCA9IG14RXZlbnQuZ2V0Q29udGVudCgpO1xuXG4gICAgICAgIC8vIG9ubHkgc3RyaXAgcmVwbHkgaWYgdGhpcyBpcyB0aGUgb3JpZ2luYWwgcmVwbHlpbmcgZXZlbnQsIGVkaXRzIHRoZXJlYWZ0ZXIgZG8gbm90IGhhdmUgdGhlIGZhbGxiYWNrXG4gICAgICAgIGNvbnN0IHN0cmlwUmVwbHkgPSAhbXhFdmVudC5yZXBsYWNpbmdFdmVudCgpICYmICEhUmVwbHlDaGFpbi5nZXRQYXJlbnRFdmVudElkKG14RXZlbnQpO1xuICAgICAgICBsZXQgYm9keSA9IEh0bWxVdGlscy5ib2R5VG9IdG1sKGNvbnRlbnQsIHRoaXMucHJvcHMuaGlnaGxpZ2h0cywge1xuICAgICAgICAgICAgZGlzYWJsZUJpZ0Vtb2ppOiBjb250ZW50Lm1zZ3R5cGUgPT09IE1zZ1R5cGUuRW1vdGVcbiAgICAgICAgICAgICAgICB8fCAhU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZTxib29sZWFuPignVGV4dHVhbEJvZHkuZW5hYmxlQmlnRW1vamknKSxcbiAgICAgICAgICAgIC8vIFBhcnQgb2YgUmVwbGllcyBmYWxsYmFjayBzdXBwb3J0XG4gICAgICAgICAgICBzdHJpcFJlcGx5RmFsbGJhY2s6IHN0cmlwUmVwbHksXG4gICAgICAgICAgICByZWY6IHRoaXMuY29udGVudFJlZixcbiAgICAgICAgICAgIHJldHVyblN0cmluZzogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5yZXBsYWNpbmdFdmVudElkKSB7XG4gICAgICAgICAgICBib2R5ID0gPD5cbiAgICAgICAgICAgICAgICB7IGJvZHkgfVxuICAgICAgICAgICAgICAgIHsgdGhpcy5yZW5kZXJFZGl0ZWRNYXJrZXIoKSB9XG4gICAgICAgICAgICA8Lz47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5oaWdobGlnaHRMaW5rKSB7XG4gICAgICAgICAgICBib2R5ID0gPGEgaHJlZj17dGhpcy5wcm9wcy5oaWdobGlnaHRMaW5rfT57IGJvZHkgfTwvYT47XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGVudC5kYXRhICYmIHR5cGVvZiBjb250ZW50LmRhdGFbXCJvcmcubWF0cml4Lm5lYi5zdGFydGVyX2xpbmtcIl0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGJvZHkgPSA8YSBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5vblN0YXJ0ZXJMaW5rQ2xpY2suYmluZCh0aGlzLCBjb250ZW50LmRhdGFbXCJvcmcubWF0cml4Lm5lYi5zdGFydGVyX2xpbmtcIl0pfVxuICAgICAgICAgICAgPnsgYm9keSB9PC9hPjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB3aWRnZXRzO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5saW5rcy5sZW5ndGggJiYgIXRoaXMuc3RhdGUud2lkZ2V0SGlkZGVuICYmIHRoaXMucHJvcHMuc2hvd1VybFByZXZpZXcpIHtcbiAgICAgICAgICAgIHdpZGdldHMgPSA8TGlua1ByZXZpZXdHcm91cFxuICAgICAgICAgICAgICAgIGxpbmtzPXt0aGlzLnN0YXRlLmxpbmtzfVxuICAgICAgICAgICAgICAgIG14RXZlbnQ9e3RoaXMucHJvcHMubXhFdmVudH1cbiAgICAgICAgICAgICAgICBvbkNhbmNlbENsaWNrPXt0aGlzLm9uQ2FuY2VsQ2xpY2t9XG4gICAgICAgICAgICAgICAgb25IZWlnaHRDaGFuZ2VkPXt0aGlzLnByb3BzLm9uSGVpZ2h0Q2hhbmdlZH1cbiAgICAgICAgICAgIC8+O1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChjb250ZW50Lm1zZ3R5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgTXNnVHlwZS5FbW90ZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm14X01FbW90ZUJvZHkgbXhfRXZlbnRUaWxlX2NvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICombmJzcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibXhfTUVtb3RlQm9keV9zZW5kZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMub25FbW90ZVNlbmRlckNsaWNrfVxuICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgbXhFdmVudC5zZW5kZXIgPyBteEV2ZW50LnNlbmRlci5uYW1lIDogbXhFdmVudC5nZXRTZW5kZXIoKSB9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAmbmJzcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgYm9keSB9XG4gICAgICAgICAgICAgICAgICAgICAgICB7IHdpZGdldHMgfVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSBNc2dUeXBlLk5vdGljZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm14X01Ob3RpY2VCb2R5IG14X0V2ZW50VGlsZV9jb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICB7IGJvZHkgfVxuICAgICAgICAgICAgICAgICAgICAgICAgeyB3aWRnZXRzIH1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6IC8vIGluY2x1ZGluZyBcIm0udGV4dFwiXG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJteF9NVGV4dEJvZHkgbXhfRXZlbnRUaWxlX2NvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsgYm9keSB9XG4gICAgICAgICAgICAgICAgICAgICAgICB7IHdpZGdldHMgfVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19