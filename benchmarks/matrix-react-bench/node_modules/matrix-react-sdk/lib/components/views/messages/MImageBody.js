"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.HiddenImagePlaceholder = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _reactBlurhash = require("react-blurhash");

var _MFileBody = _interopRequireDefault(require("./MFileBody"));

var _Modal = _interopRequireDefault(require("../../../Modal"));

var _languageHandler = require("../../../languageHandler");

var _SettingsStore = _interopRequireDefault(require("../../../settings/SettingsStore"));

var _MatrixClientContext = _interopRequireDefault(require("../../../contexts/MatrixClientContext"));

var _InlineSpinner = _interopRequireDefault(require("../elements/InlineSpinner"));

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _Media = require("../../../customisations/Media");

var _ContentMessages = require("../../../ContentMessages");

var _ImageView = _interopRequireDefault(require("../elements/ImageView"));

var _classnames = _interopRequireDefault(require("classnames"));

var _reactTransitionGroup = require("react-transition-group");

var _logger = require("matrix-js-sdk/src/logger");

var _EventTile = require("../rooms/EventTile");

var _ImageSize = require("../../../settings/enums/ImageSize");

var _dec, _class, _class2, _temp;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

let MImageBody = (_dec = (0, _replaceableComponent.replaceableComponent)("views.messages.MImageBody"), _dec(_class = (_temp = _class2 = class MImageBody extends _react.default.Component {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "unmounted", true);
    (0, _defineProperty2.default)(this, "image", /*#__PURE__*/(0, _react.createRef)());
    (0, _defineProperty2.default)(this, "timeout", void 0);
    (0, _defineProperty2.default)(this, "sizeWatcher", void 0);
    (0, _defineProperty2.default)(this, "onClientSync", (syncState, prevState) => {
      if (this.unmounted) return; // Consider the client reconnected if there is no error with syncing.
      // This means the state could be RECONNECTING, SYNCING, PREPARED or CATCHUP.

      const reconnected = syncState !== "ERROR" && prevState !== syncState;

      if (reconnected && this.state.imgError) {
        // Load the image again
        this.setState({
          imgError: false
        });
      }
    });
    (0, _defineProperty2.default)(this, "onClick", ev => {
      if (ev.button === 0 && !ev.metaKey) {
        var _content$body;

        ev.preventDefault();

        if (!this.state.showImage) {
          this.showImage();
          return;
        }

        const content = this.props.mxEvent.getContent();
        const httpUrl = this.getContentUrl();
        const params = {
          src: httpUrl,
          name: ((_content$body = content.body) === null || _content$body === void 0 ? void 0 : _content$body.length) > 0 ? content.body : (0, _languageHandler._t)('Attachment'),
          mxEvent: this.props.mxEvent,
          permalinkCreator: this.props.permalinkCreator
        };

        if (content.info) {
          params.width = content.info.w;
          params.height = content.info.h;
          params.fileSize = content.info.size;
        }

        if (this.image.current) {
          const clientRect = this.image.current.getBoundingClientRect();
          params.thumbnailInfo = {
            width: clientRect.width,
            height: clientRect.height,
            positionX: clientRect.x,
            positionY: clientRect.y
          };
        }

        _Modal.default.createDialog(_ImageView.default, params, "mx_Dialog_lightbox", null, true);
      }
    });
    (0, _defineProperty2.default)(this, "isGif", () => {
      var _content$info;

      const content = this.props.mxEvent.getContent();
      return ((_content$info = content.info) === null || _content$info === void 0 ? void 0 : _content$info.mimetype) === "image/gif";
    });
    (0, _defineProperty2.default)(this, "onImageEnter", e => {
      this.setState({
        hover: true
      });

      if (!this.state.showImage || !this.isGif() || _SettingsStore.default.getValue("autoplayGifs")) {
        return;
      }

      const imgElement = e.currentTarget;
      imgElement.src = this.getContentUrl();
    });
    (0, _defineProperty2.default)(this, "onImageLeave", e => {
      this.setState({
        hover: false
      });

      if (!this.state.showImage || !this.isGif() || _SettingsStore.default.getValue("autoplayGifs")) {
        return;
      }

      const imgElement = e.currentTarget;
      imgElement.src = this.getThumbUrl();
    });
    (0, _defineProperty2.default)(this, "onImageError", () => {
      this.clearBlurhashTimeout();
      this.setState({
        imgError: true
      });
    });
    (0, _defineProperty2.default)(this, "onImageLoad", () => {
      this.clearBlurhashTimeout();
      this.props.onHeightChanged();
      let loadedImageDimensions;

      if (this.image.current) {
        const {
          naturalWidth,
          naturalHeight
        } = this.image.current; // this is only used as a fallback in case content.info.w/h is missing

        loadedImageDimensions = {
          naturalWidth,
          naturalHeight
        };
      }

      this.setState({
        imgLoaded: true,
        loadedImageDimensions
      });
    });
    this.state = {
      decryptedUrl: null,
      decryptedThumbnailUrl: null,
      decryptedBlob: null,
      error: null,
      imgError: false,
      imgLoaded: false,
      loadedImageDimensions: null,
      hover: false,
      showImage: _SettingsStore.default.getValue("showImages"),
      placeholder: 'no-image'
    };
  } // FIXME: factor this out and apply it to MVideoBody and MAudioBody too!


  showImage() {
    localStorage.setItem("mx_ShowImage_" + this.props.mxEvent.getId(), "true");
    this.setState({
      showImage: true
    });
    this.downloadImage();
  }

  getContentUrl() {
    var _content$file;

    const content = this.props.mxEvent.getContent(); // During export, the content url will point to the MSC, which will later point to a local url

    if (this.props.forExport) return content.url || ((_content$file = content.file) === null || _content$file === void 0 ? void 0 : _content$file.url);

    if (this.media.isEncrypted) {
      return this.state.decryptedUrl;
    } else {
      return this.media.srcHttp;
    }
  }

  get media() {
    return (0, _Media.mediaFromContent)(this.props.mxEvent.getContent());
  }

  getThumbUrl() {
    // FIXME: we let images grow as wide as you like, rather than capped to 800x600.
    // So either we need to support custom timeline widths here, or reimpose the cap, otherwise the
    // thumbnail resolution will be unnecessarily reduced.
    // custom timeline widths seems preferable.
    const thumbWidth = 800;
    const thumbHeight = 600;
    const content = this.props.mxEvent.getContent();
    const media = (0, _Media.mediaFromContent)(content);

    if (media.isEncrypted) {
      // Don't use the thumbnail for clients wishing to autoplay gifs.
      if (this.state.decryptedThumbnailUrl) {
        return this.state.decryptedThumbnailUrl;
      }

      return this.state.decryptedUrl;
    } else if (content.info && content.info.mimetype === "image/svg+xml" && media.hasThumbnail) {
      // special case to return clientside sender-generated thumbnails for SVGs, if any,
      // given we deliberately don't thumbnail them serverside to prevent
      // billion lol attacks and similar
      return media.getThumbnailHttp(thumbWidth, thumbHeight, 'scale');
    } else {
      // we try to download the correct resolution
      // for hi-res images (like retina screenshots).
      // synapse only supports 800x600 thumbnails for now though,
      // so we'll need to download the original image for this to work
      // well for now. First, let's try a few cases that let us avoid
      // downloading the original, including:
      //   - When displaying a GIF, we always want to thumbnail so that we can
      //     properly respect the user's GIF autoplay setting (which relies on
      //     thumbnailing to produce the static preview image)
      //   - On a low DPI device, always thumbnail to save bandwidth
      //   - If there's no sizing info in the event, default to thumbnail
      const info = content.info;

      if (this.isGif() || window.devicePixelRatio === 1.0 || !info || !info.w || !info.h || !info.size) {
        return media.getThumbnailOfSourceHttp(thumbWidth, thumbHeight);
      } else {
        // we should only request thumbnails if the image is bigger than 800x600
        // (or 1600x1200 on retina) otherwise the image in the timeline will just
        // end up resampled and de-retina'd for no good reason.
        // Ideally the server would pregen 1600x1200 thumbnails in order to provide retina
        // thumbnails, but we don't do this currently in synapse for fear of disk space.
        // As a compromise, let's switch to non-retina thumbnails only if the original
        // image is both physically too large and going to be massive to load in the
        // timeline (e.g. >1MB).
        const isLargerThanThumbnail = info.w > thumbWidth || info.h > thumbHeight;
        const isLargeFileSize = info.size > 1 * 1024 * 1024; // 1mb

        if (isLargeFileSize && isLargerThanThumbnail) {
          // image is too large physically and bytewise to clutter our timeline so
          // we ask for a thumbnail, despite knowing that it will be max 800x600
          // despite us being retina (as synapse doesn't do 1600x1200 thumbs yet).
          return media.getThumbnailOfSourceHttp(thumbWidth, thumbHeight);
        } else {
          // download the original image otherwise, so we can scale it client side
          // to take pixelRatio into account.
          return media.srcHttp;
        }
      }
    }
  }

  async downloadImage() {
    if (this.props.mediaEventHelper.media.isEncrypted && this.state.decryptedUrl === null) {
      try {
        const thumbnailUrl = await this.props.mediaEventHelper.thumbnailUrl.value;
        this.setState({
          decryptedUrl: await this.props.mediaEventHelper.sourceUrl.value,
          decryptedThumbnailUrl: thumbnailUrl,
          decryptedBlob: await this.props.mediaEventHelper.sourceBlob.value
        });
      } catch (err) {
        if (this.unmounted) return;

        _logger.logger.warn("Unable to decrypt attachment: ", err); // Set a placeholder image when we can't decrypt the image.


        this.setState({
          error: err
        });
      }
    }
  }

  clearBlurhashTimeout() {
    if (this.timeout) {
      clearTimeout(this.timeout);
      this.timeout = undefined;
    }
  }

  componentDidMount() {
    var _this$props$mxEvent$g;

    this.unmounted = false;
    this.context.on('sync', this.onClientSync);
    const showImage = this.state.showImage || localStorage.getItem("mx_ShowImage_" + this.props.mxEvent.getId()) === "true";

    if (showImage) {
      // noinspection JSIgnoredPromiseFromCall
      this.downloadImage();
      this.setState({
        showImage: true
      });
    } // else don't download anything because we don't want to display anything.
    // Add a 150ms timer for blurhash to first appear.


    if ((_this$props$mxEvent$g = this.props.mxEvent.getContent().info) !== null && _this$props$mxEvent$g !== void 0 && _this$props$mxEvent$g[_ContentMessages.BLURHASH_FIELD]) {
      this.clearBlurhashTimeout();
      this.timeout = setTimeout(() => {
        if (!this.state.imgLoaded || !this.state.imgError) {
          this.setState({
            placeholder: 'blurhash'
          });
        }
      }, 150);
    }

    this.sizeWatcher = _SettingsStore.default.watchSetting("Images.size", null, () => {
      this.forceUpdate(); // we don't really have a reliable thing to update, so just update the whole thing
    });
  }

  componentWillUnmount() {
    this.unmounted = true;
    this.context.removeListener('sync', this.onClientSync);
    this.clearBlurhashTimeout();

    _SettingsStore.default.unwatchSetting(this.sizeWatcher);
  }

  messageContent(contentUrl, thumbUrl, content, forcedHeight) {
    var _this$props$mxEvent$g2;

    let infoWidth;
    let infoHeight;

    if (content && content.info && content.info.w && content.info.h) {
      infoWidth = content.info.w;
      infoHeight = content.info.h;
    } else {
      // Whilst the image loads, display nothing. We also don't display a blurhash image
      // because we don't really know what size of image we'll end up with.
      //
      // Once loaded, use the loaded image dimensions stored in `loadedImageDimensions`.
      //
      // By doing this, the image "pops" into the timeline, but is still restricted
      // by the same width and height logic below.
      if (!this.state.loadedImageDimensions) {
        let imageElement;

        if (!this.state.showImage) {
          imageElement = /*#__PURE__*/_react.default.createElement(HiddenImagePlaceholder, null);
        } else {
          imageElement = /*#__PURE__*/_react.default.createElement("img", {
            style: {
              display: 'none'
            },
            src: thumbUrl,
            ref: this.image,
            alt: content.body,
            onError: this.onImageError,
            onLoad: this.onImageLoad
          });
        }

        return this.wrapImage(contentUrl, imageElement);
      }

      infoWidth = this.state.loadedImageDimensions.naturalWidth;
      infoHeight = this.state.loadedImageDimensions.naturalHeight;
    } // The maximum size of the thumbnail as it is rendered as an <img>
    // check for any height constraints


    const imageSize = _SettingsStore.default.getValue("Images.size");

    const isPortrait = infoWidth < infoHeight;
    const suggestedAndPossibleWidth = Math.min((0, _ImageSize.suggestedSize)(imageSize, isPortrait).w, infoWidth);
    const suggestedAndPossibleHeight = Math.min((0, _ImageSize.suggestedSize)(imageSize, isPortrait).h, infoHeight);
    const aspectRatio = infoWidth / infoHeight;
    let maxWidth;
    let maxHeight;
    const maxHeightConstraint = forcedHeight || this.props.maxImageHeight || suggestedAndPossibleHeight;

    if (maxHeightConstraint * aspectRatio < suggestedAndPossibleWidth || imageSize === _ImageSize.ImageSize.Large) {
      // The width is dictated by the maximum height that was defined by the props or the function param `forcedHeight`
      // If the thumbnail size is set to Large, we always let the size be dictated by the height.
      maxWidth = maxHeightConstraint * aspectRatio; // there is no need to check for infoHeight here since this is done with `maxHeightConstraint * aspectRatio < suggestedAndPossibleWidth`

      maxHeight = maxHeightConstraint;
    } else {
      // height is dictated by suggestedWidth (based on the Image.size setting)
      maxWidth = suggestedAndPossibleWidth;
      maxHeight = suggestedAndPossibleWidth / aspectRatio;
    }

    let img = null;
    let placeholder = null;
    let gifLabel = null;

    if (!this.props.forExport && !this.state.imgLoaded) {
      placeholder = this.getPlaceholder(maxWidth, maxHeight);
    }

    let showPlaceholder = Boolean(placeholder);

    if (thumbUrl && !this.state.imgError) {
      // Restrict the width of the thumbnail here, otherwise it will fill the container
      // which has the same width as the timeline
      // mx_MImageBody_thumbnail resizes img to exactly container size
      img = /*#__PURE__*/_react.default.createElement("img", {
        className: "mx_MImageBody_thumbnail",
        src: thumbUrl,
        ref: this.image // Force the image to be the full size of the container, even if the
        // pixel size is smaller. The problem here is that we don't know what
        // thumbnail size the HS is going to give us, but we have to commit to
        // a container size immediately and not change it when the image loads
        // or we'll get a scroll jump (or have to leave blank space).
        // This will obviously result in an upscaled image which will be a bit
        // blurry. The best fix would be for the HS to advertise what size thumbnails
        // it guarantees to produce.
        ,
        style: {
          height: '100%'
        },
        alt: content.body,
        onError: this.onImageError,
        onLoad: this.onImageLoad,
        onMouseEnter: this.onImageEnter,
        onMouseLeave: this.onImageLeave
      });
    }

    if (!this.state.showImage) {
      img = /*#__PURE__*/_react.default.createElement(HiddenImagePlaceholder, {
        maxWidth: maxWidth
      });
      showPlaceholder = false; // because we're hiding the image, so don't show the placeholder.
    }

    if (this.isGif() && !_SettingsStore.default.getValue("autoplayGifs") && !this.state.hover) {
      gifLabel = /*#__PURE__*/_react.default.createElement("p", {
        className: "mx_MImageBody_gifLabel"
      }, "GIF");
    }

    const classes = (0, _classnames.default)({
      'mx_MImageBody_thumbnail': true,
      'mx_MImageBody_thumbnail--blurhash': (_this$props$mxEvent$g2 = this.props.mxEvent.getContent().info) === null || _this$props$mxEvent$g2 === void 0 ? void 0 : _this$props$mxEvent$g2[_ContentMessages.BLURHASH_FIELD]
    }); // This has incredibly broken types.

    const C = _reactTransitionGroup.CSSTransition;

    const thumbnail = /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_MImageBody_thumbnail_container",
      style: {
        maxHeight: maxHeight,
        maxWidth: maxWidth,
        aspectRatio: `${infoWidth}/${infoHeight}`
      }
    }, /*#__PURE__*/_react.default.createElement(_reactTransitionGroup.SwitchTransition, {
      mode: "out-in"
    }, /*#__PURE__*/_react.default.createElement(C, {
      classNames: "mx_rtg--fade",
      key: `img-${showPlaceholder}`,
      timeout: 300
    }, /*#__PURE__*/_react.default.createElement("div", null, showPlaceholder && /*#__PURE__*/_react.default.createElement("div", {
      className: classes,
      style: {
        // Constrain width here so that spinner appears central to the loaded thumbnail
        maxWidth: `min(100%, ${infoWidth}px)`,
        maxHeight: maxHeight,
        aspectRatio: `${infoWidth}/${infoHeight}`
      }
    }, placeholder)))), /*#__PURE__*/_react.default.createElement("div", {
      style: {
        height: '100%'
      }
    }, img, gifLabel), this.state.hover && this.getTooltip());

    return this.wrapImage(contentUrl, thumbnail);
  } // Overidden by MStickerBody


  wrapImage(contentUrl, children) {
    return /*#__PURE__*/_react.default.createElement("a", {
      href: contentUrl,
      target: this.props.forExport ? "_blank" : undefined,
      onClick: this.onClick
    }, children);
  } // Overidden by MStickerBody


  getPlaceholder(width, height) {
    var _this$props$mxEvent$g3;

    const blurhash = (_this$props$mxEvent$g3 = this.props.mxEvent.getContent().info) === null || _this$props$mxEvent$g3 === void 0 ? void 0 : _this$props$mxEvent$g3[_ContentMessages.BLURHASH_FIELD];

    if (blurhash) {
      if (this.state.placeholder === 'no-image') {
        return /*#__PURE__*/_react.default.createElement("div", {
          className: "mx_no-image-placeholder",
          style: {
            width: width,
            height: height
          }
        });
      } else if (this.state.placeholder === 'blurhash') {
        return /*#__PURE__*/_react.default.createElement(_reactBlurhash.Blurhash, {
          className: "mx_Blurhash",
          hash: blurhash,
          width: width,
          height: height
        });
      }
    }

    return /*#__PURE__*/_react.default.createElement(_InlineSpinner.default, {
      w: 32,
      h: 32
    });
  } // Overidden by MStickerBody


  getTooltip() {
    return null;
  } // Overidden by MStickerBody


  getFileBody() {
    if (this.props.forExport) return null;
    /*
     * In the room timeline or the thread context we don't need the download
     * link as the message action bar will fullfil that
     */

    const hasMessageActionBar = !this.props.tileShape || this.props.tileShape === _EventTile.TileShape.Thread || this.props.tileShape === _EventTile.TileShape.ThreadPanel;

    if (!hasMessageActionBar) {
      return /*#__PURE__*/_react.default.createElement(_MFileBody.default, (0, _extends2.default)({}, this.props, {
        showGenericPlaceholder: false
      }));
    }
  }

  render() {
    const content = this.props.mxEvent.getContent();

    if (this.state.error !== null) {
      return /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_MImageBody"
      }, /*#__PURE__*/_react.default.createElement("img", {
        src: require("../../../../res/img/warning.svg"),
        width: "16",
        height: "16"
      }), (0, _languageHandler._t)("Error decrypting image"));
    }

    const contentUrl = this.getContentUrl();
    let thumbUrl;

    if (this.props.forExport || this.isGif() && _SettingsStore.default.getValue("autoplayGifs")) {
      thumbUrl = contentUrl;
    } else {
      thumbUrl = this.getThumbUrl();
    }

    const thumbnail = this.messageContent(contentUrl, thumbUrl, content);
    const fileBody = this.getFileBody();
    return /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_MImageBody"
    }, thumbnail, fileBody);
  }

}, (0, _defineProperty2.default)(_class2, "contextType", _MatrixClientContext.default), _temp)) || _class);
exports.default = MImageBody;

class HiddenImagePlaceholder extends _react.default.PureComponent {
  render() {
    const maxWidth = this.props.maxWidth ? this.props.maxWidth + "px" : null;
    let className = 'mx_HiddenImagePlaceholder';
    if (this.props.hover) className += ' mx_HiddenImagePlaceholder_hover';
    return /*#__PURE__*/_react.default.createElement("div", {
      className: className,
      style: {
        maxWidth: `min(100%, ${maxWidth}px)`
      }
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_HiddenImagePlaceholder_button"
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: "mx_HiddenImagePlaceholder_eye"
    }), /*#__PURE__*/_react.default.createElement("span", null, (0, _languageHandler._t)("Show image"))));
  }

}

exports.HiddenImagePlaceholder = HiddenImagePlaceholder;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL21lc3NhZ2VzL01JbWFnZUJvZHkudHN4Il0sIm5hbWVzIjpbIk1JbWFnZUJvZHkiLCJSZWFjdCIsIkNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJzeW5jU3RhdGUiLCJwcmV2U3RhdGUiLCJ1bm1vdW50ZWQiLCJyZWNvbm5lY3RlZCIsInN0YXRlIiwiaW1nRXJyb3IiLCJzZXRTdGF0ZSIsImV2IiwiYnV0dG9uIiwibWV0YUtleSIsInByZXZlbnREZWZhdWx0Iiwic2hvd0ltYWdlIiwiY29udGVudCIsIm14RXZlbnQiLCJnZXRDb250ZW50IiwiaHR0cFVybCIsImdldENvbnRlbnRVcmwiLCJwYXJhbXMiLCJzcmMiLCJuYW1lIiwiYm9keSIsImxlbmd0aCIsInBlcm1hbGlua0NyZWF0b3IiLCJpbmZvIiwid2lkdGgiLCJ3IiwiaGVpZ2h0IiwiaCIsImZpbGVTaXplIiwic2l6ZSIsImltYWdlIiwiY3VycmVudCIsImNsaWVudFJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0aHVtYm5haWxJbmZvIiwicG9zaXRpb25YIiwieCIsInBvc2l0aW9uWSIsInkiLCJNb2RhbCIsImNyZWF0ZURpYWxvZyIsIkltYWdlVmlldyIsIm1pbWV0eXBlIiwiZSIsImhvdmVyIiwiaXNHaWYiLCJTZXR0aW5nc1N0b3JlIiwiZ2V0VmFsdWUiLCJpbWdFbGVtZW50IiwiY3VycmVudFRhcmdldCIsImdldFRodW1iVXJsIiwiY2xlYXJCbHVyaGFzaFRpbWVvdXQiLCJvbkhlaWdodENoYW5nZWQiLCJsb2FkZWRJbWFnZURpbWVuc2lvbnMiLCJuYXR1cmFsV2lkdGgiLCJuYXR1cmFsSGVpZ2h0IiwiaW1nTG9hZGVkIiwiZGVjcnlwdGVkVXJsIiwiZGVjcnlwdGVkVGh1bWJuYWlsVXJsIiwiZGVjcnlwdGVkQmxvYiIsImVycm9yIiwicGxhY2Vob2xkZXIiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiZ2V0SWQiLCJkb3dubG9hZEltYWdlIiwiZm9yRXhwb3J0IiwidXJsIiwiZmlsZSIsIm1lZGlhIiwiaXNFbmNyeXB0ZWQiLCJzcmNIdHRwIiwidGh1bWJXaWR0aCIsInRodW1iSGVpZ2h0IiwiaGFzVGh1bWJuYWlsIiwiZ2V0VGh1bWJuYWlsSHR0cCIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJnZXRUaHVtYm5haWxPZlNvdXJjZUh0dHAiLCJpc0xhcmdlclRoYW5UaHVtYm5haWwiLCJpc0xhcmdlRmlsZVNpemUiLCJtZWRpYUV2ZW50SGVscGVyIiwidGh1bWJuYWlsVXJsIiwidmFsdWUiLCJzb3VyY2VVcmwiLCJzb3VyY2VCbG9iIiwiZXJyIiwibG9nZ2VyIiwid2FybiIsInRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJ1bmRlZmluZWQiLCJjb21wb25lbnREaWRNb3VudCIsImNvbnRleHQiLCJvbiIsIm9uQ2xpZW50U3luYyIsImdldEl0ZW0iLCJCTFVSSEFTSF9GSUVMRCIsInNldFRpbWVvdXQiLCJzaXplV2F0Y2hlciIsIndhdGNoU2V0dGluZyIsImZvcmNlVXBkYXRlIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJyZW1vdmVMaXN0ZW5lciIsInVud2F0Y2hTZXR0aW5nIiwibWVzc2FnZUNvbnRlbnQiLCJjb250ZW50VXJsIiwidGh1bWJVcmwiLCJmb3JjZWRIZWlnaHQiLCJpbmZvV2lkdGgiLCJpbmZvSGVpZ2h0IiwiaW1hZ2VFbGVtZW50IiwiZGlzcGxheSIsIm9uSW1hZ2VFcnJvciIsIm9uSW1hZ2VMb2FkIiwid3JhcEltYWdlIiwiaW1hZ2VTaXplIiwiaXNQb3J0cmFpdCIsInN1Z2dlc3RlZEFuZFBvc3NpYmxlV2lkdGgiLCJNYXRoIiwibWluIiwic3VnZ2VzdGVkQW5kUG9zc2libGVIZWlnaHQiLCJhc3BlY3RSYXRpbyIsIm1heFdpZHRoIiwibWF4SGVpZ2h0IiwibWF4SGVpZ2h0Q29uc3RyYWludCIsIm1heEltYWdlSGVpZ2h0IiwiSW1hZ2VTaXplIiwiTGFyZ2UiLCJpbWciLCJnaWZMYWJlbCIsImdldFBsYWNlaG9sZGVyIiwic2hvd1BsYWNlaG9sZGVyIiwiQm9vbGVhbiIsIm9uSW1hZ2VFbnRlciIsIm9uSW1hZ2VMZWF2ZSIsImNsYXNzZXMiLCJDIiwiQ1NTVHJhbnNpdGlvbiIsInRodW1ibmFpbCIsImdldFRvb2x0aXAiLCJjaGlsZHJlbiIsIm9uQ2xpY2siLCJibHVyaGFzaCIsImdldEZpbGVCb2R5IiwiaGFzTWVzc2FnZUFjdGlvbkJhciIsInRpbGVTaGFwZSIsIlRpbGVTaGFwZSIsIlRocmVhZCIsIlRocmVhZFBhbmVsIiwicmVuZGVyIiwicmVxdWlyZSIsImZpbGVCb2R5IiwiTWF0cml4Q2xpZW50Q29udGV4dCIsIkhpZGRlbkltYWdlUGxhY2Vob2xkZXIiLCJQdXJlQ29tcG9uZW50IiwiY2xhc3NOYW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBaUJBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUdBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOzs7Ozs7OztJQW1CcUJBLFUsV0FEcEIsZ0RBQXFCLDJCQUFyQixDLG1DQUFELE1BQ3FCQSxVQURyQixTQUN3Q0MsZUFBTUMsU0FEOUMsQ0FDNEU7QUFPeEVDLEVBQUFBLFdBQVcsQ0FBQ0MsS0FBRCxFQUFvQjtBQUMzQixVQUFNQSxLQUFOO0FBRDJCLHFEQUxYLElBS1c7QUFBQSw4REFKZix1QkFJZTtBQUFBO0FBQUE7QUFBQSx3REFrQlIsQ0FBQ0MsU0FBRCxFQUF1QkMsU0FBdkIsS0FBc0Q7QUFDekUsVUFBSSxLQUFLQyxTQUFULEVBQW9CLE9BRHFELENBRXpFO0FBQ0E7O0FBQ0EsWUFBTUMsV0FBVyxHQUFHSCxTQUFTLEtBQUssT0FBZCxJQUF5QkMsU0FBUyxLQUFLRCxTQUEzRDs7QUFDQSxVQUFJRyxXQUFXLElBQUksS0FBS0MsS0FBTCxDQUFXQyxRQUE5QixFQUF3QztBQUNwQztBQUNBLGFBQUtDLFFBQUwsQ0FBYztBQUNWRCxVQUFB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QUE1QyxHQUFtRCxJQUFwRTtBQUNBLFFBQUlpQyxTQUFTLEdBQUcsMkJBQWhCO0FBQ0EsUUFBSSxLQUFLN0osS0FBTCxDQUFXNkMsS0FBZixFQUFzQmdILFNBQVMsSUFBSSxrQ0FBYjtBQUN0Qix3QkFDSTtBQUFLLE1BQUEsU0FBUyxFQUFFQSxTQUFoQjtBQUEyQixNQUFBLEtBQUssRUFBRTtBQUFFakMsUUFBQUEsUUFBUSxFQUFHLGFBQVlBLFFBQVM7QUFBbEM7QUFBbEMsb0JBQ0k7QUFBSyxNQUFBLFNBQVMsRUFBQztBQUFmLG9CQUNJO0FBQU0sTUFBQSxTQUFTLEVBQUM7QUFBaEIsTUFESixlQUVJLDJDQUFRLHlCQUFHLFlBQUgsQ0FBUixDQUZKLENBREosQ0FESjtBQVFIOztBQWI4RSIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxNSAtIDIwMjEgVGhlIE1hdHJpeC5vcmcgRm91bmRhdGlvbiBDLkkuQy5cbkNvcHlyaWdodCAyMDE4LCAyMDE5IE1pY2hhZWwgVGVsYXR5bnNraSA8N3QzY2hndXlAZ21haWwuY29tPlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnRQcm9wcywgY3JlYXRlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQmx1cmhhc2ggfSBmcm9tIFwicmVhY3QtYmx1cmhhc2hcIjtcblxuaW1wb3J0IE1GaWxlQm9keSBmcm9tICcuL01GaWxlQm9keSc7XG5pbXBvcnQgTW9kYWwgZnJvbSAnLi4vLi4vLi4vTW9kYWwnO1xuaW1wb3J0IHsgX3QgfSBmcm9tICcuLi8uLi8uLi9sYW5ndWFnZUhhbmRsZXInO1xuaW1wb3J0IFNldHRpbmdzU3RvcmUgZnJvbSBcIi4uLy4uLy4uL3NldHRpbmdzL1NldHRpbmdzU3RvcmVcIjtcbmltcG9ydCBNYXRyaXhDbGllbnRDb250ZXh0IGZyb20gXCIuLi8uLi8uLi9jb250ZXh0cy9NYXRyaXhDbGllbnRDb250ZXh0XCI7XG5pbXBvcnQgSW5saW5lU3Bpbm5lciBmcm9tICcuLi9lbGVtZW50cy9JbmxpbmVTcGlubmVyJztcbmltcG9ydCB7IHJlcGxhY2VhYmxlQ29tcG9uZW50IH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL3JlcGxhY2VhYmxlQ29tcG9uZW50XCI7XG5pbXBvcnQgeyBNZWRpYSwgbWVkaWFGcm9tQ29udGVudCB9IGZyb20gXCIuLi8uLi8uLi9jdXN0b21pc2F0aW9ucy9NZWRpYVwiO1xuaW1wb3J0IHsgQkxVUkhBU0hfRklFTEQgfSBmcm9tIFwiLi4vLi4vLi4vQ29udGVudE1lc3NhZ2VzXCI7XG5pbXBvcnQgeyBJTWVkaWFFdmVudENvbnRlbnQgfSBmcm9tICcuLi8uLi8uLi9jdXN0b21pc2F0aW9ucy9tb2RlbHMvSU1lZGlhRXZlbnRDb250ZW50JztcbmltcG9ydCBJbWFnZVZpZXcgZnJvbSAnLi4vZWxlbWVudHMvSW1hZ2VWaWV3JztcbmltcG9ydCB7IFN5bmNTdGF0ZSB9IGZyb20gJ21hdHJpeC1qcy1zZGsvc3JjL3N5bmMuYXBpJztcbmltcG9ydCB7IElCb2R5UHJvcHMgfSBmcm9tIFwiLi9JQm9keVByb3BzXCI7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IENTU1RyYW5zaXRpb24sIFN3aXRjaFRyYW5zaXRpb24gfSBmcm9tICdyZWFjdC10cmFuc2l0aW9uLWdyb3VwJztcblxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL2xvZ2dlclwiO1xuaW1wb3J0IHsgVGlsZVNoYXBlIH0gZnJvbSAnLi4vcm9vbXMvRXZlbnRUaWxlJztcbmltcG9ydCB7IEltYWdlU2l6ZSwgc3VnZ2VzdGVkU2l6ZSBhcyBzdWdnZXN0ZWRJbWFnZVNpemUgfSBmcm9tIFwiLi4vLi4vLi4vc2V0dGluZ3MvZW51bXMvSW1hZ2VTaXplXCI7XG5cbmludGVyZmFjZSBJU3RhdGUge1xuICAgIGRlY3J5cHRlZFVybD86IHN0cmluZztcbiAgICBkZWNyeXB0ZWRUaHVtYm5haWxVcmw/OiBzdHJpbmc7XG4gICAgZGVjcnlwdGVkQmxvYj86IEJsb2I7XG4gICAgZXJyb3I7XG4gICAgaW1nRXJyb3I6IGJvb2xlYW47XG4gICAgaW1nTG9hZGVkOiBib29sZWFuO1xuICAgIGxvYWRlZEltYWdlRGltZW5zaW9ucz86IHtcbiAgICAgICAgbmF0dXJhbFdpZHRoOiBudW1iZXI7XG4gICAgICAgIG5hdHVyYWxIZWlnaHQ6IG51bWJlcjtcbiAgICB9O1xuICAgIGhvdmVyOiBib29sZWFuO1xuICAgIHNob3dJbWFnZTogYm9vbGVhbjtcbiAgICBwbGFjZWhvbGRlcjogJ25vLWltYWdlJyB8ICdibHVyaGFzaCc7XG59XG5cbkByZXBsYWNlYWJsZUNvbXBvbmVudChcInZpZXdzLm1lc3NhZ2VzLk1JbWFnZUJvZHlcIilcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1JbWFnZUJvZHkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8SUJvZHlQcm9wcywgSVN0YXRlPiB7XG4gICAgc3RhdGljIGNvbnRleHRUeXBlID0gTWF0cml4Q2xpZW50Q29udGV4dDtcbiAgICBwcml2YXRlIHVubW91bnRlZCA9IHRydWU7XG4gICAgcHJpdmF0ZSBpbWFnZSA9IGNyZWF0ZVJlZjxIVE1MSW1hZ2VFbGVtZW50PigpO1xuICAgIHByaXZhdGUgdGltZW91dD86IG51bWJlcjtcbiAgICBwcml2YXRlIHNpemVXYXRjaGVyOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wczogSUJvZHlQcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGRlY3J5cHRlZFVybDogbnVsbCxcbiAgICAgICAgICAgIGRlY3J5cHRlZFRodW1ibmFpbFVybDogbnVsbCxcbiAgICAgICAgICAgIGRlY3J5cHRlZEJsb2I6IG51bGwsXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIGltZ0Vycm9yOiBmYWxzZSxcbiAgICAgICAgICAgIGltZ0xvYWRlZDogZmFsc2UsXG4gICAgICAgICAgICBsb2FkZWRJbWFnZURpbWVuc2lvbnM6IG51bGwsXG4gICAgICAgICAgICBob3ZlcjogZmFsc2UsXG4gICAgICAgICAgICBzaG93SW1hZ2U6IFNldHRpbmdzU3RvcmUuZ2V0VmFsdWUoXCJzaG93SW1hZ2VzXCIpLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICduby1pbWFnZScsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRklYTUU6IGZhY3RvciB0aGlzIG91dCBhbmQgYXBwbHkgaXQgdG8gTVZpZGVvQm9keSBhbmQgTUF1ZGlvQm9keSB0b28hXG4gICAgcHJpdmF0ZSBvbkNsaWVudFN5bmMgPSAoc3luY1N0YXRlOiBTeW5jU3RhdGUsIHByZXZTdGF0ZTogU3luY1N0YXRlKTogdm9pZCA9PiB7XG4gICAgICAgIGlmICh0aGlzLnVubW91bnRlZCkgcmV0dXJuO1xuICAgICAgICAvLyBDb25zaWRlciB0aGUgY2xpZW50IHJlY29ubmVjdGVkIGlmIHRoZXJlIGlzIG5vIGVycm9yIHdpdGggc3luY2luZy5cbiAgICAgICAgLy8gVGhpcyBtZWFucyB0aGUgc3RhdGUgY291bGQgYmUgUkVDT05ORUNUSU5HLCBTWU5DSU5HLCBQUkVQQVJFRCBvciBDQVRDSFVQLlxuICAgICAgICBjb25zdCByZWNvbm5lY3RlZCA9IHN5bmNTdGF0ZSAhPT0gXCJFUlJPUlwiICYmIHByZXZTdGF0ZSAhPT0gc3luY1N0YXRlO1xuICAgICAgICBpZiAocmVjb25uZWN0ZWQgJiYgdGhpcy5zdGF0ZS5pbWdFcnJvcikge1xuICAgICAgICAgICAgLy8gTG9hZCB0aGUgaW1hZ2UgYWdhaW5cbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGltZ0Vycm9yOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBzaG93SW1hZ2UoKTogdm9pZCB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwibXhfU2hvd0ltYWdlX1wiICsgdGhpcy5wcm9wcy5teEV2ZW50LmdldElkKCksIFwidHJ1ZVwiKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHNob3dJbWFnZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5kb3dubG9hZEltYWdlKCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIG9uQ2xpY2sgPSAoZXY6IFJlYWN0Lk1vdXNlRXZlbnQpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKGV2LmJ1dHRvbiA9PT0gMCAmJiAhZXYubWV0YUtleSkge1xuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0ZS5zaG93SW1hZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dJbWFnZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMucHJvcHMubXhFdmVudC5nZXRDb250ZW50PElNZWRpYUV2ZW50Q29udGVudD4oKTtcbiAgICAgICAgICAgIGNvbnN0IGh0dHBVcmwgPSB0aGlzLmdldENvbnRlbnRVcmwoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtczogT21pdDxDb21wb25lbnRQcm9wczx0eXBlb2YgSW1hZ2VWaWV3PiwgXCJvbkZpbmlzaGVkXCI+ID0ge1xuICAgICAgICAgICAgICAgIHNyYzogaHR0cFVybCxcbiAgICAgICAgICAgICAgICBuYW1lOiBjb250ZW50LmJvZHk/Lmxlbmd0aCA+IDAgPyBjb250ZW50LmJvZHkgOiBfdCgnQXR0YWNobWVudCcpLFxuICAgICAgICAgICAgICAgIG14RXZlbnQ6IHRoaXMucHJvcHMubXhFdmVudCxcbiAgICAgICAgICAgICAgICBwZXJtYWxpbmtDcmVhdG9yOiB0aGlzLnByb3BzLnBlcm1hbGlua0NyZWF0b3IsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoY29udGVudC5pbmZvKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLndpZHRoID0gY29udGVudC5pbmZvLnc7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmhlaWdodCA9IGNvbnRlbnQuaW5mby5oO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5maWxlU2l6ZSA9IGNvbnRlbnQuaW5mby5zaXplO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5pbWFnZS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xpZW50UmVjdCA9IHRoaXMuaW1hZ2UuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgICAgIHBhcmFtcy50aHVtYm5haWxJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogY2xpZW50UmVjdC53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBjbGllbnRSZWN0LmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25YOiBjbGllbnRSZWN0LngsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uWTogY2xpZW50UmVjdC55LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE1vZGFsLmNyZWF0ZURpYWxvZyhJbWFnZVZpZXcsIHBhcmFtcywgXCJteF9EaWFsb2dfbGlnaHRib3hcIiwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBpc0dpZiA9ICgpOiBib29sZWFuID0+IHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMucHJvcHMubXhFdmVudC5nZXRDb250ZW50KCk7XG4gICAgICAgIHJldHVybiBjb250ZW50LmluZm8/Lm1pbWV0eXBlID09PSBcImltYWdlL2dpZlwiO1xuICAgIH07XG5cbiAgICBwcml2YXRlIG9uSW1hZ2VFbnRlciA9IChlOiBSZWFjdC5Nb3VzZUV2ZW50PEhUTUxJbWFnZUVsZW1lbnQ+KTogdm9pZCA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBob3ZlcjogdHJ1ZSB9KTtcblxuICAgICAgICBpZiAoIXRoaXMuc3RhdGUuc2hvd0ltYWdlIHx8ICF0aGlzLmlzR2lmKCkgfHwgU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZShcImF1dG9wbGF5R2lmc1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGltZ0VsZW1lbnQgPSBlLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIGltZ0VsZW1lbnQuc3JjID0gdGhpcy5nZXRDb250ZW50VXJsKCk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25JbWFnZUxlYXZlID0gKGU6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTEltYWdlRWxlbWVudD4pOiB2b2lkID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGhvdmVyOiBmYWxzZSB9KTtcblxuICAgICAgICBpZiAoIXRoaXMuc3RhdGUuc2hvd0ltYWdlIHx8ICF0aGlzLmlzR2lmKCkgfHwgU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZShcImF1dG9wbGF5R2lmc1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGltZ0VsZW1lbnQgPSBlLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIGltZ0VsZW1lbnQuc3JjID0gdGhpcy5nZXRUaHVtYlVybCgpO1xuICAgIH07XG5cbiAgICBwcml2YXRlIG9uSW1hZ2VFcnJvciA9ICgpOiB2b2lkID0+IHtcbiAgICAgICAgdGhpcy5jbGVhckJsdXJoYXNoVGltZW91dCgpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGltZ0Vycm9yOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbkltYWdlTG9hZCA9ICgpOiB2b2lkID0+IHtcbiAgICAgICAgdGhpcy5jbGVhckJsdXJoYXNoVGltZW91dCgpO1xuICAgICAgICB0aGlzLnByb3BzLm9uSGVpZ2h0Q2hhbmdlZCgpO1xuXG4gICAgICAgIGxldCBsb2FkZWRJbWFnZURpbWVuc2lvbnM7XG5cbiAgICAgICAgaWYgKHRoaXMuaW1hZ2UuY3VycmVudCkge1xuICAgICAgICAgICAgY29uc3QgeyBuYXR1cmFsV2lkdGgsIG5hdHVyYWxIZWlnaHQgfSA9IHRoaXMuaW1hZ2UuY3VycmVudDtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgb25seSB1c2VkIGFzIGEgZmFsbGJhY2sgaW4gY2FzZSBjb250ZW50LmluZm8udy9oIGlzIG1pc3NpbmdcbiAgICAgICAgICAgIGxvYWRlZEltYWdlRGltZW5zaW9ucyA9IHsgbmF0dXJhbFdpZHRoLCBuYXR1cmFsSGVpZ2h0IH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGltZ0xvYWRlZDogdHJ1ZSwgbG9hZGVkSW1hZ2VEaW1lbnNpb25zIH0pO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgZ2V0Q29udGVudFVybCgpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBjb250ZW50OiBJTWVkaWFFdmVudENvbnRlbnQgPSB0aGlzLnByb3BzLm14RXZlbnQuZ2V0Q29udGVudCgpO1xuICAgICAgICAvLyBEdXJpbmcgZXhwb3J0LCB0aGUgY29udGVudCB1cmwgd2lsbCBwb2ludCB0byB0aGUgTVNDLCB3aGljaCB3aWxsIGxhdGVyIHBvaW50IHRvIGEgbG9jYWwgdXJsXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmZvckV4cG9ydCkgcmV0dXJuIGNvbnRlbnQudXJsIHx8IGNvbnRlbnQuZmlsZT8udXJsO1xuICAgICAgICBpZiAodGhpcy5tZWRpYS5pc0VuY3J5cHRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuZGVjcnlwdGVkVXJsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVkaWEuc3JjSHR0cDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0IG1lZGlhKCk6IE1lZGlhIHtcbiAgICAgICAgcmV0dXJuIG1lZGlhRnJvbUNvbnRlbnQodGhpcy5wcm9wcy5teEV2ZW50LmdldENvbnRlbnQoKSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldFRodW1iVXJsKCk6IHN0cmluZyB7XG4gICAgICAgIC8vIEZJWE1FOiB3ZSBsZXQgaW1hZ2VzIGdyb3cgYXMgd2lkZSBhcyB5b3UgbGlrZSwgcmF0aGVyIHRoYW4gY2FwcGVkIHRvIDgwMHg2MDAuXG4gICAgICAgIC8vIFNvIGVpdGhlciB3ZSBuZWVkIHRvIHN1cHBvcnQgY3VzdG9tIHRpbWVsaW5lIHdpZHRocyBoZXJlLCBvciByZWltcG9zZSB0aGUgY2FwLCBvdGhlcndpc2UgdGhlXG4gICAgICAgIC8vIHRodW1ibmFpbCByZXNvbHV0aW9uIHdpbGwgYmUgdW5uZWNlc3NhcmlseSByZWR1Y2VkLlxuICAgICAgICAvLyBjdXN0b20gdGltZWxpbmUgd2lkdGhzIHNlZW1zIHByZWZlcmFibGUuXG4gICAgICAgIGNvbnN0IHRodW1iV2lkdGggPSA4MDA7XG4gICAgICAgIGNvbnN0IHRodW1iSGVpZ2h0ID0gNjAwO1xuXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLnByb3BzLm14RXZlbnQuZ2V0Q29udGVudDxJTWVkaWFFdmVudENvbnRlbnQ+KCk7XG4gICAgICAgIGNvbnN0IG1lZGlhID0gbWVkaWFGcm9tQ29udGVudChjb250ZW50KTtcblxuICAgICAgICBpZiAobWVkaWEuaXNFbmNyeXB0ZWQpIHtcbiAgICAgICAgICAgIC8vIERvbid0IHVzZSB0aGUgdGh1bWJuYWlsIGZvciBjbGllbnRzIHdpc2hpbmcgdG8gYXV0b3BsYXkgZ2lmcy5cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmRlY3J5cHRlZFRodW1ibmFpbFVybCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmRlY3J5cHRlZFRodW1ibmFpbFVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmRlY3J5cHRlZFVybDtcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZW50LmluZm8gJiYgY29udGVudC5pbmZvLm1pbWV0eXBlID09PSBcImltYWdlL3N2Zyt4bWxcIiAmJiBtZWRpYS5oYXNUaHVtYm5haWwpIHtcbiAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZSB0byByZXR1cm4gY2xpZW50c2lkZSBzZW5kZXItZ2VuZXJhdGVkIHRodW1ibmFpbHMgZm9yIFNWR3MsIGlmIGFueSxcbiAgICAgICAgICAgIC8vIGdpdmVuIHdlIGRlbGliZXJhdGVseSBkb24ndCB0aHVtYm5haWwgdGhlbSBzZXJ2ZXJzaWRlIHRvIHByZXZlbnRcbiAgICAgICAgICAgIC8vIGJpbGxpb24gbG9sIGF0dGFja3MgYW5kIHNpbWlsYXJcbiAgICAgICAgICAgIHJldHVybiBtZWRpYS5nZXRUaHVtYm5haWxIdHRwKHRodW1iV2lkdGgsIHRodW1iSGVpZ2h0LCAnc2NhbGUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdlIHRyeSB0byBkb3dubG9hZCB0aGUgY29ycmVjdCByZXNvbHV0aW9uXG4gICAgICAgICAgICAvLyBmb3IgaGktcmVzIGltYWdlcyAobGlrZSByZXRpbmEgc2NyZWVuc2hvdHMpLlxuICAgICAgICAgICAgLy8gc3luYXBzZSBvbmx5IHN1cHBvcnRzIDgwMHg2MDAgdGh1bWJuYWlscyBmb3Igbm93IHRob3VnaCxcbiAgICAgICAgICAgIC8vIHNvIHdlJ2xsIG5lZWQgdG8gZG93bmxvYWQgdGhlIG9yaWdpbmFsIGltYWdlIGZvciB0aGlzIHRvIHdvcmtcbiAgICAgICAgICAgIC8vIHdlbGwgZm9yIG5vdy4gRmlyc3QsIGxldCdzIHRyeSBhIGZldyBjYXNlcyB0aGF0IGxldCB1cyBhdm9pZFxuICAgICAgICAgICAgLy8gZG93bmxvYWRpbmcgdGhlIG9yaWdpbmFsLCBpbmNsdWRpbmc6XG4gICAgICAgICAgICAvLyAgIC0gV2hlbiBkaXNwbGF5aW5nIGEgR0lGLCB3ZSBhbHdheXMgd2FudCB0byB0aHVtYm5haWwgc28gdGhhdCB3ZSBjYW5cbiAgICAgICAgICAgIC8vICAgICBwcm9wZXJseSByZXNwZWN0IHRoZSB1c2VyJ3MgR0lGIGF1dG9wbGF5IHNldHRpbmcgKHdoaWNoIHJlbGllcyBvblxuICAgICAgICAgICAgLy8gICAgIHRodW1ibmFpbGluZyB0byBwcm9kdWNlIHRoZSBzdGF0aWMgcHJldmlldyBpbWFnZSlcbiAgICAgICAgICAgIC8vICAgLSBPbiBhIGxvdyBEUEkgZGV2aWNlLCBhbHdheXMgdGh1bWJuYWlsIHRvIHNhdmUgYmFuZHdpZHRoXG4gICAgICAgICAgICAvLyAgIC0gSWYgdGhlcmUncyBubyBzaXppbmcgaW5mbyBpbiB0aGUgZXZlbnQsIGRlZmF1bHQgdG8gdGh1bWJuYWlsXG4gICAgICAgICAgICBjb25zdCBpbmZvID0gY29udGVudC5pbmZvO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHRoaXMuaXNHaWYoKSB8fFxuICAgICAgICAgICAgICAgIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID09PSAxLjAgfHxcbiAgICAgICAgICAgICAgICAoIWluZm8gfHwgIWluZm8udyB8fCAhaW5mby5oIHx8ICFpbmZvLnNpemUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVkaWEuZ2V0VGh1bWJuYWlsT2ZTb3VyY2VIdHRwKHRodW1iV2lkdGgsIHRodW1iSGVpZ2h0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIG9ubHkgcmVxdWVzdCB0aHVtYm5haWxzIGlmIHRoZSBpbWFnZSBpcyBiaWdnZXIgdGhhbiA4MDB4NjAwXG4gICAgICAgICAgICAgICAgLy8gKG9yIDE2MDB4MTIwMCBvbiByZXRpbmEpIG90aGVyd2lzZSB0aGUgaW1hZ2UgaW4gdGhlIHRpbWVsaW5lIHdpbGwganVzdFxuICAgICAgICAgICAgICAgIC8vIGVuZCB1cCByZXNhbXBsZWQgYW5kIGRlLXJldGluYSdkIGZvciBubyBnb29kIHJlYXNvbi5cbiAgICAgICAgICAgICAgICAvLyBJZGVhbGx5IHRoZSBzZXJ2ZXIgd291bGQgcHJlZ2VuIDE2MDB4MTIwMCB0aHVtYm5haWxzIGluIG9yZGVyIHRvIHByb3ZpZGUgcmV0aW5hXG4gICAgICAgICAgICAgICAgLy8gdGh1bWJuYWlscywgYnV0IHdlIGRvbid0IGRvIHRoaXMgY3VycmVudGx5IGluIHN5bmFwc2UgZm9yIGZlYXIgb2YgZGlzayBzcGFjZS5cbiAgICAgICAgICAgICAgICAvLyBBcyBhIGNvbXByb21pc2UsIGxldCdzIHN3aXRjaCB0byBub24tcmV0aW5hIHRodW1ibmFpbHMgb25seSBpZiB0aGUgb3JpZ2luYWxcbiAgICAgICAgICAgICAgICAvLyBpbWFnZSBpcyBib3RoIHBoeXNpY2FsbHkgdG9vIGxhcmdlIGFuZCBnb2luZyB0byBiZSBtYXNzaXZlIHRvIGxvYWQgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gdGltZWxpbmUgKGUuZy4gPjFNQikuXG5cbiAgICAgICAgICAgICAgICBjb25zdCBpc0xhcmdlclRoYW5UaHVtYm5haWwgPSAoXG4gICAgICAgICAgICAgICAgICAgIGluZm8udyA+IHRodW1iV2lkdGggfHxcbiAgICAgICAgICAgICAgICAgICAgaW5mby5oID4gdGh1bWJIZWlnaHRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzTGFyZ2VGaWxlU2l6ZSA9IGluZm8uc2l6ZSA+IDEgKiAxMDI0ICogMTAyNDsgLy8gMW1iXG5cbiAgICAgICAgICAgICAgICBpZiAoaXNMYXJnZUZpbGVTaXplICYmIGlzTGFyZ2VyVGhhblRodW1ibmFpbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbWFnZSBpcyB0b28gbGFyZ2UgcGh5c2ljYWxseSBhbmQgYnl0ZXdpc2UgdG8gY2x1dHRlciBvdXIgdGltZWxpbmUgc29cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgYXNrIGZvciBhIHRodW1ibmFpbCwgZGVzcGl0ZSBrbm93aW5nIHRoYXQgaXQgd2lsbCBiZSBtYXggODAweDYwMFxuICAgICAgICAgICAgICAgICAgICAvLyBkZXNwaXRlIHVzIGJlaW5nIHJldGluYSAoYXMgc3luYXBzZSBkb2Vzbid0IGRvIDE2MDB4MTIwMCB0aHVtYnMgeWV0KS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lZGlhLmdldFRodW1ibmFpbE9mU291cmNlSHR0cCh0aHVtYldpZHRoLCB0aHVtYkhlaWdodCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG93bmxvYWQgdGhlIG9yaWdpbmFsIGltYWdlIG90aGVyd2lzZSwgc28gd2UgY2FuIHNjYWxlIGl0IGNsaWVudCBzaWRlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHRha2UgcGl4ZWxSYXRpbyBpbnRvIGFjY291bnQuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZWRpYS5zcmNIdHRwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgZG93bmxvYWRJbWFnZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMubWVkaWFFdmVudEhlbHBlci5tZWRpYS5pc0VuY3J5cHRlZCAmJiB0aGlzLnN0YXRlLmRlY3J5cHRlZFVybCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aHVtYm5haWxVcmwgPSBhd2FpdCB0aGlzLnByb3BzLm1lZGlhRXZlbnRIZWxwZXIudGh1bWJuYWlsVXJsLnZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBkZWNyeXB0ZWRVcmw6IGF3YWl0IHRoaXMucHJvcHMubWVkaWFFdmVudEhlbHBlci5zb3VyY2VVcmwudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGRlY3J5cHRlZFRodW1ibmFpbFVybDogdGh1bWJuYWlsVXJsLFxuICAgICAgICAgICAgICAgICAgICBkZWNyeXB0ZWRCbG9iOiBhd2FpdCB0aGlzLnByb3BzLm1lZGlhRXZlbnRIZWxwZXIuc291cmNlQmxvYi52YWx1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVubW91bnRlZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiVW5hYmxlIHRvIGRlY3J5cHQgYXR0YWNobWVudDogXCIsIGVycik7XG4gICAgICAgICAgICAgICAgLy8gU2V0IGEgcGxhY2Vob2xkZXIgaW1hZ2Ugd2hlbiB3ZSBjYW4ndCBkZWNyeXB0IHRoZSBpbWFnZS5cbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgY2xlYXJCbHVyaGFzaFRpbWVvdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMudW5tb3VudGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29udGV4dC5vbignc3luYycsIHRoaXMub25DbGllbnRTeW5jKTtcblxuICAgICAgICBjb25zdCBzaG93SW1hZ2UgPSB0aGlzLnN0YXRlLnNob3dJbWFnZSB8fFxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJteF9TaG93SW1hZ2VfXCIgKyB0aGlzLnByb3BzLm14RXZlbnQuZ2V0SWQoKSkgPT09IFwidHJ1ZVwiO1xuXG4gICAgICAgIGlmIChzaG93SW1hZ2UpIHtcbiAgICAgICAgICAgIC8vIG5vaW5zcGVjdGlvbiBKU0lnbm9yZWRQcm9taXNlRnJvbUNhbGxcbiAgICAgICAgICAgIHRoaXMuZG93bmxvYWRJbWFnZSgpO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHNob3dJbWFnZTogdHJ1ZSB9KTtcbiAgICAgICAgfSAvLyBlbHNlIGRvbid0IGRvd25sb2FkIGFueXRoaW5nIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBkaXNwbGF5IGFueXRoaW5nLlxuXG4gICAgICAgIC8vIEFkZCBhIDE1MG1zIHRpbWVyIGZvciBibHVyaGFzaCB0byBmaXJzdCBhcHBlYXIuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLm14RXZlbnQuZ2V0Q29udGVudCgpLmluZm8/LltCTFVSSEFTSF9GSUVMRF0pIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJCbHVyaGFzaFRpbWVvdXQoKTtcbiAgICAgICAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdGF0ZS5pbWdMb2FkZWQgfHwgIXRoaXMuc3RhdGUuaW1nRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogJ2JsdXJoYXNoJyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTUwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2l6ZVdhdGNoZXIgPSBTZXR0aW5nc1N0b3JlLndhdGNoU2V0dGluZyhcIkltYWdlcy5zaXplXCIsIG51bGwsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKTsgLy8gd2UgZG9uJ3QgcmVhbGx5IGhhdmUgYSByZWxpYWJsZSB0aGluZyB0byB1cGRhdGUsIHNvIGp1c3QgdXBkYXRlIHRoZSB3aG9sZSB0aGluZ1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy51bm1vdW50ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNvbnRleHQucmVtb3ZlTGlzdGVuZXIoJ3N5bmMnLCB0aGlzLm9uQ2xpZW50U3luYyk7XG4gICAgICAgIHRoaXMuY2xlYXJCbHVyaGFzaFRpbWVvdXQoKTtcbiAgICAgICAgU2V0dGluZ3NTdG9yZS51bndhdGNoU2V0dGluZyh0aGlzLnNpemVXYXRjaGVyKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgbWVzc2FnZUNvbnRlbnQoXG4gICAgICAgIGNvbnRlbnRVcmw6IHN0cmluZyxcbiAgICAgICAgdGh1bWJVcmw6IHN0cmluZyxcbiAgICAgICAgY29udGVudDogSU1lZGlhRXZlbnRDb250ZW50LFxuICAgICAgICBmb3JjZWRIZWlnaHQ/OiBudW1iZXIsXG4gICAgKTogSlNYLkVsZW1lbnQge1xuICAgICAgICBsZXQgaW5mb1dpZHRoO1xuICAgICAgICBsZXQgaW5mb0hlaWdodDtcblxuICAgICAgICBpZiAoY29udGVudCAmJiBjb250ZW50LmluZm8gJiYgY29udGVudC5pbmZvLncgJiYgY29udGVudC5pbmZvLmgpIHtcbiAgICAgICAgICAgIGluZm9XaWR0aCA9IGNvbnRlbnQuaW5mby53O1xuICAgICAgICAgICAgaW5mb0hlaWdodCA9IGNvbnRlbnQuaW5mby5oO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gV2hpbHN0IHRoZSBpbWFnZSBsb2FkcywgZGlzcGxheSBub3RoaW5nLiBXZSBhbHNvIGRvbid0IGRpc3BsYXkgYSBibHVyaGFzaCBpbWFnZVxuICAgICAgICAgICAgLy8gYmVjYXVzZSB3ZSBkb24ndCByZWFsbHkga25vdyB3aGF0IHNpemUgb2YgaW1hZ2Ugd2UnbGwgZW5kIHVwIHdpdGguXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gT25jZSBsb2FkZWQsIHVzZSB0aGUgbG9hZGVkIGltYWdlIGRpbWVuc2lvbnMgc3RvcmVkIGluIGBsb2FkZWRJbWFnZURpbWVuc2lvbnNgLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEJ5IGRvaW5nIHRoaXMsIHRoZSBpbWFnZSBcInBvcHNcIiBpbnRvIHRoZSB0aW1lbGluZSwgYnV0IGlzIHN0aWxsIHJlc3RyaWN0ZWRcbiAgICAgICAgICAgIC8vIGJ5IHRoZSBzYW1lIHdpZHRoIGFuZCBoZWlnaHQgbG9naWMgYmVsb3cuXG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhdGUubG9hZGVkSW1hZ2VEaW1lbnNpb25zKSB7XG4gICAgICAgICAgICAgICAgbGV0IGltYWdlRWxlbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RhdGUuc2hvd0ltYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlRWxlbWVudCA9IDxIaWRkZW5JbWFnZVBsYWNlaG9sZGVyIC8+O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlRWxlbWVudCA9IChcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17eyBkaXNwbGF5OiAnbm9uZScgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmM9e3RodW1iVXJsfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZj17dGhpcy5pbWFnZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHQ9e2NvbnRlbnQuYm9keX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yPXt0aGlzLm9uSW1hZ2VFcnJvcn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkxvYWQ9e3RoaXMub25JbWFnZUxvYWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53cmFwSW1hZ2UoY29udGVudFVybCwgaW1hZ2VFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZm9XaWR0aCA9IHRoaXMuc3RhdGUubG9hZGVkSW1hZ2VEaW1lbnNpb25zLm5hdHVyYWxXaWR0aDtcbiAgICAgICAgICAgIGluZm9IZWlnaHQgPSB0aGlzLnN0YXRlLmxvYWRlZEltYWdlRGltZW5zaW9ucy5uYXR1cmFsSGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIG1heGltdW0gc2l6ZSBvZiB0aGUgdGh1bWJuYWlsIGFzIGl0IGlzIHJlbmRlcmVkIGFzIGFuIDxpbWc+XG4gICAgICAgIC8vIGNoZWNrIGZvciBhbnkgaGVpZ2h0IGNvbnN0cmFpbnRzXG4gICAgICAgIGNvbnN0IGltYWdlU2l6ZSA9IFNldHRpbmdzU3RvcmUuZ2V0VmFsdWUoXCJJbWFnZXMuc2l6ZVwiKSBhcyBJbWFnZVNpemU7XG4gICAgICAgIGNvbnN0IGlzUG9ydHJhaXQgPSBpbmZvV2lkdGggPCBpbmZvSGVpZ2h0O1xuICAgICAgICBjb25zdCBzdWdnZXN0ZWRBbmRQb3NzaWJsZVdpZHRoID0gTWF0aC5taW4oc3VnZ2VzdGVkSW1hZ2VTaXplKGltYWdlU2l6ZSwgaXNQb3J0cmFpdCkudywgaW5mb1dpZHRoKTtcbiAgICAgICAgY29uc3Qgc3VnZ2VzdGVkQW5kUG9zc2libGVIZWlnaHQgPSBNYXRoLm1pbihzdWdnZXN0ZWRJbWFnZVNpemUoaW1hZ2VTaXplLCBpc1BvcnRyYWl0KS5oLCBpbmZvSGVpZ2h0KTtcbiAgICAgICAgY29uc3QgYXNwZWN0UmF0aW8gPSBpbmZvV2lkdGggLyBpbmZvSGVpZ2h0O1xuXG4gICAgICAgIGxldCBtYXhXaWR0aDtcbiAgICAgICAgbGV0IG1heEhlaWdodDtcbiAgICAgICAgY29uc3QgbWF4SGVpZ2h0Q29uc3RyYWludCA9IGZvcmNlZEhlaWdodCB8fCB0aGlzLnByb3BzLm1heEltYWdlSGVpZ2h0IHx8IHN1Z2dlc3RlZEFuZFBvc3NpYmxlSGVpZ2h0O1xuICAgICAgICBpZiAobWF4SGVpZ2h0Q29uc3RyYWludCAqIGFzcGVjdFJhdGlvIDwgc3VnZ2VzdGVkQW5kUG9zc2libGVXaWR0aCB8fCBpbWFnZVNpemUgPT09IEltYWdlU2l6ZS5MYXJnZSkge1xuICAgICAgICAgICAgLy8gVGhlIHdpZHRoIGlzIGRpY3RhdGVkIGJ5IHRoZSBtYXhpbXVtIGhlaWdodCB0aGF0IHdhcyBkZWZpbmVkIGJ5IHRoZSBwcm9wcyBvciB0aGUgZnVuY3Rpb24gcGFyYW0gYGZvcmNlZEhlaWdodGBcbiAgICAgICAgICAgIC8vIElmIHRoZSB0aHVtYm5haWwgc2l6ZSBpcyBzZXQgdG8gTGFyZ2UsIHdlIGFsd2F5cyBsZXQgdGhlIHNpemUgYmUgZGljdGF0ZWQgYnkgdGhlIGhlaWdodC5cbiAgICAgICAgICAgIG1heFdpZHRoID0gbWF4SGVpZ2h0Q29uc3RyYWludCAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgLy8gdGhlcmUgaXMgbm8gbmVlZCB0byBjaGVjayBmb3IgaW5mb0hlaWdodCBoZXJlIHNpbmNlIHRoaXMgaXMgZG9uZSB3aXRoIGBtYXhIZWlnaHRDb25zdHJhaW50ICogYXNwZWN0UmF0aW8gPCBzdWdnZXN0ZWRBbmRQb3NzaWJsZVdpZHRoYFxuICAgICAgICAgICAgbWF4SGVpZ2h0ID0gbWF4SGVpZ2h0Q29uc3RyYWludDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhlaWdodCBpcyBkaWN0YXRlZCBieSBzdWdnZXN0ZWRXaWR0aCAoYmFzZWQgb24gdGhlIEltYWdlLnNpemUgc2V0dGluZylcbiAgICAgICAgICAgIG1heFdpZHRoID0gc3VnZ2VzdGVkQW5kUG9zc2libGVXaWR0aDtcbiAgICAgICAgICAgIG1heEhlaWdodCA9IHN1Z2dlc3RlZEFuZFBvc3NpYmxlV2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpbWcgPSBudWxsO1xuICAgICAgICBsZXQgcGxhY2Vob2xkZXIgPSBudWxsO1xuICAgICAgICBsZXQgZ2lmTGFiZWwgPSBudWxsO1xuXG4gICAgICAgIGlmICghdGhpcy5wcm9wcy5mb3JFeHBvcnQgJiYgIXRoaXMuc3RhdGUuaW1nTG9hZGVkKSB7XG4gICAgICAgICAgICBwbGFjZWhvbGRlciA9IHRoaXMuZ2V0UGxhY2Vob2xkZXIobWF4V2lkdGgsIG1heEhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc2hvd1BsYWNlaG9sZGVyID0gQm9vbGVhbihwbGFjZWhvbGRlcik7XG5cbiAgICAgICAgaWYgKHRodW1iVXJsICYmICF0aGlzLnN0YXRlLmltZ0Vycm9yKSB7XG4gICAgICAgICAgICAvLyBSZXN0cmljdCB0aGUgd2lkdGggb2YgdGhlIHRodW1ibmFpbCBoZXJlLCBvdGhlcndpc2UgaXQgd2lsbCBmaWxsIHRoZSBjb250YWluZXJcbiAgICAgICAgICAgIC8vIHdoaWNoIGhhcyB0aGUgc2FtZSB3aWR0aCBhcyB0aGUgdGltZWxpbmVcbiAgICAgICAgICAgIC8vIG14X01JbWFnZUJvZHlfdGh1bWJuYWlsIHJlc2l6ZXMgaW1nIHRvIGV4YWN0bHkgY29udGFpbmVyIHNpemVcbiAgICAgICAgICAgIGltZyA9IChcbiAgICAgICAgICAgICAgICA8aW1nXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIm14X01JbWFnZUJvZHlfdGh1bWJuYWlsXCJcbiAgICAgICAgICAgICAgICAgICAgc3JjPXt0aHVtYlVybH1cbiAgICAgICAgICAgICAgICAgICAgcmVmPXt0aGlzLmltYWdlfVxuICAgICAgICAgICAgICAgICAgICAvLyBGb3JjZSB0aGUgaW1hZ2UgdG8gYmUgdGhlIGZ1bGwgc2l6ZSBvZiB0aGUgY29udGFpbmVyLCBldmVuIGlmIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBwaXhlbCBzaXplIGlzIHNtYWxsZXIuIFRoZSBwcm9ibGVtIGhlcmUgaXMgdGhhdCB3ZSBkb24ndCBrbm93IHdoYXRcbiAgICAgICAgICAgICAgICAgICAgLy8gdGh1bWJuYWlsIHNpemUgdGhlIEhTIGlzIGdvaW5nIHRvIGdpdmUgdXMsIGJ1dCB3ZSBoYXZlIHRvIGNvbW1pdCB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBhIGNvbnRhaW5lciBzaXplIGltbWVkaWF0ZWx5IGFuZCBub3QgY2hhbmdlIGl0IHdoZW4gdGhlIGltYWdlIGxvYWRzXG4gICAgICAgICAgICAgICAgICAgIC8vIG9yIHdlJ2xsIGdldCBhIHNjcm9sbCBqdW1wIChvciBoYXZlIHRvIGxlYXZlIGJsYW5rIHNwYWNlKS5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIG9idmlvdXNseSByZXN1bHQgaW4gYW4gdXBzY2FsZWQgaW1hZ2Ugd2hpY2ggd2lsbCBiZSBhIGJpdFxuICAgICAgICAgICAgICAgICAgICAvLyBibHVycnkuIFRoZSBiZXN0IGZpeCB3b3VsZCBiZSBmb3IgdGhlIEhTIHRvIGFkdmVydGlzZSB3aGF0IHNpemUgdGh1bWJuYWlsc1xuICAgICAgICAgICAgICAgICAgICAvLyBpdCBndWFyYW50ZWVzIHRvIHByb2R1Y2UuXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7IGhlaWdodDogJzEwMCUnIH19XG4gICAgICAgICAgICAgICAgICAgIGFsdD17Y29udGVudC5ib2R5fVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yPXt0aGlzLm9uSW1hZ2VFcnJvcn1cbiAgICAgICAgICAgICAgICAgICAgb25Mb2FkPXt0aGlzLm9uSW1hZ2VMb2FkfVxuICAgICAgICAgICAgICAgICAgICBvbk1vdXNlRW50ZXI9e3RoaXMub25JbWFnZUVudGVyfVxuICAgICAgICAgICAgICAgICAgICBvbk1vdXNlTGVhdmU9e3RoaXMub25JbWFnZUxlYXZlfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLnNob3dJbWFnZSkge1xuICAgICAgICAgICAgaW1nID0gPEhpZGRlbkltYWdlUGxhY2Vob2xkZXIgbWF4V2lkdGg9e21heFdpZHRofSAvPjtcbiAgICAgICAgICAgIHNob3dQbGFjZWhvbGRlciA9IGZhbHNlOyAvLyBiZWNhdXNlIHdlJ3JlIGhpZGluZyB0aGUgaW1hZ2UsIHNvIGRvbid0IHNob3cgdGhlIHBsYWNlaG9sZGVyLlxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNHaWYoKSAmJiAhU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZShcImF1dG9wbGF5R2lmc1wiKSAmJiAhdGhpcy5zdGF0ZS5ob3Zlcikge1xuICAgICAgICAgICAgZ2lmTGFiZWwgPSA8cCBjbGFzc05hbWU9XCJteF9NSW1hZ2VCb2R5X2dpZkxhYmVsXCI+R0lGPC9wPjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNsYXNzZXMgPSBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgICdteF9NSW1hZ2VCb2R5X3RodW1ibmFpbCc6IHRydWUsXG4gICAgICAgICAgICAnbXhfTUltYWdlQm9keV90aHVtYm5haWwtLWJsdXJoYXNoJzogdGhpcy5wcm9wcy5teEV2ZW50LmdldENvbnRlbnQoKS5pbmZvPy5bQkxVUkhBU0hfRklFTERdLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUaGlzIGhhcyBpbmNyZWRpYmx5IGJyb2tlbiB0eXBlcy5cbiAgICAgICAgY29uc3QgQyA9IENTU1RyYW5zaXRpb24gYXMgYW55O1xuICAgICAgICBjb25zdCB0aHVtYm5haWwgPSAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm14X01JbWFnZUJvZHlfdGh1bWJuYWlsX2NvbnRhaW5lclwiIHN0eWxlPXt7IG1heEhlaWdodDogbWF4SGVpZ2h0LCBtYXhXaWR0aDogbWF4V2lkdGgsIGFzcGVjdFJhdGlvOiBgJHtpbmZvV2lkdGh9LyR7aW5mb0hlaWdodH1gIH19PlxuICAgICAgICAgICAgICAgIDxTd2l0Y2hUcmFuc2l0aW9uIG1vZGU9XCJvdXQtaW5cIj5cbiAgICAgICAgICAgICAgICAgICAgPENcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXM9XCJteF9ydGctLWZhZGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAga2V5PXtgaW1nLSR7c2hvd1BsYWNlaG9sZGVyfWB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0PXszMDB9XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsgLyogVGhpcyB3ZWlyZGx5IGxvb2tpbmcgZGl2IGlzIG5lY2Vzc2FyeSBoZXJlLCBvdGhlcndpc2UgU3dpdGNoVHJhbnNpdGlvbiBmYWlscyAqLyB9XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgc2hvd1BsYWNlaG9sZGVyICYmIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc2VzfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3RyYWluIHdpZHRoIGhlcmUgc28gdGhhdCBzcGlubmVyIGFwcGVhcnMgY2VudHJhbCB0byB0aGUgbG9hZGVkIHRodW1ibmFpbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGg6IGBtaW4oMTAwJSwgJHtpbmZvV2lkdGh9cHgpYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heEhlaWdodDogbWF4SGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNwZWN0UmF0aW86IGAke2luZm9XaWR0aH0vJHtpbmZvSGVpZ2h0fWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHBsYWNlaG9sZGVyIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvQz5cbiAgICAgICAgICAgICAgICA8L1N3aXRjaFRyYW5zaXRpb24+XG5cbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICAgICAgICB7IGltZyB9XG4gICAgICAgICAgICAgICAgICAgIHsgZ2lmTGFiZWwgfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgeyB0aGlzLnN0YXRlLmhvdmVyICYmIHRoaXMuZ2V0VG9vbHRpcCgpIH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB0aGlzLndyYXBJbWFnZShjb250ZW50VXJsLCB0aHVtYm5haWwpO1xuICAgIH1cblxuICAgIC8vIE92ZXJpZGRlbiBieSBNU3RpY2tlckJvZHlcbiAgICBwcm90ZWN0ZWQgd3JhcEltYWdlKGNvbnRlbnRVcmw6IHN0cmluZywgY2hpbGRyZW46IEpTWC5FbGVtZW50KTogSlNYLkVsZW1lbnQge1xuICAgICAgICByZXR1cm4gPGEgaHJlZj17Y29udGVudFVybH0gdGFyZ2V0PXt0aGlzLnByb3BzLmZvckV4cG9ydCA/IFwiX2JsYW5rXCIgOiB1bmRlZmluZWR9IG9uQ2xpY2s9e3RoaXMub25DbGlja30+XG4gICAgICAgICAgICB7IGNoaWxkcmVuIH1cbiAgICAgICAgPC9hPjtcbiAgICB9XG5cbiAgICAvLyBPdmVyaWRkZW4gYnkgTVN0aWNrZXJCb2R5XG4gICAgcHJvdGVjdGVkIGdldFBsYWNlaG9sZGVyKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogSlNYLkVsZW1lbnQge1xuICAgICAgICBjb25zdCBibHVyaGFzaCA9IHRoaXMucHJvcHMubXhFdmVudC5nZXRDb250ZW50KCkuaW5mbz8uW0JMVVJIQVNIX0ZJRUxEXTtcblxuICAgICAgICBpZiAoYmx1cmhhc2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnBsYWNlaG9sZGVyID09PSAnbm8taW1hZ2UnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPVwibXhfbm8taW1hZ2UtcGxhY2Vob2xkZXJcIiBzdHlsZT17eyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH19IC8+O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLnBsYWNlaG9sZGVyID09PSAnYmx1cmhhc2gnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDxCbHVyaGFzaCBjbGFzc05hbWU9XCJteF9CbHVyaGFzaFwiIGhhc2g9e2JsdXJoYXNofSB3aWR0aD17d2lkdGh9IGhlaWdodD17aGVpZ2h0fSAvPjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPElubGluZVNwaW5uZXIgdz17MzJ9IGg9ezMyfSAvPlxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIE92ZXJpZGRlbiBieSBNU3RpY2tlckJvZHlcbiAgICBwcm90ZWN0ZWQgZ2V0VG9vbHRpcCgpOiBKU1guRWxlbWVudCB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIE92ZXJpZGRlbiBieSBNU3RpY2tlckJvZHlcbiAgICBwcm90ZWN0ZWQgZ2V0RmlsZUJvZHkoKTogc3RyaW5nIHwgSlNYLkVsZW1lbnQge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5mb3JFeHBvcnQpIHJldHVybiBudWxsO1xuICAgICAgICAvKlxuICAgICAgICAgKiBJbiB0aGUgcm9vbSB0aW1lbGluZSBvciB0aGUgdGhyZWFkIGNvbnRleHQgd2UgZG9uJ3QgbmVlZCB0aGUgZG93bmxvYWRcbiAgICAgICAgICogbGluayBhcyB0aGUgbWVzc2FnZSBhY3Rpb24gYmFyIHdpbGwgZnVsbGZpbCB0aGF0XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBoYXNNZXNzYWdlQWN0aW9uQmFyID0gIXRoaXMucHJvcHMudGlsZVNoYXBlXG4gICAgICAgICAgICB8fCB0aGlzLnByb3BzLnRpbGVTaGFwZSA9PT0gVGlsZVNoYXBlLlRocmVhZFxuICAgICAgICAgICAgfHwgdGhpcy5wcm9wcy50aWxlU2hhcGUgPT09IFRpbGVTaGFwZS5UaHJlYWRQYW5lbDtcbiAgICAgICAgaWYgKCFoYXNNZXNzYWdlQWN0aW9uQmFyKSB7XG4gICAgICAgICAgICByZXR1cm4gPE1GaWxlQm9keSB7Li4udGhpcy5wcm9wc30gc2hvd0dlbmVyaWNQbGFjZWhvbGRlcj17ZmFsc2V9IC8+O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5wcm9wcy5teEV2ZW50LmdldENvbnRlbnQ8SU1lZGlhRXZlbnRDb250ZW50PigpO1xuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmVycm9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXhfTUltYWdlQm9keVwiPlxuICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz17cmVxdWlyZShcIi4uLy4uLy4uLy4uL3Jlcy9pbWcvd2FybmluZy5zdmdcIil9IHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIC8+XG4gICAgICAgICAgICAgICAgICAgIHsgX3QoXCJFcnJvciBkZWNyeXB0aW5nIGltYWdlXCIpIH1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb250ZW50VXJsID0gdGhpcy5nZXRDb250ZW50VXJsKCk7XG4gICAgICAgIGxldCB0aHVtYlVybDtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZm9yRXhwb3J0IHx8ICh0aGlzLmlzR2lmKCkgJiYgU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZShcImF1dG9wbGF5R2lmc1wiKSkpIHtcbiAgICAgICAgICAgIHRodW1iVXJsID0gY29udGVudFVybDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRodW1iVXJsID0gdGhpcy5nZXRUaHVtYlVybCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGh1bWJuYWlsID0gdGhpcy5tZXNzYWdlQ29udGVudChjb250ZW50VXJsLCB0aHVtYlVybCwgY29udGVudCk7XG4gICAgICAgIGNvbnN0IGZpbGVCb2R5ID0gdGhpcy5nZXRGaWxlQm9keSgpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm14X01JbWFnZUJvZHlcIj5cbiAgICAgICAgICAgICAgICB7IHRodW1ibmFpbCB9XG4gICAgICAgICAgICAgICAgeyBmaWxlQm9keSB9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmludGVyZmFjZSBQbGFjZWhvbGRlcklQcm9wcyB7XG4gICAgaG92ZXI/OiBib29sZWFuO1xuICAgIG1heFdpZHRoPzogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgSGlkZGVuSW1hZ2VQbGFjZWhvbGRlciBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8UGxhY2Vob2xkZXJJUHJvcHM+IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IG1heFdpZHRoID0gdGhpcy5wcm9wcy5tYXhXaWR0aCA/IHRoaXMucHJvcHMubWF4V2lkdGggKyBcInB4XCIgOiBudWxsO1xuICAgICAgICBsZXQgY2xhc3NOYW1lID0gJ214X0hpZGRlbkltYWdlUGxhY2Vob2xkZXInO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5ob3ZlcikgY2xhc3NOYW1lICs9ICcgbXhfSGlkZGVuSW1hZ2VQbGFjZWhvbGRlcl9ob3Zlcic7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBzdHlsZT17eyBtYXhXaWR0aDogYG1pbigxMDAlLCAke21heFdpZHRofXB4KWAgfX0+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J214X0hpZGRlbkltYWdlUGxhY2Vob2xkZXJfYnV0dG9uJz5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPSdteF9IaWRkZW5JbWFnZVBsYWNlaG9sZGVyX2V5ZScgLz5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+eyBfdChcIlNob3cgaW1hZ2VcIikgfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cbn1cbiJdfQ==