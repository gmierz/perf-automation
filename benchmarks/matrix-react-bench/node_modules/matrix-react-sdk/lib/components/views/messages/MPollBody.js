"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UserVote = void 0;
exports.allVotes = allVotes;
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _languageHandler = require("../../../languageHandler");

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _Modal = _interopRequireDefault(require("../../../Modal"));

var _consts = require("../../../polls/consts");

var _StyledRadioButton = _interopRequireDefault(require("../elements/StyledRadioButton"));

var _MatrixClientContext = _interopRequireDefault(require("../../../contexts/MatrixClientContext"));

var _ErrorDialog = _interopRequireDefault(require("../dialogs/ErrorDialog"));

var _dec, _class, _class2, _temp;

// TODO: [andyb] Use extensible events library when ready
const TEXT_NODE_TYPE = "org.matrix.msc1767.text";
let MPollBody = (_dec = (0, _replaceableComponent.replaceableComponent)("views.messages.MPollBody"), _dec(_class = (_temp = _class2 = class MPollBody extends _react.default.Component {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "context", void 0);
    (0, _defineProperty2.default)(this, "onPollRelationsCreated", (relationType, eventType) => {
      if (relationType === "m.reference" && _consts.POLL_RESPONSE_EVENT_TYPE.matches(eventType)) {
        this.props.mxEvent.removeListener("Event.relationsCreated", this.onPollRelationsCreated);
        const newPollRelations = this.fetchPollRelations();
        this.addListeners(newPollRelations);
        this.removeListeners(this.state.pollRelations);
        this.setState({
          pollRelations: newPollRelations
        });
      }
    });
    (0, _defineProperty2.default)(this, "onRelationsChange", () => {
      // We hold pollRelations in our state, and it has changed under us
      this.forceUpdate();
    });
    (0, _defineProperty2.default)(this, "onOptionSelected", e => {
      this.selectOption(e.currentTarget.value);
    });
    this.state = {
      selected: null,
      pollRelations: this.fetchPollRelations()
    };
    this.addListeners(this.state.pollRelations);
    this.props.mxEvent.on("Event.relationsCreated", this.onPollRelationsCreated);
  }

  componentWillUnmount() {
    this.props.mxEvent.off("Event.relationsCreated", this.onPollRelationsCreated);
    this.removeListeners(this.state.pollRelations);
  }

  addListeners(pollRelations) {
    if (pollRelations) {
      pollRelations.on("Relations.add", this.onRelationsChange);
      pollRelations.on("Relations.remove", this.onRelationsChange);
      pollRelations.on("Relations.redaction", this.onRelationsChange);
    }
  }

  removeListeners(pollRelations) {
    if (pollRelations) {
      pollRelations.off("Relations.add", this.onRelationsChange);
      pollRelations.off("Relations.remove", this.onRelationsChange);
      pollRelations.off("Relations.redaction", this.onRelationsChange);
    }
  }

  selectOption(answerId) {
    if (answerId === this.state.selected) {
      return;
    }

    const responseContent = {
      [_consts.POLL_RESPONSE_EVENT_TYPE.name]: {
        "answers": [answerId]
      },
      "m.relates_to": {
        "event_id": this.props.mxEvent.getId(),
        "rel_type": "m.reference"
      }
    };
    this.context.sendEvent(this.props.mxEvent.getRoomId(), _consts.POLL_RESPONSE_EVENT_TYPE.name, responseContent).catch(e => {
      console.error("Failed to submit poll response event:", e);

      _Modal.default.createTrackedDialog('Vote not registered', '', _ErrorDialog.default, {
        title: (0, _languageHandler._t)("Vote not registered"),
        description: (0, _languageHandler._t)("Sorry, your vote was not registered. Please try again.")
      });
    });
    this.setState({
      selected: answerId
    });
  }

  fetchPollRelations() {
    if (this.props.getRelationsForEvent) {
      return this.props.getRelationsForEvent(this.props.mxEvent.getId(), "m.reference", _consts.POLL_RESPONSE_EVENT_TYPE.name);
    } else {
      return null;
    }
  }
  /**
   * @returns userId -> UserVote
   */


  collectUserVotes() {
    return collectUserVotes(allVotes(this.state.pollRelations), this.context.getUserId(), this.state.selected);
  }

  totalVotes(collectedVotes) {
    let sum = 0;

    for (const v of collectedVotes.values()) {
      sum += v;
    }

    return sum;
  }

  render() {
    var _userVotes$get;

    const pollStart = this.props.mxEvent.getContent();
    const pollInfo = pollStart[_consts.POLL_START_EVENT_TYPE.name];

    if (pollInfo.answers.length < 1 || pollInfo.answers.length > 20) {
      return null;
    }

    const pollId = this.props.mxEvent.getId();
    const userVotes = this.collectUserVotes();
    const votes = countVotes(userVotes, this.props.mxEvent.getContent());
    const totalVotes = this.totalVotes(votes);
    const userId = this.context.getUserId();
    const myVote = (_userVotes$get = userVotes.get(userId)) === null || _userVotes$get === void 0 ? void 0 : _userVotes$get.answers[0];
    return /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_MPollBody"
    }, /*#__PURE__*/_react.default.createElement("h2", null, pollInfo.question[TEXT_NODE_TYPE]), /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_MPollBody_allOptions"
    }, pollInfo.answers.map(answer => {
      const checked = myVote === answer.id;
      const classNames = `mx_MPollBody_option${checked ? " mx_MPollBody_option_checked" : ""}`;
      const answerVotes = votes.get(answer.id) ?? 0;
      const answerPercent = Math.round(100.0 * answerVotes / totalVotes);
      return /*#__PURE__*/_react.default.createElement("div", {
        key: answer.id,
        className: classNames,
        onClick: () => this.selectOption(answer.id)
      }, /*#__PURE__*/_react.default.createElement(_StyledRadioButton.default, {
        name: `poll_answer_select-${pollId}`,
        value: answer.id,
        checked: checked,
        onChange: this.onOptionSelected
      }, /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_MPollBody_optionDescription"
      }, /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_MPollBody_optionText"
      }, answer[TEXT_NODE_TYPE]), /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_MPollBody_optionVoteCount"
      }, (0, _languageHandler._t)("%(count)s votes", {
        count: answerVotes
      })))), /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_MPollBody_popularityBackground"
      }, /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_MPollBody_popularityAmount",
        style: {
          "width": `${answerPercent}%`
        }
      })));
    })), /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_MPollBody_totalVotes"
    }, (0, _languageHandler._t)("Based on %(count)s votes", {
      count: totalVotes
    })));
  }

}, (0, _defineProperty2.default)(_class2, "contextType", _MatrixClientContext.default), _temp)) || _class);
exports.default = MPollBody;

class UserVote {
  constructor(ts, sender, answers) {
    this.ts = ts;
    this.sender = sender;
    this.answers = answers;
  }

}

exports.UserVote = UserVote;

function userResponseFromPollResponseEvent(event) {
  const pr = event.getContent();
  const answers = pr[_consts.POLL_RESPONSE_EVENT_TYPE.name].answers;
  return new UserVote(event.getTs(), event.getSender(), answers);
}

function allVotes(pollRelations) {
  function isPollResponse(responseEvent) {
    return responseEvent.getType() === _consts.POLL_RESPONSE_EVENT_TYPE.name && responseEvent.getContent().hasOwnProperty(_consts.POLL_RESPONSE_EVENT_TYPE.name);
  }

  if (pollRelations) {
    return pollRelations.getRelations().filter(isPollResponse).map(userResponseFromPollResponseEvent);
  } else {
    return [];
  }
}
/**
 * Figure out the correct vote for each user.
 * @returns a Map of user ID to their vote info
 */


function collectUserVotes(userResponses, userId, selected) {
  const userVotes = new Map();

  for (const response of userResponses) {
    const otherResponse = userVotes.get(response.sender);

    if (!otherResponse || otherResponse.ts < response.ts) {
      userVotes.set(response.sender, response);
    }
  }

  if (selected) {
    userVotes.set(userId, new UserVote(0, userId, [selected]));
  }

  return userVotes;
}

function countVotes(userVotes, pollStart) {
  const collected = new Map();
  const pollInfo = pollStart[_consts.POLL_START_EVENT_TYPE.name];
  const maxSelections = 1; // See MSC3381 - later this will be in pollInfo

  const allowedAnswerIds = pollInfo.answers.map(ans => ans.id);

  function isValidAnswer(answerId) {
    return allowedAnswerIds.includes(answerId);
  }

  for (const response of userVotes.values()) {
    if (response.answers.every(isValidAnswer)) {
      for (const [index, answerId] of response.answers.entries()) {
        if (index >= maxSelections) {
          break;
        }

        if (collected.has(answerId)) {
          collected.set(answerId, collected.get(answerId) + 1);
        } else {
          collected.set(answerId, 1);
        }
      }
    }
  }

  return collected;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL21lc3NhZ2VzL01Qb2xsQm9keS50c3giXSwibmFtZXMiOlsiVEVYVF9OT0RFX1RZUEUiLCJNUG9sbEJvZHkiLCJSZWFjdCIsIkNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJyZWxhdGlvblR5cGUiLCJldmVudFR5cGUiLCJQT0xMX1JFU1BPTlNFX0VWRU5UX1RZUEUiLCJtYXRjaGVzIiwibXhFdmVudCIsInJlbW92ZUxpc3RlbmVyIiwib25Qb2xsUmVsYXRpb25zQ3JlYXRlZCIsIm5ld1BvbGxSZWxhdGlvbnMiLCJmZXRjaFBvbGxSZWxhdGlvbnMiLCJhZGRMaXN0ZW5lcnMiLCJyZW1vdmVMaXN0ZW5lcnMiLCJzdGF0ZSIsInBvbGxSZWxhdGlvbnMiLCJzZXRTdGF0ZSIsImZvcmNlVXBkYXRlIiwiZSIsInNlbGVjdE9wdGlvbiIsImN1cnJlbnRUYXJnZXQiLCJ2YWx1ZSIsInNlbGVjdGVkIiwib24iLCJjb21wb25lbnRXaWxsVW5tb3VudCIsIm9mZiIsIm9uUmVsYXRpb25zQ2hhbmdlIiwiYW5zd2VySWQiLCJyZXNwb25zZUNvbnRlbnQiLCJuYW1lIiwiZ2V0SWQiLCJjb250ZXh0Iiwic2VuZEV2ZW50IiwiZ2V0Um9vbUlkIiwiY2F0Y2giLCJjb25zb2xlIiwiZXJyb3IiLCJNb2RhbCIsImNyZWF0ZVRyYWNrZWREaWFsb2ciLCJFcnJvckRpYWxvZyIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJnZXRSZWxhdGlvbnNGb3JFdmVudCIsImNvbGxlY3RVc2VyVm90ZXMiLCJhbGxWb3RlcyIsImdldFVzZXJJZCIsInRvdGFsVm90ZXMiLCJjb2xsZWN0ZWRWb3RlcyIsInN1bSIsInYiLCJ2YWx1ZXMiLCJyZW5kZXIiLCJwb2xsU3RhcnQiLCJnZXRDb250ZW50IiwicG9sbEluZm8iLCJQT0xMX1NUQVJUX0VWRU5UX1RZUEUiLCJhbnN3ZXJzIiwibGVuZ3RoIiwicG9sbElkIiwidXNlclZvdGVzIiwidm90ZXMiLCJjb3VudFZvdGVzIiwidXNlcklkIiwibXlWb3RlIiwiZ2V0IiwicXVlc3Rpb24iLCJtYXAiLCJhbnN3ZXIiLCJjaGVja2VkIiwiaWQiLCJjbGFzc05hbWVzIiwiYW5zd2VyVm90ZXMiLCJhbnN3ZXJQZXJjZW50IiwiTWF0aCIsInJvdW5kIiwib25PcHRpb25TZWxlY3RlZCIsImNvdW50IiwiTWF0cml4Q2xpZW50Q29udGV4dCIsIlVzZXJWb3RlIiwidHMiLCJzZW5kZXIiLCJ1c2VyUmVzcG9uc2VGcm9tUG9sbFJlc3BvbnNlRXZlbnQiLCJldmVudCIsInByIiwiZ2V0VHMiLCJnZXRTZW5kZXIiLCJpc1BvbGxSZXNwb25zZSIsInJlc3BvbnNlRXZlbnQiLCJnZXRUeXBlIiwiaGFzT3duUHJvcGVydHkiLCJnZXRSZWxhdGlvbnMiLCJmaWx0ZXIiLCJ1c2VyUmVzcG9uc2VzIiwiTWFwIiwicmVzcG9uc2UiLCJvdGhlclJlc3BvbnNlIiwic2V0IiwiY29sbGVjdGVkIiwibWF4U2VsZWN0aW9ucyIsImFsbG93ZWRBbnN3ZXJJZHMiLCJhbnMiLCJpc1ZhbGlkQW5zd2VyIiwiaW5jbHVkZXMiLCJldmVyeSIsImluZGV4IiwiZW50cmllcyIsImhhcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQWdCQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFPQTs7QUFHQTs7QUFDQTs7OztBQUVBO0FBQ0EsTUFBTUEsY0FBYyxHQUFHLHlCQUF2QjtJQVFxQkMsUyxXQURwQixnREFBcUIsMEJBQXJCLEMsbUNBQUQsTUFDcUJBLFNBRHJCLFNBQ3VDQyxlQUFNQyxTQUQ3QyxDQUMyRTtBQUl2RUMsRUFBQUEsV0FBVyxDQUFDQyxLQUFELEVBQW9CO0FBQzNCLFVBQU1BLEtBQU47QUFEMkI7QUFBQSxrRUFpQ0UsQ0FBQ0MsWUFBRCxFQUF1QkMsU0FBdkIsS0FBNkM7QUFDMUUsVUFDSUQsWUFBWSxLQUFLLGFBQWpCLElBQ0FFLGlDQUF5QkMsT0FBekIsQ0FBaUNGLFNBQWpDLENBRkosRUFHRTtBQUNF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Z0NtRSxRQUFRLENBQUN0QyxPQUFULENBQWlCaUQsT0FBakIsRUFBaEMsRUFBNEQ7QUFDeEQsWUFBSUQsS0FBSyxJQUFJTixhQUFiLEVBQTRCO0FBQ3hCO0FBQ0g7O0FBQ0QsWUFBSUQsU0FBUyxDQUFDUyxHQUFWLENBQWMvRSxRQUFkLENBQUosRUFBNkI7QUFDekJzRSxVQUFBQSxTQUFTLENBQUNELEdBQVYsQ0FBY3JFLFFBQWQsRUFBd0JzRSxTQUFTLENBQUNqQyxHQUFWLENBQWNyQyxRQUFkLElBQTBCLENBQWxEO0FBQ0gsU0FGRCxNQUVPO0FBQ0hzRSxVQUFBQSxTQUFTLENBQUNELEdBQVYsQ0FBY3JFLFFBQWQsRUFBd0IsQ0FBeEI7QUFDSDtBQUNKO0FBQ0o7QUFDSjs7QUFFRCxTQUFPc0UsU0FBUDtBQUNIIiwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDIxIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IF90IH0gZnJvbSAnLi4vLi4vLi4vbGFuZ3VhZ2VIYW5kbGVyJztcbmltcG9ydCB7IHJlcGxhY2VhYmxlQ29tcG9uZW50IH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL3JlcGxhY2VhYmxlQ29tcG9uZW50XCI7XG5pbXBvcnQgTW9kYWwgZnJvbSAnLi4vLi4vLi4vTW9kYWwnO1xuaW1wb3J0IHsgSUJvZHlQcm9wcyB9IGZyb20gXCIuL0lCb2R5UHJvcHNcIjtcbmltcG9ydCB7XG4gICAgSVBvbGxBbnN3ZXIsXG4gICAgSVBvbGxDb250ZW50LFxuICAgIElQb2xsUmVzcG9uc2UsXG4gICAgUE9MTF9SRVNQT05TRV9FVkVOVF9UWVBFLFxuICAgIFBPTExfU1RBUlRfRVZFTlRfVFlQRSxcbn0gZnJvbSAnLi4vLi4vLi4vcG9sbHMvY29uc3RzJztcbmltcG9ydCBTdHlsZWRSYWRpb0J1dHRvbiBmcm9tICcuLi9lbGVtZW50cy9TdHlsZWRSYWRpb0J1dHRvbic7XG5pbXBvcnQgeyBNYXRyaXhFdmVudCB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9tb2RlbHMvZXZlbnRcIjtcbmltcG9ydCB7IFJlbGF0aW9ucyB9IGZyb20gJ21hdHJpeC1qcy1zZGsvc3JjL21vZGVscy9yZWxhdGlvbnMnO1xuaW1wb3J0IE1hdHJpeENsaWVudENvbnRleHQgZnJvbSBcIi4uLy4uLy4uL2NvbnRleHRzL01hdHJpeENsaWVudENvbnRleHRcIjtcbmltcG9ydCBFcnJvckRpYWxvZyBmcm9tICcuLi9kaWFsb2dzL0Vycm9yRGlhbG9nJztcblxuLy8gVE9ETzogW2FuZHliXSBVc2UgZXh0ZW5zaWJsZSBldmVudHMgbGlicmFyeSB3aGVuIHJlYWR5XG5jb25zdCBURVhUX05PREVfVFlQRSA9IFwib3JnLm1hdHJpeC5tc2MxNzY3LnRleHRcIjtcblxuaW50ZXJmYWNlIElTdGF0ZSB7XG4gICAgc2VsZWN0ZWQ/OiBzdHJpbmc7XG4gICAgcG9sbFJlbGF0aW9uczogUmVsYXRpb25zO1xufVxuXG5AcmVwbGFjZWFibGVDb21wb25lbnQoXCJ2aWV3cy5tZXNzYWdlcy5NUG9sbEJvZHlcIilcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1Qb2xsQm9keSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxJQm9keVByb3BzLCBJU3RhdGU+IHtcbiAgICBzdGF0aWMgY29udGV4dFR5cGUgPSBNYXRyaXhDbGllbnRDb250ZXh0O1xuICAgIHB1YmxpYyBjb250ZXh0ITogUmVhY3QuQ29udGV4dFR5cGU8dHlwZW9mIE1hdHJpeENsaWVudENvbnRleHQ+O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHM6IElCb2R5UHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBzZWxlY3RlZDogbnVsbCxcbiAgICAgICAgICAgIHBvbGxSZWxhdGlvbnM6IHRoaXMuZmV0Y2hQb2xsUmVsYXRpb25zKCksXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5hZGRMaXN0ZW5lcnModGhpcy5zdGF0ZS5wb2xsUmVsYXRpb25zKTtcbiAgICAgICAgdGhpcy5wcm9wcy5teEV2ZW50Lm9uKFwiRXZlbnQucmVsYXRpb25zQ3JlYXRlZFwiLCB0aGlzLm9uUG9sbFJlbGF0aW9uc0NyZWF0ZWQpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLnByb3BzLm14RXZlbnQub2ZmKFwiRXZlbnQucmVsYXRpb25zQ3JlYXRlZFwiLCB0aGlzLm9uUG9sbFJlbGF0aW9uc0NyZWF0ZWQpO1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVycyh0aGlzLnN0YXRlLnBvbGxSZWxhdGlvbnMpO1xuICAgIH1cblxuICAgIHByaXZhdGUgYWRkTGlzdGVuZXJzKHBvbGxSZWxhdGlvbnM/OiBSZWxhdGlvbnMpIHtcbiAgICAgICAgaWYgKHBvbGxSZWxhdGlvbnMpIHtcbiAgICAgICAgICAgIHBvbGxSZWxhdGlvbnMub24oXCJSZWxhdGlvbnMuYWRkXCIsIHRoaXMub25SZWxhdGlvbnNDaGFuZ2UpO1xuICAgICAgICAgICAgcG9sbFJlbGF0aW9ucy5vbihcIlJlbGF0aW9ucy5yZW1vdmVcIiwgdGhpcy5vblJlbGF0aW9uc0NoYW5nZSk7XG4gICAgICAgICAgICBwb2xsUmVsYXRpb25zLm9uKFwiUmVsYXRpb25zLnJlZGFjdGlvblwiLCB0aGlzLm9uUmVsYXRpb25zQ2hhbmdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcmVtb3ZlTGlzdGVuZXJzKHBvbGxSZWxhdGlvbnM/OiBSZWxhdGlvbnMpIHtcbiAgICAgICAgaWYgKHBvbGxSZWxhdGlvbnMpIHtcbiAgICAgICAgICAgIHBvbGxSZWxhdGlvbnMub2ZmKFwiUmVsYXRpb25zLmFkZFwiLCB0aGlzLm9uUmVsYXRpb25zQ2hhbmdlKTtcbiAgICAgICAgICAgIHBvbGxSZWxhdGlvbnMub2ZmKFwiUmVsYXRpb25zLnJlbW92ZVwiLCB0aGlzLm9uUmVsYXRpb25zQ2hhbmdlKTtcbiAgICAgICAgICAgIHBvbGxSZWxhdGlvbnMub2ZmKFwiUmVsYXRpb25zLnJlZGFjdGlvblwiLCB0aGlzLm9uUmVsYXRpb25zQ2hhbmdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgb25Qb2xsUmVsYXRpb25zQ3JlYXRlZCA9IChyZWxhdGlvblR5cGU6IHN0cmluZywgZXZlbnRUeXBlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgcmVsYXRpb25UeXBlID09PSBcIm0ucmVmZXJlbmNlXCIgJiZcbiAgICAgICAgICAgIFBPTExfUkVTUE9OU0VfRVZFTlRfVFlQRS5tYXRjaGVzKGV2ZW50VHlwZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm14RXZlbnQucmVtb3ZlTGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgXCJFdmVudC5yZWxhdGlvbnNDcmVhdGVkXCIsIHRoaXMub25Qb2xsUmVsYXRpb25zQ3JlYXRlZCk7XG5cbiAgICAgICAgICAgIGNvbnN0IG5ld1BvbGxSZWxhdGlvbnMgPSB0aGlzLmZldGNoUG9sbFJlbGF0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5hZGRMaXN0ZW5lcnMobmV3UG9sbFJlbGF0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVycyh0aGlzLnN0YXRlLnBvbGxSZWxhdGlvbnMpO1xuXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBwb2xsUmVsYXRpb25zOiBuZXdQb2xsUmVsYXRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvblJlbGF0aW9uc0NoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgLy8gV2UgaG9sZCBwb2xsUmVsYXRpb25zIGluIG91ciBzdGF0ZSwgYW5kIGl0IGhhcyBjaGFuZ2VkIHVuZGVyIHVzXG4gICAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBzZWxlY3RPcHRpb24oYW5zd2VySWQ6IHN0cmluZykge1xuICAgICAgICBpZiAoYW5zd2VySWQgPT09IHRoaXMuc3RhdGUuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlQ29udGVudDogSVBvbGxSZXNwb25zZSA9IHtcbiAgICAgICAgICAgIFtQT0xMX1JFU1BPTlNFX0VWRU5UX1RZUEUubmFtZV06IHtcbiAgICAgICAgICAgICAgICBcImFuc3dlcnNcIjogW2Fuc3dlcklkXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm0ucmVsYXRlc190b1wiOiB7XG4gICAgICAgICAgICAgICAgXCJldmVudF9pZFwiOiB0aGlzLnByb3BzLm14RXZlbnQuZ2V0SWQoKSxcbiAgICAgICAgICAgICAgICBcInJlbF90eXBlXCI6IFwibS5yZWZlcmVuY2VcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5jb250ZXh0LnNlbmRFdmVudChcbiAgICAgICAgICAgIHRoaXMucHJvcHMubXhFdmVudC5nZXRSb29tSWQoKSxcbiAgICAgICAgICAgIFBPTExfUkVTUE9OU0VfRVZFTlRfVFlQRS5uYW1lLFxuICAgICAgICAgICAgcmVzcG9uc2VDb250ZW50LFxuICAgICAgICApLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBzdWJtaXQgcG9sbCByZXNwb25zZSBldmVudDpcIiwgZSk7XG5cbiAgICAgICAgICAgIE1vZGFsLmNyZWF0ZVRyYWNrZWREaWFsb2coXG4gICAgICAgICAgICAgICAgJ1ZvdGUgbm90IHJlZ2lzdGVyZWQnLFxuICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgIEVycm9yRGlhbG9nLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IF90KFwiVm90ZSBub3QgcmVnaXN0ZXJlZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IF90KFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJTb3JyeSwgeW91ciB2b3RlIHdhcyBub3QgcmVnaXN0ZXJlZC4gUGxlYXNlIHRyeSBhZ2Fpbi5cIiksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBzZWxlY3RlZDogYW5zd2VySWQgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvbk9wdGlvblNlbGVjdGVkID0gKGU6IFJlYWN0LkZvcm1FdmVudDxIVE1MSW5wdXRFbGVtZW50Pik6IHZvaWQgPT4ge1xuICAgICAgICB0aGlzLnNlbGVjdE9wdGlvbihlLmN1cnJlbnRUYXJnZXQudmFsdWUpO1xuICAgIH07XG5cbiAgICBwcml2YXRlIGZldGNoUG9sbFJlbGF0aW9ucygpOiBSZWxhdGlvbnMgfCBudWxsIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZ2V0UmVsYXRpb25zRm9yRXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLmdldFJlbGF0aW9uc0ZvckV2ZW50KFxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMubXhFdmVudC5nZXRJZCgpLFxuICAgICAgICAgICAgICAgIFwibS5yZWZlcmVuY2VcIixcbiAgICAgICAgICAgICAgICBQT0xMX1JFU1BPTlNFX0VWRU5UX1RZUEUubmFtZSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHVzZXJJZCAtPiBVc2VyVm90ZVxuICAgICAqL1xuICAgIHByaXZhdGUgY29sbGVjdFVzZXJWb3RlcygpOiBNYXA8c3RyaW5nLCBVc2VyVm90ZT4ge1xuICAgICAgICByZXR1cm4gY29sbGVjdFVzZXJWb3RlcyhcbiAgICAgICAgICAgIGFsbFZvdGVzKHRoaXMuc3RhdGUucG9sbFJlbGF0aW9ucyksXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZ2V0VXNlcklkKCksXG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGVkLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHByaXZhdGUgdG90YWxWb3Rlcyhjb2xsZWN0ZWRWb3RlczogTWFwPHN0cmluZywgbnVtYmVyPik6IG51bWJlciB7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgY29sbGVjdGVkVm90ZXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHN1bSArPSB2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBwb2xsU3RhcnQ6IElQb2xsQ29udGVudCA9IHRoaXMucHJvcHMubXhFdmVudC5nZXRDb250ZW50KCk7XG4gICAgICAgIGNvbnN0IHBvbGxJbmZvID0gcG9sbFN0YXJ0W1BPTExfU1RBUlRfRVZFTlRfVFlQRS5uYW1lXTtcblxuICAgICAgICBpZiAocG9sbEluZm8uYW5zd2Vycy5sZW5ndGggPCAxIHx8IHBvbGxJbmZvLmFuc3dlcnMubGVuZ3RoID4gMjApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcG9sbElkID0gdGhpcy5wcm9wcy5teEV2ZW50LmdldElkKCk7XG4gICAgICAgIGNvbnN0IHVzZXJWb3RlcyA9IHRoaXMuY29sbGVjdFVzZXJWb3RlcygpO1xuICAgICAgICBjb25zdCB2b3RlcyA9IGNvdW50Vm90ZXModXNlclZvdGVzLCB0aGlzLnByb3BzLm14RXZlbnQuZ2V0Q29udGVudCgpKTtcbiAgICAgICAgY29uc3QgdG90YWxWb3RlcyA9IHRoaXMudG90YWxWb3Rlcyh2b3Rlcyk7XG4gICAgICAgIGNvbnN0IHVzZXJJZCA9IHRoaXMuY29udGV4dC5nZXRVc2VySWQoKTtcbiAgICAgICAgY29uc3QgbXlWb3RlID0gdXNlclZvdGVzLmdldCh1c2VySWQpPy5hbnN3ZXJzWzBdO1xuXG4gICAgICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT1cIm14X01Qb2xsQm9keVwiPlxuICAgICAgICAgICAgPGgyPnsgcG9sbEluZm8ucXVlc3Rpb25bVEVYVF9OT0RFX1RZUEVdIH08L2gyPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJteF9NUG9sbEJvZHlfYWxsT3B0aW9uc1wiPlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcG9sbEluZm8uYW5zd2Vycy5tYXAoKGFuc3dlcjogSVBvbGxBbnN3ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrZWQgPSBteVZvdGUgPT09IGFuc3dlci5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBgbXhfTVBvbGxCb2R5X29wdGlvbiR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZCA/IFwiIG14X01Qb2xsQm9keV9vcHRpb25fY2hlY2tlZFwiOiBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFuc3dlclZvdGVzID0gdm90ZXMuZ2V0KGFuc3dlci5pZCkgPz8gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFuc3dlclBlcmNlbnQgPSBNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEwMC4wICogYW5zd2VyVm90ZXMgLyB0b3RhbFZvdGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5PXthbnN3ZXIuaWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHRoaXMuc2VsZWN0T3B0aW9uKGFuc3dlci5pZCl9XG4gICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFN0eWxlZFJhZGlvQnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9e2Bwb2xsX2Fuc3dlcl9zZWxlY3QtJHtwb2xsSWR9YH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2Fuc3dlci5pZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17Y2hlY2tlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25PcHRpb25TZWxlY3RlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXhfTVBvbGxCb2R5X29wdGlvbkRlc2NyaXB0aW9uXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm14X01Qb2xsQm9keV9vcHRpb25UZXh0XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBhbnN3ZXJbVEVYVF9OT0RFX1RZUEVdIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJteF9NUG9sbEJvZHlfb3B0aW9uVm90ZUNvdW50XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBfdChcIiUoY291bnQpcyB2b3Rlc1wiLCB7IGNvdW50OiBhbnN3ZXJWb3RlcyB9KSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9TdHlsZWRSYWRpb0J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm14X01Qb2xsQm9keV9wb3B1bGFyaXR5QmFja2dyb3VuZFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJteF9NUG9sbEJvZHlfcG9wdWxhcml0eUFtb3VudFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17eyBcIndpZHRoXCI6IGAke2Fuc3dlclBlcmNlbnR9JWAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PjtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXhfTVBvbGxCb2R5X3RvdGFsVm90ZXNcIj5cbiAgICAgICAgICAgICAgICB7IF90KCBcIkJhc2VkIG9uICUoY291bnQpcyB2b3Rlc1wiLCB7IGNvdW50OiB0b3RhbFZvdGVzIH0gKSB9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+O1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFVzZXJWb3RlIHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgdHM6IG51bWJlciwgcHVibGljIHJlYWRvbmx5IHNlbmRlcjogc3RyaW5nLCBwdWJsaWMgcmVhZG9ubHkgYW5zd2Vyczogc3RyaW5nW10pIHtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVzZXJSZXNwb25zZUZyb21Qb2xsUmVzcG9uc2VFdmVudChldmVudDogTWF0cml4RXZlbnQpOiBVc2VyVm90ZSB7XG4gICAgY29uc3QgcHIgPSBldmVudC5nZXRDb250ZW50KCkgYXMgSVBvbGxSZXNwb25zZTtcbiAgICBjb25zdCBhbnN3ZXJzID0gcHJbUE9MTF9SRVNQT05TRV9FVkVOVF9UWVBFLm5hbWVdLmFuc3dlcnM7XG5cbiAgICByZXR1cm4gbmV3IFVzZXJWb3RlKFxuICAgICAgICBldmVudC5nZXRUcygpLFxuICAgICAgICBldmVudC5nZXRTZW5kZXIoKSxcbiAgICAgICAgYW5zd2VycyxcbiAgICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWxsVm90ZXMocG9sbFJlbGF0aW9uczogUmVsYXRpb25zKTogQXJyYXk8VXNlclZvdGU+IHtcbiAgICBmdW5jdGlvbiBpc1BvbGxSZXNwb25zZShyZXNwb25zZUV2ZW50OiBNYXRyaXhFdmVudCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcmVzcG9uc2VFdmVudC5nZXRUeXBlKCkgPT09IFBPTExfUkVTUE9OU0VfRVZFTlRfVFlQRS5uYW1lICYmXG4gICAgICAgICAgICByZXNwb25zZUV2ZW50LmdldENvbnRlbnQoKS5oYXNPd25Qcm9wZXJ0eShQT0xMX1JFU1BPTlNFX0VWRU5UX1RZUEUubmFtZSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAocG9sbFJlbGF0aW9ucykge1xuICAgICAgICByZXR1cm4gcG9sbFJlbGF0aW9ucy5nZXRSZWxhdGlvbnMoKVxuICAgICAgICAgICAgLmZpbHRlcihpc1BvbGxSZXNwb25zZSlcbiAgICAgICAgICAgIC5tYXAodXNlclJlc3BvbnNlRnJvbVBvbGxSZXNwb25zZUV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuXG4vKipcbiAqIEZpZ3VyZSBvdXQgdGhlIGNvcnJlY3Qgdm90ZSBmb3IgZWFjaCB1c2VyLlxuICogQHJldHVybnMgYSBNYXAgb2YgdXNlciBJRCB0byB0aGVpciB2b3RlIGluZm9cbiAqL1xuZnVuY3Rpb24gY29sbGVjdFVzZXJWb3RlcyhcbiAgICB1c2VyUmVzcG9uc2VzOiBBcnJheTxVc2VyVm90ZT4sXG4gICAgdXNlcklkOiBzdHJpbmcsXG4gICAgc2VsZWN0ZWQ/OiBzdHJpbmcsXG4pOiBNYXA8c3RyaW5nLCBVc2VyVm90ZT4ge1xuICAgIGNvbnN0IHVzZXJWb3RlczogTWFwPHN0cmluZywgVXNlclZvdGU+ID0gbmV3IE1hcCgpO1xuXG4gICAgZm9yIChjb25zdCByZXNwb25zZSBvZiB1c2VyUmVzcG9uc2VzKSB7XG4gICAgICAgIGNvbnN0IG90aGVyUmVzcG9uc2UgPSB1c2VyVm90ZXMuZ2V0KHJlc3BvbnNlLnNlbmRlcik7XG4gICAgICAgIGlmICghb3RoZXJSZXNwb25zZSB8fCBvdGhlclJlc3BvbnNlLnRzIDwgcmVzcG9uc2UudHMpIHtcbiAgICAgICAgICAgIHVzZXJWb3Rlcy5zZXQocmVzcG9uc2Uuc2VuZGVyLCByZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgdXNlclZvdGVzLnNldCh1c2VySWQsIG5ldyBVc2VyVm90ZSgwLCB1c2VySWQsIFtzZWxlY3RlZF0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXNlclZvdGVzO1xufVxuXG5mdW5jdGlvbiBjb3VudFZvdGVzKFxuICAgIHVzZXJWb3RlczogTWFwPHN0cmluZywgVXNlclZvdGU+LFxuICAgIHBvbGxTdGFydDogSVBvbGxDb250ZW50LFxuKTogTWFwPHN0cmluZywgbnVtYmVyPiB7XG4gICAgY29uc3QgY29sbGVjdGVkID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcblxuICAgIGNvbnN0IHBvbGxJbmZvID0gcG9sbFN0YXJ0W1BPTExfU1RBUlRfRVZFTlRfVFlQRS5uYW1lXTtcbiAgICBjb25zdCBtYXhTZWxlY3Rpb25zID0gMTsgIC8vIFNlZSBNU0MzMzgxIC0gbGF0ZXIgdGhpcyB3aWxsIGJlIGluIHBvbGxJbmZvXG5cbiAgICBjb25zdCBhbGxvd2VkQW5zd2VySWRzID0gcG9sbEluZm8uYW5zd2Vycy5tYXAoKGFuczogSVBvbGxBbnN3ZXIpID0+IGFucy5pZCk7XG4gICAgZnVuY3Rpb24gaXNWYWxpZEFuc3dlcihhbnN3ZXJJZDogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBhbGxvd2VkQW5zd2VySWRzLmluY2x1ZGVzKGFuc3dlcklkKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHJlc3BvbnNlIG9mIHVzZXJWb3Rlcy52YWx1ZXMoKSkge1xuICAgICAgICBpZiAocmVzcG9uc2UuYW5zd2Vycy5ldmVyeShpc1ZhbGlkQW5zd2VyKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGFuc3dlcklkXSBvZiByZXNwb25zZS5hbnN3ZXJzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSBtYXhTZWxlY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29sbGVjdGVkLmhhcyhhbnN3ZXJJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGVkLnNldChhbnN3ZXJJZCwgY29sbGVjdGVkLmdldChhbnN3ZXJJZCkgKyAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0ZWQuc2V0KGFuc3dlcklkLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29sbGVjdGVkO1xufVxuIl19