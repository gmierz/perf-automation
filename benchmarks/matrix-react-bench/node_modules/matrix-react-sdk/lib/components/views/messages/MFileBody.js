"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DOWNLOAD_ICON_URL = void 0;
exports.computedStyle = computedStyle;
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _filesize = _interopRequireDefault(require("filesize"));

var _languageHandler = require("../../../languageHandler");

var _Modal = _interopRequireDefault(require("../../../Modal"));

var _AccessibleButton = _interopRequireDefault(require("../elements/AccessibleButton"));

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _Media = require("../../../customisations/Media");

var _ErrorDialog = _interopRequireDefault(require("../dialogs/ErrorDialog"));

var _EventTile = require("../rooms/EventTile");

var _FileUtils = require("../../../utils/FileUtils");

var _FileDownloader = require("../../../utils/FileDownloader");

var _TextWithTooltip = _interopRequireDefault(require("../elements/TextWithTooltip"));

var _logger = require("matrix-js-sdk/src/logger");

var _dec, _class, _class2, _temp;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

let DOWNLOAD_ICON_URL; // cached copy of the download.svg asset for the sandboxed iframe later on

exports.DOWNLOAD_ICON_URL = DOWNLOAD_ICON_URL;

async function cacheDownloadIcon() {
  if (DOWNLOAD_ICON_URL) return; // cached already
  // eslint-disable-next-line @typescript-eslint/no-var-requires

  const svg = await fetch(require("../../../../res/img/download.svg")).then(r => r.text());
  exports.DOWNLOAD_ICON_URL = DOWNLOAD_ICON_URL = "data:image/svg+xml;base64," + window.btoa(svg);
} // Cache the asset immediately
// noinspection JSIgnoredPromiseFromCall


cacheDownloadIcon(); // User supplied content can contain scripts, we have to be careful that
// we don't accidentally run those script within the same origin as the
// client. Otherwise those scripts written by remote users can read
// the access token and end-to-end keys that are in local storage.
//
// For attachments downloaded directly from the homeserver we can use
// Content-Security-Policy headers to disable script execution.
//
// But attachments with end-to-end encryption are more difficult to handle.
// We need to decrypt the attachment on the client and then display it.
// To display the attachment we need to turn the decrypted bytes into a URL.
//
// There are two ways to turn bytes into URLs, data URL and blob URLs.
// Data URLs aren't suitable for downloading a file because Chrome has a
// 2MB limit on the size of URLs that can be viewed in the browser or
// downloaded. This limit does not seem to apply when the url is used as
// the source attribute of an image tag.
//
// Blob URLs are generated using window.URL.createObjectURL and unfortunately
// for our purposes they inherit the origin of the page that created them.
// This means that any scripts that run when the URL is viewed will be able
// to access local storage.
//
// The easiest solution is to host the code that generates the blob URL on
// a different domain to the client.
// Another possibility is to generate the blob URL within a sandboxed iframe.
// The downside of using a second domain is that it complicates hosting,
// the downside of using a sandboxed iframe is that the browers are overly
// restrictive in what you are allowed to do with the generated URL.

/**
 * Get the current CSS style for a DOMElement.
 * @param {HTMLElement} element The element to get the current style of.
 * @return {string} The CSS style encoded as a string.
 */

function computedStyle(element) {
  if (!element) {
    return "";
  }

  const style = window.getComputedStyle(element, null);
  let cssText = style.cssText; // noinspection EqualityComparisonWithCoercionJS

  if (cssText == "") {
    // Firefox doesn't implement ".cssText" for computed styles.
    // https://bugzilla.mozilla.org/show_bug.cgi?id=137687
    for (let i = 0; i < style.length; i++) {
      cssText += style[i] + ":";
      cssText += style.getPropertyValue(style[i]) + ";";
    }
  }

  return cssText;
}

let MFileBody = (_dec = (0, _replaceableComponent.replaceableComponent)("views.messages.MFileBody"), _dec(_class = (_temp = _class2 = class MFileBody extends _react.default.Component {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "iframe", /*#__PURE__*/(0, _react.createRef)());
    (0, _defineProperty2.default)(this, "dummyLink", /*#__PURE__*/(0, _react.createRef)());
    (0, _defineProperty2.default)(this, "userDidClick", false);
    (0, _defineProperty2.default)(this, "fileDownloader", new _FileDownloader.FileDownloader(() => this.iframe.current));
    (0, _defineProperty2.default)(this, "decryptFile", async () => {
      if (this.state.decryptedBlob) {
        return;
      }

      try {
        this.userDidClick = true;
        this.setState({
          decryptedBlob: await this.props.mediaEventHelper.sourceBlob.value
        });
      } catch (err) {
        _logger.logger.warn("Unable to decrypt attachment: ", err);

        _Modal.default.createTrackedDialog('Error decrypting attachment', '', _ErrorDialog.default, {
          title: (0, _languageHandler._t)("Error"),
          description: (0, _languageHandler._t)("Error decrypting attachment")
        });
      }
    });
    (0, _defineProperty2.default)(this, "onPlaceholderClick", async () => {
      const mediaHelper = this.props.mediaEventHelper;

      if (mediaHelper !== null && mediaHelper !== void 0 && mediaHelper.media.isEncrypted) {
        await this.decryptFile();
        this.downloadFile(this.fileName, this.linkText);
      } else {
        // As a button we're missing the `download` attribute for styling reasons, so
        // download with the file downloader.
        this.fileDownloader.download({
          blob: await mediaHelper.sourceBlob.value,
          name: this.fileName
        });
      }
    });
    this.state = {};
  }

  getContentUrl() {
    if (this.props.forExport) return null;
    const media = (0, _Media.mediaFromContent)(this.props.mxEvent.getContent());
    return media.srcHttp;
  }

  get content() {
    return this.props.mxEvent.getContent();
  }

  get fileName() {
    return this.content.body && this.content.body.length > 0 ? this.content.body : (0, _languageHandler._t)("Attachment");
  }

  get linkText() {
    return (0, _FileUtils.presentableTextForFile)(this.content);
  }

  downloadFile(fileName, text) {
    this.fileDownloader.download({
      blob: this.state.decryptedBlob,
      name: fileName,
      autoDownload: this.userDidClick,
      opts: {
        imgSrc: DOWNLOAD_ICON_URL,
        imgStyle: null,
        style: computedStyle(this.dummyLink.current),
        textContent: (0, _languageHandler._t)("Download %(text)s", {
          text
        })
      }
    });
  }

  componentDidUpdate(prevProps, prevState) {
    if (this.props.onHeightChanged && !prevState.decryptedBlob && this.state.decryptedBlob) {
      this.props.onHeightChanged();
    }
  }

  render() {
    var _this$props$mediaEven;

    const isEncrypted = (_this$props$mediaEven = this.props.mediaEventHelper) === null || _this$props$mediaEven === void 0 ? void 0 : _this$props$mediaEven.media.isEncrypted;
    const contentUrl = this.getContentUrl();
    const fileSize = this.content.info ? this.content.info.size : null;
    const fileType = this.content.info ? this.content.info.mimetype : "application/octet-stream";
    let placeholder = null;

    if (this.props.showGenericPlaceholder) {
      placeholder = /*#__PURE__*/_react.default.createElement(_AccessibleButton.default, {
        className: "mx_MediaBody mx_MFileBody_info",
        onClick: this.onPlaceholderClick
      }, /*#__PURE__*/_react.default.createElement("span", {
        className: "mx_MFileBody_info_icon"
      }), /*#__PURE__*/_react.default.createElement(_TextWithTooltip.default, {
        tooltip: (0, _FileUtils.presentableTextForFile)(this.content, (0, _languageHandler._t)("Attachment"), true)
      }, /*#__PURE__*/_react.default.createElement("span", {
        className: "mx_MFileBody_info_filename"
      }, (0, _FileUtils.presentableTextForFile)(this.content, (0, _languageHandler._t)("Attachment"), true, true))));
    }

    if (this.props.forExport) {
      var _content$file;

      const content = this.props.mxEvent.getContent(); // During export, the content url will point to the MSC, which will later point to a local url

      return /*#__PURE__*/_react.default.createElement("span", {
        className: "mx_MFileBody"
      }, /*#__PURE__*/_react.default.createElement("a", {
        href: ((_content$file = content.file) === null || _content$file === void 0 ? void 0 : _content$file.url) || content.url
      }, placeholder));
    }

    const showDownloadLink = this.props.tileShape || !this.props.showGenericPlaceholder;

    if (isEncrypted) {
      if (!this.state.decryptedBlob) {
        // Need to decrypt the attachment
        // Wait for the user to click on the link before downloading
        // and decrypting the attachment.
        // This button should actually Download because usercontent/ will try to click itself
        // but it is not guaranteed between various browsers' settings.
        return /*#__PURE__*/_react.default.createElement("span", {
          className: "mx_MFileBody"
        }, placeholder, showDownloadLink && /*#__PURE__*/_react.default.createElement("div", {
          className: "mx_MFileBody_download"
        }, /*#__PURE__*/_react.default.createElement(_AccessibleButton.default, {
          onClick: this.decryptFile
        }, (0, _languageHandler._t)("Decrypt %(text)s", {
          text: this.linkText
        }))));
      }

      const url = "usercontent/"; // XXX: this path should probably be passed from the skin
      // If the attachment is encrypted then put the link inside an iframe.

      return /*#__PURE__*/_react.default.createElement("span", {
        className: "mx_MFileBody"
      }, placeholder, showDownloadLink && /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_MFileBody_download"
      }, /*#__PURE__*/_react.default.createElement("div", {
        style: {
          display: "none"
        }
      }, /*#__PURE__*/_react.default.createElement("a", {
        ref: this.dummyLink
      })), /*#__PURE__*/_react.default.createElement("iframe", {
        src: url,
        onLoad: () => this.downloadFile(this.fileName, this.linkText),
        ref: this.iframe,
        sandbox: "allow-scripts allow-downloads allow-downloads-without-user-activation"
      })));
    } else if (contentUrl) {
      const downloadProps = {
        target: "_blank",
        rel: "noreferrer noopener",
        // We set the href regardless of whether or not we intercept the download
        // because we don't really want to convert the file to a blob eagerly, and
        // still want "open in new tab" and "save link as" to work.
        href: contentUrl
      }; // Blobs can only have up to 500mb, so if the file reports as being too large then
      // we won't try and convert it. Likewise, if the file size is unknown then we'll assume
      // it is too big. There is the risk of the reported file size and the actual file size
      // being different, however the user shouldn't normally run into this problem.

      const fileTooBig = typeof fileSize === 'number' ? fileSize > 524288000 : true;

      if (["application/pdf"].includes(fileType) && !fileTooBig) {
        // We want to force a download on this type, so use an onClick handler.
        downloadProps["onClick"] = e => {
          _logger.logger.log(`Downloading ${fileType} as blob (unencrypted)`); // Avoid letting the <a> do its thing


          e.preventDefault();
          e.stopPropagation(); // Start a fetch for the download
          // Based upon https://stackoverflow.com/a/49500465

          this.props.mediaEventHelper.sourceBlob.value.then(blob => {
            const blobUrl = URL.createObjectURL(blob); // We have to create an anchor to download the file

            const tempAnchor = document.createElement('a');
            tempAnchor.download = this.fileName;
            tempAnchor.href = blobUrl;
            document.body.appendChild(tempAnchor); // for firefox: https://stackoverflow.com/a/32226068

            tempAnchor.click();
            tempAnchor.remove();
          });
        };
      } else {
        // Else we are hoping the browser will do the right thing
        downloadProps["download"] = this.fileName;
      }

      return /*#__PURE__*/_react.default.createElement("span", {
        className: "mx_MFileBody"
      }, placeholder, showDownloadLink && /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_MFileBody_download"
      }, /*#__PURE__*/_react.default.createElement("a", downloadProps, /*#__PURE__*/_react.default.createElement("span", {
        className: "mx_MFileBody_download_icon"
      }), (0, _languageHandler._t)("Download %(text)s", {
        text: this.linkText
      })), this.props.tileShape === _EventTile.TileShape.FileGrid && /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_MImageBody_size"
      }, this.content.info && this.content.info.size ? (0, _filesize.default)(this.content.info.size) : "")));
    } else {
      const extra = this.linkText ? ': ' + this.linkText : '';
      return /*#__PURE__*/_react.default.createElement("span", {
        className: "mx_MFileBody"
      }, placeholder, (0, _languageHandler._t)("Invalid file%(extra)s", {
        extra: extra
      }));
    }
  }

}, (0, _defineProperty2.default)(_class2, "defaultProps", {
  showGenericPlaceholder: true
}), _temp)) || _class);
exports.default = MFileBody;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL21lc3NhZ2VzL01GaWxlQm9keS50c3giXSwibmFtZXMiOlsiRE9XTkxPQURfSUNPTl9VUkwiLCJjYWNoZURvd25sb2FkSWNvbiIsInN2ZyIsImZldGNoIiwicmVxdWlyZSIsInRoZW4iLCJyIiwidGV4dCIsIndpbmRvdyIsImJ0b2EiLCJjb21wdXRlZFN0eWxlIiwiZWxlbWVudCIsInN0eWxlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImNzc1RleHQiLCJpIiwibGVuZ3RoIiwiZ2V0UHJvcGVydHlWYWx1ZSIsIk1GaWxlQm9keSIsIlJlYWN0IiwiQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJwcm9wcyIsIkZpbGVEb3dubG9hZGVyIiwiaWZyYW1lIiwiY3VycmVudCIsInN0YXRlIiwiZGVjcnlwdGVkQmxvYiIsInVzZXJEaWRDbGljayIsInNldFN0YXRlIiwibWVkaWFFdmVudEhlbHBlciIsInNvdXJjZUJsb2IiLCJ2YWx1ZSIsImVyciIsImxvZ2dlciIsIndhcm4iLCJNb2RhbCIsImNyZWF0ZVRyYWNrZWREaWFsb2ciLCJFcnJvckRpYWxvZyIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJtZWRpYUhlbHBlciIsIm1lZGlhIiwiaXNFbmNyeXB0ZWQiLCJkZWNyeXB0RmlsZSIsImRvd25sb2FkRmlsZSIsImZpbGVOYW1lIiwibGlua1RleHQiLCJmaWxlRG93bmxvYWRlciIsImRvd25sb2FkIiwiYmxvYiIsIm5hbWUiLCJnZXRDb250ZW50VXJsIiwiZm9yRXhwb3J0IiwibXhFdmVudCIsImdldENvbnRlbnQiLCJzcmNIdHRwIiwiY29udGVudCIsImJvZHkiLCJhdXRvRG93bmxvYWQiLCJvcHRzIiwiaW1nU3JjIiwiaW1nU3R5bGUiLCJkdW1teUxpbmsiLCJ0ZXh0Q29udGVudCIsImNvbXBvbmVudERpZFVwZGF0ZSIsInByZXZQcm9wcyIsInByZXZTdGF0ZSIsIm9uSGVpZ2h0Q2hhbmdlZCIsInJlbmRlciIsImNvbnRlbnRVcmwiLCJmaWxlU2l6ZSIsImluZm8iLCJzaXplIiwiZmlsZVR5cGUiLCJtaW1ldHlwZSIsInBsYWNlaG9sZGVyIiwic2hvd0dlbmVyaWNQbGFjZWhvbGRlciIsIm9uUGxhY2Vob2xkZXJDbGljayIsImZpbGUiLCJ1cmwiLCJzaG93RG93bmxvYWRMaW5rIiwidGlsZVNoYXBlIiwiZGlzcGxheSIsImRvd25sb2FkUHJvcHMiLCJ0YXJnZXQiLCJyZWwiLCJocmVmIiwiZmlsZVRvb0JpZyIsImluY2x1ZGVzIiwiZSIsImxvZyIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiYmxvYlVybCIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsInRlbXBBbmNob3IiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJhcHBlbmRDaGlsZCIsImNsaWNrIiwicmVtb3ZlIiwiVGlsZVNoYXBlIiwiRmlsZUdyaWQiLCJleHRyYSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQWdCQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFHQTs7QUFDQTs7QUFFQTs7Ozs7Ozs7QUFFTyxJQUFJQSxpQkFBSixDLENBQXVCOzs7O0FBRTlCLGVBQWVDLGlCQUFmLEdBQW1DO0FBQy9CLE1BQUlELGlCQUFKLEVBQXVCLE9BRFEsQ0FDQTtBQUMvQjs7QUFDQSxRQUFNRSxHQUFHLEdBQUcsTUFBTUMsS0FBSyxDQUFDQyxPQUFPLENBQUMsa0NBQUQsQ0FBUixDQUFMLENBQW1EQyxJQUFuRCxDQUF3REMsQ0FBQyxJQUFJQSxDQUFDLENBQUNDLElBQUYsRUFBN0QsQ0FBbEI7QUFDQSw4QkFBQVAsaUJBQWlCLEdBQUcsK0JBQStCUSxNQUFNLENBQUNDLElBQVAsQ0FBWVAsR0FBWixDQUFuRDtBQUNILEMsQ0FFRDtBQUNBOzs7QUFDQUQsaUJBQWlCLEcsQ0FFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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TUEyREE7QUFDSCxZQUFNZ0MsS0FBSyxHQUFHLEtBQUsxRCxRQUFMLEdBQWlCLE9BQU8sS0FBS0EsUUFBN0IsR0FBeUMsRUFBdkQ7QUFDQSwwQkFBTztBQUFNLFFBQUEsU0FBUyxFQUFDO0FBQWhCLFNBQ0Q2QixXQURDLEVBRUQseUJBQUcsdUJBQUgsRUFBNEI7QUFBRTZCLFFBQUFBLEtBQUssRUFBRUE7QUFBVCxPQUE1QixDQUZDLENBQVA7QUFJSDtBQUNKOztBQTFPa0UsQyx5REFDN0M7QUFDbEI1QixFQUFBQSxzQkFBc0IsRUFBRTtBQUROLEMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMTUgLSAyMDIxIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBmaWxlc2l6ZSBmcm9tICdmaWxlc2l6ZSc7XG5pbXBvcnQgeyBfdCB9IGZyb20gJy4uLy4uLy4uL2xhbmd1YWdlSGFuZGxlcic7XG5pbXBvcnQgTW9kYWwgZnJvbSAnLi4vLi4vLi4vTW9kYWwnO1xuaW1wb3J0IEFjY2Vzc2libGVCdXR0b24gZnJvbSBcIi4uL2VsZW1lbnRzL0FjY2Vzc2libGVCdXR0b25cIjtcbmltcG9ydCB7IHJlcGxhY2VhYmxlQ29tcG9uZW50IH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL3JlcGxhY2VhYmxlQ29tcG9uZW50XCI7XG5pbXBvcnQgeyBtZWRpYUZyb21Db250ZW50IH0gZnJvbSBcIi4uLy4uLy4uL2N1c3RvbWlzYXRpb25zL01lZGlhXCI7XG5pbXBvcnQgRXJyb3JEaWFsb2cgZnJvbSBcIi4uL2RpYWxvZ3MvRXJyb3JEaWFsb2dcIjtcbmltcG9ydCB7IFRpbGVTaGFwZSB9IGZyb20gXCIuLi9yb29tcy9FdmVudFRpbGVcIjtcbmltcG9ydCB7IHByZXNlbnRhYmxlVGV4dEZvckZpbGUgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvRmlsZVV0aWxzXCI7XG5pbXBvcnQgeyBJTWVkaWFFdmVudENvbnRlbnQgfSBmcm9tIFwiLi4vLi4vLi4vY3VzdG9taXNhdGlvbnMvbW9kZWxzL0lNZWRpYUV2ZW50Q29udGVudFwiO1xuaW1wb3J0IHsgSUJvZHlQcm9wcyB9IGZyb20gXCIuL0lCb2R5UHJvcHNcIjtcbmltcG9ydCB7IEZpbGVEb3dubG9hZGVyIH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL0ZpbGVEb3dubG9hZGVyXCI7XG5pbXBvcnQgVGV4dFdpdGhUb29sdGlwIGZyb20gXCIuLi9lbGVtZW50cy9UZXh0V2l0aFRvb2x0aXBcIjtcblxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL2xvZ2dlclwiO1xuXG5leHBvcnQgbGV0IERPV05MT0FEX0lDT05fVVJMOyAvLyBjYWNoZWQgY29weSBvZiB0aGUgZG93bmxvYWQuc3ZnIGFzc2V0IGZvciB0aGUgc2FuZGJveGVkIGlmcmFtZSBsYXRlciBvblxuXG5hc3luYyBmdW5jdGlvbiBjYWNoZURvd25sb2FkSWNvbigpIHtcbiAgICBpZiAoRE9XTkxPQURfSUNPTl9VUkwpIHJldHVybjsgLy8gY2FjaGVkIGFscmVhZHlcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuICAgIGNvbnN0IHN2ZyA9IGF3YWl0IGZldGNoKHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9yZXMvaW1nL2Rvd25sb2FkLnN2Z1wiKSkudGhlbihyID0+IHIudGV4dCgpKTtcbiAgICBET1dOTE9BRF9JQ09OX1VSTCA9IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxcIiArIHdpbmRvdy5idG9hKHN2Zyk7XG59XG5cbi8vIENhY2hlIHRoZSBhc3NldCBpbW1lZGlhdGVseVxuLy8gbm9pbnNwZWN0aW9uIEpTSWdub3JlZFByb21pc2VGcm9tQ2FsbFxuY2FjaGVEb3dubG9hZEljb24oKTtcblxuLy8gVXNlciBzdXBwbGllZCBjb250ZW50IGNhbiBjb250YWluIHNjcmlwdHMsIHdlIGhhdmUgdG8gYmUgY2FyZWZ1bCB0aGF0XG4vLyB3ZSBkb24ndCBhY2NpZGVudGFsbHkgcnVuIHRob3NlIHNjcmlwdCB3aXRoaW4gdGhlIHNhbWUgb3JpZ2luIGFzIHRoZVxuLy8gY2xpZW50LiBPdGhlcndpc2UgdGhvc2Ugc2NyaXB0cyB3cml0dGVuIGJ5IHJlbW90ZSB1c2VycyBjYW4gcmVhZFxuLy8gdGhlIGFjY2VzcyB0b2tlbiBhbmQgZW5kLXRvLWVuZCBrZXlzIHRoYXQgYXJlIGluIGxvY2FsIHN0b3JhZ2UuXG4vL1xuLy8gRm9yIGF0dGFjaG1lbnRzIGRvd25sb2FkZWQgZGlyZWN0bHkgZnJvbSB0aGUgaG9tZXNlcnZlciB3ZSBjYW4gdXNlXG4vLyBDb250ZW50LVNlY3VyaXR5LVBvbGljeSBoZWFkZXJzIHRvIGRpc2FibGUgc2NyaXB0IGV4ZWN1dGlvbi5cbi8vXG4vLyBCdXQgYXR0YWNobWVudHMgd2l0aCBlbmQtdG8tZW5kIGVuY3J5cHRpb24gYXJlIG1vcmUgZGlmZmljdWx0IHRvIGhhbmRsZS5cbi8vIFdlIG5lZWQgdG8gZGVjcnlwdCB0aGUgYXR0YWNobWVudCBvbiB0aGUgY2xpZW50IGFuZCB0aGVuIGRpc3BsYXkgaXQuXG4vLyBUbyBkaXNwbGF5IHRoZSBhdHRhY2htZW50IHdlIG5lZWQgdG8gdHVybiB0aGUgZGVjcnlwdGVkIGJ5dGVzIGludG8gYSBVUkwuXG4vL1xuLy8gVGhlcmUgYXJlIHR3byB3YXlzIHRvIHR1cm4gYnl0ZXMgaW50byBVUkxzLCBkYXRhIFVSTCBhbmQgYmxvYiBVUkxzLlxuLy8gRGF0YSBVUkxzIGFyZW4ndCBzdWl0YWJsZSBmb3IgZG93bmxvYWRpbmcgYSBmaWxlIGJlY2F1c2UgQ2hyb21lIGhhcyBhXG4vLyAyTUIgbGltaXQgb24gdGhlIHNpemUgb2YgVVJMcyB0aGF0IGNhbiBiZSB2aWV3ZWQgaW4gdGhlIGJyb3dzZXIgb3Jcbi8vIGRvd25sb2FkZWQuIFRoaXMgbGltaXQgZG9lcyBub3Qgc2VlbSB0byBhcHBseSB3aGVuIHRoZSB1cmwgaXMgdXNlZCBhc1xuLy8gdGhlIHNvdXJjZSBhdHRyaWJ1dGUgb2YgYW4gaW1hZ2UgdGFnLlxuLy9cbi8vIEJsb2IgVVJMcyBhcmUgZ2VuZXJhdGVkIHVzaW5nIHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMIGFuZCB1bmZvcnR1bmF0ZWx5XG4vLyBmb3Igb3VyIHB1cnBvc2VzIHRoZXkgaW5oZXJpdCB0aGUgb3JpZ2luIG9mIHRoZSBwYWdlIHRoYXQgY3JlYXRlZCB0aGVtLlxuLy8gVGhpcyBtZWFucyB0aGF0IGFueSBzY3JpcHRzIHRoYXQgcnVuIHdoZW4gdGhlIFVSTCBpcyB2aWV3ZWQgd2lsbCBiZSBhYmxlXG4vLyB0byBhY2Nlc3MgbG9jYWwgc3RvcmFnZS5cbi8vXG4vLyBUaGUgZWFzaWVzdCBzb2x1dGlvbiBpcyB0byBob3N0IHRoZSBjb2RlIHRoYXQgZ2VuZXJhdGVzIHRoZSBibG9iIFVSTCBvblxuLy8gYSBkaWZmZXJlbnQgZG9tYWluIHRvIHRoZSBjbGllbnQuXG4vLyBBbm90aGVyIHBvc3NpYmlsaXR5IGlzIHRvIGdlbmVyYXRlIHRoZSBibG9iIFVSTCB3aXRoaW4gYSBzYW5kYm94ZWQgaWZyYW1lLlxuLy8gVGhlIGRvd25zaWRlIG9mIHVzaW5nIGEgc2Vjb25kIGRvbWFpbiBpcyB0aGF0IGl0IGNvbXBsaWNhdGVzIGhvc3RpbmcsXG4vLyB0aGUgZG93bnNpZGUgb2YgdXNpbmcgYSBzYW5kYm94ZWQgaWZyYW1lIGlzIHRoYXQgdGhlIGJyb3dlcnMgYXJlIG92ZXJseVxuLy8gcmVzdHJpY3RpdmUgaW4gd2hhdCB5b3UgYXJlIGFsbG93ZWQgdG8gZG8gd2l0aCB0aGUgZ2VuZXJhdGVkIFVSTC5cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgQ1NTIHN0eWxlIGZvciBhIERPTUVsZW1lbnQuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGdldCB0aGUgY3VycmVudCBzdHlsZSBvZi5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIENTUyBzdHlsZSBlbmNvZGVkIGFzIGEgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZWRTdHlsZShlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbiAgICBsZXQgY3NzVGV4dCA9IHN0eWxlLmNzc1RleHQ7XG4gICAgLy8gbm9pbnNwZWN0aW9uIEVxdWFsaXR5Q29tcGFyaXNvbldpdGhDb2VyY2lvbkpTXG4gICAgaWYgKGNzc1RleHQgPT0gXCJcIikge1xuICAgICAgICAvLyBGaXJlZm94IGRvZXNuJ3QgaW1wbGVtZW50IFwiLmNzc1RleHRcIiBmb3IgY29tcHV0ZWQgc3R5bGVzLlxuICAgICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzc2ODdcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHlsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3NzVGV4dCArPSBzdHlsZVtpXSArIFwiOlwiO1xuICAgICAgICAgICAgY3NzVGV4dCArPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHN0eWxlW2ldKSArIFwiO1wiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjc3NUZXh0O1xufVxuXG5pbnRlcmZhY2UgSVByb3BzIGV4dGVuZHMgSUJvZHlQcm9wcyB7XG4gICAgLyogd2hldGhlciBvciBub3QgdG8gc2hvdyB0aGUgZGVmYXVsdCBwbGFjZWhvbGRlciBmb3IgdGhlIGZpbGUuIERlZmF1bHRzIHRvIHRydWUuICovXG4gICAgc2hvd0dlbmVyaWNQbGFjZWhvbGRlcjogYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIElTdGF0ZSB7XG4gICAgZGVjcnlwdGVkQmxvYj86IEJsb2I7XG59XG5cbkByZXBsYWNlYWJsZUNvbXBvbmVudChcInZpZXdzLm1lc3NhZ2VzLk1GaWxlQm9keVwiKVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTUZpbGVCb2R5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PElQcm9wcywgSVN0YXRlPiB7XG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgc2hvd0dlbmVyaWNQbGFjZWhvbGRlcjogdHJ1ZSxcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBpZnJhbWU6IFJlYWN0LlJlZk9iamVjdDxIVE1MSUZyYW1lRWxlbWVudD4gPSBjcmVhdGVSZWYoKTtcbiAgICBwcml2YXRlIGR1bW15TGluazogUmVhY3QuUmVmT2JqZWN0PEhUTUxBbmNob3JFbGVtZW50PiA9IGNyZWF0ZVJlZigpO1xuICAgIHByaXZhdGUgdXNlckRpZENsaWNrID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBmaWxlRG93bmxvYWRlcjogRmlsZURvd25sb2FkZXIgPSBuZXcgRmlsZURvd25sb2FkZXIoKCkgPT4gdGhpcy5pZnJhbWUuY3VycmVudCk7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IocHJvcHM6IElQcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHt9O1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0Q29udGVudFVybCgpOiBzdHJpbmcgfCBudWxsIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZm9yRXhwb3J0KSByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgbWVkaWEgPSBtZWRpYUZyb21Db250ZW50KHRoaXMucHJvcHMubXhFdmVudC5nZXRDb250ZW50KCkpO1xuICAgICAgICByZXR1cm4gbWVkaWEuc3JjSHR0cDtcbiAgICB9XG4gICAgcHJpdmF0ZSBnZXQgY29udGVudCgpOiBJTWVkaWFFdmVudENvbnRlbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5teEV2ZW50LmdldENvbnRlbnQ8SU1lZGlhRXZlbnRDb250ZW50PigpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0IGZpbGVOYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuYm9keSAmJiB0aGlzLmNvbnRlbnQuYm9keS5sZW5ndGggPiAwID8gdGhpcy5jb250ZW50LmJvZHkgOiBfdChcIkF0dGFjaG1lbnRcIik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXQgbGlua1RleHQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHByZXNlbnRhYmxlVGV4dEZvckZpbGUodGhpcy5jb250ZW50KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGRvd25sb2FkRmlsZShmaWxlTmFtZTogc3RyaW5nLCB0ZXh0OiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5maWxlRG93bmxvYWRlci5kb3dubG9hZCh7XG4gICAgICAgICAgICBibG9iOiB0aGlzLnN0YXRlLmRlY3J5cHRlZEJsb2IsXG4gICAgICAgICAgICBuYW1lOiBmaWxlTmFtZSxcbiAgICAgICAgICAgIGF1dG9Eb3dubG9hZDogdGhpcy51c2VyRGlkQ2xpY2ssXG4gICAgICAgICAgICBvcHRzOiB7XG4gICAgICAgICAgICAgICAgaW1nU3JjOiBET1dOTE9BRF9JQ09OX1VSTCxcbiAgICAgICAgICAgICAgICBpbWdTdHlsZTogbnVsbCxcbiAgICAgICAgICAgICAgICBzdHlsZTogY29tcHV0ZWRTdHlsZSh0aGlzLmR1bW15TGluay5jdXJyZW50KSxcbiAgICAgICAgICAgICAgICB0ZXh0Q29udGVudDogX3QoXCJEb3dubG9hZCAlKHRleHQpc1wiLCB7IHRleHQgfSksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uSGVpZ2h0Q2hhbmdlZCAmJiAhcHJldlN0YXRlLmRlY3J5cHRlZEJsb2IgJiYgdGhpcy5zdGF0ZS5kZWNyeXB0ZWRCbG9iKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uSGVpZ2h0Q2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkZWNyeXB0RmlsZSA9IGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZGVjcnlwdGVkQmxvYikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnVzZXJEaWRDbGljayA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBkZWNyeXB0ZWRCbG9iOiBhd2FpdCB0aGlzLnByb3BzLm1lZGlhRXZlbnRIZWxwZXIuc291cmNlQmxvYi52YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiVW5hYmxlIHRvIGRlY3J5cHQgYXR0YWNobWVudDogXCIsIGVycik7XG4gICAgICAgICAgICBNb2RhbC5jcmVhdGVUcmFja2VkRGlhbG9nKCdFcnJvciBkZWNyeXB0aW5nIGF0dGFjaG1lbnQnLCAnJywgRXJyb3JEaWFsb2csIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogX3QoXCJFcnJvclwiKSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogX3QoXCJFcnJvciBkZWNyeXB0aW5nIGF0dGFjaG1lbnRcIiksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcml2YXRlIG9uUGxhY2Vob2xkZXJDbGljayA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbWVkaWFIZWxwZXIgPSB0aGlzLnByb3BzLm1lZGlhRXZlbnRIZWxwZXI7XG4gICAgICAgIGlmIChtZWRpYUhlbHBlcj8ubWVkaWEuaXNFbmNyeXB0ZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZGVjcnlwdEZpbGUoKTtcbiAgICAgICAgICAgIHRoaXMuZG93bmxvYWRGaWxlKHRoaXMuZmlsZU5hbWUsIHRoaXMubGlua1RleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQXMgYSBidXR0b24gd2UncmUgbWlzc2luZyB0aGUgYGRvd25sb2FkYCBhdHRyaWJ1dGUgZm9yIHN0eWxpbmcgcmVhc29ucywgc29cbiAgICAgICAgICAgIC8vIGRvd25sb2FkIHdpdGggdGhlIGZpbGUgZG93bmxvYWRlci5cbiAgICAgICAgICAgIHRoaXMuZmlsZURvd25sb2FkZXIuZG93bmxvYWQoe1xuICAgICAgICAgICAgICAgIGJsb2I6IGF3YWl0IG1lZGlhSGVscGVyLnNvdXJjZUJsb2IudmFsdWUsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHB1YmxpYyByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IGlzRW5jcnlwdGVkID0gdGhpcy5wcm9wcy5tZWRpYUV2ZW50SGVscGVyPy5tZWRpYS5pc0VuY3J5cHRlZDtcbiAgICAgICAgY29uc3QgY29udGVudFVybCA9IHRoaXMuZ2V0Q29udGVudFVybCgpO1xuICAgICAgICBjb25zdCBmaWxlU2l6ZSA9IHRoaXMuY29udGVudC5pbmZvID8gdGhpcy5jb250ZW50LmluZm8uc2l6ZSA6IG51bGw7XG4gICAgICAgIGNvbnN0IGZpbGVUeXBlID0gdGhpcy5jb250ZW50LmluZm8gPyB0aGlzLmNvbnRlbnQuaW5mby5taW1ldHlwZSA6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCI7XG5cbiAgICAgICAgbGV0IHBsYWNlaG9sZGVyOiBSZWFjdC5SZWFjdE5vZGUgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5zaG93R2VuZXJpY1BsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICBwbGFjZWhvbGRlciA9IChcbiAgICAgICAgICAgICAgICA8QWNjZXNzaWJsZUJ1dHRvbiBjbGFzc05hbWU9XCJteF9NZWRpYUJvZHkgbXhfTUZpbGVCb2R5X2luZm9cIiBvbkNsaWNrPXt0aGlzLm9uUGxhY2Vob2xkZXJDbGlja30+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cIm14X01GaWxlQm9keV9pbmZvX2ljb25cIiAvPlxuICAgICAgICAgICAgICAgICAgICA8VGV4dFdpdGhUb29sdGlwIHRvb2x0aXA9e3ByZXNlbnRhYmxlVGV4dEZvckZpbGUodGhpcy5jb250ZW50LCBfdChcIkF0dGFjaG1lbnRcIiksIHRydWUpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cIm14X01GaWxlQm9keV9pbmZvX2ZpbGVuYW1lXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBwcmVzZW50YWJsZVRleHRGb3JGaWxlKHRoaXMuY29udGVudCwgX3QoXCJBdHRhY2htZW50XCIpLCB0cnVlLCB0cnVlKSB9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvVGV4dFdpdGhUb29sdGlwPlxuICAgICAgICAgICAgICAgIDwvQWNjZXNzaWJsZUJ1dHRvbj5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5mb3JFeHBvcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLnByb3BzLm14RXZlbnQuZ2V0Q29udGVudCgpO1xuICAgICAgICAgICAgLy8gRHVyaW5nIGV4cG9ydCwgdGhlIGNvbnRlbnQgdXJsIHdpbGwgcG9pbnQgdG8gdGhlIE1TQywgd2hpY2ggd2lsbCBsYXRlciBwb2ludCB0byBhIGxvY2FsIHVybFxuICAgICAgICAgICAgcmV0dXJuIDxzcGFuIGNsYXNzTmFtZT1cIm14X01GaWxlQm9keVwiPlxuICAgICAgICAgICAgICAgIDxhIGhyZWY9e2NvbnRlbnQuZmlsZT8udXJsIHx8IGNvbnRlbnQudXJsfT5cbiAgICAgICAgICAgICAgICAgICAgeyBwbGFjZWhvbGRlciB9XG4gICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgPC9zcGFuPjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNob3dEb3dubG9hZExpbmsgPSB0aGlzLnByb3BzLnRpbGVTaGFwZSB8fCAhdGhpcy5wcm9wcy5zaG93R2VuZXJpY1BsYWNlaG9sZGVyO1xuXG4gICAgICAgIGlmIChpc0VuY3J5cHRlZCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmRlY3J5cHRlZEJsb2IpIHtcbiAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIGRlY3J5cHQgdGhlIGF0dGFjaG1lbnRcbiAgICAgICAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgdXNlciB0byBjbGljayBvbiB0aGUgbGluayBiZWZvcmUgZG93bmxvYWRpbmdcbiAgICAgICAgICAgICAgICAvLyBhbmQgZGVjcnlwdGluZyB0aGUgYXR0YWNobWVudC5cblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYnV0dG9uIHNob3VsZCBhY3R1YWxseSBEb3dubG9hZCBiZWNhdXNlIHVzZXJjb250ZW50LyB3aWxsIHRyeSB0byBjbGljayBpdHNlbGZcbiAgICAgICAgICAgICAgICAvLyBidXQgaXQgaXMgbm90IGd1YXJhbnRlZWQgYmV0d2VlbiB2YXJpb3VzIGJyb3dzZXJzJyBzZXR0aW5ncy5cbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJteF9NRmlsZUJvZHlcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsgcGxhY2Vob2xkZXIgfVxuICAgICAgICAgICAgICAgICAgICAgICAgeyBzaG93RG93bmxvYWRMaW5rICYmIDxkaXYgY2xhc3NOYW1lPVwibXhfTUZpbGVCb2R5X2Rvd25sb2FkXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEFjY2Vzc2libGVCdXR0b24gb25DbGljaz17dGhpcy5kZWNyeXB0RmlsZX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgX3QoXCJEZWNyeXB0ICUodGV4dClzXCIsIHsgdGV4dDogdGhpcy5saW5rVGV4dCB9KSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9BY2Nlc3NpYmxlQnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+IH1cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHVybCA9IFwidXNlcmNvbnRlbnQvXCI7IC8vIFhYWDogdGhpcyBwYXRoIHNob3VsZCBwcm9iYWJseSBiZSBwYXNzZWQgZnJvbSB0aGUgc2tpblxuXG4gICAgICAgICAgICAvLyBJZiB0aGUgYXR0YWNobWVudCBpcyBlbmNyeXB0ZWQgdGhlbiBwdXQgdGhlIGxpbmsgaW5zaWRlIGFuIGlmcmFtZS5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwibXhfTUZpbGVCb2R5XCI+XG4gICAgICAgICAgICAgICAgICAgIHsgcGxhY2Vob2xkZXIgfVxuICAgICAgICAgICAgICAgICAgICB7IHNob3dEb3dubG9hZExpbmsgJiYgPGRpdiBjbGFzc05hbWU9XCJteF9NRmlsZUJvZHlfZG93bmxvYWRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogXCJub25lXCIgfX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBBZGQgZHVtbXkgY29weSBvZiB0aGUgXCJhXCIgdGFnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFdlJ2xsIHVzZSBpdCB0byBsZWFybiBob3cgdGhlIGRvd25sb2FkIGxpbmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogd291bGQgaGF2ZSBiZWVuIHN0eWxlZCBpZiBpdCB3YXMgcmVuZGVyZWQgaW5saW5lLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi8gfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIHJlZj17dGhpcy5kdW1teUxpbmt9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUT0RPOiBNb3ZlIGlmcmFtZSAoYW5kIGR1bW15IGxpbmspIGludG8gRmlsZURvd25sb2FkZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgV2UgY3VycmVudGx5IGhhdmUgaXQgc2V0IHVwIHRoaXMgd2F5IGJlY2F1c2Ugb2Ygc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGlmcmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0c2VsZiB3aGljaCBjYW5ub3QgYmUgZWFzaWx5IGhhbmRsZWQvb3ZlcnJpZGRlbiBieSB0aGUgRmlsZURvd25sb2FkZXIuIEluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnV0dXJlLCB0aGUgZG93bmxvYWQgbGluayBtYXkgZGlzYXBwZWFyIGVudGlyZWx5IGF0IHdoaWNoIHBvaW50IGl0IGNvdWxkIGFsc29cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSBzdWl0YWJsZSB0byBqdXN0IHJlbW92ZSB0aGlzIGJpdCBvZiBjb2RlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICovIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpZnJhbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmM9e3VybH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkxvYWQ9eygpID0+IHRoaXMuZG93bmxvYWRGaWxlKHRoaXMuZmlsZU5hbWUsIHRoaXMubGlua1RleHQpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZj17dGhpcy5pZnJhbWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2FuZGJveD1cImFsbG93LXNjcmlwdHMgYWxsb3ctZG93bmxvYWRzIGFsbG93LWRvd25sb2Fkcy13aXRob3V0LXVzZXItYWN0aXZhdGlvblwiIC8+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PiB9XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZW50VXJsKSB7XG4gICAgICAgICAgICBjb25zdCBkb3dubG9hZFByb3BzID0ge1xuICAgICAgICAgICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgICAgICAgICByZWw6IFwibm9yZWZlcnJlciBub29wZW5lclwiLFxuXG4gICAgICAgICAgICAgICAgLy8gV2Ugc2V0IHRoZSBocmVmIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBvciBub3Qgd2UgaW50ZXJjZXB0IHRoZSBkb3dubG9hZFxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2UgZG9uJ3QgcmVhbGx5IHdhbnQgdG8gY29udmVydCB0aGUgZmlsZSB0byBhIGJsb2IgZWFnZXJseSwgYW5kXG4gICAgICAgICAgICAgICAgLy8gc3RpbGwgd2FudCBcIm9wZW4gaW4gbmV3IHRhYlwiIGFuZCBcInNhdmUgbGluayBhc1wiIHRvIHdvcmsuXG4gICAgICAgICAgICAgICAgaHJlZjogY29udGVudFVybCxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIEJsb2JzIGNhbiBvbmx5IGhhdmUgdXAgdG8gNTAwbWIsIHNvIGlmIHRoZSBmaWxlIHJlcG9ydHMgYXMgYmVpbmcgdG9vIGxhcmdlIHRoZW5cbiAgICAgICAgICAgIC8vIHdlIHdvbid0IHRyeSBhbmQgY29udmVydCBpdC4gTGlrZXdpc2UsIGlmIHRoZSBmaWxlIHNpemUgaXMgdW5rbm93biB0aGVuIHdlJ2xsIGFzc3VtZVxuICAgICAgICAgICAgLy8gaXQgaXMgdG9vIGJpZy4gVGhlcmUgaXMgdGhlIHJpc2sgb2YgdGhlIHJlcG9ydGVkIGZpbGUgc2l6ZSBhbmQgdGhlIGFjdHVhbCBmaWxlIHNpemVcbiAgICAgICAgICAgIC8vIGJlaW5nIGRpZmZlcmVudCwgaG93ZXZlciB0aGUgdXNlciBzaG91bGRuJ3Qgbm9ybWFsbHkgcnVuIGludG8gdGhpcyBwcm9ibGVtLlxuICAgICAgICAgICAgY29uc3QgZmlsZVRvb0JpZyA9IHR5cGVvZihmaWxlU2l6ZSkgPT09ICdudW1iZXInID8gZmlsZVNpemUgPiA1MjQyODgwMDAgOiB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoW1wiYXBwbGljYXRpb24vcGRmXCJdLmluY2x1ZGVzKGZpbGVUeXBlKSAmJiAhZmlsZVRvb0JpZykge1xuICAgICAgICAgICAgICAgIC8vIFdlIHdhbnQgdG8gZm9yY2UgYSBkb3dubG9hZCBvbiB0aGlzIHR5cGUsIHNvIHVzZSBhbiBvbkNsaWNrIGhhbmRsZXIuXG4gICAgICAgICAgICAgICAgZG93bmxvYWRQcm9wc1tcIm9uQ2xpY2tcIl0gPSAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBEb3dubG9hZGluZyAke2ZpbGVUeXBlfSBhcyBibG9iICh1bmVuY3J5cHRlZClgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBsZXR0aW5nIHRoZSA8YT4gZG8gaXRzIHRoaW5nXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCBhIGZldGNoIGZvciB0aGUgZG93bmxvYWRcbiAgICAgICAgICAgICAgICAgICAgLy8gQmFzZWQgdXBvbiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDk1MDA0NjVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5tZWRpYUV2ZW50SGVscGVyLnNvdXJjZUJsb2IudmFsdWUudGhlbigoYmxvYikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvYlVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gY3JlYXRlIGFuIGFuY2hvciB0byBkb3dubG9hZCB0aGUgZmlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVtcEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBBbmNob3IuZG93bmxvYWQgPSB0aGlzLmZpbGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcEFuY2hvci5ocmVmID0gYmxvYlVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGVtcEFuY2hvcik7IC8vIGZvciBmaXJlZm94OiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzIyMjYwNjhcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBBbmNob3IuY2xpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBBbmNob3IucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEVsc2Ugd2UgYXJlIGhvcGluZyB0aGUgYnJvd3NlciB3aWxsIGRvIHRoZSByaWdodCB0aGluZ1xuICAgICAgICAgICAgICAgIGRvd25sb2FkUHJvcHNbXCJkb3dubG9hZFwiXSA9IHRoaXMuZmlsZU5hbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwibXhfTUZpbGVCb2R5XCI+XG4gICAgICAgICAgICAgICAgICAgIHsgcGxhY2Vob2xkZXIgfVxuICAgICAgICAgICAgICAgICAgICB7IHNob3dEb3dubG9hZExpbmsgJiYgPGRpdiBjbGFzc05hbWU9XCJteF9NRmlsZUJvZHlfZG93bmxvYWRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIHsuLi5kb3dubG9hZFByb3BzfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJteF9NRmlsZUJvZHlfZG93bmxvYWRfaWNvblwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBfdChcIkRvd25sb2FkICUodGV4dClzXCIsIHsgdGV4dDogdGhpcy5saW5rVGV4dCB9KSB9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgICAgICAgICB7IHRoaXMucHJvcHMudGlsZVNoYXBlID09PSBUaWxlU2hhcGUuRmlsZUdyaWQgJiYgPGRpdiBjbGFzc05hbWU9XCJteF9NSW1hZ2VCb2R5X3NpemVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHRoaXMuY29udGVudC5pbmZvICYmIHRoaXMuY29udGVudC5pbmZvLnNpemUgPyBmaWxlc2l6ZSh0aGlzLmNvbnRlbnQuaW5mby5zaXplKSA6IFwiXCIgfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+IH1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+IH1cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXh0cmEgPSB0aGlzLmxpbmtUZXh0ID8gKCc6ICcgKyB0aGlzLmxpbmtUZXh0KSA6ICcnO1xuICAgICAgICAgICAgcmV0dXJuIDxzcGFuIGNsYXNzTmFtZT1cIm14X01GaWxlQm9keVwiPlxuICAgICAgICAgICAgICAgIHsgcGxhY2Vob2xkZXIgfVxuICAgICAgICAgICAgICAgIHsgX3QoXCJJbnZhbGlkIGZpbGUlKGV4dHJhKXNcIiwgeyBleHRyYTogZXh0cmEgfSkgfVxuICAgICAgICAgICAgPC9zcGFuPjtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==