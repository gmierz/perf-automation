"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _MatrixClientPeg = require("../../../MatrixClientPeg");

var _dec, _class;

let ViewSourceEvent = (_dec = (0, _replaceableComponent.replaceableComponent)("views.messages.ViewSourceEvent"), _dec(_class = class ViewSourceEvent extends _react.default.PureComponent {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "onToggle", ev => {
      ev.preventDefault();
      const {
        expanded
      } = this.state;
      this.setState({
        expanded: !expanded
      });
    });
    this.state = {
      expanded: false
    };
  }

  componentDidMount() {
    const {
      mxEvent
    } = this.props;

    const client = _MatrixClientPeg.MatrixClientPeg.get();

    client.decryptEventIfNeeded(mxEvent);

    if (mxEvent.isBeingDecrypted()) {
      mxEvent.once("Event.decrypted", () => this.forceUpdate());
    }
  }

  render() {
    const {
      mxEvent
    } = this.props;
    const {
      expanded
    } = this.state;
    let content;

    if (expanded) {
      content = /*#__PURE__*/_react.default.createElement("pre", null, JSON.stringify(mxEvent, null, 4));
    } else {
      content = /*#__PURE__*/_react.default.createElement("code", null, `{ "type": ${mxEvent.getType()} }`);
    }

    const classes = (0, _classnames.default)("mx_ViewSourceEvent mx_EventTile_content", {
      mx_ViewSourceEvent_expanded: expanded
    });
    return /*#__PURE__*/_react.default.createElement("span", {
      className: classes
    }, content, /*#__PURE__*/_react.default.createElement("a", {
      className: "mx_ViewSourceEvent_toggle",
      href: "#",
      onClick: this.onToggle
    }));
  }

}) || _class);
exports.default = ViewSourceEvent;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL21lc3NhZ2VzL1ZpZXdTb3VyY2VFdmVudC50c3giXSwibmFtZXMiOlsiVmlld1NvdXJjZUV2ZW50IiwiUmVhY3QiLCJQdXJlQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJwcm9wcyIsImV2IiwicHJldmVudERlZmF1bHQiLCJleHBhbmRlZCIsInN0YXRlIiwic2V0U3RhdGUiLCJjb21wb25lbnREaWRNb3VudCIsIm14RXZlbnQiLCJjbGllbnQiLCJNYXRyaXhDbGllbnRQZWciLCJnZXQiLCJkZWNyeXB0RXZlbnRJZk5lZWRlZCIsImlzQmVpbmdEZWNyeXB0ZWQiLCJvbmNlIiwiZm9yY2VVcGRhdGUiLCJyZW5kZXIiLCJjb250ZW50IiwiSlNPTiIsInN0cmluZ2lmeSIsImdldFR5cGUiLCJjbGFzc2VzIiwibXhfVmlld1NvdXJjZUV2ZW50X2V4cGFuZGVkIiwib25Ub2dnbGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBZ0JBOztBQUVBOztBQUNBOztBQUNBOzs7O0lBV3FCQSxlLFdBRHBCLGdEQUFxQixnQ0FBckIsQyxnQkFBRCxNQUNxQkEsZUFEckIsU0FDNkNDLGVBQU1DLGFBRG5ELENBQ2lGO0FBQzdFQyxFQUFBQSxXQUFXLENBQUNDLEtBQUQsRUFBUTtBQUNmLFVBQU1BLEtBQU47QUFEZSxvREFtQkNDLEVBQUQsSUFBMEI7QUFDekNBLE1BQUFBLEVBQUUsQ0FBQ0MsY0FBSDtBQUNBLFlBQU07QUFBRUMsUUFBQUE7QUFBRixVQUFlLEtBQUtDLEtBQTFCO0FBQ0EsV0FBS0MsUUFBTCxDQUFjO0FBQ1ZGLFFBQUFBLFFBQVEsRUFBRSxDQUFDQTtBQURELE9BQWQ7QUFHSCxLQXpCa0I7QUFHZixTQUFLQyxLQUFMLEdBQWE7QUFDVEQsTUFBQUEsUUFBUSxFQUFFO0FBREQsS0FBYjtBQUdIOztBQUVNRyxFQUFBQSxpQkFBaUIsR0FBUztBQUM3QixVQUFNO0FBQUVDLE1BQUFBO0FBQUYsUUFBYyxLQUFLUCxLQUF6Qjs7QUFFQSxVQUFNUSxNQUFNLEdBQUdDLGlDQUFnQkMsR0FBaEIsRUFBZjs7QUFDQUYsSUFBQUEsTUFBTSxDQUFDRyxvQkFBUCxDQUE0QkosT0FBNUI7O0FBRUEsUUFBSUEsT0FBTyxDQUFDSyxnQkFBUixFQUFKLEVBQWdDO0FBQzVCTCxNQUFBQSxPQUFPLENBQUNNLElBQVIsQ0FBYSxpQkFBYixFQUFnQyxNQUFNLEtBQUtDLFdBQUwsRUFBdEM7QUFDSDtBQUNKOztBQVVNQyxFQUFBQSxNQUFNLEdBQW9CO0FBQzdCLFVBQU07QUFBRVIsTUFBQUE7QUFBRixRQUFjLEtBQUtQLEtBQXpCO0FBQ0EsVUFBTTtBQUFFRyxNQUFBQTtBQUFGLFFBQWUsS0FBS0MsS0FBMUI7QUFFQSxRQUFJWSxPQUFKOztBQUNBLFFBQUliLFFBQUosRUFBYztBQUNWYSxNQUFBQSxPQUFPLGdCQUFHLDBDQUFPQyxJQUFJLENBQUNDLFNBQUwsQ0FBZVgsT0FBZixFQUF3QixJQUF4QixFQUE4QixDQUE5QixDQUFQLENBQVY7QUFDSCxLQUZELE1BRU87QUFDSFMsTUFBQUEsT0FBTyxnQkFBRywyQ0FBUyxhQUFZVCxPQUFPLENBQUNZLE9BQVIsRUFBa0IsSUFBdkMsQ0FBVjtBQUNIOztBQUVELFVBQU1DLE9BQU8sR0FBRyx5QkFBVyx5Q0FBWCxFQUFzRDtBQUNsRUMsTUFBQUEsMkJBQTJCLEVBQUVsQjtBQURxQyxLQUF0RCxDQUFoQjtBQUlBLHdCQUFPO0FBQU0sTUFBQSxTQUFTLEVBQUVpQjtBQUFqQixPQUNESixPQURDLGVBRUg7QUFDSSxNQUFBLFNBQVMsRUFBQywyQkFEZDtBQUVJLE1BQUEsSUFBSSxFQUFDLEdBRlQ7QUFHSSxNQUFBLE9BQU8sRUFBRSxLQUFLTTtBQUhsQixNQUZHLENBQVA7QUFRSDs7QUFuRDRFLEMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMTkgVGhlIE1hdHJpeC5vcmcgRm91bmRhdGlvbiBDLkkuQy5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgTWF0cml4RXZlbnQgfSBmcm9tICdtYXRyaXgtanMtc2RrL3NyYyc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IHJlcGxhY2VhYmxlQ29tcG9uZW50IH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL3JlcGxhY2VhYmxlQ29tcG9uZW50XCI7XG5pbXBvcnQgeyBNYXRyaXhDbGllbnRQZWcgfSBmcm9tIFwiLi4vLi4vLi4vTWF0cml4Q2xpZW50UGVnXCI7XG5cbmludGVyZmFjZSBJUHJvcHMge1xuICAgIG14RXZlbnQ6IE1hdHJpeEV2ZW50O1xufVxuXG5pbnRlcmZhY2UgSVN0YXRlIHtcbiAgICBleHBhbmRlZDogYm9vbGVhbjtcbn1cblxuQHJlcGxhY2VhYmxlQ29tcG9uZW50KFwidmlld3MubWVzc2FnZXMuVmlld1NvdXJjZUV2ZW50XCIpXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaWV3U291cmNlRXZlbnQgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PElQcm9wcywgSVN0YXRlPiB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBleHBhbmRlZDogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHVibGljIGNvbXBvbmVudERpZE1vdW50KCk6IHZvaWQge1xuICAgICAgICBjb25zdCB7IG14RXZlbnQgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgY29uc3QgY2xpZW50ID0gTWF0cml4Q2xpZW50UGVnLmdldCgpO1xuICAgICAgICBjbGllbnQuZGVjcnlwdEV2ZW50SWZOZWVkZWQobXhFdmVudCk7XG5cbiAgICAgICAgaWYgKG14RXZlbnQuaXNCZWluZ0RlY3J5cHRlZCgpKSB7XG4gICAgICAgICAgICBteEV2ZW50Lm9uY2UoXCJFdmVudC5kZWNyeXB0ZWRcIiwgKCkgPT4gdGhpcy5mb3JjZVVwZGF0ZSgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgb25Ub2dnbGUgPSAoZXY6IFJlYWN0Lk1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29uc3QgeyBleHBhbmRlZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBleHBhbmRlZDogIWV4cGFuZGVkLFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcHVibGljIHJlbmRlcigpOiBSZWFjdC5SZWFjdE5vZGUge1xuICAgICAgICBjb25zdCB7IG14RXZlbnQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgZXhwYW5kZWQgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgbGV0IGNvbnRlbnQ7XG4gICAgICAgIGlmIChleHBhbmRlZCkge1xuICAgICAgICAgICAgY29udGVudCA9IDxwcmU+eyBKU09OLnN0cmluZ2lmeShteEV2ZW50LCBudWxsLCA0KSB9PC9wcmU+O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudCA9IDxjb2RlPnsgYHsgXCJ0eXBlXCI6ICR7bXhFdmVudC5nZXRUeXBlKCl9IH1gIH08L2NvZGU+O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2xhc3NlcyA9IGNsYXNzTmFtZXMoXCJteF9WaWV3U291cmNlRXZlbnQgbXhfRXZlbnRUaWxlX2NvbnRlbnRcIiwge1xuICAgICAgICAgICAgbXhfVmlld1NvdXJjZUV2ZW50X2V4cGFuZGVkOiBleHBhbmRlZCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIDxzcGFuIGNsYXNzTmFtZT17Y2xhc3Nlc30+XG4gICAgICAgICAgICB7IGNvbnRlbnQgfVxuICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJteF9WaWV3U291cmNlRXZlbnRfdG9nZ2xlXCJcbiAgICAgICAgICAgICAgICBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5vblRvZ2dsZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvc3Bhbj47XG4gICAgfVxufVxuIl19