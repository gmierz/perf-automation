"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.EMOJI_HEIGHT = exports.EMOJIS_PER_ROW = exports.CATEGORY_HEADER_HEIGHT = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _languageHandler = require("../../../languageHandler");

var recent = _interopRequireWildcard(require("../../../emojipicker/recent"));

var _emoji = require("../../../emoji");

var _AutoHideScrollbar = _interopRequireDefault(require("../../structures/AutoHideScrollbar"));

var _Header = _interopRequireDefault(require("./Header"));

var _Search = _interopRequireDefault(require("./Search"));

var _Preview = _interopRequireDefault(require("./Preview"));

var _QuickReactions = _interopRequireDefault(require("./QuickReactions"));

var _Category = _interopRequireDefault(require("./Category"));

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _dec, _class;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const CATEGORY_HEADER_HEIGHT = 20;
exports.CATEGORY_HEADER_HEIGHT = CATEGORY_HEADER_HEIGHT;
const EMOJI_HEIGHT = 35;
exports.EMOJI_HEIGHT = EMOJI_HEIGHT;
const EMOJIS_PER_ROW = 8;
exports.EMOJIS_PER_ROW = EMOJIS_PER_ROW;
const ZERO_WIDTH_JOINER = "\u200D";
let EmojiPicker = (_dec = (0, _replaceableComponent.replaceableComponent)("views.emojipicker.EmojiPicker"), _dec(_class = class EmojiPicker extends _react.default.Component {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "recentlyUsed", void 0);
    (0, _defineProperty2.default)(this, "memoizedDataByCategory", void 0);
    (0, _defineProperty2.default)(this, "categories", void 0);
    (0, _defineProperty2.default)(this, "bodyRef", /*#__PURE__*/_react.default.createRef());
    (0, _defineProperty2.default)(this, "onScroll", () => {
      const body = this.bodyRef.current;
      this.setState({
        scrollTop: body.scrollTop,
        viewportHeight: body.clientHeight
      });
      this.updateVisibility();
    });
    (0, _defineProperty2.default)(this, "updateVisibility", () => {
      const body = this.bodyRef.current;
      const rect = body.getBoundingClientRect();

      for (const cat of this.categories) {
        const elem = body.querySelector(`[data-category-id="${cat.id}"]`);

        if (!elem) {
          cat.visible = false;
          cat.ref.current.classList.remove("mx_EmojiPicker_anchor_visible");
          continue;
        }

        const elemRect = elem.getBoundingClientRect();
        const y = elemRect.y - rect.y;
        const yEnd = elemRect.y + elemRect.height - rect.y;
        cat.visible = y < rect.height && yEnd > 0; // We update this here instead of through React to avoid re-render on scroll.

        if (cat.visible) {
          cat.ref.current.classList.add("mx_EmojiPicker_anchor_visible");
          cat.ref.current.setAttribute("aria-selected", "true");
          cat.ref.current.setAttribute("tabindex", "0");
        } else {
          cat.ref.current.classList.remove("mx_EmojiPicker_anchor_visible");
          cat.ref.current.setAttribute("aria-selected", "false");
          cat.ref.current.setAttribute("tabindex", "-1");
        }
      }
    });
    (0, _defineProperty2.default)(this, "scrollToCategory", category => {
      this.bodyRef.current.querySelector(`[data-category-id="${category}"]`).scrollIntoView();
    });
    (0, _defineProperty2.default)(this, "onChangeFilter", filter => {
      const lcFilter = filter.toLowerCase().trim(); // filter is case insensitive

      for (const cat of this.categories) {
        let emojis; // If the new filter string includes the old filter string, we don't have to re-filter the whole dataset.

        if (lcFilter.includes(this.state.filter)) {
          emojis = this.memoizedDataByCategory[cat.id];
        } else {
          emojis = cat.id === "recent" ? this.recentlyUsed : _emoji.DATA_BY_CATEGORY[cat.id];
        }

        emojis = emojis.filter(emoji => this.emojiMatchesFilter(emoji, lcFilter));
        this.memoizedDataByCategory[cat.id] = emojis;
        cat.enabled = emojis.length > 0; // The setState below doesn't re-render the header and we already have the refs for updateVisibility, so...

        cat.ref.current.disabled = !cat.enabled;
      }

      this.setState({
        filter
      }); // Header underlines need to be updated, but updating requires knowing
      // where the categories are, so we wait for a tick.

      setTimeout(this.updateVisibility, 0);
    });
    (0, _defineProperty2.default)(this, "emojiMatchesFilter", (emoji, filter) => {
      var _emoji$emoticon;

      return emoji.annotation.toLowerCase().includes(filter) || ((_emoji$emoticon = emoji.emoticon) === null || _emoji$emoticon === void 0 ? void 0 : _emoji$emoticon.toLowerCase().includes(filter)) || emoji.shortcodes.some(x => x.toLowerCase().includes(filter)) || emoji.unicode.split(ZERO_WIDTH_JOINER).includes(filter);
    });
    (0, _defineProperty2.default)(this, "onEnterFilter", () => {
      const btn = this.bodyRef.current.querySelector(".mx_EmojiPicker_item");

      if (btn) {
        btn.click();
      }
    });
    (0, _defineProperty2.default)(this, "onHoverEmoji", emoji => {
      this.setState({
        previewEmoji: emoji
      });
    });
    (0, _defineProperty2.default)(this, "onHoverEmojiEnd", emoji => {
      this.setState({
        previewEmoji: null
      });
    });
    (0, _defineProperty2.default)(this, "onClickEmoji", emoji => {
      if (this.props.onChoose(emoji.unicode) !== false) {
        recent.add(emoji.unicode);
      }
    });
    this.state = {
      filter: "",
      previewEmoji: null,
      scrollTop: 0,
      viewportHeight: 280
    }; // Convert recent emoji characters to emoji data, removing unknowns and duplicates

    this.recentlyUsed = Array.from(new Set(recent.get().map(_emoji.getEmojiFromUnicode).filter(Boolean)));
    this.memoizedDataByCategory = _objectSpread({
      recent: this.recentlyUsed
    }, _emoji.DATA_BY_CATEGORY);
    this.categories = [{
      id: "recent",
      name: (0, _languageHandler._t)("Frequently Used"),
      enabled: this.recentlyUsed.length > 0,
      visible: this.recentlyUsed.length > 0,
      ref: /*#__PURE__*/_react.default.createRef()
    }, {
      id: "people",
      name: (0, _languageHandler._t)("Smileys & People"),
      enabled: true,
      visible: true,
      ref: /*#__PURE__*/_react.default.createRef()
    }, {
      id: "nature",
      name: (0, _languageHandler._t)("Animals & Nature"),
      enabled: true,
      visible: false,
      ref: /*#__PURE__*/_react.default.createRef()
    }, {
      id: "foods",
      name: (0, _languageHandler._t)("Food & Drink"),
      enabled: true,
      visible: false,
      ref: /*#__PURE__*/_react.default.createRef()
    }, {
      id: "activity",
      name: (0, _languageHandler._t)("Activities"),
      enabled: true,
      visible: false,
      ref: /*#__PURE__*/_react.default.createRef()
    }, {
      id: "places",
      name: (0, _languageHandler._t)("Travel & Places"),
      enabled: true,
      visible: false,
      ref: /*#__PURE__*/_react.default.createRef()
    }, {
      id: "objects",
      name: (0, _languageHandler._t)("Objects"),
      enabled: true,
      visible: false,
      ref: /*#__PURE__*/_react.default.createRef()
    }, {
      id: "symbols",
      name: (0, _languageHandler._t)("Symbols"),
      enabled: true,
      visible: false,
      ref: /*#__PURE__*/_react.default.createRef()
    }, {
      id: "flags",
      name: (0, _languageHandler._t)("Flags"),
      enabled: true,
      visible: false,
      ref: /*#__PURE__*/_react.default.createRef()
    }];
  }

  static categoryHeightForEmojiCount(count) {
    if (count === 0) {
      return 0;
    }

    return CATEGORY_HEADER_HEIGHT + Math.ceil(count / EMOJIS_PER_ROW) * EMOJI_HEIGHT;
  }

  render() {
    let heightBefore = 0;
    return /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_EmojiPicker"
    }, /*#__PURE__*/_react.default.createElement(_Header.default, {
      categories: this.categories,
      onAnchorClick: this.scrollToCategory
    }), /*#__PURE__*/_react.default.createElement(_Search.default, {
      query: this.state.filter,
      onChange: this.onChangeFilter,
      onEnter: this.onEnterFilter
    }), /*#__PURE__*/_react.default.createElement(_AutoHideScrollbar.default, {
      className: "mx_EmojiPicker_body",
      wrappedRef: ref => {
        // @ts-ignore - AutoHideScrollbar should accept a RefObject or fall back to its own instead
        this.bodyRef.current = ref;
      },
      onScroll: this.onScroll
    }, this.categories.map(category => {
      const emojis = this.memoizedDataByCategory[category.id];

      const categoryElement = /*#__PURE__*/_react.default.createElement(_Category.default, {
        key: category.id,
        id: category.id,
        name: category.name,
        heightBefore: heightBefore,
        viewportHeight: this.state.viewportHeight,
        scrollTop: this.state.scrollTop,
        emojis: emojis,
        onClick: this.onClickEmoji,
        onMouseEnter: this.onHoverEmoji,
        onMouseLeave: this.onHoverEmojiEnd,
        selectedEmojis: this.props.selectedEmojis
      });

      const height = EmojiPicker.categoryHeightForEmojiCount(emojis.length);
      heightBefore += height;
      return categoryElement;
    })), this.state.previewEmoji || !this.props.showQuickReactions ? /*#__PURE__*/_react.default.createElement(_Preview.default, {
      emoji: this.state.previewEmoji
    }) : /*#__PURE__*/_react.default.createElement(_QuickReactions.default, {
      onClick: this.onClickEmoji,
      selectedEmojis: this.props.selectedEmojis
    }));
  }

}) || _class);
var _default = EmojiPicker;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2Vtb2ppcGlja2VyL0Vtb2ppUGlja2VyLnRzeCJdLCJuYW1lcyI6WyJDQVRFR09SWV9IRUFERVJfSEVJR0hUIiwiRU1PSklfSEVJR0hUIiwiRU1PSklTX1BFUl9ST1ciLCJaRVJPX1dJRFRIX0pPSU5FUiIsIkVtb2ppUGlja2VyIiwiUmVhY3QiLCJDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsInByb3BzIiwiY3JlYXRlUmVmIiwiYm9keSIsImJvZHlSZWYiLCJjdXJyZW50Iiwic2V0U3RhdGUiLCJzY3JvbGxUb3AiLCJ2aWV3cG9ydEhlaWdodCIsImNsaWVudEhlaWdodCIsInVwZGF0ZVZpc2liaWxpdHkiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY2F0IiwiY2F0ZWdvcmllcyIsImVsZW0iLCJxdWVyeVNlbGVjdG9yIiwiaWQiLCJ2aXNpYmxlIiwicmVmIiwiY2xhc3NMaXN0IiwicmVtb3ZlIiwiZWxlbVJlY3QiLCJ5IiwieUVuZCIsImhlaWdodCIsImFkZCIsInNldEF0dHJpYnV0ZSIsImNhdGVnb3J5Iiwic2Nyb2xsSW50b1ZpZXciLCJmaWx0ZXIiLCJsY0ZpbHRlciIsInRvTG93ZXJDYXNlIiwidHJpbSIsImVtb2ppcyIsImluY2x1ZGVzIiwic3RhdGUiLCJtZW1vaXplZERhdGFCeUNhdGVnb3J5IiwicmVjZW50bHlVc2VkIiwiREFUQV9CWV9DQVRFR09SWSIsImVtb2ppIiwiZW1vamlNYXRjaGVzRmlsdGVyIiwiZW5hYmxlZCIsImxlbmd0aCIsImRpc2FibGVkIiwic2V0VGltZW91dCIsImFubm90YXRpb24iLCJlbW90aWNvbiIsInNob3J0Y29kZXMiLCJzb21lIiwieCIsInVuaWNvZGUiLCJzcGxpdCIsImJ0biIsImNsaWNrIiwicHJldmlld0Vtb2ppIiwib25DaG9vc2UiLCJyZWNlbnQiLCJBcnJheSIsImZyb20iLCJTZXQiLCJnZXQiLCJtYXAiLCJnZXRFbW9qaUZyb21Vbmljb2RlIiwiQm9vbGVhbiIsIm5hbWUiLCJjYXRlZ29yeUhlaWdodEZvckVtb2ppQ291bnQiLCJjb3VudCIsIk1hdGgiLCJjZWlsIiwicmVuZGVyIiwiaGVpZ2h0QmVmb3JlIiwic2Nyb2xsVG9DYXRlZ29yeSIsIm9uQ2hhbmdlRmlsdGVyIiwib25FbnRlckZpbHRlciIsIm9uU2Nyb2xsIiwiY2F0ZWdvcnlFbGVtZW50Iiwib25DbGlja0Vtb2ppIiwib25Ib3ZlckVtb2ppIiwib25Ib3ZlckVtb2ppRW5kIiwic2VsZWN0ZWRFbW9qaXMiLCJzaG93UXVpY2tSZWFjdGlvbnMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBaUJBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7QUFFTyxNQUFNQSxzQkFBc0IsR0FBRyxFQUEvQjs7QUFDQSxNQUFNQyxZQUFZLEdBQUcsRUFBckI7O0FBQ0EsTUFBTUMsY0FBYyxHQUFHLENBQXZCOztBQUVQLE1BQU1DLGlCQUFpQixHQUFHLFFBQTFCO0lBbUJNQyxXLFdBREwsZ0RBQXFCLCtCQUFyQixDLGdCQUFELE1BQ01BLFdBRE4sU0FDMEJDLGVBQU1DLFNBRGhDLENBQzBEO0FBT3REQyxFQUFBQSxXQUFXLENBQUNDLEtBQUQsRUFBUTtBQUNmLFVBQU1BLEtBQU47QUFEZTtBQUFBO0FBQUE7QUFBQSxnRUFGREgsZUFBTUksU0FBTixFQUVDO0FBQUEsb0RBMEVBLE1BQU07QUFDckIsWUFBTUMsSUFBSSxHQUFHLEtBQUtDLE9BQUwsQ0FBYUMsT0FBMUI7QUFDQSxXQUFLQyxRQUFMLENBQWM7QUFDVkMsUUFBQUEsU0FBUyxFQUFFSixJQUFJLENBQUNJLFNBRE47QUFFVkMsUUFBQUEsY0FBYyxFQUFFTCxJQUFJLENBQUNNO0FBRlgsT0FBZDtBQUlBLFdBQUtDLGdCQUFMO0FBQ0gsS0FqRmtCO0FBQUEsNERBbUZRLE1BQU07QUFDN0IsWUFBTVAsSUFBSSxHQUFHLEtBQUtDLE9BQUwsQ0FBYUMs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ZUEsWUFBTXZELE1BQU0sR0FBRzVCLFdBQVcsQ0FBQ3FFLDJCQUFaLENBQXdDaEMsTUFBTSxDQUFDUyxNQUEvQyxDQUFmO0FBQ0E0QixNQUFBQSxZQUFZLElBQUk5QyxNQUFoQjtBQUNBLGFBQU9tRCxlQUFQO0FBQ0gsS0FwQkMsQ0FSTixDQUhKLEVBaUNNLEtBQUt4QyxLQUFMLENBQVdtQixZQUFYLElBQTJCLENBQUMsS0FBS3RELEtBQUwsQ0FBV2dGLGtCQUF2QyxnQkFDSSw2QkFBQyxnQkFBRDtBQUFTLE1BQUEsS0FBSyxFQUFFLEtBQUs3QyxLQUFMLENBQVdtQjtBQUEzQixNQURKLGdCQUVJLDZCQUFDLHVCQUFEO0FBQWdCLE1BQUEsT0FBTyxFQUFFLEtBQUtzQixZQUE5QjtBQUE0QyxNQUFBLGNBQWMsRUFBRSxLQUFLNUUsS0FBTCxDQUFXK0U7QUFBdkUsTUFuQ1YsQ0FESjtBQXVDSDs7QUEvTnFELEM7ZUFrTzNDbkYsVyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxOSBUdWxpciBBc29rYW4gPHR1bGlyQG1hdW5pdW0ubmV0PlxuQ29weXJpZ2h0IDIwMjAgVGhlIE1hdHJpeC5vcmcgRm91bmRhdGlvbiBDLkkuQy5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBfdCB9IGZyb20gJy4uLy4uLy4uL2xhbmd1YWdlSGFuZGxlcic7XG5pbXBvcnQgKiBhcyByZWNlbnQgZnJvbSAnLi4vLi4vLi4vZW1vamlwaWNrZXIvcmVjZW50JztcbmltcG9ydCB7IERBVEFfQllfQ0FURUdPUlksIGdldEVtb2ppRnJvbVVuaWNvZGUsIElFbW9qaSB9IGZyb20gXCIuLi8uLi8uLi9lbW9qaVwiO1xuaW1wb3J0IEF1dG9IaWRlU2Nyb2xsYmFyIGZyb20gXCIuLi8uLi9zdHJ1Y3R1cmVzL0F1dG9IaWRlU2Nyb2xsYmFyXCI7XG5pbXBvcnQgSGVhZGVyIGZyb20gXCIuL0hlYWRlclwiO1xuaW1wb3J0IFNlYXJjaCBmcm9tIFwiLi9TZWFyY2hcIjtcbmltcG9ydCBQcmV2aWV3IGZyb20gXCIuL1ByZXZpZXdcIjtcbmltcG9ydCBRdWlja1JlYWN0aW9ucyBmcm9tIFwiLi9RdWlja1JlYWN0aW9uc1wiO1xuaW1wb3J0IENhdGVnb3J5LCB7IElDYXRlZ29yeSwgQ2F0ZWdvcnlLZXkgfSBmcm9tIFwiLi9DYXRlZ29yeVwiO1xuaW1wb3J0IHsgcmVwbGFjZWFibGVDb21wb25lbnQgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvcmVwbGFjZWFibGVDb21wb25lbnRcIjtcblxuZXhwb3J0IGNvbnN0IENBVEVHT1JZX0hFQURFUl9IRUlHSFQgPSAyMDtcbmV4cG9ydCBjb25zdCBFTU9KSV9IRUlHSFQgPSAzNTtcbmV4cG9ydCBjb25zdCBFTU9KSVNfUEVSX1JPVyA9IDg7XG5cbmNvbnN0IFpFUk9fV0lEVEhfSk9JTkVSID0gXCJcXHUyMDBEXCI7XG5cbmludGVyZmFjZSBJUHJvcHMge1xuICAgIHNlbGVjdGVkRW1vamlzPzogU2V0PHN0cmluZz47XG4gICAgc2hvd1F1aWNrUmVhY3Rpb25zPzogYm9vbGVhbjtcbiAgICBvbkNob29zZSh1bmljb2RlOiBzdHJpbmcpOiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgSVN0YXRlIHtcbiAgICBmaWx0ZXI6IHN0cmluZztcbiAgICBwcmV2aWV3RW1vamk/OiBJRW1vamk7XG4gICAgc2Nyb2xsVG9wOiBudW1iZXI7XG4gICAgLy8gaW5pdGlhbCBlc3RpbWF0aW9uIG9mIGhlaWdodCwgZGlhbG9nIGlzIGhhcmRjb2RlZCB0byA0NTBweCBoZWlnaHQuXG4gICAgLy8gc2hvdWxkIGJlIGVub3VnaCB0byBuZXZlciBoYXZlIGJsYW5rIHJvd3Mgb2YgZW1vamlzIGFzXG4gICAgLy8gMyByb3dzIG9mIG92ZXJmbG93IGFyZSBhbHNvIHJlbmRlcmVkLiBUaGUgYWN0dWFsIHZhbHVlIGlzIHVwZGF0ZWQgb24gc2Nyb2xsLlxuICAgIHZpZXdwb3J0SGVpZ2h0OiBudW1iZXI7XG59XG5cbkByZXBsYWNlYWJsZUNvbXBvbmVudChcInZpZXdzLmVtb2ppcGlja2VyLkVtb2ppUGlja2VyXCIpXG5jbGFzcyBFbW9qaVBpY2tlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxJUHJvcHMsIElTdGF0ZT4ge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgcmVjZW50bHlVc2VkOiBJRW1vamlbXTtcbiAgICBwcml2YXRlIHJlYWRvbmx5IG1lbW9pemVkRGF0YUJ5Q2F0ZWdvcnk6IFJlY29yZDxDYXRlZ29yeUtleSwgSUVtb2ppW10+O1xuICAgIHByaXZhdGUgcmVhZG9ubHkgY2F0ZWdvcmllczogSUNhdGVnb3J5W107XG5cbiAgICBwcml2YXRlIGJvZHlSZWYgPSBSZWFjdC5jcmVhdGVSZWY8SFRNTERpdkVsZW1lbnQ+KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGZpbHRlcjogXCJcIixcbiAgICAgICAgICAgIHByZXZpZXdFbW9qaTogbnVsbCxcbiAgICAgICAgICAgIHNjcm9sbFRvcDogMCxcbiAgICAgICAgICAgIHZpZXdwb3J0SGVpZ2h0OiAyODAsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ29udmVydCByZWNlbnQgZW1vamkgY2hhcmFjdGVycyB0byBlbW9qaSBkYXRhLCByZW1vdmluZyB1bmtub3ducyBhbmQgZHVwbGljYXRlc1xuICAgICAgICB0aGlzLnJlY2VudGx5VXNlZCA9IEFycmF5LmZyb20obmV3IFNldChyZWNlbnQuZ2V0KCkubWFwKGdldEVtb2ppRnJvbVVuaWNvZGUpLmZpbHRlcihCb29sZWFuKSkpO1xuICAgICAgICB0aGlzLm1lbW9pemVkRGF0YUJ5Q2F0ZWdvcnkgPSB7XG4gICAgICAgICAgICByZWNlbnQ6IHRoaXMucmVjZW50bHlVc2VkLFxuICAgICAgICAgICAgLi4uREFUQV9CWV9DQVRFR09SWSxcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmNhdGVnb3JpZXMgPSBbe1xuICAgICAgICAgICAgaWQ6IFwicmVjZW50XCIsXG4gICAgICAgICAgICBuYW1lOiBfdChcIkZyZXF1ZW50bHkgVXNlZFwiKSxcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRoaXMucmVjZW50bHlVc2VkLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICB2aXNpYmxlOiB0aGlzLnJlY2VudGx5VXNlZC5sZW5ndGggPiAwLFxuICAgICAgICAgICAgcmVmOiBSZWFjdC5jcmVhdGVSZWYoKSxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgaWQ6IFwicGVvcGxlXCIsXG4gICAgICAgICAgICBuYW1lOiBfdChcIlNtaWxleXMgJiBQZW9wbGVcIiksXG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHJlZjogUmVhY3QuY3JlYXRlUmVmKCksXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGlkOiBcIm5hdHVyZVwiLFxuICAgICAgICAgICAgbmFtZTogX3QoXCJBbmltYWxzICYgTmF0dXJlXCIpLFxuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgcmVmOiBSZWFjdC5jcmVhdGVSZWYoKSxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgaWQ6IFwiZm9vZHNcIixcbiAgICAgICAgICAgIG5hbWU6IF90KFwiRm9vZCAmIERyaW5rXCIpLFxuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgcmVmOiBSZWFjdC5jcmVhdGVSZWYoKSxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgaWQ6IFwiYWN0aXZpdHlcIixcbiAgICAgICAgICAgIG5hbWU6IF90KFwiQWN0aXZpdGllc1wiKSxcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHJlZjogUmVhY3QuY3JlYXRlUmVmKCksXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGlkOiBcInBsYWNlc1wiLFxuICAgICAgICAgICAgbmFtZTogX3QoXCJUcmF2ZWwgJiBQbGFjZXNcIiksXG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICByZWY6IFJlYWN0LmNyZWF0ZVJlZigpLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBpZDogXCJvYmplY3RzXCIsXG4gICAgICAgICAgICBuYW1lOiBfdChcIk9iamVjdHNcIiksXG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICByZWY6IFJlYWN0LmNyZWF0ZVJlZigpLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBpZDogXCJzeW1ib2xzXCIsXG4gICAgICAgICAgICBuYW1lOiBfdChcIlN5bWJvbHNcIiksXG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICByZWY6IFJlYWN0LmNyZWF0ZVJlZigpLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBpZDogXCJmbGFnc1wiLFxuICAgICAgICAgICAgbmFtZTogX3QoXCJGbGFnc1wiKSxcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHJlZjogUmVhY3QuY3JlYXRlUmVmKCksXG4gICAgICAgIH1dO1xuICAgIH1cblxuICAgIHByaXZhdGUgb25TY3JvbGwgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLmJvZHlSZWYuY3VycmVudDtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBzY3JvbGxUb3A6IGJvZHkuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgdmlld3BvcnRIZWlnaHQ6IGJvZHkuY2xpZW50SGVpZ2h0LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgdXBkYXRlVmlzaWJpbGl0eSA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgYm9keSA9IHRoaXMuYm9keVJlZi5jdXJyZW50O1xuICAgICAgICBjb25zdCByZWN0ID0gYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgZm9yIChjb25zdCBjYXQgb2YgdGhpcy5jYXRlZ29yaWVzKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtID0gYm9keS5xdWVyeVNlbGVjdG9yKGBbZGF0YS1jYXRlZ29yeS1pZD1cIiR7Y2F0LmlkfVwiXWApO1xuICAgICAgICAgICAgaWYgKCFlbGVtKSB7XG4gICAgICAgICAgICAgICAgY2F0LnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjYXQucmVmLmN1cnJlbnQuY2xhc3NMaXN0LnJlbW92ZShcIm14X0Vtb2ppUGlja2VyX2FuY2hvcl92aXNpYmxlXCIpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZWxlbVJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgY29uc3QgeSA9IGVsZW1SZWN0LnkgLSByZWN0Lnk7XG4gICAgICAgICAgICBjb25zdCB5RW5kID0gZWxlbVJlY3QueSArIGVsZW1SZWN0LmhlaWdodCAtIHJlY3QueTtcbiAgICAgICAgICAgIGNhdC52aXNpYmxlID0geSA8IHJlY3QuaGVpZ2h0ICYmIHlFbmQgPiAwO1xuICAgICAgICAgICAgLy8gV2UgdXBkYXRlIHRoaXMgaGVyZSBpbnN0ZWFkIG9mIHRocm91Z2ggUmVhY3QgdG8gYXZvaWQgcmUtcmVuZGVyIG9uIHNjcm9sbC5cbiAgICAgICAgICAgIGlmIChjYXQudmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNhdC5yZWYuY3VycmVudC5jbGFzc0xpc3QuYWRkKFwibXhfRW1vamlQaWNrZXJfYW5jaG9yX3Zpc2libGVcIik7XG4gICAgICAgICAgICAgICAgY2F0LnJlZi5jdXJyZW50LnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgXCJ0cnVlXCIpO1xuICAgICAgICAgICAgICAgIGNhdC5yZWYuY3VycmVudC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIjBcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhdC5yZWYuY3VycmVudC5jbGFzc0xpc3QucmVtb3ZlKFwibXhfRW1vamlQaWNrZXJfYW5jaG9yX3Zpc2libGVcIik7XG4gICAgICAgICAgICAgICAgY2F0LnJlZi5jdXJyZW50LnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgXCJmYWxzZVwiKTtcbiAgICAgICAgICAgICAgICBjYXQucmVmLmN1cnJlbnQuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCItMVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcml2YXRlIHNjcm9sbFRvQ2F0ZWdvcnkgPSAoY2F0ZWdvcnk6IHN0cmluZykgPT4ge1xuICAgICAgICB0aGlzLmJvZHlSZWYuY3VycmVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1jYXRlZ29yeS1pZD1cIiR7Y2F0ZWdvcnl9XCJdYCkuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbkNoYW5nZUZpbHRlciA9IChmaWx0ZXI6IHN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCBsY0ZpbHRlciA9IGZpbHRlci50b0xvd2VyQ2FzZSgpLnRyaW0oKTsgLy8gZmlsdGVyIGlzIGNhc2UgaW5zZW5zaXRpdmVcbiAgICAgICAgZm9yIChjb25zdCBjYXQgb2YgdGhpcy5jYXRlZ29yaWVzKSB7XG4gICAgICAgICAgICBsZXQgZW1vamlzO1xuICAgICAgICAgICAgLy8gSWYgdGhlIG5ldyBmaWx0ZXIgc3RyaW5nIGluY2x1ZGVzIHRoZSBvbGQgZmlsdGVyIHN0cmluZywgd2UgZG9uJ3QgaGF2ZSB0byByZS1maWx0ZXIgdGhlIHdob2xlIGRhdGFzZXQuXG4gICAgICAgICAgICBpZiAobGNGaWx0ZXIuaW5jbHVkZXModGhpcy5zdGF0ZS5maWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgZW1vamlzID0gdGhpcy5tZW1vaXplZERhdGFCeUNhdGVnb3J5W2NhdC5pZF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVtb2ppcyA9IGNhdC5pZCA9PT0gXCJyZWNlbnRcIiA/IHRoaXMucmVjZW50bHlVc2VkIDogREFUQV9CWV9DQVRFR09SWVtjYXQuaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW1vamlzID0gZW1vamlzLmZpbHRlcihlbW9qaSA9PiB0aGlzLmVtb2ppTWF0Y2hlc0ZpbHRlcihlbW9qaSwgbGNGaWx0ZXIpKTtcbiAgICAgICAgICAgIHRoaXMubWVtb2l6ZWREYXRhQnlDYXRlZ29yeVtjYXQuaWRdID0gZW1vamlzO1xuICAgICAgICAgICAgY2F0LmVuYWJsZWQgPSBlbW9qaXMubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIC8vIFRoZSBzZXRTdGF0ZSBiZWxvdyBkb2Vzbid0IHJlLXJlbmRlciB0aGUgaGVhZGVyIGFuZCB3ZSBhbHJlYWR5IGhhdmUgdGhlIHJlZnMgZm9yIHVwZGF0ZVZpc2liaWxpdHksIHNvLi4uXG4gICAgICAgICAgICBjYXQucmVmLmN1cnJlbnQuZGlzYWJsZWQgPSAhY2F0LmVuYWJsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGZpbHRlciB9KTtcbiAgICAgICAgLy8gSGVhZGVyIHVuZGVybGluZXMgbmVlZCB0byBiZSB1cGRhdGVkLCBidXQgdXBkYXRpbmcgcmVxdWlyZXMga25vd2luZ1xuICAgICAgICAvLyB3aGVyZSB0aGUgY2F0ZWdvcmllcyBhcmUsIHNvIHdlIHdhaXQgZm9yIGEgdGljay5cbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnVwZGF0ZVZpc2liaWxpdHksIDApO1xuICAgIH07XG5cbiAgICBwcml2YXRlIGVtb2ppTWF0Y2hlc0ZpbHRlciA9IChlbW9qaTogSUVtb2ppLCBmaWx0ZXI6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgICAgICByZXR1cm4gZW1vamkuYW5ub3RhdGlvbi50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGZpbHRlcikgfHxcbiAgICAgICAgICAgIGVtb2ppLmVtb3RpY29uPy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGZpbHRlcikgfHxcbiAgICAgICAgICAgIGVtb2ppLnNob3J0Y29kZXMuc29tZSh4ID0+IHgudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhmaWx0ZXIpKSB8fFxuICAgICAgICAgICAgZW1vamkudW5pY29kZS5zcGxpdChaRVJPX1dJRFRIX0pPSU5FUikuaW5jbHVkZXMoZmlsdGVyKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbkVudGVyRmlsdGVyID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBidG4gPSB0aGlzLmJvZHlSZWYuY3VycmVudC5xdWVyeVNlbGVjdG9yPEhUTUxCdXR0b25FbGVtZW50PihcIi5teF9FbW9qaVBpY2tlcl9pdGVtXCIpO1xuICAgICAgICBpZiAoYnRuKSB7XG4gICAgICAgICAgICBidG4uY2xpY2soKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcml2YXRlIG9uSG92ZXJFbW9qaSA9IChlbW9qaTogSUVtb2ppKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgcHJldmlld0Vtb2ppOiBlbW9qaSxcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25Ib3ZlckVtb2ppRW5kID0gKGVtb2ppOiBJRW1vamkpID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBwcmV2aWV3RW1vamk6IG51bGwsXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBwcml2YXRlIG9uQ2xpY2tFbW9qaSA9IChlbW9qaTogSUVtb2ppKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uQ2hvb3NlKGVtb2ppLnVuaWNvZGUpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgcmVjZW50LmFkZChlbW9qaS51bmljb2RlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcml2YXRlIHN0YXRpYyBjYXRlZ29yeUhlaWdodEZvckVtb2ppQ291bnQoY291bnQ6IG51bWJlcikge1xuICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDQVRFR09SWV9IRUFERVJfSEVJR0hUICsgKE1hdGguY2VpbChjb3VudCAvIEVNT0pJU19QRVJfUk9XKSAqIEVNT0pJX0hFSUdIVCk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgaGVpZ2h0QmVmb3JlID0gMDtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXhfRW1vamlQaWNrZXJcIj5cbiAgICAgICAgICAgICAgICA8SGVhZGVyIGNhdGVnb3JpZXM9e3RoaXMuY2F0ZWdvcmllc30gb25BbmNob3JDbGljaz17dGhpcy5zY3JvbGxUb0NhdGVnb3J5fSAvPlxuICAgICAgICAgICAgICAgIDxTZWFyY2ggcXVlcnk9e3RoaXMuc3RhdGUuZmlsdGVyfSBvbkNoYW5nZT17dGhpcy5vbkNoYW5nZUZpbHRlcn0gb25FbnRlcj17dGhpcy5vbkVudGVyRmlsdGVyfSAvPlxuICAgICAgICAgICAgICAgIDxBdXRvSGlkZVNjcm9sbGJhclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJteF9FbW9qaVBpY2tlcl9ib2R5XCJcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlZFJlZj17cmVmID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSBBdXRvSGlkZVNjcm9sbGJhciBzaG91bGQgYWNjZXB0IGEgUmVmT2JqZWN0IG9yIGZhbGwgYmFjayB0byBpdHMgb3duIGluc3RlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYm9keVJlZi5jdXJyZW50ID0gcmVmO1xuICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICBvblNjcm9sbD17dGhpcy5vblNjcm9sbH1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIHsgdGhpcy5jYXRlZ29yaWVzLm1hcChjYXRlZ29yeSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbW9qaXMgPSB0aGlzLm1lbW9pemVkRGF0YUJ5Q2F0ZWdvcnlbY2F0ZWdvcnkuaWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2F0ZWdvcnlFbGVtZW50ID0gKChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2F0ZWdvcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5PXtjYXRlZ29yeS5pZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ9e2NhdGVnb3J5LmlkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPXtjYXRlZ29yeS5uYW1lfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHRCZWZvcmU9e2hlaWdodEJlZm9yZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRIZWlnaHQ9e3RoaXMuc3RhdGUudmlld3BvcnRIZWlnaHR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFRvcD17dGhpcy5zdGF0ZS5zY3JvbGxUb3B9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtb2ppcz17ZW1vamlzfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tFbW9qaX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZUVudGVyPXt0aGlzLm9uSG92ZXJFbW9qaX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZUxlYXZlPXt0aGlzLm9uSG92ZXJFbW9qaUVuZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRFbW9qaXM9e3RoaXMucHJvcHMuc2VsZWN0ZWRFbW9qaXN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gRW1vamlQaWNrZXIuY2F0ZWdvcnlIZWlnaHRGb3JFbW9qaUNvdW50KGVtb2ppcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0QmVmb3JlICs9IGhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYXRlZ29yeUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH0pIH1cbiAgICAgICAgICAgICAgICA8L0F1dG9IaWRlU2Nyb2xsYmFyPlxuICAgICAgICAgICAgICAgIHsgdGhpcy5zdGF0ZS5wcmV2aWV3RW1vamkgfHwgIXRoaXMucHJvcHMuc2hvd1F1aWNrUmVhY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgID8gPFByZXZpZXcgZW1vamk9e3RoaXMuc3RhdGUucHJldmlld0Vtb2ppfSAvPlxuICAgICAgICAgICAgICAgICAgICA6IDxRdWlja1JlYWN0aW9ucyBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tFbW9qaX0gc2VsZWN0ZWRFbW9qaXM9e3RoaXMucHJvcHMuc2VsZWN0ZWRFbW9qaXN9IC8+IH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRW1vamlQaWNrZXI7XG4iXX0=