"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _EmojiPicker = require("./EmojiPicker");

var _LazyRenderList = _interopRequireDefault(require("../elements/LazyRenderList"));

var _Emoji = _interopRequireDefault(require("./Emoji"));

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _dec, _class;

const OVERFLOW_ROWS = 3;
let Category = (_dec = (0, _replaceableComponent.replaceableComponent)("views.emojipicker.Category"), _dec(_class = class Category extends _react.default.PureComponent {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "renderEmojiRow", rowIndex => {
      const {
        onClick,
        onMouseEnter,
        onMouseLeave,
        selectedEmojis,
        emojis
      } = this.props;
      const emojisForRow = emojis.slice(rowIndex * 8, (rowIndex + 1) * 8);
      return /*#__PURE__*/_react.default.createElement("div", {
        key: rowIndex
      }, emojisForRow.map(emoji => /*#__PURE__*/_react.default.createElement(_Emoji.default, {
        key: emoji.hexcode,
        emoji: emoji,
        selectedEmojis: selectedEmojis,
        onClick: onClick,
        onMouseEnter: onMouseEnter,
        onMouseLeave: onMouseLeave
      })));
    });
  }

  render() {
    const {
      emojis,
      name,
      heightBefore,
      viewportHeight,
      scrollTop
    } = this.props;

    if (!emojis || emojis.length === 0) {
      return null;
    }

    const rows = new Array(Math.ceil(emojis.length / _EmojiPicker.EMOJIS_PER_ROW));

    for (let counter = 0; counter < rows.length; ++counter) {
      rows[counter] = counter;
    }

    const viewportTop = scrollTop;
    const viewportBottom = viewportTop + viewportHeight;
    const listTop = heightBefore + _EmojiPicker.CATEGORY_HEADER_HEIGHT;
    const listBottom = listTop + rows.length * _EmojiPicker.EMOJI_HEIGHT;
    const top = Math.max(viewportTop, listTop);
    const bottom = Math.min(viewportBottom, listBottom); // the viewport height and scrollTop passed to the LazyRenderList
    // is capped at the intersection with the real viewport, so lists
    // out of view are passed height 0, so they won't render any items.

    const localHeight = Math.max(0, bottom - top);
    const localScrollTop = Math.max(0, scrollTop - listTop);
    return /*#__PURE__*/_react.default.createElement("section", {
      id: `mx_EmojiPicker_category_${this.props.id}`,
      className: "mx_EmojiPicker_category",
      "data-category-id": this.props.id,
      role: "tabpanel",
      "aria-label": name
    }, /*#__PURE__*/_react.default.createElement("h2", {
      className: "mx_EmojiPicker_category_label"
    }, name), /*#__PURE__*/_react.default.createElement(_LazyRenderList.default, {
      element: "ul",
      className: "mx_EmojiPicker_list",
      itemHeight: _EmojiPicker.EMOJI_HEIGHT,
      items: rows,
      scrollTop: localScrollTop,
      height: localHeight,
      overflowItems: OVERFLOW_ROWS,
      overflowMargin: 0,
      renderItem: this.renderEmojiRow
    }));
  }

}) || _class);
var _default = Category;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2Vtb2ppcGlja2VyL0NhdGVnb3J5LnRzeCJdLCJuYW1lcyI6WyJPVkVSRkxPV19ST1dTIiwiQ2F0ZWdvcnkiLCJSZWFjdCIsIlB1cmVDb21wb25lbnQiLCJyb3dJbmRleCIsIm9uQ2xpY2siLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlTGVhdmUiLCJzZWxlY3RlZEVtb2ppcyIsImVtb2ppcyIsInByb3BzIiwiZW1vamlzRm9yUm93Iiwic2xpY2UiLCJtYXAiLCJlbW9qaSIsImhleGNvZGUiLCJyZW5kZXIiLCJuYW1lIiwiaGVpZ2h0QmVmb3JlIiwidmlld3BvcnRIZWlnaHQiLCJzY3JvbGxUb3AiLCJsZW5ndGgiLCJyb3dzIiwiQXJyYXkiLCJNYXRoIiwiY2VpbCIsIkVNT0pJU19QRVJfUk9XIiwiY291bnRlciIsInZpZXdwb3J0VG9wIiwidmlld3BvcnRCb3R0b20iLCJsaXN0VG9wIiwiQ0FURUdPUllfSEVBREVSX0hFSUdIVCIsImxpc3RCb3R0b20iLCJFTU9KSV9IRUlHSFQiLCJ0b3AiLCJtYXgiLCJib3R0b20iLCJtaW4iLCJsb2NhbEhlaWdodCIsImxvY2FsU2Nyb2xsVG9wIiwiaWQiLCJyZW5kZXJFbW9qaVJvdyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFpQkE7O0FBRUE7O0FBQ0E7O0FBRUE7O0FBQ0E7Ozs7QUFFQSxNQUFNQSxhQUFhLEdBQUcsQ0FBdEI7SUEwQk1DLFEsV0FETCxnREFBcUIsNEJBQXJCLEMsZ0JBQUQsTUFDTUEsUUFETixTQUN1QkMsZUFBTUMsYUFEN0IsQ0FDbUQ7QUFBQTtBQUFBO0FBQUEsMERBQ3JCQyxRQUFELElBQXNCO0FBQzNDLFlBQU07QUFBRUMsUUFBQUEsT0FBRjtBQUFXQyxRQUFBQSxZQUFYO0FBQXlCQyxRQUFBQSxZQUF6QjtBQUF1Q0MsUUFBQUEsY0FBdkM7QUFBdURDLFFBQUFBO0FBQXZELFVBQWtFLEtBQUtDLEtBQTdFO0FBQ0EsWUFBTUMsWUFB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VSxFQUFFLEtBQUt5QztBQVRyQixNQVZKLENBREo7QUF3Qkg7O0FBaEU4QyxDO2VBbUVwQ3hDLFEiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMTkgVHVsaXIgQXNva2FuIDx0dWxpckBtYXVuaXVtLm5ldD5cbkNvcHlyaWdodCAyMDIwIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IFJlYWN0LCB7IFJlZk9iamVjdCB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgQ0FURUdPUllfSEVBREVSX0hFSUdIVCwgRU1PSklfSEVJR0hULCBFTU9KSVNfUEVSX1JPVyB9IGZyb20gXCIuL0Vtb2ppUGlja2VyXCI7XG5pbXBvcnQgTGF6eVJlbmRlckxpc3QgZnJvbSBcIi4uL2VsZW1lbnRzL0xhenlSZW5kZXJMaXN0XCI7XG5pbXBvcnQgeyBEQVRBX0JZX0NBVEVHT1JZLCBJRW1vamkgfSBmcm9tIFwiLi4vLi4vLi4vZW1vamlcIjtcbmltcG9ydCBFbW9qaSBmcm9tICcuL0Vtb2ppJztcbmltcG9ydCB7IHJlcGxhY2VhYmxlQ29tcG9uZW50IH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL3JlcGxhY2VhYmxlQ29tcG9uZW50XCI7XG5cbmNvbnN0IE9WRVJGTE9XX1JPV1MgPSAzO1xuXG5leHBvcnQgdHlwZSBDYXRlZ29yeUtleSA9IChrZXlvZiB0eXBlb2YgREFUQV9CWV9DQVRFR09SWSkgfCBcInJlY2VudFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIElDYXRlZ29yeSB7XG4gICAgaWQ6IENhdGVnb3J5S2V5O1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBlbmFibGVkOiBib29sZWFuO1xuICAgIHZpc2libGU6IGJvb2xlYW47XG4gICAgcmVmOiBSZWZPYmplY3Q8SFRNTEJ1dHRvbkVsZW1lbnQ+O1xufVxuXG5pbnRlcmZhY2UgSVByb3BzIHtcbiAgICBpZDogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBlbW9qaXM6IElFbW9qaVtdO1xuICAgIHNlbGVjdGVkRW1vamlzOiBTZXQ8c3RyaW5nPjtcbiAgICBoZWlnaHRCZWZvcmU6IG51bWJlcjtcbiAgICB2aWV3cG9ydEhlaWdodDogbnVtYmVyO1xuICAgIHNjcm9sbFRvcDogbnVtYmVyO1xuICAgIG9uQ2xpY2soZW1vamk6IElFbW9qaSk6IHZvaWQ7XG4gICAgb25Nb3VzZUVudGVyKGVtb2ppOiBJRW1vamkpOiB2b2lkO1xuICAgIG9uTW91c2VMZWF2ZShlbW9qaTogSUVtb2ppKTogdm9pZDtcbn1cblxuQHJlcGxhY2VhYmxlQ29tcG9uZW50KFwidmlld3MuZW1vamlwaWNrZXIuQ2F0ZWdvcnlcIilcbmNsYXNzIENhdGVnb3J5IGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxJUHJvcHM+IHtcbiAgICBwcml2YXRlIHJlbmRlckVtb2ppUm93ID0gKHJvd0luZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgY29uc3QgeyBvbkNsaWNrLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZSwgc2VsZWN0ZWRFbW9qaXMsIGVtb2ppcyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgZW1vamlzRm9yUm93ID0gZW1vamlzLnNsaWNlKHJvd0luZGV4ICogOCwgKHJvd0luZGV4ICsgMSkgKiA4KTtcbiAgICAgICAgcmV0dXJuICg8ZGl2IGtleT17cm93SW5kZXh9PntcbiAgICAgICAgICAgIGVtb2ppc0ZvclJvdy5tYXAoZW1vamkgPT4gKChcbiAgICAgICAgICAgICAgICA8RW1vamlcbiAgICAgICAgICAgICAgICAgICAga2V5PXtlbW9qaS5oZXhjb2RlfVxuICAgICAgICAgICAgICAgICAgICBlbW9qaT17ZW1vaml9XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkRW1vamlzPXtzZWxlY3RlZEVtb2ppc31cbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17b25DbGlja31cbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZUVudGVyPXtvbk1vdXNlRW50ZXJ9XG4gICAgICAgICAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17b25Nb3VzZUxlYXZlfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICApKSlcbiAgICAgICAgfTwvZGl2Pik7XG4gICAgfTtcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBlbW9qaXMsIG5hbWUsIGhlaWdodEJlZm9yZSwgdmlld3BvcnRIZWlnaHQsIHNjcm9sbFRvcCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKCFlbW9qaXMgfHwgZW1vamlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm93cyA9IG5ldyBBcnJheShNYXRoLmNlaWwoZW1vamlzLmxlbmd0aCAvIEVNT0pJU19QRVJfUk9XKSk7XG4gICAgICAgIGZvciAobGV0IGNvdW50ZXIgPSAwOyBjb3VudGVyIDwgcm93cy5sZW5ndGg7ICsrY291bnRlcikge1xuICAgICAgICAgICAgcm93c1tjb3VudGVyXSA9IGNvdW50ZXI7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2aWV3cG9ydFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgY29uc3Qgdmlld3BvcnRCb3R0b20gPSB2aWV3cG9ydFRvcCArIHZpZXdwb3J0SGVpZ2h0O1xuICAgICAgICBjb25zdCBsaXN0VG9wID0gaGVpZ2h0QmVmb3JlICsgQ0FURUdPUllfSEVBREVSX0hFSUdIVDtcbiAgICAgICAgY29uc3QgbGlzdEJvdHRvbSA9IGxpc3RUb3AgKyAocm93cy5sZW5ndGggKiBFTU9KSV9IRUlHSFQpO1xuICAgICAgICBjb25zdCB0b3AgPSBNYXRoLm1heCh2aWV3cG9ydFRvcCwgbGlzdFRvcCk7XG4gICAgICAgIGNvbnN0IGJvdHRvbSA9IE1hdGgubWluKHZpZXdwb3J0Qm90dG9tLCBsaXN0Qm90dG9tKTtcbiAgICAgICAgLy8gdGhlIHZpZXdwb3J0IGhlaWdodCBhbmQgc2Nyb2xsVG9wIHBhc3NlZCB0byB0aGUgTGF6eVJlbmRlckxpc3RcbiAgICAgICAgLy8gaXMgY2FwcGVkIGF0IHRoZSBpbnRlcnNlY3Rpb24gd2l0aCB0aGUgcmVhbCB2aWV3cG9ydCwgc28gbGlzdHNcbiAgICAgICAgLy8gb3V0IG9mIHZpZXcgYXJlIHBhc3NlZCBoZWlnaHQgMCwgc28gdGhleSB3b24ndCByZW5kZXIgYW55IGl0ZW1zLlxuICAgICAgICBjb25zdCBsb2NhbEhlaWdodCA9IE1hdGgubWF4KDAsIGJvdHRvbSAtIHRvcCk7XG4gICAgICAgIGNvbnN0IGxvY2FsU2Nyb2xsVG9wID0gTWF0aC5tYXgoMCwgc2Nyb2xsVG9wIC0gbGlzdFRvcCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxzZWN0aW9uXG4gICAgICAgICAgICAgICAgaWQ9e2BteF9FbW9qaVBpY2tlcl9jYXRlZ29yeV8ke3RoaXMucHJvcHMuaWR9YH1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJteF9FbW9qaVBpY2tlcl9jYXRlZ29yeVwiXG4gICAgICAgICAgICAgICAgZGF0YS1jYXRlZ29yeS1pZD17dGhpcy5wcm9wcy5pZH1cbiAgICAgICAgICAgICAgICByb2xlPVwidGFicGFuZWxcIlxuICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9e25hbWV9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPGgyIGNsYXNzTmFtZT1cIm14X0Vtb2ppUGlja2VyX2NhdGVnb3J5X2xhYmVsXCI+XG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZSB9XG4gICAgICAgICAgICAgICAgPC9oMj5cbiAgICAgICAgICAgICAgICA8TGF6eVJlbmRlckxpc3RcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudD1cInVsXCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibXhfRW1vamlQaWNrZXJfbGlzdFwiXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1IZWlnaHQ9e0VNT0pJX0hFSUdIVH1cbiAgICAgICAgICAgICAgICAgICAgaXRlbXM9e3Jvd3N9XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFRvcD17bG9jYWxTY3JvbGxUb3B9XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodD17bG9jYWxIZWlnaHR9XG4gICAgICAgICAgICAgICAgICAgIG92ZXJmbG93SXRlbXM9e09WRVJGTE9XX1JPV1N9XG4gICAgICAgICAgICAgICAgICAgIG92ZXJmbG93TWFyZ2luPXswfVxuICAgICAgICAgICAgICAgICAgICByZW5kZXJJdGVtPXt0aGlzLnJlbmRlckVtb2ppUm93fVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L3NlY3Rpb24+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYXRlZ29yeTtcbiJdfQ==