"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _Playback = require("../../../audio/Playback");

var _react = _interopRequireDefault(require("react"));

var _AsyncStore = require("../../../stores/AsyncStore");

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _languageHandler = require("../../../languageHandler");

var _logger = require("matrix-js-sdk/src/logger");

var _dec, _class;

let AudioPlayerBase = (_dec = (0, _replaceableComponent.replaceableComponent)("views.audio_messages.AudioPlayerBase"), _dec(_class = class AudioPlayerBase extends _react.default.PureComponent {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "onPlaybackUpdate", ev => {
      this.setState({
        playbackPhase: ev
      });
    });
    this.state = {
      playbackPhase: _Playback.PlaybackState.Decoding // default assumption

    }; // We don't need to de-register: the class handles this for us internally

    this.props.playback.on(_AsyncStore.UPDATE_EVENT, this.onPlaybackUpdate); // Don't wait for the promise to complete - it will emit a progress update when it
    // is done, and it's not meant to take long anyhow.

    this.props.playback.prepare().catch(e => {
      _logger.logger.error("Error processing audio file:", e);

      this.setState({
        error: true
      });
    });
  }

  render() {
    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, this.renderComponent(), this.state.error && /*#__PURE__*/_react.default.createElement("div", {
      className: "text-warning"
    }, (0, _languageHandler._t)("Error downloading audio")));
  }

}) || _class);
exports.default = AudioPlayerBase;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2F1ZGlvX21lc3NhZ2VzL0F1ZGlvUGxheWVyQmFzZS50c3giXSwibmFtZXMiOlsiQXVkaW9QbGF5ZXJCYXNlIiwiUmVhY3QiLCJQdXJlQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJwcm9wcyIsImV2Iiwic2V0U3RhdGUiLCJwbGF5YmFja1BoYXNlIiwic3RhdGUiLCJQbGF5YmFja1N0YXRlIiwiRGVjb2RpbmciLCJwbGF5YmFjayIsIm9uIiwiVVBEQVRFX0VWRU5UIiwib25QbGF5YmFja1VwZGF0ZSIsInByZXBhcmUiLCJjYXRjaCIsImUiLCJsb2dnZXIiLCJlcnJvciIsInJlbmRlciIsInJlbmRlckNvbXBvbmVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFnQkE7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7Ozs7SUFpQjhCQSxlLFdBRDdCLGdEQUFxQixzQ0FBckIsQyxnQkFBRCxNQUM4QkEsZUFEOUIsU0FDc0RDLGVBQU1DLGFBRDVELENBQzBGO0FBQ3RGQyxFQUFBQSxXQUFXLENBQUNDLEtBQUQsRUFBZ0I7QUFDdkIsVUFBTUEsS0FBTjtBQUR1Qiw0REFrQkNDLEVBQUQsSUFBdUI7QUFDOUMsV0FBS0MsUUFBTCxDQUFjO0FBQUVDLFFBQUFBLGFBQWEsRUFBRUY7QUFBakIsT0FBZDtBQUNILEtBcEIwQjtBQUd2QixTQUFLRyxLQUFMLEdBQWE7QUFDVEQsTUFBQUEsYUFBYSxFQUFFRSx3QkFBY0MsUUFEcEIsQ0FDOEI7O0FBRDlCLEtBQWIsQ0FIdUIsQ0FPdkI7O0FBQ0EsU0FBS04sS0FBTCxDQUFXTyxRQUFYLENBQW9CQyxFQUFwQixDQUF1QkMsd0JBQXZCLEVBQXFDLEtBQUtDLGdCQUExQyxFQVJ1QixDQVV2QjtBQUNBOztBQUNBLFNBQUtWLEtBQUwsQ0FBV08sUUFBWCxDQUFvQkksT0FBcEIsR0FBOEJDLEtBQTlCLENBQW9DQyxDQUFDLElBQUk7QUFDckNDLHFCQUFPQyxLQUFQLENBQWEsOEJBQWIsRUFBNkNGLENBQTdDOztBQUNBLFdBQUtYLFFBQUwsQ0FBYztBQUFFYSxRQUFBQSxLQUFLLEVBQUU7QUFBVCxPQUFkO0FBQ0gsS0FIRDtBQUlIOztBQVFNQyxFQUFBQSxNQUFNLEdBQWM7QUFDdkIsd0JBQU8sNERBQ0QsS0FBS0MsZUFBTCxFQURDLEVBRUQsS0FBS2IsS0FBTCxDQUFXVyxLQUFYLGlCQUFvQjtBQUFLLE1BQUEsU0FBUyxFQUFDO0FBQWYsT0FBZ0MseUJBQUcseUJBQUgsQ0FBaEMsQ0FGbkIsQ0FBUDtBQUlIOztBQTlCcUYsQyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAyMSBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB7IFBsYXliYWNrLCBQbGF5YmFja1N0YXRlIH0gZnJvbSBcIi4uLy4uLy4uL2F1ZGlvL1BsYXliYWNrXCI7XG5pbXBvcnQgeyBUaWxlU2hhcGUgfSBmcm9tIFwiLi4vcm9vbXMvRXZlbnRUaWxlXCI7XG5pbXBvcnQgUmVhY3QsIHsgUmVhY3ROb2RlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBVUERBVEVfRVZFTlQgfSBmcm9tIFwiLi4vLi4vLi4vc3RvcmVzL0FzeW5jU3RvcmVcIjtcbmltcG9ydCB7IHJlcGxhY2VhYmxlQ29tcG9uZW50IH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL3JlcGxhY2VhYmxlQ29tcG9uZW50XCI7XG5pbXBvcnQgeyBfdCB9IGZyb20gXCIuLi8uLi8uLi9sYW5ndWFnZUhhbmRsZXJcIjtcblxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL2xvZ2dlclwiO1xuXG5pbnRlcmZhY2UgSVByb3BzIHtcbiAgICAvLyBQbGF5YmFjayBpbnN0YW5jZSB0byByZW5kZXIuIENhbm5vdCBjaGFuZ2UgZHVyaW5nIGNvbXBvbmVudCBsaWZlY3ljbGU6IGNyZWF0ZVxuICAgIC8vIGFuIGFsbC1uZXcgY29tcG9uZW50IGluc3RlYWQuXG4gICAgcGxheWJhY2s6IFBsYXliYWNrO1xuXG4gICAgbWVkaWFOYW1lPzogc3RyaW5nO1xuICAgIHRpbGVTaGFwZT86IFRpbGVTaGFwZTtcbn1cblxuaW50ZXJmYWNlIElTdGF0ZSB7XG4gICAgcGxheWJhY2tQaGFzZTogUGxheWJhY2tTdGF0ZTtcbiAgICBlcnJvcj86IGJvb2xlYW47XG59XG5cbkByZXBsYWNlYWJsZUNvbXBvbmVudChcInZpZXdzLmF1ZGlvX21lc3NhZ2VzLkF1ZGlvUGxheWVyQmFzZVwiKVxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgQXVkaW9QbGF5ZXJCYXNlIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxJUHJvcHMsIElTdGF0ZT4ge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzOiBJUHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBwbGF5YmFja1BoYXNlOiBQbGF5YmFja1N0YXRlLkRlY29kaW5nLCAvLyBkZWZhdWx0IGFzc3VtcHRpb25cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGRlLXJlZ2lzdGVyOiB0aGUgY2xhc3MgaGFuZGxlcyB0aGlzIGZvciB1cyBpbnRlcm5hbGx5XG4gICAgICAgIHRoaXMucHJvcHMucGxheWJhY2sub24oVVBEQVRFX0VWRU5ULCB0aGlzLm9uUGxheWJhY2tVcGRhdGUpO1xuXG4gICAgICAgIC8vIERvbid0IHdhaXQgZm9yIHRoZSBwcm9taXNlIHRvIGNvbXBsZXRlIC0gaXQgd2lsbCBlbWl0IGEgcHJvZ3Jlc3MgdXBkYXRlIHdoZW4gaXRcbiAgICAgICAgLy8gaXMgZG9uZSwgYW5kIGl0J3Mgbm90IG1lYW50IHRvIHRha2UgbG9uZyBhbnlob3cuXG4gICAgICAgIHRoaXMucHJvcHMucGxheWJhY2sucHJlcGFyZSgpLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRXJyb3IgcHJvY2Vzc2luZyBhdWRpbyBmaWxlOlwiLCBlKTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBlcnJvcjogdHJ1ZSB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvblBsYXliYWNrVXBkYXRlID0gKGV2OiBQbGF5YmFja1N0YXRlKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBwbGF5YmFja1BoYXNlOiBldiB9KTtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHJlbmRlckNvbXBvbmVudCgpOiBSZWFjdE5vZGU7XG5cbiAgICBwdWJsaWMgcmVuZGVyKCk6IFJlYWN0Tm9kZSB7XG4gICAgICAgIHJldHVybiA8PlxuICAgICAgICAgICAgeyB0aGlzLnJlbmRlckNvbXBvbmVudCgpIH1cbiAgICAgICAgICAgIHsgdGhpcy5zdGF0ZS5lcnJvciAmJiA8ZGl2IGNsYXNzTmFtZT1cInRleHQtd2FybmluZ1wiPnsgX3QoXCJFcnJvciBkb3dubG9hZGluZyBhdWRpb1wiKSB9PC9kaXY+IH1cbiAgICAgICAgPC8+O1xuICAgIH1cbn1cbiJdfQ==