"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _replaceableComponent = require("../../../utils/replaceableComponent");

var _Clock = _interopRequireDefault(require("./Clock"));

var _dec, _class;

let DurationClock = (
/**
 * A clock which shows a clip's maximum duration.
 */
_dec = (0, _replaceableComponent.replaceableComponent)("views.audio_messages.DurationClock"), _dec(_class = class DurationClock extends _react.default.PureComponent {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "onTimeUpdate", time => {
      this.setState({
        durationSeconds: time[1]
      });
    });
    this.state = {
      // we track the duration on state because we won't really know what the clip duration
      // is until the first time update, and as a PureComponent we are trying to dedupe state
      // updates as much as possible. This is just the easiest way to avoid a forceUpdate() or
      // member property to track "did we get a duration".
      durationSeconds: this.props.playback.clockInfo.durationSeconds
    };
    this.props.playback.clockInfo.liveData.onUpdate(this.onTimeUpdate);
  }

  render() {
    return /*#__PURE__*/_react.default.createElement(_Clock.default, {
      seconds: this.state.durationSeconds
    });
  }

}) || _class);
exports.default = DurationClock;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2F1ZGlvX21lc3NhZ2VzL0R1cmF0aW9uQ2xvY2sudHN4Il0sIm5hbWVzIjpbIkR1cmF0aW9uQ2xvY2siLCJSZWFjdCIsIlB1cmVDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsInByb3BzIiwidGltZSIsInNldFN0YXRlIiwiZHVyYXRpb25TZWNvbmRzIiwic3RhdGUiLCJwbGF5YmFjayIsImNsb2NrSW5mbyIsImxpdmVEYXRhIiwib25VcGRhdGUiLCJvblRpbWVVcGRhdGUiLCJyZW5kZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBZ0JBOztBQUNBOztBQUNBOzs7O0lBZXFCQSxhO0FBSnJCO0FBQ0E7QUFDQTtPQUNDLGdEQUFxQixvQ0FBckIsQyxnQkFBRCxNQUNxQkEsYUFEckIsU0FDMkNDLGVBQU1DLGFBRGpELENBQytFO0FBQ3BFQyxFQUFBQSxXQUFXLENBQUNDLEtBQUQsRUFBUTtBQUN0QixVQUFNQSxLQUFOO0FBRHNCLHdEQWFGQyxJQUFELElBQW9CO0FBQ3ZDLFdBQUtDLFFBQUwsQ0FBYztBQUFFQyxRQUFBQSxlQUFlLEVBQUVGLElBQUksQ0FBQyxDQUFEO0FBQXZCLE9BQWQ7QUFDSCxLQWZ5QjtBQUd0QixTQUFLRyxLQUFMLEdBQWE7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBRCxNQUFBQSxlQUFlLEVBQUUsS0FBS0gsS0FBTCxDQUFXSyxRQUFYLENBQW9CQyxTQUFwQixDQUE4Qkg7QUFMdEMsS0FBYjtBQU9BLFNBQUtILEtBQUwsQ0FBV0ssUUFBWCxDQUFvQkMsU0FBcEIsQ0FBOEJDLFFBQTlCLENBQXVDQyxRQUF2QyxDQUFnRCxLQUFLQyxZQUFyRDtBQUNIOztBQU1NQyxFQUFBQSxNQUFNLEdBQUc7QUFDWix3QkFBTyw2QkFBQyxjQUFEO0FBQU8sTUFBQSxPQUFPLEVBQUUsS0FBS04sS0FBTCxDQUFXRDtBQUEzQixNQUFQO0FBQ0g7O0FBcEIwRSxDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDIxIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgcmVwbGFjZWFibGVDb21wb25lbnQgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvcmVwbGFjZWFibGVDb21wb25lbnRcIjtcbmltcG9ydCBDbG9jayBmcm9tIFwiLi9DbG9ja1wiO1xuaW1wb3J0IHsgUGxheWJhY2sgfSBmcm9tIFwiLi4vLi4vLi4vYXVkaW8vUGxheWJhY2tcIjtcblxuaW50ZXJmYWNlIElQcm9wcyB7XG4gICAgcGxheWJhY2s6IFBsYXliYWNrO1xufVxuXG5pbnRlcmZhY2UgSVN0YXRlIHtcbiAgICBkdXJhdGlvblNlY29uZHM6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBBIGNsb2NrIHdoaWNoIHNob3dzIGEgY2xpcCdzIG1heGltdW0gZHVyYXRpb24uXG4gKi9cbkByZXBsYWNlYWJsZUNvbXBvbmVudChcInZpZXdzLmF1ZGlvX21lc3NhZ2VzLkR1cmF0aW9uQ2xvY2tcIilcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIER1cmF0aW9uQ2xvY2sgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PElQcm9wcywgSVN0YXRlPiB7XG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgLy8gd2UgdHJhY2sgdGhlIGR1cmF0aW9uIG9uIHN0YXRlIGJlY2F1c2Ugd2Ugd29uJ3QgcmVhbGx5IGtub3cgd2hhdCB0aGUgY2xpcCBkdXJhdGlvblxuICAgICAgICAgICAgLy8gaXMgdW50aWwgdGhlIGZpcnN0IHRpbWUgdXBkYXRlLCBhbmQgYXMgYSBQdXJlQ29tcG9uZW50IHdlIGFyZSB0cnlpbmcgdG8gZGVkdXBlIHN0YXRlXG4gICAgICAgICAgICAvLyB1cGRhdGVzIGFzIG11Y2ggYXMgcG9zc2libGUuIFRoaXMgaXMganVzdCB0aGUgZWFzaWVzdCB3YXkgdG8gYXZvaWQgYSBmb3JjZVVwZGF0ZSgpIG9yXG4gICAgICAgICAgICAvLyBtZW1iZXIgcHJvcGVydHkgdG8gdHJhY2sgXCJkaWQgd2UgZ2V0IGEgZHVyYXRpb25cIi5cbiAgICAgICAgICAgIGR1cmF0aW9uU2Vjb25kczogdGhpcy5wcm9wcy5wbGF5YmFjay5jbG9ja0luZm8uZHVyYXRpb25TZWNvbmRzLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb3BzLnBsYXliYWNrLmNsb2NrSW5mby5saXZlRGF0YS5vblVwZGF0ZSh0aGlzLm9uVGltZVVwZGF0ZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvblRpbWVVcGRhdGUgPSAodGltZTogbnVtYmVyW10pID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGR1cmF0aW9uU2Vjb25kczogdGltZVsxXSB9KTtcbiAgICB9O1xuXG4gICAgcHVibGljIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIDxDbG9jayBzZWNvbmRzPXt0aGlzLnN0YXRlLmR1cmF0aW9uU2Vjb25kc30gLz47XG4gICAgfVxufVxuIl19